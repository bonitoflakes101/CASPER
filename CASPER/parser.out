Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_statement -> var_statement global_statement_tail
Rule 11    var_statement -> data_type IDENT list_dec
Rule 12    list_dec -> empty
Rule 13    list_dec -> LBRACKET RBRACKET _2d_list
Rule 14    _2d_list -> empty
Rule 15    _2d_list -> LBRACKET RBRACKET
Rule 16    global_statement_tail -> empty
Rule 17    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 18    global_statement_tail -> EQ global_value global_statement_tail2
Rule 19    global_statement_tail2 -> COMMA IDENT global_statement_tail
Rule 20    global_statement_tail2 -> empty
Rule 21    global_value -> expression
Rule 22    global_value -> list_value
Rule 23    list_value -> LBRACKET list_element RBRACKET
Rule 24    list_element -> literal element_tail
Rule 25    element_tail -> COMMA list_element
Rule 26    element_tail -> empty
Rule 27    data_type -> INT
Rule 28    data_type -> FLT
Rule 29    data_type -> BLN
Rule 30    data_type -> CHR
Rule 31    data_type -> STR
Rule 32    expression -> factor factor_tail
Rule 33    factor -> var_call postfix
Rule 34    factor -> literal1
Rule 35    factor -> TILDE INT_LIT
Rule 36    factor -> TILDE FLT_LIT
Rule 37    factor -> LPAREN factor_expression RPAREN
Rule 38    factor_expression -> factor_expression_factor factor_expression_tail
Rule 39    factor_expression_factor -> var_call postfix
Rule 40    factor_expression_factor -> factor_expression1
Rule 41    factor_expression_factor -> TILDE INT_LIT
Rule 42    factor_expression_factor -> TILDE FLT_LIT
Rule 43    factor_expression_factor -> LPAREN factor_expression RPAREN
Rule 44    factor_expression_tail -> PLUS factor_expression_factor factor_expression_tail
Rule 45    factor_expression_tail -> MINUS factor_expression_factor factor_expression_tail
Rule 46    factor_expression_tail -> MULTIPLY factor_expression_factor factor_expression_tail
Rule 47    factor_expression_tail -> DIVISION factor_expression_factor factor_expression_tail
Rule 48    factor_expression_tail -> MODULO factor_expression_factor factor_expression_tail
Rule 49    factor_expression_tail -> EXPONENT factor_expression_factor factor_expression_tail
Rule 50    factor_expression_tail -> GT factor_expression_factor factor_expression_tail
Rule 51    factor_expression_tail -> LT factor_expression_factor factor_expression_tail
Rule 52    factor_expression_tail -> EQ_EQ factor_expression_factor factor_expression_tail
Rule 53    factor_expression_tail -> GT_EQ factor_expression_factor factor_expression_tail
Rule 54    factor_expression_tail -> LT_EQ factor_expression_factor factor_expression_tail
Rule 55    factor_expression_tail -> NOT_EQ factor_expression_factor factor_expression_tail
Rule 56    factor_expression_tail -> AND factor_expression_factor factor_expression_tail
Rule 57    factor_expression_tail -> OR factor_expression_factor factor_expression_tail
Rule 58    factor_expression_tail -> empty
Rule 59    factor_expression1 -> INT_LIT
Rule 60    factor_expression1 -> FLT_LIT
Rule 61    factor_expression1 -> DAY
Rule 62    factor_expression1 -> NIGHT
Rule 63    factor_expression1 -> STR_LIT
Rule 64    factor_tail -> PLUS factor factor_tail
Rule 65    factor_tail -> MINUS factor factor_tail
Rule 66    factor_tail -> MULTIPLY factor factor_tail
Rule 67    factor_tail -> DIVISION factor factor_tail
Rule 68    factor_tail -> MODULO factor factor_tail
Rule 69    factor_tail -> EXPONENT factor factor_tail
Rule 70    factor_tail -> GT factor factor_tail
Rule 71    factor_tail -> LT factor factor_tail
Rule 72    factor_tail -> EQ_EQ factor factor_tail
Rule 73    factor_tail -> GT_EQ factor factor_tail
Rule 74    factor_tail -> LT_EQ factor factor_tail
Rule 75    factor_tail -> NOT_EQ factor factor_tail
Rule 76    factor_tail -> AND factor factor_tail
Rule 77    factor_tail -> OR factor factor_tail
Rule 78    factor_tail -> empty
Rule 79    literal -> literal1
Rule 80    literal -> literal2
Rule 81    literal1 -> INT_LIT
Rule 82    literal1 -> FLT_LIT
Rule 83    literal1 -> DAY
Rule 84    literal1 -> NIGHT
Rule 85    literal1 -> STR_LIT
Rule 86    literal2 -> CHR_LIT
Rule 87    function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
Rule 88    function_statements -> empty
Rule 89    function_statements_tail -> function_statements
Rule 90    function_statements_tail -> empty
Rule 91    ret_type -> FUNCTION
Rule 92    ret_type -> function_dtype
Rule 93    function_dtype -> FUNCTION_INT
Rule 94    function_dtype -> FUNCTION_FLT
Rule 95    function_dtype -> FUNCTION_CHR
Rule 96    function_dtype -> FUNCTION_BLN
Rule 97    function_dtype -> FUNCTION_STR
Rule 98    function_dtype -> FUNCTION_LIST_INT
Rule 99    function_dtype -> FUNCTION_LIST_FLT
Rule 100   function_dtype -> FUNCTION_LIST_CHR
Rule 101   function_dtype -> FUNCTION_LIST_STR
Rule 102   function_dtype -> FUNCTION_LIST_BLN
Rule 103   parameters -> data_type IDENT parameters_tail
Rule 104   parameters -> empty
Rule 105   parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 106   parameters_tail -> empty
Rule 107   revive -> REVIVE revive_value
Rule 108   revive -> empty
Rule 109   revive_value -> revive_type_cast
Rule 110   revive_value -> expression
Rule 111   revive_value -> function_call
Rule 112   revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 113   revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 114   revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 115   revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 116   statements -> empty
Rule 117   statements -> local_dec maybe_newline statements_tail
Rule 118   statements_tail -> switch_statement unli_newline statements
Rule 119   statements_tail -> loop_statement unli_newline statements
Rule 120   statements_tail -> function_call unli_newline statements
Rule 121   statements_tail -> assignment_statement unli_newline statements
Rule 122   statements_tail -> output_statement unli_newline statements
Rule 123   statements_tail -> conditional_statement unli_newline statements
Rule 124   statements_tail -> statements
Rule 125   local_dec -> var_statement local_dec_tail
Rule 126   local_dec -> empty
Rule 127   local_dec_tail -> empty
Rule 128   local_dec_tail -> COMMA IDENT local_dec_tail
Rule 129   local_dec_tail -> EQ local_value local_dec_tail2
Rule 130   local_dec_tail2 -> COMMA IDENT local_dec_tail
Rule 131   local_dec_tail2 -> empty
Rule 132   local_value -> local_value_value
Rule 133   local_value -> list_value
Rule 134   local_value_value -> local_type_cast
Rule 135   local_value_value -> expression
Rule 136   local_value_value -> function_call
Rule 137   local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 138   local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 139   local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 140   local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 141   conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 142   conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN LBRACE statements RBRACE conditional_tail
Rule 143   conditional_tail -> empty
Rule 144   condition -> condition_factor condition_tail
Rule 145   condition_factor -> var_call postfix
Rule 146   condition_factor -> condition1
Rule 147   condition_factor -> TILDE INT_LIT
Rule 148   condition_factor -> TILDE FLT_LIT
Rule 149   condition_factor -> LPAREN condition RPAREN
Rule 150   condition_tail -> PLUS condition_factor condition_tail
Rule 151   condition_tail -> MINUS condition_factor condition_tail
Rule 152   condition_tail -> MULTIPLY condition_factor condition_tail
Rule 153   condition_tail -> DIVISION condition_factor condition_tail
Rule 154   condition_tail -> MODULO condition_factor condition_tail
Rule 155   condition_tail -> EXPONENT condition_factor condition_tail
Rule 156   condition_tail -> GT condition_factor condition_tail
Rule 157   condition_tail -> LT condition_factor condition_tail
Rule 158   condition_tail -> EQ_EQ condition_factor condition_tail
Rule 159   condition_tail -> GT_EQ condition_factor condition_tail
Rule 160   condition_tail -> LT_EQ condition_factor condition_tail
Rule 161   condition_tail -> NOT_EQ condition_factor condition_tail
Rule 162   condition_tail -> AND condition_factor condition_tail
Rule 163   condition_tail -> OR condition_factor condition_tail
Rule 164   condition_tail -> empty
Rule 165   condition1 -> INT_LIT
Rule 166   condition1 -> FLT_LIT
Rule 167   condition1 -> DAY
Rule 168   condition1 -> NIGHT
Rule 169   condition1 -> STR_LIT
Rule 170   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
Rule 171   switch_condition -> SHIFT switch_value COLON statements switchcond_tail
Rule 172   switch_value -> switch_type_cast
Rule 173   switch_value -> expression
Rule 174   switch_value -> function_call
Rule 175   switch_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 176   switch_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 177   switch_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 178   switch_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 179   switchcond_tail -> switch_condition
Rule 180   switchcond_tail -> empty
Rule 181   loop_statement -> for_loop
Rule 182   loop_statement -> until_loop
Rule 183   loop_statement -> repeat_until
Rule 184   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE
Rule 185   until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
Rule 186   repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
Rule 187   control_variable -> INT IDENT EQ control_var_tail
Rule 188   control_var_tail -> INT_LIT
Rule 189   control_var_tail -> var_call
Rule 190   update -> var_call update_tail
Rule 191   update_tail -> postfix_op
Rule 192   update_tail -> compound_op value
Rule 193   postfix_op -> PLUS_PLUS
Rule 194   postfix_op -> MINUS_MINUS
Rule 195   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 196   function_call -> input_statement
Rule 197   arguments -> empty
Rule 198   arguments -> arg_value arg_tail
Rule 199   arg_tail -> COMMA arg_value arg_tail
Rule 200   arg_tail -> empty
Rule 201   arg_value -> literal
Rule 202   arg_value -> var_call
Rule 203   output_statement -> DISPLAY value next_val
Rule 204   next_val -> COMMA value next_val
Rule 205   next_val -> empty
Rule 206   assignment_statement -> IDENT assign_tail
Rule 207   assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
Rule 208   assign_tail -> DOT PUSH LPAREN list_element RPAREN
Rule 209   assign_tail -> assign_op value
Rule 210   assign_op -> compound_op
Rule 211   assign_op -> EQ
Rule 212   compound_op -> PLUS_EQ
Rule 213   compound_op -> MINUS_EQ
Rule 214   compound_op -> MUL_EQ
Rule 215   compound_op -> DIV_EQ
Rule 216   compound_op -> MOD_EQ
Rule 217   start -> INT_LIT
Rule 218   deleteCount -> empty
Rule 219   deleteCount -> INT_LIT
Rule 220   splice_items -> empty
Rule 221   splice_items -> list_element
Rule 222   var_call -> IDENT list_index
Rule 223   list_index -> LBRACKET index RBRACKET list_index2
Rule 224   list_index -> empty
Rule 225   list_index2 -> LBRACKET index RBRACKET
Rule 226   list_index2 -> empty
Rule 227   index -> INT_LIT
Rule 228   index -> IDENT
Rule 229   postfix -> empty
Rule 230   postfix -> postfix_op
Rule 231   value -> type_cast
Rule 232   value -> expression
Rule 233   value -> function_call
Rule 234   type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 235   type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 236   type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 237   type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 238   typecast_value -> expression
Rule 239   typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 240   typecast_value -> input_statement
Rule 241   input_statement -> INPUT LPAREN RPAREN
Rule 242   empty -> <empty>

Terminals, with rules where they appear

AND                  : 56 76 162
BIRTH                : 1
BLN                  : 29
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 141
CHR                  : 30
CHR_LIT              : 86
COLON                : 171
COMMA                : 17 19 25 105 128 130 199 204 207 207
COMMENT              : 
CONVERT_TO_BLN       : 114 139 177 236
CONVERT_TO_FLT       : 113 138 176 235
CONVERT_TO_INT       : 112 137 175 234
CONVERT_TO_STR       : 115 140 178 237
DAY                  : 61 83 167
DISPLAY              : 203
DIVISION             : 47 67 153
DIV_EQ               : 215
DOT                  : 207 208
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 18 129 187 211
EQ_EQ                : 52 72 158
EXPONENT             : 49 69 155
FLT                  : 28
FLT_LIT              : 36 42 60 82 148 166
FOR                  : 184
FUNCTION             : 91
FUNCTION_BLN         : 96
FUNCTION_CHR         : 95
FUNCTION_FLT         : 94
FUNCTION_INT         : 93
FUNCTION_LIST_BLN    : 102
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 100
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 99
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 98
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 101
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 87 195 239
FUNCTION_STR         : 97
GHOST                : 1
GT                   : 50 70 156
GT_EQ                : 53 73 159
IDENT                : 11 17 19 103 105 128 130 170 187 206 222 228
ILLEGAL              : 
IN                   : 
INPUT                : 241
INT                  : 27 187
INT_LIT              : 35 41 59 81 147 165 188 217 219 227
LBRACE               : 6 87 141 141 142 170 170 184 185 186
LBRACKET             : 13 15 23 223 225
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 37 43 87 112 113 114 115 137 138 139 140 141 142 149 170 175 176 177 178 184 185 186 195 207 208 234 235 236 237 239 241
LT                   : 51 71 157
LT_EQ                : 54 74 160
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 45 65 151
MINUS_EQ             : 213
MINUS_MINUS          : 194
MODULO               : 48 68 154
MOD_EQ               : 216
MULTIPLY             : 46 66 152
MUL_EQ               : 214
NEWLINE              : 3 4 5
NIGHT                : 62 84 168
NOT                  : 
NOT_EQ               : 55 75 161
OR                   : 57 77 163
OTHERWISE            : 141 170
OTHERWISE_CHECK      : 142
PLUS                 : 44 64 150
PLUS_EQ              : 212
PLUS_PLUS            : 193
POW                  : 
PUSH                 : 208
RBRACE               : 6 87 141 141 142 170 170 184 185 186
RBRACKET             : 13 15 23 223 225
REPEAT               : 186
REVIVE               : 107
RPAREN               : 6 37 43 87 112 113 114 115 137 138 139 140 141 142 149 170 175 176 177 178 184 185 186 195 207 208 234 235 236 237 239 241
SEMICOLON            : 184 184
SHIFT                : 171
SKIP                 : 
SPLICE               : 207
STOP                 : 
STR                  : 31
STR_LIT              : 63 85 169
SWAP                 : 170
TILDE                : 35 36 41 42 147 148
TYPE                 : 
UNTIL                : 185 186
error                : 

Nonterminals, with rules where they appear

_2d_list             : 13
arg_tail             : 198 199
arg_value            : 198 199
arguments            : 195
assign_op            : 209
assign_tail          : 206
assignment_statement : 121
compound_op          : 192 210
condition            : 141 142 149
condition1           : 146
condition_factor     : 144 150 151 152 153 154 155 156 157 158 159 160 161 162 163
condition_tail       : 144 150 151 152 153 154 155 156 157 158 159 160 161 162 163
conditional_statement : 123
conditional_tail     : 141 142
control_var_tail     : 187
control_variable     : 184
data_type            : 11 103 105
deleteCount          : 207
element_tail         : 24
empty                : 2 8 12 14 16 20 26 58 78 88 90 104 106 108 116 126 127 131 143 164 180 197 200 205 218 220 224 226 229
expression           : 21 110 135 173 184 185 186 232 238
factor               : 32 64 65 66 67 68 69 70 71 72 73 74 75 76 77
factor_expression    : 37 43
factor_expression1   : 40
factor_expression_factor : 38 44 45 46 47 48 49 50 51 52 53 54 55 56 57
factor_expression_tail : 38 44 45 46 47 48 49 50 51 52 53 54 55 56 57
factor_tail          : 32 64 65 66 67 68 69 70 71 72 73 74 75 76 77
for_loop             : 181
function_call        : 111 120 136 174 233
function_dtype       : 92
function_statements  : 1 89
function_statements_tail : 87
global_dec           : 1 9
global_statement     : 7
global_statement_tail : 10 17 19
global_statement_tail2 : 18
global_tail          : 7
global_value         : 18
index                : 223 225
input_statement      : 196 240
list_dec             : 11
list_element         : 23 25 208 221
list_index           : 222
list_index2          : 223
list_value           : 22 133
literal              : 24 201
literal1             : 34 79
literal2             : 80
local_dec            : 117
local_dec_tail       : 125 128 130
local_dec_tail2      : 129
local_type_cast      : 134
local_value          : 129
local_value_value    : 132
loop_statement       : 119
main_function        : 1
maybe_newline        : 1 1 3 6 6 6 87 87 117 141 141 141 141 141 141 141
next_val             : 203 204
output_statement     : 122
parameters           : 87
parameters_tail      : 103 105
postfix              : 33 39 145
postfix_op           : 191 230
program              : 0
repeat_until         : 183
ret_type             : 87
revive               : 87
revive_type_cast     : 109
revive_value         : 107
splice_items         : 207
start                : 207
statements           : 6 87 118 119 120 121 122 123 124 141 141 142 170 171 184 185 186
statements_tail      : 117
switch_condition     : 170 179
switch_statement     : 118
switch_type_cast     : 172
switch_value         : 171
switchcond_tail      : 171
type_cast            : 231
typecast_value       : 112 113 114 115 137 138 139 140 175 176 177 178 234 235 236 237
unli_newline         : 1 1 5 7 87 118 119 120 121 122 123 184 184
until_loop           : 182
update               : 184
update_tail          : 190
value                : 192 203 204 209
var_call             : 33 39 145 189 190 202
var_statement        : 10 125

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . var_statement global_statement_tail
    (242) empty -> .
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    NEWLINE         reduce using rule 242 (empty -> .)
    FUNCTION        reduce using rule 242 (empty -> .)
    FUNCTION_INT    reduce using rule 242 (empty -> .)
    FUNCTION_FLT    reduce using rule 242 (empty -> .)
    FUNCTION_CHR    reduce using rule 242 (empty -> .)
    FUNCTION_BLN    reduce using rule 242 (empty -> .)
    FUNCTION_STR    reduce using rule 242 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 242 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 242 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 242 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 242 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 242 (empty -> .)
    MAIN_CASPER     reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    var_statement                  shift and go to state 8
    data_type                      shift and go to state 9

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    INPUT           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 15

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    FUNCTION        reduce using rule 242 (empty -> .)
    FUNCTION_INT    reduce using rule 242 (empty -> .)
    FUNCTION_FLT    reduce using rule 242 (empty -> .)
    FUNCTION_CHR    reduce using rule 242 (empty -> .)
    FUNCTION_BLN    reduce using rule 242 (empty -> .)
    FUNCTION_STR    reduce using rule 242 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 242 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 242 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 242 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 242 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 242 (empty -> .)
    MAIN_CASPER     reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 16
    empty                          shift and go to state 17

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 19

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)


state 8

    (10) global_statement -> var_statement . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (242) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 242 (empty -> .)

    global_statement_tail          shift and go to state 20
    empty                          shift and go to state 21

state 9

    (11) var_statement -> data_type . IDENT list_dec

    IDENT           shift and go to state 24


state 10

    (27) data_type -> INT .

    IDENT           reduce using rule 27 (data_type -> INT .)


state 11

    (28) data_type -> FLT .

    IDENT           reduce using rule 28 (data_type -> FLT .)


state 12

    (29) data_type -> BLN .

    IDENT           reduce using rule 29 (data_type -> BLN .)


state 13

    (30) data_type -> CHR .

    IDENT           reduce using rule 30 (data_type -> CHR .)


state 14

    (31) data_type -> STR .

    IDENT           reduce using rule 31 (data_type -> STR .)


state 15

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    INPUT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 16

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (87) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (88) function_statements -> . empty
    (91) ret_type -> . FUNCTION
    (92) ret_type -> . function_dtype
    (242) empty -> .
    (93) function_dtype -> . FUNCTION_INT
    (94) function_dtype -> . FUNCTION_FLT
    (95) function_dtype -> . FUNCTION_CHR
    (96) function_dtype -> . FUNCTION_BLN
    (97) function_dtype -> . FUNCTION_STR
    (98) function_dtype -> . FUNCTION_LIST_INT
    (99) function_dtype -> . FUNCTION_LIST_FLT
    (100) function_dtype -> . FUNCTION_LIST_CHR
    (101) function_dtype -> . FUNCTION_LIST_STR
    (102) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 28
    NEWLINE         reduce using rule 242 (empty -> .)
    MAIN_CASPER     reduce using rule 242 (empty -> .)
    FUNCTION_INT    shift and go to state 30
    FUNCTION_FLT    shift and go to state 31
    FUNCTION_CHR    shift and go to state 32
    FUNCTION_BLN    shift and go to state 33
    FUNCTION_STR    shift and go to state 34
    FUNCTION_LIST_INT shift and go to state 35
    FUNCTION_LIST_FLT shift and go to state 36
    FUNCTION_LIST_CHR shift and go to state 37
    FUNCTION_LIST_STR shift and go to state 38
    FUNCTION_LIST_BLN shift and go to state 39

    function_statements            shift and go to state 25
    ret_type                       shift and go to state 26
    empty                          shift and go to state 27
    function_dtype                 shift and go to state 29

state 17

    (2) maybe_newline -> empty .

    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    INPUT           reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE_CHECK reduce using rule 2 (maybe_newline -> empty .)


state 18

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    FUNCTION        reduce using rule 242 (empty -> .)
    FUNCTION_INT    reduce using rule 242 (empty -> .)
    FUNCTION_FLT    reduce using rule 242 (empty -> .)
    FUNCTION_CHR    reduce using rule 242 (empty -> .)
    FUNCTION_BLN    reduce using rule 242 (empty -> .)
    FUNCTION_STR    reduce using rule 242 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 242 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 242 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 242 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 242 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 242 (empty -> .)
    MAIN_CASPER     reduce using rule 242 (empty -> .)
    LBRACE          reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    OTHERWISE_CHECK reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 40
    empty                          shift and go to state 17

state 19

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . var_statement global_statement_tail
    (242) empty -> .
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    NEWLINE         reduce using rule 242 (empty -> .)
    FUNCTION        reduce using rule 242 (empty -> .)
    FUNCTION_INT    reduce using rule 242 (empty -> .)
    FUNCTION_FLT    reduce using rule 242 (empty -> .)
    FUNCTION_CHR    reduce using rule 242 (empty -> .)
    FUNCTION_BLN    reduce using rule 242 (empty -> .)
    FUNCTION_STR    reduce using rule 242 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 242 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 242 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 242 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 242 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 242 (empty -> .)
    MAIN_CASPER     reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 41
    global_dec                     shift and go to state 42
    empty                          shift and go to state 7
    var_statement                  shift and go to state 8
    data_type                      shift and go to state 9

state 20

    (10) global_statement -> var_statement global_statement_tail .

    NEWLINE         reduce using rule 10 (global_statement -> var_statement global_statement_tail .)


state 21

    (16) global_statement_tail -> empty .

    NEWLINE         reduce using rule 16 (global_statement_tail -> empty .)


state 22

    (17) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 43


state 23

    (18) global_statement_tail -> EQ . global_value global_statement_tail2
    (21) global_value -> . expression
    (22) global_value -> . list_value
    (32) expression -> . factor factor_tail
    (23) list_value -> . LBRACKET list_element RBRACKET
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    LBRACKET        shift and go to state 48
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    global_value                   shift and go to state 44
    expression                     shift and go to state 45
    list_value                     shift and go to state 46
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 24

    (11) var_statement -> data_type IDENT . list_dec
    (12) list_dec -> . empty
    (13) list_dec -> . LBRACKET RBRACKET _2d_list
    (242) empty -> .

    LBRACKET        shift and go to state 61
    COMMA           reduce using rule 242 (empty -> .)
    EQ              reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

    list_dec                       shift and go to state 59
    empty                          shift and go to state 60

state 25

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

    NEWLINE         shift and go to state 18
    MAIN_CASPER     reduce using rule 242 (empty -> .)

    maybe_newline                  shift and go to state 62
    empty                          shift and go to state 17

state 26

    (87) function_statements -> ret_type . FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail

    FUNCTION_NAME   shift and go to state 63


state 27

    (88) function_statements -> empty .

    NEWLINE         reduce using rule 88 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 88 (function_statements -> empty .)


state 28

    (91) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 91 (ret_type -> FUNCTION .)


state 29

    (92) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 92 (ret_type -> function_dtype .)


state 30

    (93) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 93 (function_dtype -> FUNCTION_INT .)


state 31

    (94) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 94 (function_dtype -> FUNCTION_FLT .)


state 32

    (95) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 95 (function_dtype -> FUNCTION_CHR .)


state 33

    (96) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 96 (function_dtype -> FUNCTION_BLN .)


state 34

    (97) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 97 (function_dtype -> FUNCTION_STR .)


state 35

    (98) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 98 (function_dtype -> FUNCTION_LIST_INT .)


state 36

    (99) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 99 (function_dtype -> FUNCTION_LIST_FLT .)


state 37

    (100) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 100 (function_dtype -> FUNCTION_LIST_CHR .)


state 38

    (101) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 101 (function_dtype -> FUNCTION_LIST_STR .)


state 39

    (102) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 102 (function_dtype -> FUNCTION_LIST_BLN .)


state 40

    (3) maybe_newline -> NEWLINE maybe_newline .

    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INPUT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE_CHECK reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 41

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 42

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)


state 43

    (17) global_statement_tail -> COMMA IDENT . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (242) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 242 (empty -> .)

    global_statement_tail          shift and go to state 64
    empty                          shift and go to state 21

state 44

    (18) global_statement_tail -> EQ global_value . global_statement_tail2
    (19) global_statement_tail2 -> . COMMA IDENT global_statement_tail
    (20) global_statement_tail2 -> . empty
    (242) empty -> .

    COMMA           shift and go to state 66
    NEWLINE         reduce using rule 242 (empty -> .)

    global_statement_tail2         shift and go to state 65
    empty                          shift and go to state 67

state 45

    (21) global_value -> expression .

    COMMA           reduce using rule 21 (global_value -> expression .)
    NEWLINE         reduce using rule 21 (global_value -> expression .)


state 46

    (22) global_value -> list_value .

    COMMA           reduce using rule 22 (global_value -> list_value .)
    NEWLINE         reduce using rule 22 (global_value -> list_value .)


state 47

    (32) expression -> factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 68
    empty                          shift and go to state 83

state 48

    (23) list_value -> LBRACKET . list_element RBRACKET
    (24) list_element -> . literal element_tail
    (79) literal -> . literal1
    (80) literal -> . literal2
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT
    (86) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 84
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 49

    (33) factor -> var_call . postfix
    (229) postfix -> . empty
    (230) postfix -> . postfix_op
    (242) empty -> .
    (193) postfix_op -> . PLUS_PLUS
    (194) postfix_op -> . MINUS_MINUS

    PLUS            reduce using rule 242 (empty -> .)
    MINUS           reduce using rule 242 (empty -> .)
    MULTIPLY        reduce using rule 242 (empty -> .)
    DIVISION        reduce using rule 242 (empty -> .)
    MODULO          reduce using rule 242 (empty -> .)
    EXPONENT        reduce using rule 242 (empty -> .)
    GT              reduce using rule 242 (empty -> .)
    LT              reduce using rule 242 (empty -> .)
    EQ_EQ           reduce using rule 242 (empty -> .)
    GT_EQ           reduce using rule 242 (empty -> .)
    LT_EQ           reduce using rule 242 (empty -> .)
    NOT_EQ          reduce using rule 242 (empty -> .)
    AND             reduce using rule 242 (empty -> .)
    OR              reduce using rule 242 (empty -> .)
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)
    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93

    postfix                        shift and go to state 89
    empty                          shift and go to state 90
    postfix_op                     shift and go to state 91

state 50

    (34) factor -> literal1 .

    PLUS            reduce using rule 34 (factor -> literal1 .)
    MINUS           reduce using rule 34 (factor -> literal1 .)
    MULTIPLY        reduce using rule 34 (factor -> literal1 .)
    DIVISION        reduce using rule 34 (factor -> literal1 .)
    MODULO          reduce using rule 34 (factor -> literal1 .)
    EXPONENT        reduce using rule 34 (factor -> literal1 .)
    GT              reduce using rule 34 (factor -> literal1 .)
    LT              reduce using rule 34 (factor -> literal1 .)
    EQ_EQ           reduce using rule 34 (factor -> literal1 .)
    GT_EQ           reduce using rule 34 (factor -> literal1 .)
    LT_EQ           reduce using rule 34 (factor -> literal1 .)
    NOT_EQ          reduce using rule 34 (factor -> literal1 .)
    AND             reduce using rule 34 (factor -> literal1 .)
    OR              reduce using rule 34 (factor -> literal1 .)
    COMMA           reduce using rule 34 (factor -> literal1 .)
    NEWLINE         reduce using rule 34 (factor -> literal1 .)
    SWAP            reduce using rule 34 (factor -> literal1 .)
    FUNCTION_NAME   reduce using rule 34 (factor -> literal1 .)
    IDENT           reduce using rule 34 (factor -> literal1 .)
    DISPLAY         reduce using rule 34 (factor -> literal1 .)
    CHECK           reduce using rule 34 (factor -> literal1 .)
    FOR             reduce using rule 34 (factor -> literal1 .)
    UNTIL           reduce using rule 34 (factor -> literal1 .)
    REPEAT          reduce using rule 34 (factor -> literal1 .)
    INPUT           reduce using rule 34 (factor -> literal1 .)
    INT             reduce using rule 34 (factor -> literal1 .)
    FLT             reduce using rule 34 (factor -> literal1 .)
    BLN             reduce using rule 34 (factor -> literal1 .)
    CHR             reduce using rule 34 (factor -> literal1 .)
    STR             reduce using rule 34 (factor -> literal1 .)
    REVIVE          reduce using rule 34 (factor -> literal1 .)
    RBRACE          reduce using rule 34 (factor -> literal1 .)
    SHIFT           reduce using rule 34 (factor -> literal1 .)
    OTHERWISE       reduce using rule 34 (factor -> literal1 .)
    RPAREN          reduce using rule 34 (factor -> literal1 .)
    SEMICOLON       reduce using rule 34 (factor -> literal1 .)
    COLON           reduce using rule 34 (factor -> literal1 .)


state 51

    (35) factor -> TILDE . INT_LIT
    (36) factor -> TILDE . FLT_LIT

    INT_LIT         shift and go to state 94
    FLT_LIT         shift and go to state 95


state 52

    (81) literal1 -> INT_LIT .

    PLUS            reduce using rule 81 (literal1 -> INT_LIT .)
    MINUS           reduce using rule 81 (literal1 -> INT_LIT .)
    MULTIPLY        reduce using rule 81 (literal1 -> INT_LIT .)
    DIVISION        reduce using rule 81 (literal1 -> INT_LIT .)
    MODULO          reduce using rule 81 (literal1 -> INT_LIT .)
    EXPONENT        reduce using rule 81 (literal1 -> INT_LIT .)
    GT              reduce using rule 81 (literal1 -> INT_LIT .)
    LT              reduce using rule 81 (literal1 -> INT_LIT .)
    EQ_EQ           reduce using rule 81 (literal1 -> INT_LIT .)
    GT_EQ           reduce using rule 81 (literal1 -> INT_LIT .)
    LT_EQ           reduce using rule 81 (literal1 -> INT_LIT .)
    NOT_EQ          reduce using rule 81 (literal1 -> INT_LIT .)
    AND             reduce using rule 81 (literal1 -> INT_LIT .)
    OR              reduce using rule 81 (literal1 -> INT_LIT .)
    COMMA           reduce using rule 81 (literal1 -> INT_LIT .)
    NEWLINE         reduce using rule 81 (literal1 -> INT_LIT .)
    RBRACKET        reduce using rule 81 (literal1 -> INT_LIT .)
    SWAP            reduce using rule 81 (literal1 -> INT_LIT .)
    FUNCTION_NAME   reduce using rule 81 (literal1 -> INT_LIT .)
    IDENT           reduce using rule 81 (literal1 -> INT_LIT .)
    DISPLAY         reduce using rule 81 (literal1 -> INT_LIT .)
    CHECK           reduce using rule 81 (literal1 -> INT_LIT .)
    FOR             reduce using rule 81 (literal1 -> INT_LIT .)
    UNTIL           reduce using rule 81 (literal1 -> INT_LIT .)
    REPEAT          reduce using rule 81 (literal1 -> INT_LIT .)
    INPUT           reduce using rule 81 (literal1 -> INT_LIT .)
    INT             reduce using rule 81 (literal1 -> INT_LIT .)
    FLT             reduce using rule 81 (literal1 -> INT_LIT .)
    BLN             reduce using rule 81 (literal1 -> INT_LIT .)
    CHR             reduce using rule 81 (literal1 -> INT_LIT .)
    STR             reduce using rule 81 (literal1 -> INT_LIT .)
    REVIVE          reduce using rule 81 (literal1 -> INT_LIT .)
    RBRACE          reduce using rule 81 (literal1 -> INT_LIT .)
    SHIFT           reduce using rule 81 (literal1 -> INT_LIT .)
    OTHERWISE       reduce using rule 81 (literal1 -> INT_LIT .)
    RPAREN          reduce using rule 81 (literal1 -> INT_LIT .)
    SEMICOLON       reduce using rule 81 (literal1 -> INT_LIT .)
    COLON           reduce using rule 81 (literal1 -> INT_LIT .)


state 53

    (82) literal1 -> FLT_LIT .

    PLUS            reduce using rule 82 (literal1 -> FLT_LIT .)
    MINUS           reduce using rule 82 (literal1 -> FLT_LIT .)
    MULTIPLY        reduce using rule 82 (literal1 -> FLT_LIT .)
    DIVISION        reduce using rule 82 (literal1 -> FLT_LIT .)
    MODULO          reduce using rule 82 (literal1 -> FLT_LIT .)
    EXPONENT        reduce using rule 82 (literal1 -> FLT_LIT .)
    GT              reduce using rule 82 (literal1 -> FLT_LIT .)
    LT              reduce using rule 82 (literal1 -> FLT_LIT .)
    EQ_EQ           reduce using rule 82 (literal1 -> FLT_LIT .)
    GT_EQ           reduce using rule 82 (literal1 -> FLT_LIT .)
    LT_EQ           reduce using rule 82 (literal1 -> FLT_LIT .)
    NOT_EQ          reduce using rule 82 (literal1 -> FLT_LIT .)
    AND             reduce using rule 82 (literal1 -> FLT_LIT .)
    OR              reduce using rule 82 (literal1 -> FLT_LIT .)
    COMMA           reduce using rule 82 (literal1 -> FLT_LIT .)
    NEWLINE         reduce using rule 82 (literal1 -> FLT_LIT .)
    RBRACKET        reduce using rule 82 (literal1 -> FLT_LIT .)
    SWAP            reduce using rule 82 (literal1 -> FLT_LIT .)
    FUNCTION_NAME   reduce using rule 82 (literal1 -> FLT_LIT .)
    IDENT           reduce using rule 82 (literal1 -> FLT_LIT .)
    DISPLAY         reduce using rule 82 (literal1 -> FLT_LIT .)
    CHECK           reduce using rule 82 (literal1 -> FLT_LIT .)
    FOR             reduce using rule 82 (literal1 -> FLT_LIT .)
    UNTIL           reduce using rule 82 (literal1 -> FLT_LIT .)
    REPEAT          reduce using rule 82 (literal1 -> FLT_LIT .)
    INPUT           reduce using rule 82 (literal1 -> FLT_LIT .)
    INT             reduce using rule 82 (literal1 -> FLT_LIT .)
    FLT             reduce using rule 82 (literal1 -> FLT_LIT .)
    BLN             reduce using rule 82 (literal1 -> FLT_LIT .)
    CHR             reduce using rule 82 (literal1 -> FLT_LIT .)
    STR             reduce using rule 82 (literal1 -> FLT_LIT .)
    REVIVE          reduce using rule 82 (literal1 -> FLT_LIT .)
    RBRACE          reduce using rule 82 (literal1 -> FLT_LIT .)
    SHIFT           reduce using rule 82 (literal1 -> FLT_LIT .)
    OTHERWISE       reduce using rule 82 (literal1 -> FLT_LIT .)
    RPAREN          reduce using rule 82 (literal1 -> FLT_LIT .)
    SEMICOLON       reduce using rule 82 (literal1 -> FLT_LIT .)
    COLON           reduce using rule 82 (literal1 -> FLT_LIT .)


state 54

    (37) factor -> LPAREN . factor_expression RPAREN
    (38) factor_expression -> . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression              shift and go to state 97
    factor_expression_factor       shift and go to state 98
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 55

    (222) var_call -> IDENT . list_index
    (223) list_index -> . LBRACKET index RBRACKET list_index2
    (224) list_index -> . empty
    (242) empty -> .

    LBRACKET        shift and go to state 108
    PLUS_PLUS       reduce using rule 242 (empty -> .)
    MINUS_MINUS     reduce using rule 242 (empty -> .)
    PLUS            reduce using rule 242 (empty -> .)
    MINUS           reduce using rule 242 (empty -> .)
    MULTIPLY        reduce using rule 242 (empty -> .)
    DIVISION        reduce using rule 242 (empty -> .)
    MODULO          reduce using rule 242 (empty -> .)
    EXPONENT        reduce using rule 242 (empty -> .)
    GT              reduce using rule 242 (empty -> .)
    LT              reduce using rule 242 (empty -> .)
    EQ_EQ           reduce using rule 242 (empty -> .)
    GT_EQ           reduce using rule 242 (empty -> .)
    LT_EQ           reduce using rule 242 (empty -> .)
    NOT_EQ          reduce using rule 242 (empty -> .)
    AND             reduce using rule 242 (empty -> .)
    OR              reduce using rule 242 (empty -> .)
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)
    PLUS_EQ         reduce using rule 242 (empty -> .)
    MINUS_EQ        reduce using rule 242 (empty -> .)
    MUL_EQ          reduce using rule 242 (empty -> .)
    DIV_EQ          reduce using rule 242 (empty -> .)
    MOD_EQ          reduce using rule 242 (empty -> .)

    list_index                     shift and go to state 107
    empty                          shift and go to state 109

state 56

    (83) literal1 -> DAY .

    PLUS            reduce using rule 83 (literal1 -> DAY .)
    MINUS           reduce using rule 83 (literal1 -> DAY .)
    MULTIPLY        reduce using rule 83 (literal1 -> DAY .)
    DIVISION        reduce using rule 83 (literal1 -> DAY .)
    MODULO          reduce using rule 83 (literal1 -> DAY .)
    EXPONENT        reduce using rule 83 (literal1 -> DAY .)
    GT              reduce using rule 83 (literal1 -> DAY .)
    LT              reduce using rule 83 (literal1 -> DAY .)
    EQ_EQ           reduce using rule 83 (literal1 -> DAY .)
    GT_EQ           reduce using rule 83 (literal1 -> DAY .)
    LT_EQ           reduce using rule 83 (literal1 -> DAY .)
    NOT_EQ          reduce using rule 83 (literal1 -> DAY .)
    AND             reduce using rule 83 (literal1 -> DAY .)
    OR              reduce using rule 83 (literal1 -> DAY .)
    COMMA           reduce using rule 83 (literal1 -> DAY .)
    NEWLINE         reduce using rule 83 (literal1 -> DAY .)
    RBRACKET        reduce using rule 83 (literal1 -> DAY .)
    SWAP            reduce using rule 83 (literal1 -> DAY .)
    FUNCTION_NAME   reduce using rule 83 (literal1 -> DAY .)
    IDENT           reduce using rule 83 (literal1 -> DAY .)
    DISPLAY         reduce using rule 83 (literal1 -> DAY .)
    CHECK           reduce using rule 83 (literal1 -> DAY .)
    FOR             reduce using rule 83 (literal1 -> DAY .)
    UNTIL           reduce using rule 83 (literal1 -> DAY .)
    REPEAT          reduce using rule 83 (literal1 -> DAY .)
    INPUT           reduce using rule 83 (literal1 -> DAY .)
    INT             reduce using rule 83 (literal1 -> DAY .)
    FLT             reduce using rule 83 (literal1 -> DAY .)
    BLN             reduce using rule 83 (literal1 -> DAY .)
    CHR             reduce using rule 83 (literal1 -> DAY .)
    STR             reduce using rule 83 (literal1 -> DAY .)
    REVIVE          reduce using rule 83 (literal1 -> DAY .)
    RBRACE          reduce using rule 83 (literal1 -> DAY .)
    SHIFT           reduce using rule 83 (literal1 -> DAY .)
    OTHERWISE       reduce using rule 83 (literal1 -> DAY .)
    RPAREN          reduce using rule 83 (literal1 -> DAY .)
    SEMICOLON       reduce using rule 83 (literal1 -> DAY .)
    COLON           reduce using rule 83 (literal1 -> DAY .)


state 57

    (84) literal1 -> NIGHT .

    PLUS            reduce using rule 84 (literal1 -> NIGHT .)
    MINUS           reduce using rule 84 (literal1 -> NIGHT .)
    MULTIPLY        reduce using rule 84 (literal1 -> NIGHT .)
    DIVISION        reduce using rule 84 (literal1 -> NIGHT .)
    MODULO          reduce using rule 84 (literal1 -> NIGHT .)
    EXPONENT        reduce using rule 84 (literal1 -> NIGHT .)
    GT              reduce using rule 84 (literal1 -> NIGHT .)
    LT              reduce using rule 84 (literal1 -> NIGHT .)
    EQ_EQ           reduce using rule 84 (literal1 -> NIGHT .)
    GT_EQ           reduce using rule 84 (literal1 -> NIGHT .)
    LT_EQ           reduce using rule 84 (literal1 -> NIGHT .)
    NOT_EQ          reduce using rule 84 (literal1 -> NIGHT .)
    AND             reduce using rule 84 (literal1 -> NIGHT .)
    OR              reduce using rule 84 (literal1 -> NIGHT .)
    COMMA           reduce using rule 84 (literal1 -> NIGHT .)
    NEWLINE         reduce using rule 84 (literal1 -> NIGHT .)
    RBRACKET        reduce using rule 84 (literal1 -> NIGHT .)
    SWAP            reduce using rule 84 (literal1 -> NIGHT .)
    FUNCTION_NAME   reduce using rule 84 (literal1 -> NIGHT .)
    IDENT           reduce using rule 84 (literal1 -> NIGHT .)
    DISPLAY         reduce using rule 84 (literal1 -> NIGHT .)
    CHECK           reduce using rule 84 (literal1 -> NIGHT .)
    FOR             reduce using rule 84 (literal1 -> NIGHT .)
    UNTIL           reduce using rule 84 (literal1 -> NIGHT .)
    REPEAT          reduce using rule 84 (literal1 -> NIGHT .)
    INPUT           reduce using rule 84 (literal1 -> NIGHT .)
    INT             reduce using rule 84 (literal1 -> NIGHT .)
    FLT             reduce using rule 84 (literal1 -> NIGHT .)
    BLN             reduce using rule 84 (literal1 -> NIGHT .)
    CHR             reduce using rule 84 (literal1 -> NIGHT .)
    STR             reduce using rule 84 (literal1 -> NIGHT .)
    REVIVE          reduce using rule 84 (literal1 -> NIGHT .)
    RBRACE          reduce using rule 84 (literal1 -> NIGHT .)
    SHIFT           reduce using rule 84 (literal1 -> NIGHT .)
    OTHERWISE       reduce using rule 84 (literal1 -> NIGHT .)
    RPAREN          reduce using rule 84 (literal1 -> NIGHT .)
    SEMICOLON       reduce using rule 84 (literal1 -> NIGHT .)
    COLON           reduce using rule 84 (literal1 -> NIGHT .)


state 58

    (85) literal1 -> STR_LIT .

    PLUS            reduce using rule 85 (literal1 -> STR_LIT .)
    MINUS           reduce using rule 85 (literal1 -> STR_LIT .)
    MULTIPLY        reduce using rule 85 (literal1 -> STR_LIT .)
    DIVISION        reduce using rule 85 (literal1 -> STR_LIT .)
    MODULO          reduce using rule 85 (literal1 -> STR_LIT .)
    EXPONENT        reduce using rule 85 (literal1 -> STR_LIT .)
    GT              reduce using rule 85 (literal1 -> STR_LIT .)
    LT              reduce using rule 85 (literal1 -> STR_LIT .)
    EQ_EQ           reduce using rule 85 (literal1 -> STR_LIT .)
    GT_EQ           reduce using rule 85 (literal1 -> STR_LIT .)
    LT_EQ           reduce using rule 85 (literal1 -> STR_LIT .)
    NOT_EQ          reduce using rule 85 (literal1 -> STR_LIT .)
    AND             reduce using rule 85 (literal1 -> STR_LIT .)
    OR              reduce using rule 85 (literal1 -> STR_LIT .)
    COMMA           reduce using rule 85 (literal1 -> STR_LIT .)
    NEWLINE         reduce using rule 85 (literal1 -> STR_LIT .)
    RBRACKET        reduce using rule 85 (literal1 -> STR_LIT .)
    SWAP            reduce using rule 85 (literal1 -> STR_LIT .)
    FUNCTION_NAME   reduce using rule 85 (literal1 -> STR_LIT .)
    IDENT           reduce using rule 85 (literal1 -> STR_LIT .)
    DISPLAY         reduce using rule 85 (literal1 -> STR_LIT .)
    CHECK           reduce using rule 85 (literal1 -> STR_LIT .)
    FOR             reduce using rule 85 (literal1 -> STR_LIT .)
    UNTIL           reduce using rule 85 (literal1 -> STR_LIT .)
    REPEAT          reduce using rule 85 (literal1 -> STR_LIT .)
    INPUT           reduce using rule 85 (literal1 -> STR_LIT .)
    INT             reduce using rule 85 (literal1 -> STR_LIT .)
    FLT             reduce using rule 85 (literal1 -> STR_LIT .)
    BLN             reduce using rule 85 (literal1 -> STR_LIT .)
    CHR             reduce using rule 85 (literal1 -> STR_LIT .)
    STR             reduce using rule 85 (literal1 -> STR_LIT .)
    REVIVE          reduce using rule 85 (literal1 -> STR_LIT .)
    RBRACE          reduce using rule 85 (literal1 -> STR_LIT .)
    SHIFT           reduce using rule 85 (literal1 -> STR_LIT .)
    OTHERWISE       reduce using rule 85 (literal1 -> STR_LIT .)
    RPAREN          reduce using rule 85 (literal1 -> STR_LIT .)
    SEMICOLON       reduce using rule 85 (literal1 -> STR_LIT .)
    COLON           reduce using rule 85 (literal1 -> STR_LIT .)


state 59

    (11) var_statement -> data_type IDENT list_dec .

    COMMA           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    EQ              reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    NEWLINE         reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    SWAP            reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_NAME   reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    IDENT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    DISPLAY         reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    CHECK           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FOR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    UNTIL           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    REPEAT          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    INPUT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    INT             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FLT             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    BLN             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    CHR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    STR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    REVIVE          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    RBRACE          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    SHIFT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    OTHERWISE       reduce using rule 11 (var_statement -> data_type IDENT list_dec .)


state 60

    (12) list_dec -> empty .

    COMMA           reduce using rule 12 (list_dec -> empty .)
    EQ              reduce using rule 12 (list_dec -> empty .)
    NEWLINE         reduce using rule 12 (list_dec -> empty .)
    SWAP            reduce using rule 12 (list_dec -> empty .)
    FUNCTION_NAME   reduce using rule 12 (list_dec -> empty .)
    IDENT           reduce using rule 12 (list_dec -> empty .)
    DISPLAY         reduce using rule 12 (list_dec -> empty .)
    CHECK           reduce using rule 12 (list_dec -> empty .)
    FOR             reduce using rule 12 (list_dec -> empty .)
    UNTIL           reduce using rule 12 (list_dec -> empty .)
    REPEAT          reduce using rule 12 (list_dec -> empty .)
    INPUT           reduce using rule 12 (list_dec -> empty .)
    INT             reduce using rule 12 (list_dec -> empty .)
    FLT             reduce using rule 12 (list_dec -> empty .)
    BLN             reduce using rule 12 (list_dec -> empty .)
    CHR             reduce using rule 12 (list_dec -> empty .)
    STR             reduce using rule 12 (list_dec -> empty .)
    REVIVE          reduce using rule 12 (list_dec -> empty .)
    RBRACE          reduce using rule 12 (list_dec -> empty .)
    SHIFT           reduce using rule 12 (list_dec -> empty .)
    OTHERWISE       reduce using rule 12 (list_dec -> empty .)


state 61

    (13) list_dec -> LBRACKET . RBRACKET _2d_list

    RBRACKET        shift and go to state 110


state 62

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 112

    main_function                  shift and go to state 111

state 63

    (87) function_statements -> ret_type FUNCTION_NAME . LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail

    LPAREN          shift and go to state 113


state 64

    (17) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 65

    (18) global_statement_tail -> EQ global_value global_statement_tail2 .

    NEWLINE         reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)


state 66

    (19) global_statement_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 114


state 67

    (20) global_statement_tail2 -> empty .

    NEWLINE         reduce using rule 20 (global_statement_tail2 -> empty .)


state 68

    (32) expression -> factor factor_tail .

    COMMA           reduce using rule 32 (expression -> factor factor_tail .)
    NEWLINE         reduce using rule 32 (expression -> factor factor_tail .)
    SWAP            reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_NAME   reduce using rule 32 (expression -> factor factor_tail .)
    IDENT           reduce using rule 32 (expression -> factor factor_tail .)
    DISPLAY         reduce using rule 32 (expression -> factor factor_tail .)
    CHECK           reduce using rule 32 (expression -> factor factor_tail .)
    FOR             reduce using rule 32 (expression -> factor factor_tail .)
    UNTIL           reduce using rule 32 (expression -> factor factor_tail .)
    REPEAT          reduce using rule 32 (expression -> factor factor_tail .)
    INPUT           reduce using rule 32 (expression -> factor factor_tail .)
    INT             reduce using rule 32 (expression -> factor factor_tail .)
    FLT             reduce using rule 32 (expression -> factor factor_tail .)
    BLN             reduce using rule 32 (expression -> factor factor_tail .)
    CHR             reduce using rule 32 (expression -> factor factor_tail .)
    STR             reduce using rule 32 (expression -> factor factor_tail .)
    REVIVE          reduce using rule 32 (expression -> factor factor_tail .)
    RBRACE          reduce using rule 32 (expression -> factor factor_tail .)
    SHIFT           reduce using rule 32 (expression -> factor factor_tail .)
    OTHERWISE       reduce using rule 32 (expression -> factor factor_tail .)
    RPAREN          reduce using rule 32 (expression -> factor factor_tail .)
    SEMICOLON       reduce using rule 32 (expression -> factor factor_tail .)
    COLON           reduce using rule 32 (expression -> factor factor_tail .)


state 69

    (64) factor_tail -> PLUS . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 115
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 70

    (65) factor_tail -> MINUS . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 116
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 71

    (66) factor_tail -> MULTIPLY . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 117
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 72

    (67) factor_tail -> DIVISION . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 118
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 73

    (68) factor_tail -> MODULO . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 119
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 74

    (69) factor_tail -> EXPONENT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 120
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 75

    (70) factor_tail -> GT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 121
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 76

    (71) factor_tail -> LT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 122
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 77

    (72) factor_tail -> EQ_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 123
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 78

    (73) factor_tail -> GT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 124
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 79

    (74) factor_tail -> LT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 125
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 80

    (75) factor_tail -> NOT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 126
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 81

    (76) factor_tail -> AND . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 127
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 82

    (77) factor_tail -> OR . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 128
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 83

    (78) factor_tail -> empty .

    COMMA           reduce using rule 78 (factor_tail -> empty .)
    NEWLINE         reduce using rule 78 (factor_tail -> empty .)
    SWAP            reduce using rule 78 (factor_tail -> empty .)
    FUNCTION_NAME   reduce using rule 78 (factor_tail -> empty .)
    IDENT           reduce using rule 78 (factor_tail -> empty .)
    DISPLAY         reduce using rule 78 (factor_tail -> empty .)
    CHECK           reduce using rule 78 (factor_tail -> empty .)
    FOR             reduce using rule 78 (factor_tail -> empty .)
    UNTIL           reduce using rule 78 (factor_tail -> empty .)
    REPEAT          reduce using rule 78 (factor_tail -> empty .)
    INPUT           reduce using rule 78 (factor_tail -> empty .)
    INT             reduce using rule 78 (factor_tail -> empty .)
    FLT             reduce using rule 78 (factor_tail -> empty .)
    BLN             reduce using rule 78 (factor_tail -> empty .)
    CHR             reduce using rule 78 (factor_tail -> empty .)
    STR             reduce using rule 78 (factor_tail -> empty .)
    REVIVE          reduce using rule 78 (factor_tail -> empty .)
    RBRACE          reduce using rule 78 (factor_tail -> empty .)
    SHIFT           reduce using rule 78 (factor_tail -> empty .)
    OTHERWISE       reduce using rule 78 (factor_tail -> empty .)
    RPAREN          reduce using rule 78 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 78 (factor_tail -> empty .)
    COLON           reduce using rule 78 (factor_tail -> empty .)


state 84

    (23) list_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 129


state 85

    (24) list_element -> literal . element_tail
    (25) element_tail -> . COMMA list_element
    (26) element_tail -> . empty
    (242) empty -> .

    COMMA           shift and go to state 131
    RBRACKET        reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)

    element_tail                   shift and go to state 130
    empty                          shift and go to state 132

state 86

    (79) literal -> literal1 .

    COMMA           reduce using rule 79 (literal -> literal1 .)
    RBRACKET        reduce using rule 79 (literal -> literal1 .)
    RPAREN          reduce using rule 79 (literal -> literal1 .)


state 87

    (80) literal -> literal2 .

    COMMA           reduce using rule 80 (literal -> literal2 .)
    RBRACKET        reduce using rule 80 (literal -> literal2 .)
    RPAREN          reduce using rule 80 (literal -> literal2 .)


state 88

    (86) literal2 -> CHR_LIT .

    COMMA           reduce using rule 86 (literal2 -> CHR_LIT .)
    RBRACKET        reduce using rule 86 (literal2 -> CHR_LIT .)
    RPAREN          reduce using rule 86 (literal2 -> CHR_LIT .)


state 89

    (33) factor -> var_call postfix .

    PLUS            reduce using rule 33 (factor -> var_call postfix .)
    MINUS           reduce using rule 33 (factor -> var_call postfix .)
    MULTIPLY        reduce using rule 33 (factor -> var_call postfix .)
    DIVISION        reduce using rule 33 (factor -> var_call postfix .)
    MODULO          reduce using rule 33 (factor -> var_call postfix .)
    EXPONENT        reduce using rule 33 (factor -> var_call postfix .)
    GT              reduce using rule 33 (factor -> var_call postfix .)
    LT              reduce using rule 33 (factor -> var_call postfix .)
    EQ_EQ           reduce using rule 33 (factor -> var_call postfix .)
    GT_EQ           reduce using rule 33 (factor -> var_call postfix .)
    LT_EQ           reduce using rule 33 (factor -> var_call postfix .)
    NOT_EQ          reduce using rule 33 (factor -> var_call postfix .)
    AND             reduce using rule 33 (factor -> var_call postfix .)
    OR              reduce using rule 33 (factor -> var_call postfix .)
    COMMA           reduce using rule 33 (factor -> var_call postfix .)
    NEWLINE         reduce using rule 33 (factor -> var_call postfix .)
    SWAP            reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_NAME   reduce using rule 33 (factor -> var_call postfix .)
    IDENT           reduce using rule 33 (factor -> var_call postfix .)
    DISPLAY         reduce using rule 33 (factor -> var_call postfix .)
    CHECK           reduce using rule 33 (factor -> var_call postfix .)
    FOR             reduce using rule 33 (factor -> var_call postfix .)
    UNTIL           reduce using rule 33 (factor -> var_call postfix .)
    REPEAT          reduce using rule 33 (factor -> var_call postfix .)
    INPUT           reduce using rule 33 (factor -> var_call postfix .)
    INT             reduce using rule 33 (factor -> var_call postfix .)
    FLT             reduce using rule 33 (factor -> var_call postfix .)
    BLN             reduce using rule 33 (factor -> var_call postfix .)
    CHR             reduce using rule 33 (factor -> var_call postfix .)
    STR             reduce using rule 33 (factor -> var_call postfix .)
    REVIVE          reduce using rule 33 (factor -> var_call postfix .)
    RBRACE          reduce using rule 33 (factor -> var_call postfix .)
    SHIFT           reduce using rule 33 (factor -> var_call postfix .)
    OTHERWISE       reduce using rule 33 (factor -> var_call postfix .)
    RPAREN          reduce using rule 33 (factor -> var_call postfix .)
    SEMICOLON       reduce using rule 33 (factor -> var_call postfix .)
    COLON           reduce using rule 33 (factor -> var_call postfix .)


state 90

    (229) postfix -> empty .

    PLUS            reduce using rule 229 (postfix -> empty .)
    MINUS           reduce using rule 229 (postfix -> empty .)
    MULTIPLY        reduce using rule 229 (postfix -> empty .)
    DIVISION        reduce using rule 229 (postfix -> empty .)
    MODULO          reduce using rule 229 (postfix -> empty .)
    EXPONENT        reduce using rule 229 (postfix -> empty .)
    GT              reduce using rule 229 (postfix -> empty .)
    LT              reduce using rule 229 (postfix -> empty .)
    EQ_EQ           reduce using rule 229 (postfix -> empty .)
    GT_EQ           reduce using rule 229 (postfix -> empty .)
    LT_EQ           reduce using rule 229 (postfix -> empty .)
    NOT_EQ          reduce using rule 229 (postfix -> empty .)
    AND             reduce using rule 229 (postfix -> empty .)
    OR              reduce using rule 229 (postfix -> empty .)
    COMMA           reduce using rule 229 (postfix -> empty .)
    NEWLINE         reduce using rule 229 (postfix -> empty .)
    SWAP            reduce using rule 229 (postfix -> empty .)
    FUNCTION_NAME   reduce using rule 229 (postfix -> empty .)
    IDENT           reduce using rule 229 (postfix -> empty .)
    DISPLAY         reduce using rule 229 (postfix -> empty .)
    CHECK           reduce using rule 229 (postfix -> empty .)
    FOR             reduce using rule 229 (postfix -> empty .)
    UNTIL           reduce using rule 229 (postfix -> empty .)
    REPEAT          reduce using rule 229 (postfix -> empty .)
    INPUT           reduce using rule 229 (postfix -> empty .)
    INT             reduce using rule 229 (postfix -> empty .)
    FLT             reduce using rule 229 (postfix -> empty .)
    BLN             reduce using rule 229 (postfix -> empty .)
    CHR             reduce using rule 229 (postfix -> empty .)
    STR             reduce using rule 229 (postfix -> empty .)
    REVIVE          reduce using rule 229 (postfix -> empty .)
    RBRACE          reduce using rule 229 (postfix -> empty .)
    SHIFT           reduce using rule 229 (postfix -> empty .)
    OTHERWISE       reduce using rule 229 (postfix -> empty .)
    RPAREN          reduce using rule 229 (postfix -> empty .)
    SEMICOLON       reduce using rule 229 (postfix -> empty .)
    COLON           reduce using rule 229 (postfix -> empty .)


state 91

    (230) postfix -> postfix_op .

    PLUS            reduce using rule 230 (postfix -> postfix_op .)
    MINUS           reduce using rule 230 (postfix -> postfix_op .)
    MULTIPLY        reduce using rule 230 (postfix -> postfix_op .)
    DIVISION        reduce using rule 230 (postfix -> postfix_op .)
    MODULO          reduce using rule 230 (postfix -> postfix_op .)
    EXPONENT        reduce using rule 230 (postfix -> postfix_op .)
    GT              reduce using rule 230 (postfix -> postfix_op .)
    LT              reduce using rule 230 (postfix -> postfix_op .)
    EQ_EQ           reduce using rule 230 (postfix -> postfix_op .)
    GT_EQ           reduce using rule 230 (postfix -> postfix_op .)
    LT_EQ           reduce using rule 230 (postfix -> postfix_op .)
    NOT_EQ          reduce using rule 230 (postfix -> postfix_op .)
    AND             reduce using rule 230 (postfix -> postfix_op .)
    OR              reduce using rule 230 (postfix -> postfix_op .)
    COMMA           reduce using rule 230 (postfix -> postfix_op .)
    NEWLINE         reduce using rule 230 (postfix -> postfix_op .)
    SWAP            reduce using rule 230 (postfix -> postfix_op .)
    FUNCTION_NAME   reduce using rule 230 (postfix -> postfix_op .)
    IDENT           reduce using rule 230 (postfix -> postfix_op .)
    DISPLAY         reduce using rule 230 (postfix -> postfix_op .)
    CHECK           reduce using rule 230 (postfix -> postfix_op .)
    FOR             reduce using rule 230 (postfix -> postfix_op .)
    UNTIL           reduce using rule 230 (postfix -> postfix_op .)
    REPEAT          reduce using rule 230 (postfix -> postfix_op .)
    INPUT           reduce using rule 230 (postfix -> postfix_op .)
    INT             reduce using rule 230 (postfix -> postfix_op .)
    FLT             reduce using rule 230 (postfix -> postfix_op .)
    BLN             reduce using rule 230 (postfix -> postfix_op .)
    CHR             reduce using rule 230 (postfix -> postfix_op .)
    STR             reduce using rule 230 (postfix -> postfix_op .)
    REVIVE          reduce using rule 230 (postfix -> postfix_op .)
    RBRACE          reduce using rule 230 (postfix -> postfix_op .)
    SHIFT           reduce using rule 230 (postfix -> postfix_op .)
    OTHERWISE       reduce using rule 230 (postfix -> postfix_op .)
    RPAREN          reduce using rule 230 (postfix -> postfix_op .)
    SEMICOLON       reduce using rule 230 (postfix -> postfix_op .)
    COLON           reduce using rule 230 (postfix -> postfix_op .)


state 92

    (193) postfix_op -> PLUS_PLUS .

    PLUS            reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    MINUS           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    MULTIPLY        reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    DIVISION        reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    MODULO          reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    EXPONENT        reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    GT              reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    LT              reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    EQ_EQ           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    GT_EQ           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    LT_EQ           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    NOT_EQ          reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    AND             reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    OR              reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    COMMA           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    NEWLINE         reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    SWAP            reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    FUNCTION_NAME   reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    IDENT           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    DISPLAY         reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    CHECK           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    FOR             reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    UNTIL           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    REPEAT          reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    INPUT           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    INT             reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    FLT             reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    BLN             reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    CHR             reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    STR             reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    REVIVE          reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    RBRACE          reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    SHIFT           reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    OTHERWISE       reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    RPAREN          reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    SEMICOLON       reduce using rule 193 (postfix_op -> PLUS_PLUS .)
    COLON           reduce using rule 193 (postfix_op -> PLUS_PLUS .)


state 93

    (194) postfix_op -> MINUS_MINUS .

    PLUS            reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    MINUS           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    MULTIPLY        reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    DIVISION        reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    MODULO          reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    EXPONENT        reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    GT              reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    LT              reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    EQ_EQ           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    GT_EQ           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    LT_EQ           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    NOT_EQ          reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    AND             reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    OR              reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    COMMA           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    NEWLINE         reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    SWAP            reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    FUNCTION_NAME   reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    IDENT           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    DISPLAY         reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    CHECK           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    FOR             reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    UNTIL           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    REPEAT          reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    INPUT           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    INT             reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    FLT             reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    BLN             reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    CHR             reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    STR             reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    REVIVE          reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    RBRACE          reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    SHIFT           reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    OTHERWISE       reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    RPAREN          reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    SEMICOLON       reduce using rule 194 (postfix_op -> MINUS_MINUS .)
    COLON           reduce using rule 194 (postfix_op -> MINUS_MINUS .)


state 94

    (35) factor -> TILDE INT_LIT .

    PLUS            reduce using rule 35 (factor -> TILDE INT_LIT .)
    MINUS           reduce using rule 35 (factor -> TILDE INT_LIT .)
    MULTIPLY        reduce using rule 35 (factor -> TILDE INT_LIT .)
    DIVISION        reduce using rule 35 (factor -> TILDE INT_LIT .)
    MODULO          reduce using rule 35 (factor -> TILDE INT_LIT .)
    EXPONENT        reduce using rule 35 (factor -> TILDE INT_LIT .)
    GT              reduce using rule 35 (factor -> TILDE INT_LIT .)
    LT              reduce using rule 35 (factor -> TILDE INT_LIT .)
    EQ_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    GT_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    LT_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    NOT_EQ          reduce using rule 35 (factor -> TILDE INT_LIT .)
    AND             reduce using rule 35 (factor -> TILDE INT_LIT .)
    OR              reduce using rule 35 (factor -> TILDE INT_LIT .)
    COMMA           reduce using rule 35 (factor -> TILDE INT_LIT .)
    NEWLINE         reduce using rule 35 (factor -> TILDE INT_LIT .)
    SWAP            reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_NAME   reduce using rule 35 (factor -> TILDE INT_LIT .)
    IDENT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    DISPLAY         reduce using rule 35 (factor -> TILDE INT_LIT .)
    CHECK           reduce using rule 35 (factor -> TILDE INT_LIT .)
    FOR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    UNTIL           reduce using rule 35 (factor -> TILDE INT_LIT .)
    REPEAT          reduce using rule 35 (factor -> TILDE INT_LIT .)
    INPUT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    INT             reduce using rule 35 (factor -> TILDE INT_LIT .)
    FLT             reduce using rule 35 (factor -> TILDE INT_LIT .)
    BLN             reduce using rule 35 (factor -> TILDE INT_LIT .)
    CHR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    STR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    REVIVE          reduce using rule 35 (factor -> TILDE INT_LIT .)
    RBRACE          reduce using rule 35 (factor -> TILDE INT_LIT .)
    SHIFT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    OTHERWISE       reduce using rule 35 (factor -> TILDE INT_LIT .)
    RPAREN          reduce using rule 35 (factor -> TILDE INT_LIT .)
    SEMICOLON       reduce using rule 35 (factor -> TILDE INT_LIT .)
    COLON           reduce using rule 35 (factor -> TILDE INT_LIT .)


state 95

    (36) factor -> TILDE FLT_LIT .

    PLUS            reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MINUS           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MULTIPLY        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    DIVISION        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MODULO          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    EXPONENT        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    GT              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    LT              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    EQ_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    GT_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    LT_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    NOT_EQ          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    AND             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    OR              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    COMMA           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    NEWLINE         reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SWAP            reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_NAME   reduce using rule 36 (factor -> TILDE FLT_LIT .)
    IDENT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    DISPLAY         reduce using rule 36 (factor -> TILDE FLT_LIT .)
    CHECK           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FOR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    UNTIL           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    REPEAT          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    INPUT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    INT             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FLT             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    BLN             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    CHR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    STR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    REVIVE          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    RBRACE          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SHIFT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    OTHERWISE       reduce using rule 36 (factor -> TILDE FLT_LIT .)
    RPAREN          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SEMICOLON       reduce using rule 36 (factor -> TILDE FLT_LIT .)
    COLON           reduce using rule 36 (factor -> TILDE FLT_LIT .)


state 96

    (43) factor_expression_factor -> LPAREN . factor_expression RPAREN
    (38) factor_expression -> . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression              shift and go to state 133
    factor_expression_factor       shift and go to state 98
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 97

    (37) factor -> LPAREN factor_expression . RPAREN

    RPAREN          shift and go to state 134


state 98

    (38) factor_expression -> factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 135
    empty                          shift and go to state 150

state 99

    (39) factor_expression_factor -> var_call . postfix
    (229) postfix -> . empty
    (230) postfix -> . postfix_op
    (242) empty -> .
    (193) postfix_op -> . PLUS_PLUS
    (194) postfix_op -> . MINUS_MINUS

    PLUS            reduce using rule 242 (empty -> .)
    MINUS           reduce using rule 242 (empty -> .)
    MULTIPLY        reduce using rule 242 (empty -> .)
    DIVISION        reduce using rule 242 (empty -> .)
    MODULO          reduce using rule 242 (empty -> .)
    EXPONENT        reduce using rule 242 (empty -> .)
    GT              reduce using rule 242 (empty -> .)
    LT              reduce using rule 242 (empty -> .)
    EQ_EQ           reduce using rule 242 (empty -> .)
    GT_EQ           reduce using rule 242 (empty -> .)
    LT_EQ           reduce using rule 242 (empty -> .)
    NOT_EQ          reduce using rule 242 (empty -> .)
    AND             reduce using rule 242 (empty -> .)
    OR              reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93

    postfix                        shift and go to state 151
    empty                          shift and go to state 90
    postfix_op                     shift and go to state 91

state 100

    (40) factor_expression_factor -> factor_expression1 .

    PLUS            reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    MINUS           reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    MULTIPLY        reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    DIVISION        reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    MODULO          reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    EXPONENT        reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    GT              reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    LT              reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    EQ_EQ           reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    GT_EQ           reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    LT_EQ           reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    NOT_EQ          reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    AND             reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    OR              reduce using rule 40 (factor_expression_factor -> factor_expression1 .)
    RPAREN          reduce using rule 40 (factor_expression_factor -> factor_expression1 .)


state 101

    (41) factor_expression_factor -> TILDE . INT_LIT
    (42) factor_expression_factor -> TILDE . FLT_LIT

    INT_LIT         shift and go to state 152
    FLT_LIT         shift and go to state 153


state 102

    (59) factor_expression1 -> INT_LIT .

    PLUS            reduce using rule 59 (factor_expression1 -> INT_LIT .)
    MINUS           reduce using rule 59 (factor_expression1 -> INT_LIT .)
    MULTIPLY        reduce using rule 59 (factor_expression1 -> INT_LIT .)
    DIVISION        reduce using rule 59 (factor_expression1 -> INT_LIT .)
    MODULO          reduce using rule 59 (factor_expression1 -> INT_LIT .)
    EXPONENT        reduce using rule 59 (factor_expression1 -> INT_LIT .)
    GT              reduce using rule 59 (factor_expression1 -> INT_LIT .)
    LT              reduce using rule 59 (factor_expression1 -> INT_LIT .)
    EQ_EQ           reduce using rule 59 (factor_expression1 -> INT_LIT .)
    GT_EQ           reduce using rule 59 (factor_expression1 -> INT_LIT .)
    LT_EQ           reduce using rule 59 (factor_expression1 -> INT_LIT .)
    NOT_EQ          reduce using rule 59 (factor_expression1 -> INT_LIT .)
    AND             reduce using rule 59 (factor_expression1 -> INT_LIT .)
    OR              reduce using rule 59 (factor_expression1 -> INT_LIT .)
    RPAREN          reduce using rule 59 (factor_expression1 -> INT_LIT .)


state 103

    (60) factor_expression1 -> FLT_LIT .

    PLUS            reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    MINUS           reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    MULTIPLY        reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    DIVISION        reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    MODULO          reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    EXPONENT        reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    GT              reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    LT              reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    EQ_EQ           reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    GT_EQ           reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    LT_EQ           reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    NOT_EQ          reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    AND             reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    OR              reduce using rule 60 (factor_expression1 -> FLT_LIT .)
    RPAREN          reduce using rule 60 (factor_expression1 -> FLT_LIT .)


state 104

    (61) factor_expression1 -> DAY .

    PLUS            reduce using rule 61 (factor_expression1 -> DAY .)
    MINUS           reduce using rule 61 (factor_expression1 -> DAY .)
    MULTIPLY        reduce using rule 61 (factor_expression1 -> DAY .)
    DIVISION        reduce using rule 61 (factor_expression1 -> DAY .)
    MODULO          reduce using rule 61 (factor_expression1 -> DAY .)
    EXPONENT        reduce using rule 61 (factor_expression1 -> DAY .)
    GT              reduce using rule 61 (factor_expression1 -> DAY .)
    LT              reduce using rule 61 (factor_expression1 -> DAY .)
    EQ_EQ           reduce using rule 61 (factor_expression1 -> DAY .)
    GT_EQ           reduce using rule 61 (factor_expression1 -> DAY .)
    LT_EQ           reduce using rule 61 (factor_expression1 -> DAY .)
    NOT_EQ          reduce using rule 61 (factor_expression1 -> DAY .)
    AND             reduce using rule 61 (factor_expression1 -> DAY .)
    OR              reduce using rule 61 (factor_expression1 -> DAY .)
    RPAREN          reduce using rule 61 (factor_expression1 -> DAY .)


state 105

    (62) factor_expression1 -> NIGHT .

    PLUS            reduce using rule 62 (factor_expression1 -> NIGHT .)
    MINUS           reduce using rule 62 (factor_expression1 -> NIGHT .)
    MULTIPLY        reduce using rule 62 (factor_expression1 -> NIGHT .)
    DIVISION        reduce using rule 62 (factor_expression1 -> NIGHT .)
    MODULO          reduce using rule 62 (factor_expression1 -> NIGHT .)
    EXPONENT        reduce using rule 62 (factor_expression1 -> NIGHT .)
    GT              reduce using rule 62 (factor_expression1 -> NIGHT .)
    LT              reduce using rule 62 (factor_expression1 -> NIGHT .)
    EQ_EQ           reduce using rule 62 (factor_expression1 -> NIGHT .)
    GT_EQ           reduce using rule 62 (factor_expression1 -> NIGHT .)
    LT_EQ           reduce using rule 62 (factor_expression1 -> NIGHT .)
    NOT_EQ          reduce using rule 62 (factor_expression1 -> NIGHT .)
    AND             reduce using rule 62 (factor_expression1 -> NIGHT .)
    OR              reduce using rule 62 (factor_expression1 -> NIGHT .)
    RPAREN          reduce using rule 62 (factor_expression1 -> NIGHT .)


state 106

    (63) factor_expression1 -> STR_LIT .

    PLUS            reduce using rule 63 (factor_expression1 -> STR_LIT .)
    MINUS           reduce using rule 63 (factor_expression1 -> STR_LIT .)
    MULTIPLY        reduce using rule 63 (factor_expression1 -> STR_LIT .)
    DIVISION        reduce using rule 63 (factor_expression1 -> STR_LIT .)
    MODULO          reduce using rule 63 (factor_expression1 -> STR_LIT .)
    EXPONENT        reduce using rule 63 (factor_expression1 -> STR_LIT .)
    GT              reduce using rule 63 (factor_expression1 -> STR_LIT .)
    LT              reduce using rule 63 (factor_expression1 -> STR_LIT .)
    EQ_EQ           reduce using rule 63 (factor_expression1 -> STR_LIT .)
    GT_EQ           reduce using rule 63 (factor_expression1 -> STR_LIT .)
    LT_EQ           reduce using rule 63 (factor_expression1 -> STR_LIT .)
    NOT_EQ          reduce using rule 63 (factor_expression1 -> STR_LIT .)
    AND             reduce using rule 63 (factor_expression1 -> STR_LIT .)
    OR              reduce using rule 63 (factor_expression1 -> STR_LIT .)
    RPAREN          reduce using rule 63 (factor_expression1 -> STR_LIT .)


state 107

    (222) var_call -> IDENT list_index .

    PLUS_PLUS       reduce using rule 222 (var_call -> IDENT list_index .)
    MINUS_MINUS     reduce using rule 222 (var_call -> IDENT list_index .)
    PLUS            reduce using rule 222 (var_call -> IDENT list_index .)
    MINUS           reduce using rule 222 (var_call -> IDENT list_index .)
    MULTIPLY        reduce using rule 222 (var_call -> IDENT list_index .)
    DIVISION        reduce using rule 222 (var_call -> IDENT list_index .)
    MODULO          reduce using rule 222 (var_call -> IDENT list_index .)
    EXPONENT        reduce using rule 222 (var_call -> IDENT list_index .)
    GT              reduce using rule 222 (var_call -> IDENT list_index .)
    LT              reduce using rule 222 (var_call -> IDENT list_index .)
    EQ_EQ           reduce using rule 222 (var_call -> IDENT list_index .)
    GT_EQ           reduce using rule 222 (var_call -> IDENT list_index .)
    LT_EQ           reduce using rule 222 (var_call -> IDENT list_index .)
    NOT_EQ          reduce using rule 222 (var_call -> IDENT list_index .)
    AND             reduce using rule 222 (var_call -> IDENT list_index .)
    OR              reduce using rule 222 (var_call -> IDENT list_index .)
    COMMA           reduce using rule 222 (var_call -> IDENT list_index .)
    NEWLINE         reduce using rule 222 (var_call -> IDENT list_index .)
    RPAREN          reduce using rule 222 (var_call -> IDENT list_index .)
    SWAP            reduce using rule 222 (var_call -> IDENT list_index .)
    FUNCTION_NAME   reduce using rule 222 (var_call -> IDENT list_index .)
    IDENT           reduce using rule 222 (var_call -> IDENT list_index .)
    DISPLAY         reduce using rule 222 (var_call -> IDENT list_index .)
    CHECK           reduce using rule 222 (var_call -> IDENT list_index .)
    FOR             reduce using rule 222 (var_call -> IDENT list_index .)
    UNTIL           reduce using rule 222 (var_call -> IDENT list_index .)
    REPEAT          reduce using rule 222 (var_call -> IDENT list_index .)
    INPUT           reduce using rule 222 (var_call -> IDENT list_index .)
    INT             reduce using rule 222 (var_call -> IDENT list_index .)
    FLT             reduce using rule 222 (var_call -> IDENT list_index .)
    BLN             reduce using rule 222 (var_call -> IDENT list_index .)
    CHR             reduce using rule 222 (var_call -> IDENT list_index .)
    STR             reduce using rule 222 (var_call -> IDENT list_index .)
    REVIVE          reduce using rule 222 (var_call -> IDENT list_index .)
    RBRACE          reduce using rule 222 (var_call -> IDENT list_index .)
    SHIFT           reduce using rule 222 (var_call -> IDENT list_index .)
    OTHERWISE       reduce using rule 222 (var_call -> IDENT list_index .)
    SEMICOLON       reduce using rule 222 (var_call -> IDENT list_index .)
    COLON           reduce using rule 222 (var_call -> IDENT list_index .)
    PLUS_EQ         reduce using rule 222 (var_call -> IDENT list_index .)
    MINUS_EQ        reduce using rule 222 (var_call -> IDENT list_index .)
    MUL_EQ          reduce using rule 222 (var_call -> IDENT list_index .)
    DIV_EQ          reduce using rule 222 (var_call -> IDENT list_index .)
    MOD_EQ          reduce using rule 222 (var_call -> IDENT list_index .)


state 108

    (223) list_index -> LBRACKET . index RBRACKET list_index2
    (227) index -> . INT_LIT
    (228) index -> . IDENT

    INT_LIT         shift and go to state 155
    IDENT           shift and go to state 156

    index                          shift and go to state 154

state 109

    (224) list_index -> empty .

    PLUS_PLUS       reduce using rule 224 (list_index -> empty .)
    MINUS_MINUS     reduce using rule 224 (list_index -> empty .)
    PLUS            reduce using rule 224 (list_index -> empty .)
    MINUS           reduce using rule 224 (list_index -> empty .)
    MULTIPLY        reduce using rule 224 (list_index -> empty .)
    DIVISION        reduce using rule 224 (list_index -> empty .)
    MODULO          reduce using rule 224 (list_index -> empty .)
    EXPONENT        reduce using rule 224 (list_index -> empty .)
    GT              reduce using rule 224 (list_index -> empty .)
    LT              reduce using rule 224 (list_index -> empty .)
    EQ_EQ           reduce using rule 224 (list_index -> empty .)
    GT_EQ           reduce using rule 224 (list_index -> empty .)
    LT_EQ           reduce using rule 224 (list_index -> empty .)
    NOT_EQ          reduce using rule 224 (list_index -> empty .)
    AND             reduce using rule 224 (list_index -> empty .)
    OR              reduce using rule 224 (list_index -> empty .)
    COMMA           reduce using rule 224 (list_index -> empty .)
    NEWLINE         reduce using rule 224 (list_index -> empty .)
    RPAREN          reduce using rule 224 (list_index -> empty .)
    SWAP            reduce using rule 224 (list_index -> empty .)
    FUNCTION_NAME   reduce using rule 224 (list_index -> empty .)
    IDENT           reduce using rule 224 (list_index -> empty .)
    DISPLAY         reduce using rule 224 (list_index -> empty .)
    CHECK           reduce using rule 224 (list_index -> empty .)
    FOR             reduce using rule 224 (list_index -> empty .)
    UNTIL           reduce using rule 224 (list_index -> empty .)
    REPEAT          reduce using rule 224 (list_index -> empty .)
    INPUT           reduce using rule 224 (list_index -> empty .)
    INT             reduce using rule 224 (list_index -> empty .)
    FLT             reduce using rule 224 (list_index -> empty .)
    BLN             reduce using rule 224 (list_index -> empty .)
    CHR             reduce using rule 224 (list_index -> empty .)
    STR             reduce using rule 224 (list_index -> empty .)
    REVIVE          reduce using rule 224 (list_index -> empty .)
    RBRACE          reduce using rule 224 (list_index -> empty .)
    SHIFT           reduce using rule 224 (list_index -> empty .)
    OTHERWISE       reduce using rule 224 (list_index -> empty .)
    SEMICOLON       reduce using rule 224 (list_index -> empty .)
    COLON           reduce using rule 224 (list_index -> empty .)
    PLUS_EQ         reduce using rule 224 (list_index -> empty .)
    MINUS_EQ        reduce using rule 224 (list_index -> empty .)
    MUL_EQ          reduce using rule 224 (list_index -> empty .)
    DIV_EQ          reduce using rule 224 (list_index -> empty .)
    MOD_EQ          reduce using rule 224 (list_index -> empty .)


state 110

    (13) list_dec -> LBRACKET RBRACKET . _2d_list
    (14) _2d_list -> . empty
    (15) _2d_list -> . LBRACKET RBRACKET
    (242) empty -> .

    LBRACKET        shift and go to state 157
    COMMA           reduce using rule 242 (empty -> .)
    EQ              reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

    _2d_list                       shift and go to state 158
    empty                          shift and go to state 159

state 111

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 160

state 112

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 161


state 113

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN . parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (103) parameters -> . data_type IDENT parameters_tail
    (104) parameters -> . empty
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR
    (242) empty -> .

    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14
    RPAREN          reduce using rule 242 (empty -> .)

    parameters                     shift and go to state 162
    data_type                      shift and go to state 163
    empty                          shift and go to state 164

state 114

    (19) global_statement_tail2 -> COMMA IDENT . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (242) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 242 (empty -> .)

    global_statement_tail          shift and go to state 165
    empty                          shift and go to state 21

state 115

    (64) factor_tail -> PLUS factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 166
    empty                          shift and go to state 83

state 116

    (65) factor_tail -> MINUS factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 167
    empty                          shift and go to state 83

state 117

    (66) factor_tail -> MULTIPLY factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 168
    empty                          shift and go to state 83

state 118

    (67) factor_tail -> DIVISION factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 169
    empty                          shift and go to state 83

state 119

    (68) factor_tail -> MODULO factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 170
    empty                          shift and go to state 83

state 120

    (69) factor_tail -> EXPONENT factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 171
    empty                          shift and go to state 83

state 121

    (70) factor_tail -> GT factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 172
    empty                          shift and go to state 83

state 122

    (71) factor_tail -> LT factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 173
    empty                          shift and go to state 83

state 123

    (72) factor_tail -> EQ_EQ factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 174
    empty                          shift and go to state 83

state 124

    (73) factor_tail -> GT_EQ factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 175
    empty                          shift and go to state 83

state 125

    (74) factor_tail -> LT_EQ factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 176
    empty                          shift and go to state 83

state 126

    (75) factor_tail -> NOT_EQ factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 177
    empty                          shift and go to state 83

state 127

    (76) factor_tail -> AND factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 178
    empty                          shift and go to state 83

state 128

    (77) factor_tail -> OR factor . factor_tail
    (64) factor_tail -> . PLUS factor factor_tail
    (65) factor_tail -> . MINUS factor factor_tail
    (66) factor_tail -> . MULTIPLY factor factor_tail
    (67) factor_tail -> . DIVISION factor factor_tail
    (68) factor_tail -> . MODULO factor factor_tail
    (69) factor_tail -> . EXPONENT factor factor_tail
    (70) factor_tail -> . GT factor factor_tail
    (71) factor_tail -> . LT factor factor_tail
    (72) factor_tail -> . EQ_EQ factor factor_tail
    (73) factor_tail -> . GT_EQ factor factor_tail
    (74) factor_tail -> . LT_EQ factor factor_tail
    (75) factor_tail -> . NOT_EQ factor factor_tail
    (76) factor_tail -> . AND factor factor_tail
    (77) factor_tail -> . OR factor factor_tail
    (78) factor_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)

    factor_tail                    shift and go to state 179
    empty                          shift and go to state 83

state 129

    (23) list_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    SWAP            reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_NAME   reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    IDENT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    DISPLAY         reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    CHECK           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FOR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    UNTIL           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    REPEAT          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    INPUT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    INT             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FLT             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    BLN             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    CHR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    STR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    REVIVE          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    RBRACE          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    SHIFT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    OTHERWISE       reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)


state 130

    (24) list_element -> literal element_tail .

    RBRACKET        reduce using rule 24 (list_element -> literal element_tail .)
    RPAREN          reduce using rule 24 (list_element -> literal element_tail .)


state 131

    (25) element_tail -> COMMA . list_element
    (24) list_element -> . literal element_tail
    (79) literal -> . literal1
    (80) literal -> . literal2
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT
    (86) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 180
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 132

    (26) element_tail -> empty .

    RBRACKET        reduce using rule 26 (element_tail -> empty .)
    RPAREN          reduce using rule 26 (element_tail -> empty .)


state 133

    (43) factor_expression_factor -> LPAREN factor_expression . RPAREN

    RPAREN          shift and go to state 181


state 134

    (37) factor -> LPAREN factor_expression RPAREN .

    PLUS            reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    MINUS           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    MULTIPLY        reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    DIVISION        reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    MODULO          reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    EXPONENT        reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    GT              reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    LT              reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    EQ_EQ           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    GT_EQ           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    LT_EQ           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    NOT_EQ          reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    AND             reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    OR              reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    COMMA           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    NEWLINE         reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    SWAP            reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    FUNCTION_NAME   reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    IDENT           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    DISPLAY         reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    CHECK           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    FOR             reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    UNTIL           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    REPEAT          reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    INPUT           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    INT             reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    FLT             reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    BLN             reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    CHR             reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    STR             reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    REVIVE          reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    RBRACE          reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    SHIFT           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    OTHERWISE       reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    RPAREN          reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    SEMICOLON       reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)
    COLON           reduce using rule 37 (factor -> LPAREN factor_expression RPAREN .)


state 135

    (38) factor_expression -> factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 38 (factor_expression -> factor_expression_factor factor_expression_tail .)


state 136

    (44) factor_expression_tail -> PLUS . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 182
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 137

    (45) factor_expression_tail -> MINUS . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 183
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 138

    (46) factor_expression_tail -> MULTIPLY . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 184
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 139

    (47) factor_expression_tail -> DIVISION . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 185
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 140

    (48) factor_expression_tail -> MODULO . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 186
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 141

    (49) factor_expression_tail -> EXPONENT . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 187
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 142

    (50) factor_expression_tail -> GT . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 188
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 143

    (51) factor_expression_tail -> LT . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 189
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 144

    (52) factor_expression_tail -> EQ_EQ . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 190
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 145

    (53) factor_expression_tail -> GT_EQ . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 191
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 146

    (54) factor_expression_tail -> LT_EQ . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 192
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 147

    (55) factor_expression_tail -> NOT_EQ . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 193
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 148

    (56) factor_expression_tail -> AND . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 194
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 149

    (57) factor_expression_tail -> OR . factor_expression_factor factor_expression_tail
    (39) factor_expression_factor -> . var_call postfix
    (40) factor_expression_factor -> . factor_expression1
    (41) factor_expression_factor -> . TILDE INT_LIT
    (42) factor_expression_factor -> . TILDE FLT_LIT
    (43) factor_expression_factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (59) factor_expression1 -> . INT_LIT
    (60) factor_expression1 -> . FLT_LIT
    (61) factor_expression1 -> . DAY
    (62) factor_expression1 -> . NIGHT
    (63) factor_expression1 -> . STR_LIT

    TILDE           shift and go to state 101
    LPAREN          shift and go to state 96
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 102
    FLT_LIT         shift and go to state 103
    DAY             shift and go to state 104
    NIGHT           shift and go to state 105
    STR_LIT         shift and go to state 106

    factor_expression_factor       shift and go to state 195
    var_call                       shift and go to state 99
    factor_expression1             shift and go to state 100

state 150

    (58) factor_expression_tail -> empty .

    RPAREN          reduce using rule 58 (factor_expression_tail -> empty .)


state 151

    (39) factor_expression_factor -> var_call postfix .

    PLUS            reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    MINUS           reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    MULTIPLY        reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    DIVISION        reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    MODULO          reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    EXPONENT        reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    GT              reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    LT              reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    EQ_EQ           reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    GT_EQ           reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    LT_EQ           reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    NOT_EQ          reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    AND             reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    OR              reduce using rule 39 (factor_expression_factor -> var_call postfix .)
    RPAREN          reduce using rule 39 (factor_expression_factor -> var_call postfix .)


state 152

    (41) factor_expression_factor -> TILDE INT_LIT .

    PLUS            reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    MINUS           reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    MULTIPLY        reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    DIVISION        reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    MODULO          reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    EXPONENT        reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    GT              reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    LT              reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    EQ_EQ           reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    GT_EQ           reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    LT_EQ           reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    NOT_EQ          reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    AND             reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    OR              reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)
    RPAREN          reduce using rule 41 (factor_expression_factor -> TILDE INT_LIT .)


state 153

    (42) factor_expression_factor -> TILDE FLT_LIT .

    PLUS            reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    MINUS           reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    MULTIPLY        reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    DIVISION        reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    MODULO          reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    EXPONENT        reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    GT              reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    LT              reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    EQ_EQ           reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    GT_EQ           reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    LT_EQ           reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    NOT_EQ          reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    AND             reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    OR              reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)
    RPAREN          reduce using rule 42 (factor_expression_factor -> TILDE FLT_LIT .)


state 154

    (223) list_index -> LBRACKET index . RBRACKET list_index2

    RBRACKET        shift and go to state 196


state 155

    (227) index -> INT_LIT .

    RBRACKET        reduce using rule 227 (index -> INT_LIT .)


state 156

    (228) index -> IDENT .

    RBRACKET        reduce using rule 228 (index -> IDENT .)


state 157

    (15) _2d_list -> LBRACKET . RBRACKET

    RBRACKET        shift and go to state 197


state 158

    (13) list_dec -> LBRACKET RBRACKET _2d_list .

    COMMA           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    EQ              reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    NEWLINE         reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    SWAP            reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_NAME   reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    IDENT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    DISPLAY         reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    CHECK           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FOR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    UNTIL           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    REPEAT          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    INPUT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    INT             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FLT             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    BLN             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    CHR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    STR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    REVIVE          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    RBRACE          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    SHIFT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    OTHERWISE       reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)


state 159

    (14) _2d_list -> empty .

    COMMA           reduce using rule 14 (_2d_list -> empty .)
    EQ              reduce using rule 14 (_2d_list -> empty .)
    NEWLINE         reduce using rule 14 (_2d_list -> empty .)
    SWAP            reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_NAME   reduce using rule 14 (_2d_list -> empty .)
    IDENT           reduce using rule 14 (_2d_list -> empty .)
    DISPLAY         reduce using rule 14 (_2d_list -> empty .)
    CHECK           reduce using rule 14 (_2d_list -> empty .)
    FOR             reduce using rule 14 (_2d_list -> empty .)
    UNTIL           reduce using rule 14 (_2d_list -> empty .)
    REPEAT          reduce using rule 14 (_2d_list -> empty .)
    INPUT           reduce using rule 14 (_2d_list -> empty .)
    INT             reduce using rule 14 (_2d_list -> empty .)
    FLT             reduce using rule 14 (_2d_list -> empty .)
    BLN             reduce using rule 14 (_2d_list -> empty .)
    CHR             reduce using rule 14 (_2d_list -> empty .)
    STR             reduce using rule 14 (_2d_list -> empty .)
    REVIVE          reduce using rule 14 (_2d_list -> empty .)
    RBRACE          reduce using rule 14 (_2d_list -> empty .)
    SHIFT           reduce using rule 14 (_2d_list -> empty .)
    OTHERWISE       reduce using rule 14 (_2d_list -> empty .)


state 160

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 198


state 161

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 199


state 162

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters . RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail

    RPAREN          shift and go to state 200


state 163

    (103) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 201


state 164

    (104) parameters -> empty .

    RPAREN          reduce using rule 104 (parameters -> empty .)


state 165

    (19) global_statement_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)


state 166

    (64) factor_tail -> PLUS factor factor_tail .

    COMMA           reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    NEWLINE         reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    SWAP            reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_NAME   reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    IDENT           reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    DISPLAY         reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    CHECK           reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    FOR             reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    UNTIL           reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    REPEAT          reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    INPUT           reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    INT             reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    FLT             reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    BLN             reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    CHR             reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    STR             reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    REVIVE          reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    RBRACE          reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    SHIFT           reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    OTHERWISE       reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    RPAREN          reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    SEMICOLON       reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)
    COLON           reduce using rule 64 (factor_tail -> PLUS factor factor_tail .)


state 167

    (65) factor_tail -> MINUS factor factor_tail .

    COMMA           reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    NEWLINE         reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    SWAP            reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_NAME   reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    IDENT           reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    DISPLAY         reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    CHECK           reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    FOR             reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    UNTIL           reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    REPEAT          reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    INPUT           reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    INT             reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    FLT             reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    BLN             reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    CHR             reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    STR             reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    REVIVE          reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    RBRACE          reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    SHIFT           reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    OTHERWISE       reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    RPAREN          reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    SEMICOLON       reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)
    COLON           reduce using rule 65 (factor_tail -> MINUS factor factor_tail .)


state 168

    (66) factor_tail -> MULTIPLY factor factor_tail .

    COMMA           reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    NEWLINE         reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    SWAP            reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_NAME   reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    IDENT           reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    DISPLAY         reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    CHECK           reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    FOR             reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    UNTIL           reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    REPEAT          reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    INPUT           reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    INT             reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    FLT             reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    BLN             reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    CHR             reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    STR             reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    REVIVE          reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    RBRACE          reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    SHIFT           reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    OTHERWISE       reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    RPAREN          reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    SEMICOLON       reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)
    COLON           reduce using rule 66 (factor_tail -> MULTIPLY factor factor_tail .)


state 169

    (67) factor_tail -> DIVISION factor factor_tail .

    COMMA           reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    NEWLINE         reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    SWAP            reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_NAME   reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    IDENT           reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    DISPLAY         reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    CHECK           reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    FOR             reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    UNTIL           reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    REPEAT          reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    INPUT           reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    INT             reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    FLT             reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    BLN             reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    CHR             reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    STR             reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    REVIVE          reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    RBRACE          reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    SHIFT           reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    OTHERWISE       reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    RPAREN          reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    SEMICOLON       reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)
    COLON           reduce using rule 67 (factor_tail -> DIVISION factor factor_tail .)


state 170

    (68) factor_tail -> MODULO factor factor_tail .

    COMMA           reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    NEWLINE         reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    SWAP            reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_NAME   reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    IDENT           reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    DISPLAY         reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    CHECK           reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    FOR             reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    UNTIL           reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    REPEAT          reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    INPUT           reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    INT             reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    FLT             reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    BLN             reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    CHR             reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    STR             reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    REVIVE          reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    RBRACE          reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    SHIFT           reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    OTHERWISE       reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    RPAREN          reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    SEMICOLON       reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)
    COLON           reduce using rule 68 (factor_tail -> MODULO factor factor_tail .)


state 171

    (69) factor_tail -> EXPONENT factor factor_tail .

    COMMA           reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    NEWLINE         reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    SWAP            reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    IDENT           reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    DISPLAY         reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    CHECK           reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    FOR             reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    UNTIL           reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    REPEAT          reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    INPUT           reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    INT             reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    FLT             reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    BLN             reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    CHR             reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    STR             reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    REVIVE          reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    RBRACE          reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    SHIFT           reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    OTHERWISE       reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    RPAREN          reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    SEMICOLON       reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)
    COLON           reduce using rule 69 (factor_tail -> EXPONENT factor factor_tail .)


state 172

    (70) factor_tail -> GT factor factor_tail .

    COMMA           reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    NEWLINE         reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    SWAP            reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    IDENT           reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    DISPLAY         reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    CHECK           reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    FOR             reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    UNTIL           reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    REPEAT          reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    INPUT           reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    INT             reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    FLT             reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    BLN             reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    CHR             reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    STR             reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    REVIVE          reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    RBRACE          reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    SHIFT           reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    OTHERWISE       reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    RPAREN          reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    SEMICOLON       reduce using rule 70 (factor_tail -> GT factor factor_tail .)
    COLON           reduce using rule 70 (factor_tail -> GT factor factor_tail .)


state 173

    (71) factor_tail -> LT factor factor_tail .

    COMMA           reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    NEWLINE         reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    SWAP            reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    IDENT           reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    DISPLAY         reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    CHECK           reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    FOR             reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    UNTIL           reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    REPEAT          reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    INPUT           reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    INT             reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    FLT             reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    BLN             reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    CHR             reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    STR             reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    REVIVE          reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    RBRACE          reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    SHIFT           reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    OTHERWISE       reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    RPAREN          reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    SEMICOLON       reduce using rule 71 (factor_tail -> LT factor factor_tail .)
    COLON           reduce using rule 71 (factor_tail -> LT factor factor_tail .)


state 174

    (72) factor_tail -> EQ_EQ factor factor_tail .

    COMMA           reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    NEWLINE         reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    SWAP            reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    IDENT           reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    DISPLAY         reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    CHECK           reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    FOR             reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    UNTIL           reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    REPEAT          reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    INPUT           reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    INT             reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    FLT             reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    BLN             reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    CHR             reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    STR             reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    REVIVE          reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    RBRACE          reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    SHIFT           reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    RPAREN          reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)
    COLON           reduce using rule 72 (factor_tail -> EQ_EQ factor factor_tail .)


state 175

    (73) factor_tail -> GT_EQ factor factor_tail .

    COMMA           reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    SWAP            reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    IDENT           reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    CHECK           reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    FOR             reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    UNTIL           reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    REPEAT          reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    INPUT           reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    INT             reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    FLT             reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    BLN             reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    CHR             reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    STR             reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    REVIVE          reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    RBRACE          reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    SHIFT           reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    RPAREN          reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)
    COLON           reduce using rule 73 (factor_tail -> GT_EQ factor factor_tail .)


state 176

    (74) factor_tail -> LT_EQ factor factor_tail .

    COMMA           reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    SWAP            reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    IDENT           reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    CHECK           reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    FOR             reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    UNTIL           reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    REPEAT          reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    INPUT           reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    INT             reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    FLT             reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    BLN             reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    CHR             reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    STR             reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    REVIVE          reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    RBRACE          reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    SHIFT           reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    RPAREN          reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)
    COLON           reduce using rule 74 (factor_tail -> LT_EQ factor factor_tail .)


state 177

    (75) factor_tail -> NOT_EQ factor factor_tail .

    COMMA           reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    SWAP            reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    IDENT           reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    CHECK           reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    FOR             reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    UNTIL           reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    REPEAT          reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    INPUT           reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    INT             reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    FLT             reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    BLN             reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    CHR             reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    STR             reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    REVIVE          reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    RBRACE          reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    SHIFT           reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    RPAREN          reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)
    COLON           reduce using rule 75 (factor_tail -> NOT_EQ factor factor_tail .)


state 178

    (76) factor_tail -> AND factor factor_tail .

    COMMA           reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    NEWLINE         reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    SWAP            reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    FUNCTION_NAME   reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    IDENT           reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    DISPLAY         reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    CHECK           reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    FOR             reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    UNTIL           reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    REPEAT          reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    INPUT           reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    INT             reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    FLT             reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    BLN             reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    CHR             reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    STR             reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    REVIVE          reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    RBRACE          reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    SHIFT           reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    OTHERWISE       reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    RPAREN          reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    SEMICOLON       reduce using rule 76 (factor_tail -> AND factor factor_tail .)
    COLON           reduce using rule 76 (factor_tail -> AND factor factor_tail .)


state 179

    (77) factor_tail -> OR factor factor_tail .

    COMMA           reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    NEWLINE         reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    SWAP            reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    FUNCTION_NAME   reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    IDENT           reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    DISPLAY         reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    CHECK           reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    FOR             reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    UNTIL           reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    REPEAT          reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    INPUT           reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    INT             reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    FLT             reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    BLN             reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    CHR             reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    STR             reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    REVIVE          reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    RBRACE          reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    SHIFT           reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    OTHERWISE       reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    RPAREN          reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    SEMICOLON       reduce using rule 77 (factor_tail -> OR factor factor_tail .)
    COLON           reduce using rule 77 (factor_tail -> OR factor factor_tail .)


state 180

    (25) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 25 (element_tail -> COMMA list_element .)
    RPAREN          reduce using rule 25 (element_tail -> COMMA list_element .)


state 181

    (43) factor_expression_factor -> LPAREN factor_expression RPAREN .

    PLUS            reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    MINUS           reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    MULTIPLY        reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    DIVISION        reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    MODULO          reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    EXPONENT        reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    GT              reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    LT              reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    EQ_EQ           reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    GT_EQ           reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    LT_EQ           reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    NOT_EQ          reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    AND             reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    OR              reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)
    RPAREN          reduce using rule 43 (factor_expression_factor -> LPAREN factor_expression RPAREN .)


state 182

    (44) factor_expression_tail -> PLUS factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 202
    empty                          shift and go to state 150

state 183

    (45) factor_expression_tail -> MINUS factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 203
    empty                          shift and go to state 150

state 184

    (46) factor_expression_tail -> MULTIPLY factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 204
    empty                          shift and go to state 150

state 185

    (47) factor_expression_tail -> DIVISION factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 205
    empty                          shift and go to state 150

state 186

    (48) factor_expression_tail -> MODULO factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 206
    empty                          shift and go to state 150

state 187

    (49) factor_expression_tail -> EXPONENT factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 207
    empty                          shift and go to state 150

state 188

    (50) factor_expression_tail -> GT factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 208
    empty                          shift and go to state 150

state 189

    (51) factor_expression_tail -> LT factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 209
    empty                          shift and go to state 150

state 190

    (52) factor_expression_tail -> EQ_EQ factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 210
    empty                          shift and go to state 150

state 191

    (53) factor_expression_tail -> GT_EQ factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 211
    empty                          shift and go to state 150

state 192

    (54) factor_expression_tail -> LT_EQ factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 212
    empty                          shift and go to state 150

state 193

    (55) factor_expression_tail -> NOT_EQ factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 213
    empty                          shift and go to state 150

state 194

    (56) factor_expression_tail -> AND factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 214
    empty                          shift and go to state 150

state 195

    (57) factor_expression_tail -> OR factor_expression_factor . factor_expression_tail
    (44) factor_expression_tail -> . PLUS factor_expression_factor factor_expression_tail
    (45) factor_expression_tail -> . MINUS factor_expression_factor factor_expression_tail
    (46) factor_expression_tail -> . MULTIPLY factor_expression_factor factor_expression_tail
    (47) factor_expression_tail -> . DIVISION factor_expression_factor factor_expression_tail
    (48) factor_expression_tail -> . MODULO factor_expression_factor factor_expression_tail
    (49) factor_expression_tail -> . EXPONENT factor_expression_factor factor_expression_tail
    (50) factor_expression_tail -> . GT factor_expression_factor factor_expression_tail
    (51) factor_expression_tail -> . LT factor_expression_factor factor_expression_tail
    (52) factor_expression_tail -> . EQ_EQ factor_expression_factor factor_expression_tail
    (53) factor_expression_tail -> . GT_EQ factor_expression_factor factor_expression_tail
    (54) factor_expression_tail -> . LT_EQ factor_expression_factor factor_expression_tail
    (55) factor_expression_tail -> . NOT_EQ factor_expression_factor factor_expression_tail
    (56) factor_expression_tail -> . AND factor_expression_factor factor_expression_tail
    (57) factor_expression_tail -> . OR factor_expression_factor factor_expression_tail
    (58) factor_expression_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    MULTIPLY        shift and go to state 138
    DIVISION        shift and go to state 139
    MODULO          shift and go to state 140
    EXPONENT        shift and go to state 141
    GT              shift and go to state 142
    LT              shift and go to state 143
    EQ_EQ           shift and go to state 144
    GT_EQ           shift and go to state 145
    LT_EQ           shift and go to state 146
    NOT_EQ          shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149
    RPAREN          reduce using rule 242 (empty -> .)

    factor_expression_tail         shift and go to state 215
    empty                          shift and go to state 150

state 196

    (223) list_index -> LBRACKET index RBRACKET . list_index2
    (225) list_index2 -> . LBRACKET index RBRACKET
    (226) list_index2 -> . empty
    (242) empty -> .

    LBRACKET        shift and go to state 216
    PLUS_PLUS       reduce using rule 242 (empty -> .)
    MINUS_MINUS     reduce using rule 242 (empty -> .)
    PLUS            reduce using rule 242 (empty -> .)
    MINUS           reduce using rule 242 (empty -> .)
    MULTIPLY        reduce using rule 242 (empty -> .)
    DIVISION        reduce using rule 242 (empty -> .)
    MODULO          reduce using rule 242 (empty -> .)
    EXPONENT        reduce using rule 242 (empty -> .)
    GT              reduce using rule 242 (empty -> .)
    LT              reduce using rule 242 (empty -> .)
    EQ_EQ           reduce using rule 242 (empty -> .)
    GT_EQ           reduce using rule 242 (empty -> .)
    LT_EQ           reduce using rule 242 (empty -> .)
    NOT_EQ          reduce using rule 242 (empty -> .)
    AND             reduce using rule 242 (empty -> .)
    OR              reduce using rule 242 (empty -> .)
    COMMA           reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    SEMICOLON       reduce using rule 242 (empty -> .)
    COLON           reduce using rule 242 (empty -> .)
    PLUS_EQ         reduce using rule 242 (empty -> .)
    MINUS_EQ        reduce using rule 242 (empty -> .)
    MUL_EQ          reduce using rule 242 (empty -> .)
    DIV_EQ          reduce using rule 242 (empty -> .)
    MOD_EQ          reduce using rule 242 (empty -> .)

    list_index2                    shift and go to state 217
    empty                          shift and go to state 218

state 197

    (15) _2d_list -> LBRACKET RBRACKET .

    COMMA           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    EQ              reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    NEWLINE         reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    SWAP            reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_NAME   reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    IDENT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    DISPLAY         reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    CHECK           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FOR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    UNTIL           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    REPEAT          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    INPUT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    INT             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FLT             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    BLN             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    CHR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    STR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    REVIVE          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    SHIFT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    OTHERWISE       reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)


state 198

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 199

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

    NEWLINE         shift and go to state 18
    LBRACE          reduce using rule 242 (empty -> .)

    maybe_newline                  shift and go to state 219
    empty                          shift and go to state 17

state 200

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN . LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail

    LBRACE          shift and go to state 220


state 201

    (103) parameters -> data_type IDENT . parameters_tail
    (105) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (106) parameters_tail -> . empty
    (242) empty -> .

    COMMA           shift and go to state 222
    RPAREN          reduce using rule 242 (empty -> .)

    parameters_tail                shift and go to state 221
    empty                          shift and go to state 223

state 202

    (44) factor_expression_tail -> PLUS factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 44 (factor_expression_tail -> PLUS factor_expression_factor factor_expression_tail .)


state 203

    (45) factor_expression_tail -> MINUS factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 45 (factor_expression_tail -> MINUS factor_expression_factor factor_expression_tail .)


state 204

    (46) factor_expression_tail -> MULTIPLY factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 46 (factor_expression_tail -> MULTIPLY factor_expression_factor factor_expression_tail .)


state 205

    (47) factor_expression_tail -> DIVISION factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 47 (factor_expression_tail -> DIVISION factor_expression_factor factor_expression_tail .)


state 206

    (48) factor_expression_tail -> MODULO factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 48 (factor_expression_tail -> MODULO factor_expression_factor factor_expression_tail .)


state 207

    (49) factor_expression_tail -> EXPONENT factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 49 (factor_expression_tail -> EXPONENT factor_expression_factor factor_expression_tail .)


state 208

    (50) factor_expression_tail -> GT factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 50 (factor_expression_tail -> GT factor_expression_factor factor_expression_tail .)


state 209

    (51) factor_expression_tail -> LT factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 51 (factor_expression_tail -> LT factor_expression_factor factor_expression_tail .)


state 210

    (52) factor_expression_tail -> EQ_EQ factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 52 (factor_expression_tail -> EQ_EQ factor_expression_factor factor_expression_tail .)


state 211

    (53) factor_expression_tail -> GT_EQ factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 53 (factor_expression_tail -> GT_EQ factor_expression_factor factor_expression_tail .)


state 212

    (54) factor_expression_tail -> LT_EQ factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 54 (factor_expression_tail -> LT_EQ factor_expression_factor factor_expression_tail .)


state 213

    (55) factor_expression_tail -> NOT_EQ factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 55 (factor_expression_tail -> NOT_EQ factor_expression_factor factor_expression_tail .)


state 214

    (56) factor_expression_tail -> AND factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 56 (factor_expression_tail -> AND factor_expression_factor factor_expression_tail .)


state 215

    (57) factor_expression_tail -> OR factor_expression_factor factor_expression_tail .

    RPAREN          reduce using rule 57 (factor_expression_tail -> OR factor_expression_factor factor_expression_tail .)


state 216

    (225) list_index2 -> LBRACKET . index RBRACKET
    (227) index -> . INT_LIT
    (228) index -> . IDENT

    INT_LIT         shift and go to state 155
    IDENT           shift and go to state 156

    index                          shift and go to state 224

state 217

    (223) list_index -> LBRACKET index RBRACKET list_index2 .

    PLUS_PLUS       reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS_MINUS     reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    PLUS            reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MULTIPLY        reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DIVISION        reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MODULO          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    EXPONENT        reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    GT              reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    LT              reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    EQ_EQ           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    GT_EQ           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    LT_EQ           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    NOT_EQ          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    AND             reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    OR              reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    COMMA           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    NEWLINE         reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    RPAREN          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SWAP            reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_NAME   reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    IDENT           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DISPLAY         reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    CHECK           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FOR             reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    UNTIL           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    REPEAT          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    INPUT           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    INT             reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FLT             reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    BLN             reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    CHR             reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    STR             reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    REVIVE          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    RBRACE          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SHIFT           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    OTHERWISE       reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SEMICOLON       reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    COLON           reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    PLUS_EQ         reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS_EQ        reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MUL_EQ          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DIV_EQ          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MOD_EQ          reduce using rule 223 (list_index -> LBRACKET index RBRACKET list_index2 .)


state 218

    (226) list_index2 -> empty .

    PLUS_PLUS       reduce using rule 226 (list_index2 -> empty .)
    MINUS_MINUS     reduce using rule 226 (list_index2 -> empty .)
    PLUS            reduce using rule 226 (list_index2 -> empty .)
    MINUS           reduce using rule 226 (list_index2 -> empty .)
    MULTIPLY        reduce using rule 226 (list_index2 -> empty .)
    DIVISION        reduce using rule 226 (list_index2 -> empty .)
    MODULO          reduce using rule 226 (list_index2 -> empty .)
    EXPONENT        reduce using rule 226 (list_index2 -> empty .)
    GT              reduce using rule 226 (list_index2 -> empty .)
    LT              reduce using rule 226 (list_index2 -> empty .)
    EQ_EQ           reduce using rule 226 (list_index2 -> empty .)
    GT_EQ           reduce using rule 226 (list_index2 -> empty .)
    LT_EQ           reduce using rule 226 (list_index2 -> empty .)
    NOT_EQ          reduce using rule 226 (list_index2 -> empty .)
    AND             reduce using rule 226 (list_index2 -> empty .)
    OR              reduce using rule 226 (list_index2 -> empty .)
    COMMA           reduce using rule 226 (list_index2 -> empty .)
    NEWLINE         reduce using rule 226 (list_index2 -> empty .)
    RPAREN          reduce using rule 226 (list_index2 -> empty .)
    SWAP            reduce using rule 226 (list_index2 -> empty .)
    FUNCTION_NAME   reduce using rule 226 (list_index2 -> empty .)
    IDENT           reduce using rule 226 (list_index2 -> empty .)
    DISPLAY         reduce using rule 226 (list_index2 -> empty .)
    CHECK           reduce using rule 226 (list_index2 -> empty .)
    FOR             reduce using rule 226 (list_index2 -> empty .)
    UNTIL           reduce using rule 226 (list_index2 -> empty .)
    REPEAT          reduce using rule 226 (list_index2 -> empty .)
    INPUT           reduce using rule 226 (list_index2 -> empty .)
    INT             reduce using rule 226 (list_index2 -> empty .)
    FLT             reduce using rule 226 (list_index2 -> empty .)
    BLN             reduce using rule 226 (list_index2 -> empty .)
    CHR             reduce using rule 226 (list_index2 -> empty .)
    STR             reduce using rule 226 (list_index2 -> empty .)
    REVIVE          reduce using rule 226 (list_index2 -> empty .)
    RBRACE          reduce using rule 226 (list_index2 -> empty .)
    SHIFT           reduce using rule 226 (list_index2 -> empty .)
    OTHERWISE       reduce using rule 226 (list_index2 -> empty .)
    SEMICOLON       reduce using rule 226 (list_index2 -> empty .)
    COLON           reduce using rule 226 (list_index2 -> empty .)
    PLUS_EQ         reduce using rule 226 (list_index2 -> empty .)
    MINUS_EQ        reduce using rule 226 (list_index2 -> empty .)
    MUL_EQ          reduce using rule 226 (list_index2 -> empty .)
    DIV_EQ          reduce using rule 226 (list_index2 -> empty .)
    MOD_EQ          reduce using rule 226 (list_index2 -> empty .)


state 219

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 225


state 220

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE . maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 226
    empty                          shift and go to state 17

state 221

    (103) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 103 (parameters -> data_type IDENT parameters_tail .)


state 222

    (105) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    data_type                      shift and go to state 227

state 223

    (106) parameters_tail -> empty .

    RPAREN          reduce using rule 106 (parameters_tail -> empty .)


state 224

    (225) list_index2 -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 228


state 225

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 229
    empty                          shift and go to state 17

state 226

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline . statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 230
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 227

    (105) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 234


state 228

    (225) list_index2 -> LBRACKET index RBRACKET .

    PLUS_PLUS       reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    PLUS            reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    GT              reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    LT              reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    AND             reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    OR              reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    SWAP            reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_NAME   reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    IDENT           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    DISPLAY         reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    CHECK           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    FOR             reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    UNTIL           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    REPEAT          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    INPUT           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    INT             reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    FLT             reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    BLN             reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    CHR             reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    STR             reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    REVIVE          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    SHIFT           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    OTHERWISE       reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 225 (list_index2 -> LBRACKET index RBRACKET .)


state 229

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 235
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 230

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements . maybe_newline revive unli_newline RBRACE function_statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    REVIVE          reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 236
    empty                          shift and go to state 17

state 231

    (116) statements -> empty .
    (126) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 116 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 116 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 116 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 116 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 116 (statements -> empty .)
    NEWLINE         reduce using rule 116 (statements -> empty .)
    REVIVE          reduce using rule 116 (statements -> empty .)
    RBRACE          reduce using rule 116 (statements -> empty .)
    SHIFT           reduce using rule 116 (statements -> empty .)
    OTHERWISE       reduce using rule 116 (statements -> empty .)
    SWAP            reduce using rule 126 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 126 (local_dec -> empty .)
    IDENT           reduce using rule 126 (local_dec -> empty .)
    DISPLAY         reduce using rule 126 (local_dec -> empty .)
    CHECK           reduce using rule 126 (local_dec -> empty .)
    FOR             reduce using rule 126 (local_dec -> empty .)
    UNTIL           reduce using rule 126 (local_dec -> empty .)
    REPEAT          reduce using rule 126 (local_dec -> empty .)
    INPUT           reduce using rule 126 (local_dec -> empty .)
    INT             reduce using rule 126 (local_dec -> empty .)
    FLT             reduce using rule 126 (local_dec -> empty .)
    BLN             reduce using rule 126 (local_dec -> empty .)
    CHR             reduce using rule 126 (local_dec -> empty .)
    STR             reduce using rule 126 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 126 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 126 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 126 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 126 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 126 (local_dec -> empty .) ]


state 232

    (117) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 237
    empty                          shift and go to state 17

state 233

    (125) local_dec -> var_statement . local_dec_tail
    (127) local_dec_tail -> . empty
    (128) local_dec_tail -> . COMMA IDENT local_dec_tail
    (129) local_dec_tail -> . EQ local_value local_dec_tail2
    (242) empty -> .

    COMMA           shift and go to state 240
    EQ              shift and go to state 241
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

    local_dec_tail                 shift and go to state 238
    empty                          shift and go to state 239

state 234

    (105) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (105) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (106) parameters_tail -> . empty
    (242) empty -> .

    COMMA           shift and go to state 222
    RPAREN          reduce using rule 242 (empty -> .)

    parameters_tail                shift and go to state 242
    empty                          shift and go to state 223

state 235

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 242 (empty -> .)

    maybe_newline                  shift and go to state 243
    empty                          shift and go to state 17

state 236

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline . revive unli_newline RBRACE function_statements_tail
    (107) revive -> . REVIVE revive_value
    (108) revive -> . empty
    (242) empty -> .

    REVIVE          shift and go to state 245
    NEWLINE         reduce using rule 242 (empty -> .)

    revive                         shift and go to state 244
    empty                          shift and go to state 246

state 237

    (117) statements -> local_dec maybe_newline . statements_tail
    (118) statements_tail -> . switch_statement unli_newline statements
    (119) statements_tail -> . loop_statement unli_newline statements
    (120) statements_tail -> . function_call unli_newline statements
    (121) statements_tail -> . assignment_statement unli_newline statements
    (122) statements_tail -> . output_statement unli_newline statements
    (123) statements_tail -> . conditional_statement unli_newline statements
    (124) statements_tail -> . statements
    (170) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
    (181) loop_statement -> . for_loop
    (182) loop_statement -> . until_loop
    (183) loop_statement -> . repeat_until
    (195) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (196) function_call -> . input_statement
    (206) assignment_statement -> . IDENT assign_tail
    (203) output_statement -> . DISPLAY value next_val
    (141) conditional_statement -> . CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (184) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE
    (185) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (186) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (241) input_statement -> . INPUT LPAREN RPAREN
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SWAP            shift and go to state 255
    FUNCTION_NAME   shift and go to state 260
    IDENT           shift and go to state 256
    DISPLAY         shift and go to state 262
    CHECK           shift and go to state 263
    FOR             shift and go to state 264
    UNTIL           shift and go to state 265
    REPEAT          shift and go to state 266
    INPUT           shift and go to state 267
    NEWLINE         reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! SWAP            [ reduce using rule 242 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 242 (empty -> .) ]
  ! IDENT           [ reduce using rule 242 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 242 (empty -> .) ]
  ! CHECK           [ reduce using rule 242 (empty -> .) ]
  ! FOR             [ reduce using rule 242 (empty -> .) ]
  ! UNTIL           [ reduce using rule 242 (empty -> .) ]
  ! REPEAT          [ reduce using rule 242 (empty -> .) ]
  ! INPUT           [ reduce using rule 242 (empty -> .) ]
  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    local_dec                      shift and go to state 232
    statements_tail                shift and go to state 247
    switch_statement               shift and go to state 248
    statements                     shift and go to state 249
    loop_statement                 shift and go to state 250
    function_call                  shift and go to state 251
    assignment_statement           shift and go to state 252
    output_statement               shift and go to state 253
    conditional_statement          shift and go to state 254
    for_loop                       shift and go to state 257
    until_loop                     shift and go to state 258
    repeat_until                   shift and go to state 259
    input_statement                shift and go to state 261
    empty                          shift and go to state 231
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 238

    (125) local_dec -> var_statement local_dec_tail .

    NEWLINE         reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    SWAP            reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    FUNCTION_NAME   reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    IDENT           reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    DISPLAY         reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    CHECK           reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    FOR             reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    UNTIL           reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    REPEAT          reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    INPUT           reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    INT             reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    FLT             reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    BLN             reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    CHR             reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    STR             reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    REVIVE          reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    RBRACE          reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    SHIFT           reduce using rule 125 (local_dec -> var_statement local_dec_tail .)
    OTHERWISE       reduce using rule 125 (local_dec -> var_statement local_dec_tail .)


state 239

    (127) local_dec_tail -> empty .

    NEWLINE         reduce using rule 127 (local_dec_tail -> empty .)
    SWAP            reduce using rule 127 (local_dec_tail -> empty .)
    FUNCTION_NAME   reduce using rule 127 (local_dec_tail -> empty .)
    IDENT           reduce using rule 127 (local_dec_tail -> empty .)
    DISPLAY         reduce using rule 127 (local_dec_tail -> empty .)
    CHECK           reduce using rule 127 (local_dec_tail -> empty .)
    FOR             reduce using rule 127 (local_dec_tail -> empty .)
    UNTIL           reduce using rule 127 (local_dec_tail -> empty .)
    REPEAT          reduce using rule 127 (local_dec_tail -> empty .)
    INPUT           reduce using rule 127 (local_dec_tail -> empty .)
    INT             reduce using rule 127 (local_dec_tail -> empty .)
    FLT             reduce using rule 127 (local_dec_tail -> empty .)
    BLN             reduce using rule 127 (local_dec_tail -> empty .)
    CHR             reduce using rule 127 (local_dec_tail -> empty .)
    STR             reduce using rule 127 (local_dec_tail -> empty .)
    REVIVE          reduce using rule 127 (local_dec_tail -> empty .)
    RBRACE          reduce using rule 127 (local_dec_tail -> empty .)
    SHIFT           reduce using rule 127 (local_dec_tail -> empty .)
    OTHERWISE       reduce using rule 127 (local_dec_tail -> empty .)


state 240

    (128) local_dec_tail -> COMMA . IDENT local_dec_tail

    IDENT           shift and go to state 268


state 241

    (129) local_dec_tail -> EQ . local_value local_dec_tail2
    (132) local_value -> . local_value_value
    (133) local_value -> . list_value
    (134) local_value_value -> . local_type_cast
    (135) local_value_value -> . expression
    (136) local_value_value -> . function_call
    (23) list_value -> . LBRACKET list_element RBRACKET
    (137) local_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (138) local_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (139) local_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (140) local_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (195) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (196) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (241) input_statement -> . INPUT LPAREN RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    LBRACKET        shift and go to state 48
    CONVERT_TO_INT  shift and go to state 275
    CONVERT_TO_FLT  shift and go to state 276
    CONVERT_TO_BLN  shift and go to state 277
    CONVERT_TO_STR  shift and go to state 278
    FUNCTION_NAME   shift and go to state 260
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 267
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    local_value                    shift and go to state 269
    local_value_value              shift and go to state 270
    list_value                     shift and go to state 271
    local_type_cast                shift and go to state 272
    expression                     shift and go to state 273
    function_call                  shift and go to state 274
    factor                         shift and go to state 47
    input_statement                shift and go to state 261
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 242

    (105) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 105 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 243

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 279


state 244

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive . unli_newline RBRACE function_statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 280

state 245

    (107) revive -> REVIVE . revive_value
    (109) revive_value -> . revive_type_cast
    (110) revive_value -> . expression
    (111) revive_value -> . function_call
    (112) revive_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (113) revive_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (114) revive_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (115) revive_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (195) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (196) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (241) input_statement -> . INPUT LPAREN RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 285
    CONVERT_TO_FLT  shift and go to state 286
    CONVERT_TO_BLN  shift and go to state 287
    CONVERT_TO_STR  shift and go to state 288
    FUNCTION_NAME   shift and go to state 260
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 267
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    revive_value                   shift and go to state 281
    revive_type_cast               shift and go to state 282
    expression                     shift and go to state 283
    function_call                  shift and go to state 284
    factor                         shift and go to state 47
    input_statement                shift and go to state 261
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 246

    (108) revive -> empty .

    NEWLINE         reduce using rule 108 (revive -> empty .)


state 247

    (117) statements -> local_dec maybe_newline statements_tail .

    NEWLINE         reduce using rule 117 (statements -> local_dec maybe_newline statements_tail .)
    REVIVE          reduce using rule 117 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 117 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 117 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 117 (statements -> local_dec maybe_newline statements_tail .)


state 248

    (118) statements_tail -> switch_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 289

state 249

    (124) statements_tail -> statements .

    NEWLINE         reduce using rule 124 (statements_tail -> statements .)
    REVIVE          reduce using rule 124 (statements_tail -> statements .)
    RBRACE          reduce using rule 124 (statements_tail -> statements .)
    SHIFT           reduce using rule 124 (statements_tail -> statements .)
    OTHERWISE       reduce using rule 124 (statements_tail -> statements .)


state 250

    (119) statements_tail -> loop_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 290

state 251

    (120) statements_tail -> function_call . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 291

state 252

    (121) statements_tail -> assignment_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 292

state 253

    (122) statements_tail -> output_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 293

state 254

    (123) statements_tail -> conditional_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 294

state 255

    (170) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    LPAREN          shift and go to state 295


state 256

    (206) assignment_statement -> IDENT . assign_tail
    (207) assign_tail -> . DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
    (208) assign_tail -> . DOT PUSH LPAREN list_element RPAREN
    (209) assign_tail -> . assign_op value
    (210) assign_op -> . compound_op
    (211) assign_op -> . EQ
    (212) compound_op -> . PLUS_EQ
    (213) compound_op -> . MINUS_EQ
    (214) compound_op -> . MUL_EQ
    (215) compound_op -> . DIV_EQ
    (216) compound_op -> . MOD_EQ

    DOT             shift and go to state 297
    EQ              shift and go to state 300
    PLUS_EQ         shift and go to state 301
    MINUS_EQ        shift and go to state 302
    MUL_EQ          shift and go to state 303
    DIV_EQ          shift and go to state 304
    MOD_EQ          shift and go to state 305

    assign_tail                    shift and go to state 296
    assign_op                      shift and go to state 298
    compound_op                    shift and go to state 299

state 257

    (181) loop_statement -> for_loop .

    NEWLINE         reduce using rule 181 (loop_statement -> for_loop .)


state 258

    (182) loop_statement -> until_loop .

    NEWLINE         reduce using rule 182 (loop_statement -> until_loop .)


state 259

    (183) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 183 (loop_statement -> repeat_until .)


state 260

    (195) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 306


state 261

    (196) function_call -> input_statement .

    NEWLINE         reduce using rule 196 (function_call -> input_statement .)
    COMMA           reduce using rule 196 (function_call -> input_statement .)
    SWAP            reduce using rule 196 (function_call -> input_statement .)
    FUNCTION_NAME   reduce using rule 196 (function_call -> input_statement .)
    IDENT           reduce using rule 196 (function_call -> input_statement .)
    DISPLAY         reduce using rule 196 (function_call -> input_statement .)
    CHECK           reduce using rule 196 (function_call -> input_statement .)
    FOR             reduce using rule 196 (function_call -> input_statement .)
    UNTIL           reduce using rule 196 (function_call -> input_statement .)
    REPEAT          reduce using rule 196 (function_call -> input_statement .)
    INPUT           reduce using rule 196 (function_call -> input_statement .)
    INT             reduce using rule 196 (function_call -> input_statement .)
    FLT             reduce using rule 196 (function_call -> input_statement .)
    BLN             reduce using rule 196 (function_call -> input_statement .)
    CHR             reduce using rule 196 (function_call -> input_statement .)
    STR             reduce using rule 196 (function_call -> input_statement .)
    REVIVE          reduce using rule 196 (function_call -> input_statement .)
    RBRACE          reduce using rule 196 (function_call -> input_statement .)
    SHIFT           reduce using rule 196 (function_call -> input_statement .)
    OTHERWISE       reduce using rule 196 (function_call -> input_statement .)
    COLON           reduce using rule 196 (function_call -> input_statement .)
    RPAREN          reduce using rule 196 (function_call -> input_statement .)


state 262

    (203) output_statement -> DISPLAY . value next_val
    (231) value -> . type_cast
    (232) value -> . expression
    (233) value -> . function_call
    (234) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (235) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (236) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (237) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (195) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (196) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (241) input_statement -> . INPUT LPAREN RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 311
    CONVERT_TO_FLT  shift and go to state 312
    CONVERT_TO_BLN  shift and go to state 313
    CONVERT_TO_STR  shift and go to state 314
    FUNCTION_NAME   shift and go to state 260
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 267
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 307
    type_cast                      shift and go to state 308
    expression                     shift and go to state 309
    function_call                  shift and go to state 310
    factor                         shift and go to state 47
    input_statement                shift and go to state 261
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 263

    (141) conditional_statement -> CHECK . LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 315


state 264

    (184) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE

    LPAREN          shift and go to state 316


state 265

    (185) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 317


state 266

    (186) repeat_until -> REPEAT . LBRACE statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 318


state 267

    (241) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 319


state 268

    (128) local_dec_tail -> COMMA IDENT . local_dec_tail
    (127) local_dec_tail -> . empty
    (128) local_dec_tail -> . COMMA IDENT local_dec_tail
    (129) local_dec_tail -> . EQ local_value local_dec_tail2
    (242) empty -> .

    COMMA           shift and go to state 240
    EQ              shift and go to state 241
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

    local_dec_tail                 shift and go to state 320
    empty                          shift and go to state 239

state 269

    (129) local_dec_tail -> EQ local_value . local_dec_tail2
    (130) local_dec_tail2 -> . COMMA IDENT local_dec_tail
    (131) local_dec_tail2 -> . empty
    (242) empty -> .

    COMMA           shift and go to state 322
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

    local_dec_tail2                shift and go to state 321
    empty                          shift and go to state 323

state 270

    (132) local_value -> local_value_value .

    COMMA           reduce using rule 132 (local_value -> local_value_value .)
    NEWLINE         reduce using rule 132 (local_value -> local_value_value .)
    SWAP            reduce using rule 132 (local_value -> local_value_value .)
    FUNCTION_NAME   reduce using rule 132 (local_value -> local_value_value .)
    IDENT           reduce using rule 132 (local_value -> local_value_value .)
    DISPLAY         reduce using rule 132 (local_value -> local_value_value .)
    CHECK           reduce using rule 132 (local_value -> local_value_value .)
    FOR             reduce using rule 132 (local_value -> local_value_value .)
    UNTIL           reduce using rule 132 (local_value -> local_value_value .)
    REPEAT          reduce using rule 132 (local_value -> local_value_value .)
    INPUT           reduce using rule 132 (local_value -> local_value_value .)
    INT             reduce using rule 132 (local_value -> local_value_value .)
    FLT             reduce using rule 132 (local_value -> local_value_value .)
    BLN             reduce using rule 132 (local_value -> local_value_value .)
    CHR             reduce using rule 132 (local_value -> local_value_value .)
    STR             reduce using rule 132 (local_value -> local_value_value .)
    REVIVE          reduce using rule 132 (local_value -> local_value_value .)
    RBRACE          reduce using rule 132 (local_value -> local_value_value .)
    SHIFT           reduce using rule 132 (local_value -> local_value_value .)
    OTHERWISE       reduce using rule 132 (local_value -> local_value_value .)


state 271

    (133) local_value -> list_value .

    COMMA           reduce using rule 133 (local_value -> list_value .)
    NEWLINE         reduce using rule 133 (local_value -> list_value .)
    SWAP            reduce using rule 133 (local_value -> list_value .)
    FUNCTION_NAME   reduce using rule 133 (local_value -> list_value .)
    IDENT           reduce using rule 133 (local_value -> list_value .)
    DISPLAY         reduce using rule 133 (local_value -> list_value .)
    CHECK           reduce using rule 133 (local_value -> list_value .)
    FOR             reduce using rule 133 (local_value -> list_value .)
    UNTIL           reduce using rule 133 (local_value -> list_value .)
    REPEAT          reduce using rule 133 (local_value -> list_value .)
    INPUT           reduce using rule 133 (local_value -> list_value .)
    INT             reduce using rule 133 (local_value -> list_value .)
    FLT             reduce using rule 133 (local_value -> list_value .)
    BLN             reduce using rule 133 (local_value -> list_value .)
    CHR             reduce using rule 133 (local_value -> list_value .)
    STR             reduce using rule 133 (local_value -> list_value .)
    REVIVE          reduce using rule 133 (local_value -> list_value .)
    RBRACE          reduce using rule 133 (local_value -> list_value .)
    SHIFT           reduce using rule 133 (local_value -> list_value .)
    OTHERWISE       reduce using rule 133 (local_value -> list_value .)


state 272

    (134) local_value_value -> local_type_cast .

    COMMA           reduce using rule 134 (local_value_value -> local_type_cast .)
    NEWLINE         reduce using rule 134 (local_value_value -> local_type_cast .)
    SWAP            reduce using rule 134 (local_value_value -> local_type_cast .)
    FUNCTION_NAME   reduce using rule 134 (local_value_value -> local_type_cast .)
    IDENT           reduce using rule 134 (local_value_value -> local_type_cast .)
    DISPLAY         reduce using rule 134 (local_value_value -> local_type_cast .)
    CHECK           reduce using rule 134 (local_value_value -> local_type_cast .)
    FOR             reduce using rule 134 (local_value_value -> local_type_cast .)
    UNTIL           reduce using rule 134 (local_value_value -> local_type_cast .)
    REPEAT          reduce using rule 134 (local_value_value -> local_type_cast .)
    INPUT           reduce using rule 134 (local_value_value -> local_type_cast .)
    INT             reduce using rule 134 (local_value_value -> local_type_cast .)
    FLT             reduce using rule 134 (local_value_value -> local_type_cast .)
    BLN             reduce using rule 134 (local_value_value -> local_type_cast .)
    CHR             reduce using rule 134 (local_value_value -> local_type_cast .)
    STR             reduce using rule 134 (local_value_value -> local_type_cast .)
    REVIVE          reduce using rule 134 (local_value_value -> local_type_cast .)
    RBRACE          reduce using rule 134 (local_value_value -> local_type_cast .)
    SHIFT           reduce using rule 134 (local_value_value -> local_type_cast .)
    OTHERWISE       reduce using rule 134 (local_value_value -> local_type_cast .)


state 273

    (135) local_value_value -> expression .

    COMMA           reduce using rule 135 (local_value_value -> expression .)
    NEWLINE         reduce using rule 135 (local_value_value -> expression .)
    SWAP            reduce using rule 135 (local_value_value -> expression .)
    FUNCTION_NAME   reduce using rule 135 (local_value_value -> expression .)
    IDENT           reduce using rule 135 (local_value_value -> expression .)
    DISPLAY         reduce using rule 135 (local_value_value -> expression .)
    CHECK           reduce using rule 135 (local_value_value -> expression .)
    FOR             reduce using rule 135 (local_value_value -> expression .)
    UNTIL           reduce using rule 135 (local_value_value -> expression .)
    REPEAT          reduce using rule 135 (local_value_value -> expression .)
    INPUT           reduce using rule 135 (local_value_value -> expression .)
    INT             reduce using rule 135 (local_value_value -> expression .)
    FLT             reduce using rule 135 (local_value_value -> expression .)
    BLN             reduce using rule 135 (local_value_value -> expression .)
    CHR             reduce using rule 135 (local_value_value -> expression .)
    STR             reduce using rule 135 (local_value_value -> expression .)
    REVIVE          reduce using rule 135 (local_value_value -> expression .)
    RBRACE          reduce using rule 135 (local_value_value -> expression .)
    SHIFT           reduce using rule 135 (local_value_value -> expression .)
    OTHERWISE       reduce using rule 135 (local_value_value -> expression .)


state 274

    (136) local_value_value -> function_call .

    COMMA           reduce using rule 136 (local_value_value -> function_call .)
    NEWLINE         reduce using rule 136 (local_value_value -> function_call .)
    SWAP            reduce using rule 136 (local_value_value -> function_call .)
    FUNCTION_NAME   reduce using rule 136 (local_value_value -> function_call .)
    IDENT           reduce using rule 136 (local_value_value -> function_call .)
    DISPLAY         reduce using rule 136 (local_value_value -> function_call .)
    CHECK           reduce using rule 136 (local_value_value -> function_call .)
    FOR             reduce using rule 136 (local_value_value -> function_call .)
    UNTIL           reduce using rule 136 (local_value_value -> function_call .)
    REPEAT          reduce using rule 136 (local_value_value -> function_call .)
    INPUT           reduce using rule 136 (local_value_value -> function_call .)
    INT             reduce using rule 136 (local_value_value -> function_call .)
    FLT             reduce using rule 136 (local_value_value -> function_call .)
    BLN             reduce using rule 136 (local_value_value -> function_call .)
    CHR             reduce using rule 136 (local_value_value -> function_call .)
    STR             reduce using rule 136 (local_value_value -> function_call .)
    REVIVE          reduce using rule 136 (local_value_value -> function_call .)
    RBRACE          reduce using rule 136 (local_value_value -> function_call .)
    SHIFT           reduce using rule 136 (local_value_value -> function_call .)
    OTHERWISE       reduce using rule 136 (local_value_value -> function_call .)


state 275

    (137) local_type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 324


state 276

    (138) local_type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 325


state 277

    (139) local_type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 326


state 278

    (140) local_type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 327


state 279

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)


state 280

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline . RBRACE function_statements_tail

    RBRACE          shift and go to state 328


state 281

    (107) revive -> REVIVE revive_value .

    NEWLINE         reduce using rule 107 (revive -> REVIVE revive_value .)


state 282

    (109) revive_value -> revive_type_cast .

    NEWLINE         reduce using rule 109 (revive_value -> revive_type_cast .)


state 283

    (110) revive_value -> expression .

    NEWLINE         reduce using rule 110 (revive_value -> expression .)


state 284

    (111) revive_value -> function_call .

    NEWLINE         reduce using rule 111 (revive_value -> function_call .)


state 285

    (112) revive_type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 329


state 286

    (113) revive_type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 330


state 287

    (114) revive_type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 331


state 288

    (115) revive_type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 332


state 289

    (118) statements_tail -> switch_statement unli_newline . statements
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 333
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 290

    (119) statements_tail -> loop_statement unli_newline . statements
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 334
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 291

    (120) statements_tail -> function_call unli_newline . statements
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 335
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 292

    (121) statements_tail -> assignment_statement unli_newline . statements
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 336
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 293

    (122) statements_tail -> output_statement unli_newline . statements
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 337
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 294

    (123) statements_tail -> conditional_statement unli_newline . statements
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 338
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 295

    (170) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    IDENT           shift and go to state 339


state 296

    (206) assignment_statement -> IDENT assign_tail .

    NEWLINE         reduce using rule 206 (assignment_statement -> IDENT assign_tail .)


state 297

    (207) assign_tail -> DOT . SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
    (208) assign_tail -> DOT . PUSH LPAREN list_element RPAREN

    SPLICE          shift and go to state 340
    PUSH            shift and go to state 341


state 298

    (209) assign_tail -> assign_op . value
    (231) value -> . type_cast
    (232) value -> . expression
    (233) value -> . function_call
    (234) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (235) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (236) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (237) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (195) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (196) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (241) input_statement -> . INPUT LPAREN RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 311
    CONVERT_TO_FLT  shift and go to state 312
    CONVERT_TO_BLN  shift and go to state 313
    CONVERT_TO_STR  shift and go to state 314
    FUNCTION_NAME   shift and go to state 260
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 267
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 342
    type_cast                      shift and go to state 308
    expression                     shift and go to state 309
    function_call                  shift and go to state 310
    factor                         shift and go to state 47
    input_statement                shift and go to state 261
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 299

    (210) assign_op -> compound_op .

    CONVERT_TO_INT  reduce using rule 210 (assign_op -> compound_op .)
    CONVERT_TO_FLT  reduce using rule 210 (assign_op -> compound_op .)
    CONVERT_TO_BLN  reduce using rule 210 (assign_op -> compound_op .)
    CONVERT_TO_STR  reduce using rule 210 (assign_op -> compound_op .)
    FUNCTION_NAME   reduce using rule 210 (assign_op -> compound_op .)
    TILDE           reduce using rule 210 (assign_op -> compound_op .)
    LPAREN          reduce using rule 210 (assign_op -> compound_op .)
    INPUT           reduce using rule 210 (assign_op -> compound_op .)
    IDENT           reduce using rule 210 (assign_op -> compound_op .)
    INT_LIT         reduce using rule 210 (assign_op -> compound_op .)
    FLT_LIT         reduce using rule 210 (assign_op -> compound_op .)
    DAY             reduce using rule 210 (assign_op -> compound_op .)
    NIGHT           reduce using rule 210 (assign_op -> compound_op .)
    STR_LIT         reduce using rule 210 (assign_op -> compound_op .)


state 300

    (211) assign_op -> EQ .

    CONVERT_TO_INT  reduce using rule 211 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 211 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 211 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 211 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 211 (assign_op -> EQ .)
    TILDE           reduce using rule 211 (assign_op -> EQ .)
    LPAREN          reduce using rule 211 (assign_op -> EQ .)
    INPUT           reduce using rule 211 (assign_op -> EQ .)
    IDENT           reduce using rule 211 (assign_op -> EQ .)
    INT_LIT         reduce using rule 211 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 211 (assign_op -> EQ .)
    DAY             reduce using rule 211 (assign_op -> EQ .)
    NIGHT           reduce using rule 211 (assign_op -> EQ .)
    STR_LIT         reduce using rule 211 (assign_op -> EQ .)


state 301

    (212) compound_op -> PLUS_EQ .

    CONVERT_TO_INT  reduce using rule 212 (compound_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 212 (compound_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 212 (compound_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 212 (compound_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 212 (compound_op -> PLUS_EQ .)
    TILDE           reduce using rule 212 (compound_op -> PLUS_EQ .)
    LPAREN          reduce using rule 212 (compound_op -> PLUS_EQ .)
    INPUT           reduce using rule 212 (compound_op -> PLUS_EQ .)
    IDENT           reduce using rule 212 (compound_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 212 (compound_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 212 (compound_op -> PLUS_EQ .)
    DAY             reduce using rule 212 (compound_op -> PLUS_EQ .)
    NIGHT           reduce using rule 212 (compound_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 212 (compound_op -> PLUS_EQ .)


state 302

    (213) compound_op -> MINUS_EQ .

    CONVERT_TO_INT  reduce using rule 213 (compound_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 213 (compound_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 213 (compound_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 213 (compound_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 213 (compound_op -> MINUS_EQ .)
    TILDE           reduce using rule 213 (compound_op -> MINUS_EQ .)
    LPAREN          reduce using rule 213 (compound_op -> MINUS_EQ .)
    INPUT           reduce using rule 213 (compound_op -> MINUS_EQ .)
    IDENT           reduce using rule 213 (compound_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 213 (compound_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 213 (compound_op -> MINUS_EQ .)
    DAY             reduce using rule 213 (compound_op -> MINUS_EQ .)
    NIGHT           reduce using rule 213 (compound_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 213 (compound_op -> MINUS_EQ .)


state 303

    (214) compound_op -> MUL_EQ .

    CONVERT_TO_INT  reduce using rule 214 (compound_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 214 (compound_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 214 (compound_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 214 (compound_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 214 (compound_op -> MUL_EQ .)
    TILDE           reduce using rule 214 (compound_op -> MUL_EQ .)
    LPAREN          reduce using rule 214 (compound_op -> MUL_EQ .)
    INPUT           reduce using rule 214 (compound_op -> MUL_EQ .)
    IDENT           reduce using rule 214 (compound_op -> MUL_EQ .)
    INT_LIT         reduce using rule 214 (compound_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 214 (compound_op -> MUL_EQ .)
    DAY             reduce using rule 214 (compound_op -> MUL_EQ .)
    NIGHT           reduce using rule 214 (compound_op -> MUL_EQ .)
    STR_LIT         reduce using rule 214 (compound_op -> MUL_EQ .)


state 304

    (215) compound_op -> DIV_EQ .

    CONVERT_TO_INT  reduce using rule 215 (compound_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 215 (compound_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 215 (compound_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 215 (compound_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 215 (compound_op -> DIV_EQ .)
    TILDE           reduce using rule 215 (compound_op -> DIV_EQ .)
    LPAREN          reduce using rule 215 (compound_op -> DIV_EQ .)
    INPUT           reduce using rule 215 (compound_op -> DIV_EQ .)
    IDENT           reduce using rule 215 (compound_op -> DIV_EQ .)
    INT_LIT         reduce using rule 215 (compound_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 215 (compound_op -> DIV_EQ .)
    DAY             reduce using rule 215 (compound_op -> DIV_EQ .)
    NIGHT           reduce using rule 215 (compound_op -> DIV_EQ .)
    STR_LIT         reduce using rule 215 (compound_op -> DIV_EQ .)


state 305

    (216) compound_op -> MOD_EQ .

    CONVERT_TO_INT  reduce using rule 216 (compound_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 216 (compound_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 216 (compound_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 216 (compound_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 216 (compound_op -> MOD_EQ .)
    TILDE           reduce using rule 216 (compound_op -> MOD_EQ .)
    LPAREN          reduce using rule 216 (compound_op -> MOD_EQ .)
    INPUT           reduce using rule 216 (compound_op -> MOD_EQ .)
    IDENT           reduce using rule 216 (compound_op -> MOD_EQ .)
    INT_LIT         reduce using rule 216 (compound_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 216 (compound_op -> MOD_EQ .)
    DAY             reduce using rule 216 (compound_op -> MOD_EQ .)
    NIGHT           reduce using rule 216 (compound_op -> MOD_EQ .)
    STR_LIT         reduce using rule 216 (compound_op -> MOD_EQ .)


state 306

    (195) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (197) arguments -> . empty
    (198) arguments -> . arg_value arg_tail
    (242) empty -> .
    (201) arg_value -> . literal
    (202) arg_value -> . var_call
    (79) literal -> . literal1
    (80) literal -> . literal2
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT
    (86) literal2 -> . CHR_LIT

    RPAREN          reduce using rule 242 (empty -> .)
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    arguments                      shift and go to state 343
    empty                          shift and go to state 344
    arg_value                      shift and go to state 345
    literal                        shift and go to state 346
    var_call                       shift and go to state 347
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 307

    (203) output_statement -> DISPLAY value . next_val
    (204) next_val -> . COMMA value next_val
    (205) next_val -> . empty
    (242) empty -> .

    COMMA           shift and go to state 349
    NEWLINE         reduce using rule 242 (empty -> .)

    next_val                       shift and go to state 348
    empty                          shift and go to state 350

state 308

    (231) value -> type_cast .

    COMMA           reduce using rule 231 (value -> type_cast .)
    NEWLINE         reduce using rule 231 (value -> type_cast .)
    RPAREN          reduce using rule 231 (value -> type_cast .)


state 309

    (232) value -> expression .

    COMMA           reduce using rule 232 (value -> expression .)
    NEWLINE         reduce using rule 232 (value -> expression .)
    RPAREN          reduce using rule 232 (value -> expression .)


state 310

    (233) value -> function_call .

    COMMA           reduce using rule 233 (value -> function_call .)
    NEWLINE         reduce using rule 233 (value -> function_call .)
    RPAREN          reduce using rule 233 (value -> function_call .)


state 311

    (234) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 351


state 312

    (235) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 352


state 313

    (236) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 353


state 314

    (237) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 354


state 315

    (141) conditional_statement -> CHECK LPAREN . condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (144) condition -> . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition                      shift and go to state 356
    condition_factor               shift and go to state 357
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 316

    (184) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE
    (187) control_variable -> . INT IDENT EQ control_var_tail

    INT             shift and go to state 367

    control_variable               shift and go to state 366

state 317

    (185) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE statements RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 368
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 318

    (186) repeat_until -> REPEAT LBRACE . statements RBRACE UNTIL LPAREN expression RPAREN
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 369
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 319

    (241) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 370


state 320

    (128) local_dec_tail -> COMMA IDENT local_dec_tail .

    NEWLINE         reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    SWAP            reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FUNCTION_NAME   reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    IDENT           reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    DISPLAY         reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    CHECK           reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FOR             reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    UNTIL           reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    REPEAT          reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    INPUT           reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    INT             reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FLT             reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    BLN             reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    CHR             reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    STR             reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    REVIVE          reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    RBRACE          reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    SHIFT           reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    OTHERWISE       reduce using rule 128 (local_dec_tail -> COMMA IDENT local_dec_tail .)


state 321

    (129) local_dec_tail -> EQ local_value local_dec_tail2 .

    NEWLINE         reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    SWAP            reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FUNCTION_NAME   reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    IDENT           reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    DISPLAY         reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    CHECK           reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FOR             reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    UNTIL           reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    REPEAT          reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    INPUT           reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    INT             reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FLT             reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    BLN             reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    CHR             reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    STR             reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    REVIVE          reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    RBRACE          reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    SHIFT           reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    OTHERWISE       reduce using rule 129 (local_dec_tail -> EQ local_value local_dec_tail2 .)


state 322

    (130) local_dec_tail2 -> COMMA . IDENT local_dec_tail

    IDENT           shift and go to state 371


state 323

    (131) local_dec_tail2 -> empty .

    NEWLINE         reduce using rule 131 (local_dec_tail2 -> empty .)
    SWAP            reduce using rule 131 (local_dec_tail2 -> empty .)
    FUNCTION_NAME   reduce using rule 131 (local_dec_tail2 -> empty .)
    IDENT           reduce using rule 131 (local_dec_tail2 -> empty .)
    DISPLAY         reduce using rule 131 (local_dec_tail2 -> empty .)
    CHECK           reduce using rule 131 (local_dec_tail2 -> empty .)
    FOR             reduce using rule 131 (local_dec_tail2 -> empty .)
    UNTIL           reduce using rule 131 (local_dec_tail2 -> empty .)
    REPEAT          reduce using rule 131 (local_dec_tail2 -> empty .)
    INPUT           reduce using rule 131 (local_dec_tail2 -> empty .)
    INT             reduce using rule 131 (local_dec_tail2 -> empty .)
    FLT             reduce using rule 131 (local_dec_tail2 -> empty .)
    BLN             reduce using rule 131 (local_dec_tail2 -> empty .)
    CHR             reduce using rule 131 (local_dec_tail2 -> empty .)
    STR             reduce using rule 131 (local_dec_tail2 -> empty .)
    REVIVE          reduce using rule 131 (local_dec_tail2 -> empty .)
    RBRACE          reduce using rule 131 (local_dec_tail2 -> empty .)
    SHIFT           reduce using rule 131 (local_dec_tail2 -> empty .)
    OTHERWISE       reduce using rule 131 (local_dec_tail2 -> empty .)


state 324

    (137) local_type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 372
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 325

    (138) local_type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 376
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 326

    (139) local_type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 377
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 327

    (140) local_type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 378
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 328

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE . function_statements_tail
    (89) function_statements_tail -> . function_statements
    (90) function_statements_tail -> . empty
    (87) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (88) function_statements -> . empty
    (242) empty -> .
    (91) ret_type -> . FUNCTION
    (92) ret_type -> . function_dtype
    (93) function_dtype -> . FUNCTION_INT
    (94) function_dtype -> . FUNCTION_FLT
    (95) function_dtype -> . FUNCTION_CHR
    (96) function_dtype -> . FUNCTION_BLN
    (97) function_dtype -> . FUNCTION_STR
    (98) function_dtype -> . FUNCTION_LIST_INT
    (99) function_dtype -> . FUNCTION_LIST_FLT
    (100) function_dtype -> . FUNCTION_LIST_CHR
    (101) function_dtype -> . FUNCTION_LIST_STR
    (102) function_dtype -> . FUNCTION_LIST_BLN

    NEWLINE         reduce using rule 242 (empty -> .)
    MAIN_CASPER     reduce using rule 242 (empty -> .)
    FUNCTION        shift and go to state 28
    FUNCTION_INT    shift and go to state 30
    FUNCTION_FLT    shift and go to state 31
    FUNCTION_CHR    shift and go to state 32
    FUNCTION_BLN    shift and go to state 33
    FUNCTION_STR    shift and go to state 34
    FUNCTION_LIST_INT shift and go to state 35
    FUNCTION_LIST_FLT shift and go to state 36
    FUNCTION_LIST_CHR shift and go to state 37
    FUNCTION_LIST_STR shift and go to state 38
    FUNCTION_LIST_BLN shift and go to state 39

    ret_type                       shift and go to state 26
    function_statements_tail       shift and go to state 379
    function_statements            shift and go to state 380
    empty                          shift and go to state 381
    function_dtype                 shift and go to state 29

state 329

    (112) revive_type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 382
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 330

    (113) revive_type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 383
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 331

    (114) revive_type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 384
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 332

    (115) revive_type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 385
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 333

    (118) statements_tail -> switch_statement unli_newline statements .

    NEWLINE         reduce using rule 118 (statements_tail -> switch_statement unli_newline statements .)
    REVIVE          reduce using rule 118 (statements_tail -> switch_statement unli_newline statements .)
    RBRACE          reduce using rule 118 (statements_tail -> switch_statement unli_newline statements .)
    SHIFT           reduce using rule 118 (statements_tail -> switch_statement unli_newline statements .)
    OTHERWISE       reduce using rule 118 (statements_tail -> switch_statement unli_newline statements .)


state 334

    (119) statements_tail -> loop_statement unli_newline statements .

    NEWLINE         reduce using rule 119 (statements_tail -> loop_statement unli_newline statements .)
    REVIVE          reduce using rule 119 (statements_tail -> loop_statement unli_newline statements .)
    RBRACE          reduce using rule 119 (statements_tail -> loop_statement unli_newline statements .)
    SHIFT           reduce using rule 119 (statements_tail -> loop_statement unli_newline statements .)
    OTHERWISE       reduce using rule 119 (statements_tail -> loop_statement unli_newline statements .)


state 335

    (120) statements_tail -> function_call unli_newline statements .

    NEWLINE         reduce using rule 120 (statements_tail -> function_call unli_newline statements .)
    REVIVE          reduce using rule 120 (statements_tail -> function_call unli_newline statements .)
    RBRACE          reduce using rule 120 (statements_tail -> function_call unli_newline statements .)
    SHIFT           reduce using rule 120 (statements_tail -> function_call unli_newline statements .)
    OTHERWISE       reduce using rule 120 (statements_tail -> function_call unli_newline statements .)


state 336

    (121) statements_tail -> assignment_statement unli_newline statements .

    NEWLINE         reduce using rule 121 (statements_tail -> assignment_statement unli_newline statements .)
    REVIVE          reduce using rule 121 (statements_tail -> assignment_statement unli_newline statements .)
    RBRACE          reduce using rule 121 (statements_tail -> assignment_statement unli_newline statements .)
    SHIFT           reduce using rule 121 (statements_tail -> assignment_statement unli_newline statements .)
    OTHERWISE       reduce using rule 121 (statements_tail -> assignment_statement unli_newline statements .)


state 337

    (122) statements_tail -> output_statement unli_newline statements .

    NEWLINE         reduce using rule 122 (statements_tail -> output_statement unli_newline statements .)
    REVIVE          reduce using rule 122 (statements_tail -> output_statement unli_newline statements .)
    RBRACE          reduce using rule 122 (statements_tail -> output_statement unli_newline statements .)
    SHIFT           reduce using rule 122 (statements_tail -> output_statement unli_newline statements .)
    OTHERWISE       reduce using rule 122 (statements_tail -> output_statement unli_newline statements .)


state 338

    (123) statements_tail -> conditional_statement unli_newline statements .

    NEWLINE         reduce using rule 123 (statements_tail -> conditional_statement unli_newline statements .)
    REVIVE          reduce using rule 123 (statements_tail -> conditional_statement unli_newline statements .)
    RBRACE          reduce using rule 123 (statements_tail -> conditional_statement unli_newline statements .)
    SHIFT           reduce using rule 123 (statements_tail -> conditional_statement unli_newline statements .)
    OTHERWISE       reduce using rule 123 (statements_tail -> conditional_statement unli_newline statements .)


state 339

    (170) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    RPAREN          shift and go to state 386


state 340

    (207) assign_tail -> DOT SPLICE . LPAREN start COMMA deleteCount COMMA splice_items RPAREN

    LPAREN          shift and go to state 387


state 341

    (208) assign_tail -> DOT PUSH . LPAREN list_element RPAREN

    LPAREN          shift and go to state 388


state 342

    (209) assign_tail -> assign_op value .

    NEWLINE         reduce using rule 209 (assign_tail -> assign_op value .)


state 343

    (195) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 389


state 344

    (197) arguments -> empty .

    RPAREN          reduce using rule 197 (arguments -> empty .)


state 345

    (198) arguments -> arg_value . arg_tail
    (199) arg_tail -> . COMMA arg_value arg_tail
    (200) arg_tail -> . empty
    (242) empty -> .

    COMMA           shift and go to state 391
    RPAREN          reduce using rule 242 (empty -> .)

    arg_tail                       shift and go to state 390
    empty                          shift and go to state 392

state 346

    (201) arg_value -> literal .

    COMMA           reduce using rule 201 (arg_value -> literal .)
    RPAREN          reduce using rule 201 (arg_value -> literal .)


state 347

    (202) arg_value -> var_call .

    COMMA           reduce using rule 202 (arg_value -> var_call .)
    RPAREN          reduce using rule 202 (arg_value -> var_call .)


state 348

    (203) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 203 (output_statement -> DISPLAY value next_val .)


state 349

    (204) next_val -> COMMA . value next_val
    (231) value -> . type_cast
    (232) value -> . expression
    (233) value -> . function_call
    (234) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (235) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (236) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (237) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (195) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (196) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (241) input_statement -> . INPUT LPAREN RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 311
    CONVERT_TO_FLT  shift and go to state 312
    CONVERT_TO_BLN  shift and go to state 313
    CONVERT_TO_STR  shift and go to state 314
    FUNCTION_NAME   shift and go to state 260
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 267
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 393
    type_cast                      shift and go to state 308
    expression                     shift and go to state 309
    function_call                  shift and go to state 310
    factor                         shift and go to state 47
    input_statement                shift and go to state 261
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 350

    (205) next_val -> empty .

    NEWLINE         reduce using rule 205 (next_val -> empty .)


state 351

    (234) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 394
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 352

    (235) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 395
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 353

    (236) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 396
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 354

    (237) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 397
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 355

    (149) condition_factor -> LPAREN . condition RPAREN
    (144) condition -> . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition                      shift and go to state 398
    condition_factor               shift and go to state 357
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 356

    (141) conditional_statement -> CHECK LPAREN condition . RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 399


state 357

    (144) condition -> condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 400
    empty                          shift and go to state 415

state 358

    (145) condition_factor -> var_call . postfix
    (229) postfix -> . empty
    (230) postfix -> . postfix_op
    (242) empty -> .
    (193) postfix_op -> . PLUS_PLUS
    (194) postfix_op -> . MINUS_MINUS

    PLUS            reduce using rule 242 (empty -> .)
    MINUS           reduce using rule 242 (empty -> .)
    MULTIPLY        reduce using rule 242 (empty -> .)
    DIVISION        reduce using rule 242 (empty -> .)
    MODULO          reduce using rule 242 (empty -> .)
    EXPONENT        reduce using rule 242 (empty -> .)
    GT              reduce using rule 242 (empty -> .)
    LT              reduce using rule 242 (empty -> .)
    EQ_EQ           reduce using rule 242 (empty -> .)
    GT_EQ           reduce using rule 242 (empty -> .)
    LT_EQ           reduce using rule 242 (empty -> .)
    NOT_EQ          reduce using rule 242 (empty -> .)
    AND             reduce using rule 242 (empty -> .)
    OR              reduce using rule 242 (empty -> .)
    RPAREN          reduce using rule 242 (empty -> .)
    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93

    postfix                        shift and go to state 416
    empty                          shift and go to state 90
    postfix_op                     shift and go to state 91

state 359

    (146) condition_factor -> condition1 .

    PLUS            reduce using rule 146 (condition_factor -> condition1 .)
    MINUS           reduce using rule 146 (condition_factor -> condition1 .)
    MULTIPLY        reduce using rule 146 (condition_factor -> condition1 .)
    DIVISION        reduce using rule 146 (condition_factor -> condition1 .)
    MODULO          reduce using rule 146 (condition_factor -> condition1 .)
    EXPONENT        reduce using rule 146 (condition_factor -> condition1 .)
    GT              reduce using rule 146 (condition_factor -> condition1 .)
    LT              reduce using rule 146 (condition_factor -> condition1 .)
    EQ_EQ           reduce using rule 146 (condition_factor -> condition1 .)
    GT_EQ           reduce using rule 146 (condition_factor -> condition1 .)
    LT_EQ           reduce using rule 146 (condition_factor -> condition1 .)
    NOT_EQ          reduce using rule 146 (condition_factor -> condition1 .)
    AND             reduce using rule 146 (condition_factor -> condition1 .)
    OR              reduce using rule 146 (condition_factor -> condition1 .)
    RPAREN          reduce using rule 146 (condition_factor -> condition1 .)


state 360

    (147) condition_factor -> TILDE . INT_LIT
    (148) condition_factor -> TILDE . FLT_LIT

    INT_LIT         shift and go to state 417
    FLT_LIT         shift and go to state 418


state 361

    (165) condition1 -> INT_LIT .

    PLUS            reduce using rule 165 (condition1 -> INT_LIT .)
    MINUS           reduce using rule 165 (condition1 -> INT_LIT .)
    MULTIPLY        reduce using rule 165 (condition1 -> INT_LIT .)
    DIVISION        reduce using rule 165 (condition1 -> INT_LIT .)
    MODULO          reduce using rule 165 (condition1 -> INT_LIT .)
    EXPONENT        reduce using rule 165 (condition1 -> INT_LIT .)
    GT              reduce using rule 165 (condition1 -> INT_LIT .)
    LT              reduce using rule 165 (condition1 -> INT_LIT .)
    EQ_EQ           reduce using rule 165 (condition1 -> INT_LIT .)
    GT_EQ           reduce using rule 165 (condition1 -> INT_LIT .)
    LT_EQ           reduce using rule 165 (condition1 -> INT_LIT .)
    NOT_EQ          reduce using rule 165 (condition1 -> INT_LIT .)
    AND             reduce using rule 165 (condition1 -> INT_LIT .)
    OR              reduce using rule 165 (condition1 -> INT_LIT .)
    RPAREN          reduce using rule 165 (condition1 -> INT_LIT .)


state 362

    (166) condition1 -> FLT_LIT .

    PLUS            reduce using rule 166 (condition1 -> FLT_LIT .)
    MINUS           reduce using rule 166 (condition1 -> FLT_LIT .)
    MULTIPLY        reduce using rule 166 (condition1 -> FLT_LIT .)
    DIVISION        reduce using rule 166 (condition1 -> FLT_LIT .)
    MODULO          reduce using rule 166 (condition1 -> FLT_LIT .)
    EXPONENT        reduce using rule 166 (condition1 -> FLT_LIT .)
    GT              reduce using rule 166 (condition1 -> FLT_LIT .)
    LT              reduce using rule 166 (condition1 -> FLT_LIT .)
    EQ_EQ           reduce using rule 166 (condition1 -> FLT_LIT .)
    GT_EQ           reduce using rule 166 (condition1 -> FLT_LIT .)
    LT_EQ           reduce using rule 166 (condition1 -> FLT_LIT .)
    NOT_EQ          reduce using rule 166 (condition1 -> FLT_LIT .)
    AND             reduce using rule 166 (condition1 -> FLT_LIT .)
    OR              reduce using rule 166 (condition1 -> FLT_LIT .)
    RPAREN          reduce using rule 166 (condition1 -> FLT_LIT .)


state 363

    (167) condition1 -> DAY .

    PLUS            reduce using rule 167 (condition1 -> DAY .)
    MINUS           reduce using rule 167 (condition1 -> DAY .)
    MULTIPLY        reduce using rule 167 (condition1 -> DAY .)
    DIVISION        reduce using rule 167 (condition1 -> DAY .)
    MODULO          reduce using rule 167 (condition1 -> DAY .)
    EXPONENT        reduce using rule 167 (condition1 -> DAY .)
    GT              reduce using rule 167 (condition1 -> DAY .)
    LT              reduce using rule 167 (condition1 -> DAY .)
    EQ_EQ           reduce using rule 167 (condition1 -> DAY .)
    GT_EQ           reduce using rule 167 (condition1 -> DAY .)
    LT_EQ           reduce using rule 167 (condition1 -> DAY .)
    NOT_EQ          reduce using rule 167 (condition1 -> DAY .)
    AND             reduce using rule 167 (condition1 -> DAY .)
    OR              reduce using rule 167 (condition1 -> DAY .)
    RPAREN          reduce using rule 167 (condition1 -> DAY .)


state 364

    (168) condition1 -> NIGHT .

    PLUS            reduce using rule 168 (condition1 -> NIGHT .)
    MINUS           reduce using rule 168 (condition1 -> NIGHT .)
    MULTIPLY        reduce using rule 168 (condition1 -> NIGHT .)
    DIVISION        reduce using rule 168 (condition1 -> NIGHT .)
    MODULO          reduce using rule 168 (condition1 -> NIGHT .)
    EXPONENT        reduce using rule 168 (condition1 -> NIGHT .)
    GT              reduce using rule 168 (condition1 -> NIGHT .)
    LT              reduce using rule 168 (condition1 -> NIGHT .)
    EQ_EQ           reduce using rule 168 (condition1 -> NIGHT .)
    GT_EQ           reduce using rule 168 (condition1 -> NIGHT .)
    LT_EQ           reduce using rule 168 (condition1 -> NIGHT .)
    NOT_EQ          reduce using rule 168 (condition1 -> NIGHT .)
    AND             reduce using rule 168 (condition1 -> NIGHT .)
    OR              reduce using rule 168 (condition1 -> NIGHT .)
    RPAREN          reduce using rule 168 (condition1 -> NIGHT .)


state 365

    (169) condition1 -> STR_LIT .

    PLUS            reduce using rule 169 (condition1 -> STR_LIT .)
    MINUS           reduce using rule 169 (condition1 -> STR_LIT .)
    MULTIPLY        reduce using rule 169 (condition1 -> STR_LIT .)
    DIVISION        reduce using rule 169 (condition1 -> STR_LIT .)
    MODULO          reduce using rule 169 (condition1 -> STR_LIT .)
    EXPONENT        reduce using rule 169 (condition1 -> STR_LIT .)
    GT              reduce using rule 169 (condition1 -> STR_LIT .)
    LT              reduce using rule 169 (condition1 -> STR_LIT .)
    EQ_EQ           reduce using rule 169 (condition1 -> STR_LIT .)
    GT_EQ           reduce using rule 169 (condition1 -> STR_LIT .)
    LT_EQ           reduce using rule 169 (condition1 -> STR_LIT .)
    NOT_EQ          reduce using rule 169 (condition1 -> STR_LIT .)
    AND             reduce using rule 169 (condition1 -> STR_LIT .)
    OR              reduce using rule 169 (condition1 -> STR_LIT .)
    RPAREN          reduce using rule 169 (condition1 -> STR_LIT .)


state 366

    (184) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE

    SEMICOLON       shift and go to state 419


state 367

    (187) control_variable -> INT . IDENT EQ control_var_tail

    IDENT           shift and go to state 420


state 368

    (185) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 421


state 369

    (186) repeat_until -> REPEAT LBRACE statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 422


state 370

    (241) input_statement -> INPUT LPAREN RPAREN .

    NEWLINE         reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    SWAP            reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION_NAME   reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    IDENT           reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    DISPLAY         reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    CHECK           reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    UNTIL           reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    REPEAT          reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    FLT             reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    BLN             reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    CHR             reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    STR             reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    REVIVE          reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    SHIFT           reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    OTHERWISE       reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 241 (input_statement -> INPUT LPAREN RPAREN .)


state 371

    (130) local_dec_tail2 -> COMMA IDENT . local_dec_tail
    (127) local_dec_tail -> . empty
    (128) local_dec_tail -> . COMMA IDENT local_dec_tail
    (129) local_dec_tail -> . EQ local_value local_dec_tail2
    (242) empty -> .

    COMMA           shift and go to state 240
    EQ              shift and go to state 241
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    REVIVE          reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

    local_dec_tail                 shift and go to state 423
    empty                          shift and go to state 239

state 372

    (137) local_type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 424


state 373

    (238) typecast_value -> expression .

    RPAREN          reduce using rule 238 (typecast_value -> expression .)


state 374

    (239) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 425


state 375

    (240) typecast_value -> input_statement .

    RPAREN          reduce using rule 240 (typecast_value -> input_statement .)


state 376

    (138) local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 426


state 377

    (139) local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 427


state 378

    (140) local_type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 428


state 379

    (87) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail .

    NEWLINE         reduce using rule 87 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail .)
    MAIN_CASPER     reduce using rule 87 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail .)


state 380

    (89) function_statements_tail -> function_statements .

    NEWLINE         reduce using rule 89 (function_statements_tail -> function_statements .)
    MAIN_CASPER     reduce using rule 89 (function_statements_tail -> function_statements .)


state 381

    (90) function_statements_tail -> empty .
    (88) function_statements -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 88 (function_statements -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 88 (function_statements -> empty .)
    NEWLINE         reduce using rule 88 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 88 (function_statements -> empty .)

  ! NEWLINE         [ reduce using rule 90 (function_statements_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 90 (function_statements_tail -> empty .) ]


state 382

    (112) revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 429


state 383

    (113) revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 430


state 384

    (114) revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 431


state 385

    (115) revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 432


state 386

    (170) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    LBRACE          shift and go to state 433


state 387

    (207) assign_tail -> DOT SPLICE LPAREN . start COMMA deleteCount COMMA splice_items RPAREN
    (217) start -> . INT_LIT

    INT_LIT         shift and go to state 435

    start                          shift and go to state 434

state 388

    (208) assign_tail -> DOT PUSH LPAREN . list_element RPAREN
    (24) list_element -> . literal element_tail
    (79) literal -> . literal1
    (80) literal -> . literal2
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT
    (86) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 436
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 389

    (195) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SWAP            reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FUNCTION_NAME   reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    IDENT           reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    DISPLAY         reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHECK           reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FOR             reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    UNTIL           reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REPEAT          reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INPUT           reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INT             reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FLT             reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    BLN             reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHR             reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    STR             reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REVIVE          reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SHIFT           reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    OTHERWISE       reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 195 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 390

    (198) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 198 (arguments -> arg_value arg_tail .)


state 391

    (199) arg_tail -> COMMA . arg_value arg_tail
    (201) arg_value -> . literal
    (202) arg_value -> . var_call
    (79) literal -> . literal1
    (80) literal -> . literal2
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT
    (86) literal2 -> . CHR_LIT

    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    arg_value                      shift and go to state 437
    literal                        shift and go to state 346
    var_call                       shift and go to state 347
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 392

    (200) arg_tail -> empty .

    RPAREN          reduce using rule 200 (arg_tail -> empty .)


state 393

    (204) next_val -> COMMA value . next_val
    (204) next_val -> . COMMA value next_val
    (205) next_val -> . empty
    (242) empty -> .

    COMMA           shift and go to state 349
    NEWLINE         reduce using rule 242 (empty -> .)

    next_val                       shift and go to state 438
    empty                          shift and go to state 350

state 394

    (234) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 439


state 395

    (235) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 440


state 396

    (236) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 441


state 397

    (237) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 442


state 398

    (149) condition_factor -> LPAREN condition . RPAREN

    RPAREN          shift and go to state 443


state 399

    (141) conditional_statement -> CHECK LPAREN condition RPAREN . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 444


state 400

    (144) condition -> condition_factor condition_tail .

    RPAREN          reduce using rule 144 (condition -> condition_factor condition_tail .)


state 401

    (150) condition_tail -> PLUS . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 445
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 402

    (151) condition_tail -> MINUS . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 446
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 403

    (152) condition_tail -> MULTIPLY . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 447
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 404

    (153) condition_tail -> DIVISION . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 448
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 405

    (154) condition_tail -> MODULO . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 449
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 406

    (155) condition_tail -> EXPONENT . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 450
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 407

    (156) condition_tail -> GT . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 451
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 408

    (157) condition_tail -> LT . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 452
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 409

    (158) condition_tail -> EQ_EQ . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 453
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 410

    (159) condition_tail -> GT_EQ . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 454
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 411

    (160) condition_tail -> LT_EQ . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 455
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 412

    (161) condition_tail -> NOT_EQ . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 456
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 413

    (162) condition_tail -> AND . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 457
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 414

    (163) condition_tail -> OR . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition_factor               shift and go to state 458
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 415

    (164) condition_tail -> empty .

    RPAREN          reduce using rule 164 (condition_tail -> empty .)


state 416

    (145) condition_factor -> var_call postfix .

    PLUS            reduce using rule 145 (condition_factor -> var_call postfix .)
    MINUS           reduce using rule 145 (condition_factor -> var_call postfix .)
    MULTIPLY        reduce using rule 145 (condition_factor -> var_call postfix .)
    DIVISION        reduce using rule 145 (condition_factor -> var_call postfix .)
    MODULO          reduce using rule 145 (condition_factor -> var_call postfix .)
    EXPONENT        reduce using rule 145 (condition_factor -> var_call postfix .)
    GT              reduce using rule 145 (condition_factor -> var_call postfix .)
    LT              reduce using rule 145 (condition_factor -> var_call postfix .)
    EQ_EQ           reduce using rule 145 (condition_factor -> var_call postfix .)
    GT_EQ           reduce using rule 145 (condition_factor -> var_call postfix .)
    LT_EQ           reduce using rule 145 (condition_factor -> var_call postfix .)
    NOT_EQ          reduce using rule 145 (condition_factor -> var_call postfix .)
    AND             reduce using rule 145 (condition_factor -> var_call postfix .)
    OR              reduce using rule 145 (condition_factor -> var_call postfix .)
    RPAREN          reduce using rule 145 (condition_factor -> var_call postfix .)


state 417

    (147) condition_factor -> TILDE INT_LIT .

    PLUS            reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    MINUS           reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    MULTIPLY        reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    DIVISION        reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    MODULO          reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    EXPONENT        reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    GT              reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    LT              reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    EQ_EQ           reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    GT_EQ           reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    LT_EQ           reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    NOT_EQ          reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    AND             reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    OR              reduce using rule 147 (condition_factor -> TILDE INT_LIT .)
    RPAREN          reduce using rule 147 (condition_factor -> TILDE INT_LIT .)


state 418

    (148) condition_factor -> TILDE FLT_LIT .

    PLUS            reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    MINUS           reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    MULTIPLY        reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    DIVISION        reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    MODULO          reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    EXPONENT        reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    GT              reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    LT              reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    EQ_EQ           reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    GT_EQ           reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    LT_EQ           reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    NOT_EQ          reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    AND             reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    OR              reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)
    RPAREN          reduce using rule 148 (condition_factor -> TILDE FLT_LIT .)


state 419

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 459
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 420

    (187) control_variable -> INT IDENT . EQ control_var_tail

    EQ              shift and go to state 460


state 421

    (185) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 461


state 422

    (186) repeat_until -> REPEAT LBRACE statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 462


state 423

    (130) local_dec_tail2 -> COMMA IDENT local_dec_tail .

    NEWLINE         reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    SWAP            reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FUNCTION_NAME   reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    IDENT           reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    DISPLAY         reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    CHECK           reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FOR             reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    UNTIL           reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    REPEAT          reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    INPUT           reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    INT             reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FLT             reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    BLN             reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    CHR             reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    STR             reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    REVIVE          reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    RBRACE          reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    SHIFT           reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    OTHERWISE       reduce using rule 130 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)


state 424

    (137) local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 137 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 425

    (239) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 463


state 426

    (138) local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 138 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 427

    (139) local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INT             reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    STR             reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 139 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 428

    (140) local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INT             reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    STR             reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 140 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 429

    (112) revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 112 (revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 430

    (113) revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 113 (revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 431

    (114) revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 114 (revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 432

    (115) revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 115 (revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 433

    (170) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
    (171) switch_condition -> . SHIFT switch_value COLON statements switchcond_tail

    SHIFT           shift and go to state 465

    switch_condition               shift and go to state 464

state 434

    (207) assign_tail -> DOT SPLICE LPAREN start . COMMA deleteCount COMMA splice_items RPAREN

    COMMA           shift and go to state 466


state 435

    (217) start -> INT_LIT .

    COMMA           reduce using rule 217 (start -> INT_LIT .)


state 436

    (208) assign_tail -> DOT PUSH LPAREN list_element . RPAREN

    RPAREN          shift and go to state 467


state 437

    (199) arg_tail -> COMMA arg_value . arg_tail
    (199) arg_tail -> . COMMA arg_value arg_tail
    (200) arg_tail -> . empty
    (242) empty -> .

    COMMA           shift and go to state 391
    RPAREN          reduce using rule 242 (empty -> .)

    arg_tail                       shift and go to state 468
    empty                          shift and go to state 392

state 438

    (204) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 204 (next_val -> COMMA value next_val .)


state 439

    (234) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 234 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 234 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 234 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 440

    (235) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 235 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 235 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 235 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 441

    (236) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 236 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 236 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 236 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 442

    (237) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 237 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 237 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 237 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 443

    (149) condition_factor -> LPAREN condition RPAREN .

    PLUS            reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    MINUS           reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    MULTIPLY        reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    DIVISION        reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    MODULO          reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    EXPONENT        reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    GT              reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    LT              reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    EQ_EQ           reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    GT_EQ           reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    LT_EQ           reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    NOT_EQ          reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    AND             reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    OR              reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)
    RPAREN          reduce using rule 149 (condition_factor -> LPAREN condition RPAREN .)


state 444

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 469
    empty                          shift and go to state 17

state 445

    (150) condition_tail -> PLUS condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 470
    empty                          shift and go to state 415

state 446

    (151) condition_tail -> MINUS condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 471
    empty                          shift and go to state 415

state 447

    (152) condition_tail -> MULTIPLY condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 472
    empty                          shift and go to state 415

state 448

    (153) condition_tail -> DIVISION condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 473
    empty                          shift and go to state 415

state 449

    (154) condition_tail -> MODULO condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 474
    empty                          shift and go to state 415

state 450

    (155) condition_tail -> EXPONENT condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 475
    empty                          shift and go to state 415

state 451

    (156) condition_tail -> GT condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 476
    empty                          shift and go to state 415

state 452

    (157) condition_tail -> LT condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 477
    empty                          shift and go to state 415

state 453

    (158) condition_tail -> EQ_EQ condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 478
    empty                          shift and go to state 415

state 454

    (159) condition_tail -> GT_EQ condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 479
    empty                          shift and go to state 415

state 455

    (160) condition_tail -> LT_EQ condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 480
    empty                          shift and go to state 415

state 456

    (161) condition_tail -> NOT_EQ condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 481
    empty                          shift and go to state 415

state 457

    (162) condition_tail -> AND condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 482
    empty                          shift and go to state 415

state 458

    (163) condition_tail -> OR condition_factor . condition_tail
    (150) condition_tail -> . PLUS condition_factor condition_tail
    (151) condition_tail -> . MINUS condition_factor condition_tail
    (152) condition_tail -> . MULTIPLY condition_factor condition_tail
    (153) condition_tail -> . DIVISION condition_factor condition_tail
    (154) condition_tail -> . MODULO condition_factor condition_tail
    (155) condition_tail -> . EXPONENT condition_factor condition_tail
    (156) condition_tail -> . GT condition_factor condition_tail
    (157) condition_tail -> . LT condition_factor condition_tail
    (158) condition_tail -> . EQ_EQ condition_factor condition_tail
    (159) condition_tail -> . GT_EQ condition_factor condition_tail
    (160) condition_tail -> . LT_EQ condition_factor condition_tail
    (161) condition_tail -> . NOT_EQ condition_factor condition_tail
    (162) condition_tail -> . AND condition_factor condition_tail
    (163) condition_tail -> . OR condition_factor condition_tail
    (164) condition_tail -> . empty
    (242) empty -> .

    PLUS            shift and go to state 401
    MINUS           shift and go to state 402
    MULTIPLY        shift and go to state 403
    DIVISION        shift and go to state 404
    MODULO          shift and go to state 405
    EXPONENT        shift and go to state 406
    GT              shift and go to state 407
    LT              shift and go to state 408
    EQ_EQ           shift and go to state 409
    GT_EQ           shift and go to state 410
    LT_EQ           shift and go to state 411
    NOT_EQ          shift and go to state 412
    AND             shift and go to state 413
    OR              shift and go to state 414
    RPAREN          reduce using rule 242 (empty -> .)

    condition_tail                 shift and go to state 483
    empty                          shift and go to state 415

state 459

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE

    SEMICOLON       shift and go to state 484


state 460

    (187) control_variable -> INT IDENT EQ . control_var_tail
    (188) control_var_tail -> . INT_LIT
    (189) control_var_tail -> . var_call
    (222) var_call -> . IDENT list_index

    INT_LIT         shift and go to state 486
    IDENT           shift and go to state 55

    control_var_tail               shift and go to state 485
    var_call                       shift and go to state 487

state 461

    (185) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . statements RBRACE
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 488
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 462

    (186) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 489


state 463

    (239) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 239 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 464

    (170) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition . OTHERWISE LBRACE statements RBRACE RBRACE

    OTHERWISE       shift and go to state 490


state 465

    (171) switch_condition -> SHIFT . switch_value COLON statements switchcond_tail
    (172) switch_value -> . switch_type_cast
    (173) switch_value -> . expression
    (174) switch_value -> . function_call
    (175) switch_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (176) switch_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (177) switch_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (178) switch_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (195) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (196) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (241) input_statement -> . INPUT LPAREN RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 495
    CONVERT_TO_FLT  shift and go to state 496
    CONVERT_TO_BLN  shift and go to state 497
    CONVERT_TO_STR  shift and go to state 498
    FUNCTION_NAME   shift and go to state 260
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 267
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    switch_value                   shift and go to state 491
    switch_type_cast               shift and go to state 492
    expression                     shift and go to state 493
    function_call                  shift and go to state 494
    factor                         shift and go to state 47
    input_statement                shift and go to state 261
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 466

    (207) assign_tail -> DOT SPLICE LPAREN start COMMA . deleteCount COMMA splice_items RPAREN
    (218) deleteCount -> . empty
    (219) deleteCount -> . INT_LIT
    (242) empty -> .

    INT_LIT         shift and go to state 501
    COMMA           reduce using rule 242 (empty -> .)

    deleteCount                    shift and go to state 499
    empty                          shift and go to state 500

state 467

    (208) assign_tail -> DOT PUSH LPAREN list_element RPAREN .

    NEWLINE         reduce using rule 208 (assign_tail -> DOT PUSH LPAREN list_element RPAREN .)


state 468

    (199) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 199 (arg_tail -> COMMA arg_value arg_tail .)


state 469

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 502
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 470

    (150) condition_tail -> PLUS condition_factor condition_tail .

    RPAREN          reduce using rule 150 (condition_tail -> PLUS condition_factor condition_tail .)


state 471

    (151) condition_tail -> MINUS condition_factor condition_tail .

    RPAREN          reduce using rule 151 (condition_tail -> MINUS condition_factor condition_tail .)


state 472

    (152) condition_tail -> MULTIPLY condition_factor condition_tail .

    RPAREN          reduce using rule 152 (condition_tail -> MULTIPLY condition_factor condition_tail .)


state 473

    (153) condition_tail -> DIVISION condition_factor condition_tail .

    RPAREN          reduce using rule 153 (condition_tail -> DIVISION condition_factor condition_tail .)


state 474

    (154) condition_tail -> MODULO condition_factor condition_tail .

    RPAREN          reduce using rule 154 (condition_tail -> MODULO condition_factor condition_tail .)


state 475

    (155) condition_tail -> EXPONENT condition_factor condition_tail .

    RPAREN          reduce using rule 155 (condition_tail -> EXPONENT condition_factor condition_tail .)


state 476

    (156) condition_tail -> GT condition_factor condition_tail .

    RPAREN          reduce using rule 156 (condition_tail -> GT condition_factor condition_tail .)


state 477

    (157) condition_tail -> LT condition_factor condition_tail .

    RPAREN          reduce using rule 157 (condition_tail -> LT condition_factor condition_tail .)


state 478

    (158) condition_tail -> EQ_EQ condition_factor condition_tail .

    RPAREN          reduce using rule 158 (condition_tail -> EQ_EQ condition_factor condition_tail .)


state 479

    (159) condition_tail -> GT_EQ condition_factor condition_tail .

    RPAREN          reduce using rule 159 (condition_tail -> GT_EQ condition_factor condition_tail .)


state 480

    (160) condition_tail -> LT_EQ condition_factor condition_tail .

    RPAREN          reduce using rule 160 (condition_tail -> LT_EQ condition_factor condition_tail .)


state 481

    (161) condition_tail -> NOT_EQ condition_factor condition_tail .

    RPAREN          reduce using rule 161 (condition_tail -> NOT_EQ condition_factor condition_tail .)


state 482

    (162) condition_tail -> AND condition_factor condition_tail .

    RPAREN          reduce using rule 162 (condition_tail -> AND condition_factor condition_tail .)


state 483

    (163) condition_tail -> OR condition_factor condition_tail .

    RPAREN          reduce using rule 163 (condition_tail -> OR condition_factor condition_tail .)


state 484

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN LBRACE unli_newline statements unli_newline RBRACE
    (190) update -> . var_call update_tail
    (222) var_call -> . IDENT list_index

    IDENT           shift and go to state 55

    update                         shift and go to state 503
    var_call                       shift and go to state 504

state 485

    (187) control_variable -> INT IDENT EQ control_var_tail .

    SEMICOLON       reduce using rule 187 (control_variable -> INT IDENT EQ control_var_tail .)


state 486

    (188) control_var_tail -> INT_LIT .

    SEMICOLON       reduce using rule 188 (control_var_tail -> INT_LIT .)


state 487

    (189) control_var_tail -> var_call .

    SEMICOLON       reduce using rule 189 (control_var_tail -> var_call .)


state 488

    (185) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 505


state 489

    (186) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN . expression RPAREN
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 506
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 490

    (170) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE . LBRACE statements RBRACE RBRACE

    LBRACE          shift and go to state 507


state 491

    (171) switch_condition -> SHIFT switch_value . COLON statements switchcond_tail

    COLON           shift and go to state 508


state 492

    (172) switch_value -> switch_type_cast .

    COLON           reduce using rule 172 (switch_value -> switch_type_cast .)


state 493

    (173) switch_value -> expression .

    COLON           reduce using rule 173 (switch_value -> expression .)


state 494

    (174) switch_value -> function_call .

    COLON           reduce using rule 174 (switch_value -> function_call .)


state 495

    (175) switch_type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 509


state 496

    (176) switch_type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 510


state 497

    (177) switch_type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 511


state 498

    (178) switch_type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 512


state 499

    (207) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount . COMMA splice_items RPAREN

    COMMA           shift and go to state 513


state 500

    (218) deleteCount -> empty .

    COMMA           reduce using rule 218 (deleteCount -> empty .)


state 501

    (219) deleteCount -> INT_LIT .

    COMMA           reduce using rule 219 (deleteCount -> INT_LIT .)


state 502

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 242 (empty -> .)

    maybe_newline                  shift and go to state 514
    empty                          shift and go to state 17

state 503

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN LBRACE unli_newline statements unli_newline RBRACE

    RPAREN          shift and go to state 515


state 504

    (190) update -> var_call . update_tail
    (191) update_tail -> . postfix_op
    (192) update_tail -> . compound_op value
    (193) postfix_op -> . PLUS_PLUS
    (194) postfix_op -> . MINUS_MINUS
    (212) compound_op -> . PLUS_EQ
    (213) compound_op -> . MINUS_EQ
    (214) compound_op -> . MUL_EQ
    (215) compound_op -> . DIV_EQ
    (216) compound_op -> . MOD_EQ

    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93
    PLUS_EQ         shift and go to state 301
    MINUS_EQ        shift and go to state 302
    MUL_EQ          shift and go to state 303
    DIV_EQ          shift and go to state 304
    MOD_EQ          shift and go to state 305

    update_tail                    shift and go to state 516
    postfix_op                     shift and go to state 517
    compound_op                    shift and go to state 518

state 505

    (185) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 185 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .)


state 506

    (186) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 519


state 507

    (170) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE . statements RBRACE RBRACE
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 520
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 508

    (171) switch_condition -> SHIFT switch_value COLON . statements switchcond_tail
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SHIFT           reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 521
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 509

    (175) switch_type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 522
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 510

    (176) switch_type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 523
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 511

    (177) switch_type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 524
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 512

    (178) switch_type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (238) typecast_value -> . expression
    (239) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (240) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (241) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 374
    INPUT           shift and go to state 267
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 525
    expression                     shift and go to state 373
    input_statement                shift and go to state 375
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 513

    (207) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA . splice_items RPAREN
    (220) splice_items -> . empty
    (221) splice_items -> . list_element
    (242) empty -> .
    (24) list_element -> . literal element_tail
    (79) literal -> . literal1
    (80) literal -> . literal2
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT
    (86) literal2 -> . CHR_LIT

    RPAREN          reduce using rule 242 (empty -> .)
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    splice_items                   shift and go to state 526
    empty                          shift and go to state 527
    list_element                   shift and go to state 528
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 514

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RBRACE          shift and go to state 529


state 515

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . LBRACE unli_newline statements unli_newline RBRACE

    LBRACE          shift and go to state 530


state 516

    (190) update -> var_call update_tail .

    RPAREN          reduce using rule 190 (update -> var_call update_tail .)


state 517

    (191) update_tail -> postfix_op .

    RPAREN          reduce using rule 191 (update_tail -> postfix_op .)


state 518

    (192) update_tail -> compound_op . value
    (231) value -> . type_cast
    (232) value -> . expression
    (233) value -> . function_call
    (234) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (235) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (236) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (237) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (195) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (196) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN factor_expression RPAREN
    (241) input_statement -> . INPUT LPAREN RPAREN
    (222) var_call -> . IDENT list_index
    (81) literal1 -> . INT_LIT
    (82) literal1 -> . FLT_LIT
    (83) literal1 -> . DAY
    (84) literal1 -> . NIGHT
    (85) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 311
    CONVERT_TO_FLT  shift and go to state 312
    CONVERT_TO_BLN  shift and go to state 313
    CONVERT_TO_STR  shift and go to state 314
    FUNCTION_NAME   shift and go to state 260
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 267
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 531
    type_cast                      shift and go to state 308
    expression                     shift and go to state 309
    function_call                  shift and go to state 310
    factor                         shift and go to state 47
    input_statement                shift and go to state 261
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 519

    (186) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 186 (repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .)


state 520

    (170) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements . RBRACE RBRACE

    RBRACE          shift and go to state 532


state 521

    (171) switch_condition -> SHIFT switch_value COLON statements . switchcond_tail
    (179) switchcond_tail -> . switch_condition
    (180) switchcond_tail -> . empty
    (171) switch_condition -> . SHIFT switch_value COLON statements switchcond_tail
    (242) empty -> .

    SHIFT           shift and go to state 465
    OTHERWISE       reduce using rule 242 (empty -> .)

    switchcond_tail                shift and go to state 533
    switch_condition               shift and go to state 534
    empty                          shift and go to state 535

state 522

    (175) switch_type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 536


state 523

    (176) switch_type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 537


state 524

    (177) switch_type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 538


state 525

    (178) switch_type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 539


state 526

    (207) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items . RPAREN

    RPAREN          shift and go to state 540


state 527

    (220) splice_items -> empty .

    RPAREN          reduce using rule 220 (splice_items -> empty .)


state 528

    (221) splice_items -> list_element .

    RPAREN          reduce using rule 221 (splice_items -> list_element .)


state 529

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    OTHERWISE_CHECK reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 541
    empty                          shift and go to state 17

state 530

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE . unli_newline statements unli_newline RBRACE
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 542

state 531

    (192) update_tail -> compound_op value .

    RPAREN          reduce using rule 192 (update_tail -> compound_op value .)


state 532

    (170) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE . RBRACE

    RBRACE          shift and go to state 543


state 533

    (171) switch_condition -> SHIFT switch_value COLON statements switchcond_tail .

    OTHERWISE       reduce using rule 171 (switch_condition -> SHIFT switch_value COLON statements switchcond_tail .)


state 534

    (179) switchcond_tail -> switch_condition .

    OTHERWISE       reduce using rule 179 (switchcond_tail -> switch_condition .)


state 535

    (180) switchcond_tail -> empty .

    OTHERWISE       reduce using rule 180 (switchcond_tail -> empty .)


state 536

    (175) switch_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COLON           reduce using rule 175 (switch_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 537

    (176) switch_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COLON           reduce using rule 176 (switch_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 538

    (177) switch_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COLON           reduce using rule 177 (switch_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 539

    (178) switch_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COLON           reduce using rule 178 (switch_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 540

    (207) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN .

    NEWLINE         reduce using rule 207 (assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN .)


state 541

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (142) conditional_tail -> . OTHERWISE_CHECK LPAREN condition RPAREN LBRACE statements RBRACE conditional_tail
    (143) conditional_tail -> . empty
    (242) empty -> .

    OTHERWISE_CHECK shift and go to state 545
    NEWLINE         reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

    conditional_tail               shift and go to state 544
    empty                          shift and go to state 546

state 542

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline . statements unli_newline RBRACE
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 547
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 543

    (170) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE .

    NEWLINE         reduce using rule 170 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE .)


state 544

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

    NEWLINE         shift and go to state 18
    OTHERWISE       reduce using rule 242 (empty -> .)

    maybe_newline                  shift and go to state 548
    empty                          shift and go to state 17

state 545

    (142) conditional_tail -> OTHERWISE_CHECK . LPAREN condition RPAREN LBRACE statements RBRACE conditional_tail

    LPAREN          shift and go to state 549


state 546

    (143) conditional_tail -> empty .

    NEWLINE         reduce using rule 143 (conditional_tail -> empty .)
    OTHERWISE       reduce using rule 143 (conditional_tail -> empty .)


state 547

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements . unli_newline RBRACE
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 550

state 548

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    OTHERWISE       shift and go to state 551


state 549

    (142) conditional_tail -> OTHERWISE_CHECK LPAREN . condition RPAREN LBRACE statements RBRACE conditional_tail
    (144) condition -> . condition_factor condition_tail
    (145) condition_factor -> . var_call postfix
    (146) condition_factor -> . condition1
    (147) condition_factor -> . TILDE INT_LIT
    (148) condition_factor -> . TILDE FLT_LIT
    (149) condition_factor -> . LPAREN condition RPAREN
    (222) var_call -> . IDENT list_index
    (165) condition1 -> . INT_LIT
    (166) condition1 -> . FLT_LIT
    (167) condition1 -> . DAY
    (168) condition1 -> . NIGHT
    (169) condition1 -> . STR_LIT

    TILDE           shift and go to state 360
    LPAREN          shift and go to state 355
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 361
    FLT_LIT         shift and go to state 362
    DAY             shift and go to state 363
    NIGHT           shift and go to state 364
    STR_LIT         shift and go to state 365

    condition                      shift and go to state 552
    condition_factor               shift and go to state 357
    var_call                       shift and go to state 358
    condition1                     shift and go to state 359

state 550

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline . RBRACE

    RBRACE          shift and go to state 553


state 551

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

    NEWLINE         shift and go to state 18
    LBRACE          reduce using rule 242 (empty -> .)

    maybe_newline                  shift and go to state 554
    empty                          shift and go to state 17

state 552

    (142) conditional_tail -> OTHERWISE_CHECK LPAREN condition . RPAREN LBRACE statements RBRACE conditional_tail

    RPAREN          shift and go to state 555


state 553

    (184) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE .

    NEWLINE         reduce using rule 184 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE .)


state 554

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 556


state 555

    (142) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN . LBRACE statements RBRACE conditional_tail

    LBRACE          shift and go to state 557


state 556

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 242 (empty -> .)
    FLT             reduce using rule 242 (empty -> .)
    BLN             reduce using rule 242 (empty -> .)
    CHR             reduce using rule 242 (empty -> .)
    STR             reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)

  ! NEWLINE         [ reduce using rule 242 (empty -> .) ]

    maybe_newline                  shift and go to state 558
    empty                          shift and go to state 17

state 557

    (142) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN LBRACE . statements RBRACE conditional_tail
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 242 (empty -> .)
    NEWLINE         reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 559
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 558

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (116) statements -> . empty
    (117) statements -> . local_dec maybe_newline statements_tail
    (242) empty -> .
    (125) local_dec -> . var_statement local_dec_tail
    (126) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 242 (empty -> .)
    RBRACE          reduce using rule 242 (empty -> .)
    SWAP            reduce using rule 242 (empty -> .)
    FUNCTION_NAME   reduce using rule 242 (empty -> .)
    IDENT           reduce using rule 242 (empty -> .)
    DISPLAY         reduce using rule 242 (empty -> .)
    CHECK           reduce using rule 242 (empty -> .)
    FOR             reduce using rule 242 (empty -> .)
    UNTIL           reduce using rule 242 (empty -> .)
    REPEAT          reduce using rule 242 (empty -> .)
    INPUT           reduce using rule 242 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 242 (empty -> .) ]
  ! FLT             [ reduce using rule 242 (empty -> .) ]
  ! BLN             [ reduce using rule 242 (empty -> .) ]
  ! CHR             [ reduce using rule 242 (empty -> .) ]
  ! STR             [ reduce using rule 242 (empty -> .) ]

    statements                     shift and go to state 560
    empty                          shift and go to state 231
    local_dec                      shift and go to state 232
    var_statement                  shift and go to state 233
    data_type                      shift and go to state 9

state 559

    (142) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN LBRACE statements . RBRACE conditional_tail

    RBRACE          shift and go to state 561


state 560

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (242) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 242 (empty -> .)

    maybe_newline                  shift and go to state 562
    empty                          shift and go to state 17

state 561

    (142) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN LBRACE statements RBRACE . conditional_tail
    (142) conditional_tail -> . OTHERWISE_CHECK LPAREN condition RPAREN LBRACE statements RBRACE conditional_tail
    (143) conditional_tail -> . empty
    (242) empty -> .

    OTHERWISE_CHECK shift and go to state 545
    NEWLINE         reduce using rule 242 (empty -> .)
    OTHERWISE       reduce using rule 242 (empty -> .)

    conditional_tail               shift and go to state 563
    empty                          shift and go to state 546

state 562

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 564


state 563

    (142) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN LBRACE statements RBRACE conditional_tail .

    NEWLINE         reduce using rule 142 (conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN LBRACE statements RBRACE conditional_tail .)
    OTHERWISE       reduce using rule 142 (conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN LBRACE statements RBRACE conditional_tail .)


state 564

    (141) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 141 (conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 18 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 220 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 225 resolved as shift
WARNING: shift/reduce conflict for INT in state 226 resolved as shift
WARNING: shift/reduce conflict for FLT in state 226 resolved as shift
WARNING: shift/reduce conflict for BLN in state 226 resolved as shift
WARNING: shift/reduce conflict for CHR in state 226 resolved as shift
WARNING: shift/reduce conflict for STR in state 226 resolved as shift
WARNING: shift/reduce conflict for INT in state 229 resolved as shift
WARNING: shift/reduce conflict for FLT in state 229 resolved as shift
WARNING: shift/reduce conflict for BLN in state 229 resolved as shift
WARNING: shift/reduce conflict for CHR in state 229 resolved as shift
WARNING: shift/reduce conflict for STR in state 229 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 230 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 232 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 237 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 237 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 237 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 237 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 237 resolved as shift
WARNING: shift/reduce conflict for FOR in state 237 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 237 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 237 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 237 resolved as shift
WARNING: shift/reduce conflict for INT in state 237 resolved as shift
WARNING: shift/reduce conflict for FLT in state 237 resolved as shift
WARNING: shift/reduce conflict for BLN in state 237 resolved as shift
WARNING: shift/reduce conflict for CHR in state 237 resolved as shift
WARNING: shift/reduce conflict for STR in state 237 resolved as shift
WARNING: shift/reduce conflict for INT in state 289 resolved as shift
WARNING: shift/reduce conflict for FLT in state 289 resolved as shift
WARNING: shift/reduce conflict for BLN in state 289 resolved as shift
WARNING: shift/reduce conflict for CHR in state 289 resolved as shift
WARNING: shift/reduce conflict for STR in state 289 resolved as shift
WARNING: shift/reduce conflict for INT in state 290 resolved as shift
WARNING: shift/reduce conflict for FLT in state 290 resolved as shift
WARNING: shift/reduce conflict for BLN in state 290 resolved as shift
WARNING: shift/reduce conflict for CHR in state 290 resolved as shift
WARNING: shift/reduce conflict for STR in state 290 resolved as shift
WARNING: shift/reduce conflict for INT in state 291 resolved as shift
WARNING: shift/reduce conflict for FLT in state 291 resolved as shift
WARNING: shift/reduce conflict for BLN in state 291 resolved as shift
WARNING: shift/reduce conflict for CHR in state 291 resolved as shift
WARNING: shift/reduce conflict for STR in state 291 resolved as shift
WARNING: shift/reduce conflict for INT in state 292 resolved as shift
WARNING: shift/reduce conflict for FLT in state 292 resolved as shift
WARNING: shift/reduce conflict for BLN in state 292 resolved as shift
WARNING: shift/reduce conflict for CHR in state 292 resolved as shift
WARNING: shift/reduce conflict for STR in state 292 resolved as shift
WARNING: shift/reduce conflict for INT in state 293 resolved as shift
WARNING: shift/reduce conflict for FLT in state 293 resolved as shift
WARNING: shift/reduce conflict for BLN in state 293 resolved as shift
WARNING: shift/reduce conflict for CHR in state 293 resolved as shift
WARNING: shift/reduce conflict for STR in state 293 resolved as shift
WARNING: shift/reduce conflict for INT in state 294 resolved as shift
WARNING: shift/reduce conflict for FLT in state 294 resolved as shift
WARNING: shift/reduce conflict for BLN in state 294 resolved as shift
WARNING: shift/reduce conflict for CHR in state 294 resolved as shift
WARNING: shift/reduce conflict for STR in state 294 resolved as shift
WARNING: shift/reduce conflict for INT in state 318 resolved as shift
WARNING: shift/reduce conflict for FLT in state 318 resolved as shift
WARNING: shift/reduce conflict for BLN in state 318 resolved as shift
WARNING: shift/reduce conflict for CHR in state 318 resolved as shift
WARNING: shift/reduce conflict for STR in state 318 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 444 resolved as shift
WARNING: shift/reduce conflict for INT in state 461 resolved as shift
WARNING: shift/reduce conflict for FLT in state 461 resolved as shift
WARNING: shift/reduce conflict for BLN in state 461 resolved as shift
WARNING: shift/reduce conflict for CHR in state 461 resolved as shift
WARNING: shift/reduce conflict for STR in state 461 resolved as shift
WARNING: shift/reduce conflict for INT in state 469 resolved as shift
WARNING: shift/reduce conflict for FLT in state 469 resolved as shift
WARNING: shift/reduce conflict for BLN in state 469 resolved as shift
WARNING: shift/reduce conflict for CHR in state 469 resolved as shift
WARNING: shift/reduce conflict for STR in state 469 resolved as shift
WARNING: shift/reduce conflict for INT in state 507 resolved as shift
WARNING: shift/reduce conflict for FLT in state 507 resolved as shift
WARNING: shift/reduce conflict for BLN in state 507 resolved as shift
WARNING: shift/reduce conflict for CHR in state 507 resolved as shift
WARNING: shift/reduce conflict for STR in state 507 resolved as shift
WARNING: shift/reduce conflict for INT in state 508 resolved as shift
WARNING: shift/reduce conflict for FLT in state 508 resolved as shift
WARNING: shift/reduce conflict for BLN in state 508 resolved as shift
WARNING: shift/reduce conflict for CHR in state 508 resolved as shift
WARNING: shift/reduce conflict for STR in state 508 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 529 resolved as shift
WARNING: shift/reduce conflict for INT in state 542 resolved as shift
WARNING: shift/reduce conflict for FLT in state 542 resolved as shift
WARNING: shift/reduce conflict for BLN in state 542 resolved as shift
WARNING: shift/reduce conflict for CHR in state 542 resolved as shift
WARNING: shift/reduce conflict for STR in state 542 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 556 resolved as shift
WARNING: shift/reduce conflict for INT in state 557 resolved as shift
WARNING: shift/reduce conflict for FLT in state 557 resolved as shift
WARNING: shift/reduce conflict for BLN in state 557 resolved as shift
WARNING: shift/reduce conflict for CHR in state 557 resolved as shift
WARNING: shift/reduce conflict for STR in state 557 resolved as shift
WARNING: shift/reduce conflict for INT in state 558 resolved as shift
WARNING: shift/reduce conflict for FLT in state 558 resolved as shift
WARNING: shift/reduce conflict for BLN in state 558 resolved as shift
WARNING: shift/reduce conflict for CHR in state 558 resolved as shift
WARNING: shift/reduce conflict for STR in state 558 resolved as shift
WARNING: reduce/reduce conflict in state 231 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 231
WARNING: reduce/reduce conflict in state 381 resolved using rule (function_statements -> empty)
WARNING: rejected rule (function_statements_tail -> empty) in state 381
WARNING: Rule (function_statements_tail -> empty) is never reduced
