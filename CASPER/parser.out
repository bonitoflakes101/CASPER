Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_statement -> data_type IDENT global_statement_tail
Rule 11    global_statement_tail -> empty
Rule 12    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 13    global_statement_tail -> EQ global_dec_value global_tail2
Rule 14    global_tail2 -> empty
Rule 15    global_tail2 -> COMMA IDENT global_statement_tail
Rule 16    global_dec_value -> global_value
Rule 17    global_dec_value -> LBRACKET list_element RBRACKET
Rule 18    global_value -> expression
Rule 19    var_statement -> data_type IDENT var_tail unli_newline
Rule 20    var_tail -> empty
Rule 21    var_tail -> EQ tail_value var_tail2
Rule 22    var_tail -> COMMA IDENT var_tail
Rule 23    var_tail2 -> empty
Rule 24    var_tail2 -> COMMA IDENT var_tail
Rule 25    tail_value -> value
Rule 26    tail_value -> LBRACKET list_element RBRACKET
Rule 27    list_element -> literal element_tail
Rule 28    element_tail -> empty
Rule 29    element_tail -> COMMA list_element
Rule 30    index -> INT_LIT
Rule 31    index -> IDENT
Rule 32    data_type -> INT
Rule 33    data_type -> FLT
Rule 34    data_type -> BLN
Rule 35    data_type -> CHR
Rule 36    data_type -> STR
Rule 37    value -> type_cast
Rule 38    value -> expression
Rule 39    value -> function_call
Rule 40    type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 41    type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 42    type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 43    type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 44    typecast_value -> expression
Rule 45    typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 46    typecast_value -> input_statement
Rule 47    literal -> INT_LIT
Rule 48    literal -> FLT_LIT
Rule 49    literal -> DAY
Rule 50    literal -> NIGHT
Rule 51    literal -> CHR_LIT
Rule 52    literal -> STR_LIT
Rule 53    expression -> factor factor_tail
Rule 54    factor -> var_call
Rule 55    factor -> literal
Rule 56    factor -> TILDE literal
Rule 57    factor -> LPAREN expression RPAREN
Rule 58    factor_tail -> empty
Rule 59    factor_tail -> PLUS expression
Rule 60    factor_tail -> MINUS expression
Rule 61    factor_tail -> MULTIPLY expression
Rule 62    factor_tail -> DIVISION expression
Rule 63    factor_tail -> MODULO expression
Rule 64    factor_tail -> EXPONENT expression
Rule 65    factor_tail -> GT expression
Rule 66    factor_tail -> LT expression
Rule 67    factor_tail -> EQ_EQ expression
Rule 68    factor_tail -> GT_EQ expression
Rule 69    factor_tail -> LT_EQ expression
Rule 70    factor_tail -> NOT_EQ expression
Rule 71    factor_tail -> AND expression
Rule 72    factor_tail -> OR expression
Rule 73    var_call -> IDENT var_call_tail
Rule 74    var_call_tail -> empty
Rule 75    var_call_tail -> LBRACKET index RBRACKET
Rule 76    function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
Rule 77    function_statements -> empty
Rule 78    function_statements_tail -> function_statements
Rule 79    function_statements_tail -> empty
Rule 80    ret_type -> FUNCTION
Rule 81    ret_type -> function_dtype
Rule 82    function_dtype -> FUNCTION_INT
Rule 83    function_dtype -> FUNCTION_FLT
Rule 84    function_dtype -> FUNCTION_CHR
Rule 85    function_dtype -> FUNCTION_BLN
Rule 86    function_dtype -> FUNCTION_STR
Rule 87    function_dtype -> FUNCTION_LIST_INT
Rule 88    function_dtype -> FUNCTION_LIST_FLT
Rule 89    function_dtype -> FUNCTION_LIST_CHR
Rule 90    function_dtype -> FUNCTION_LIST_STR
Rule 91    function_dtype -> FUNCTION_LIST_BLN
Rule 92    parameters -> data_type IDENT parameters_tail
Rule 93    parameters -> empty
Rule 94    parameters_tail -> empty
Rule 95    parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 96    revive -> REVIVE value
Rule 97    revive -> empty
Rule 98    statements -> local_dec maybe_newline statements_tail
Rule 99    statements_tail -> string_operation_statement unli_newline statements
Rule 100   statements_tail -> conditional_statement unli_newline statements
Rule 101   statements_tail -> switch_statement unli_newline statements
Rule 102   statements_tail -> loop_statement unli_newline statements
Rule 103   statements_tail -> function_call unli_newline statements
Rule 104   statements_tail -> output_statement unli_newline statements
Rule 105   statements_tail -> statements
Rule 106   local_dec -> empty
Rule 107   local_dec -> var_statement
Rule 108   conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
Rule 109   conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
Rule 110   conditional_tail -> empty
Rule 111   condition -> condition_factor condition_factor_tail
Rule 112   condition_factor -> var_call
Rule 113   condition_factor -> condition_literal
Rule 114   condition_factor -> TILDE condition_literal
Rule 115   condition_factor -> LPAREN condition RPAREN
Rule 116   condition_factor_tail -> empty
Rule 117   condition_factor_tail -> PLUS condition
Rule 118   condition_factor_tail -> MINUS condition
Rule 119   condition_factor_tail -> MULTIPLY condition
Rule 120   condition_factor_tail -> DIVISION condition
Rule 121   condition_factor_tail -> MODULO condition
Rule 122   condition_factor_tail -> EXPONENT condition
Rule 123   condition_factor_tail -> GT condition
Rule 124   condition_factor_tail -> LT condition
Rule 125   condition_factor_tail -> EQ_EQ condition
Rule 126   condition_factor_tail -> GT_EQ condition
Rule 127   condition_factor_tail -> LT_EQ condition
Rule 128   condition_factor_tail -> NOT_EQ condition
Rule 129   condition_factor_tail -> AND condition
Rule 130   condition_factor_tail -> OR condition
Rule 131   condition_literal -> INT_LIT
Rule 132   condition_literal -> FLT_LIT
Rule 133   condition_literal -> DAY
Rule 134   condition_literal -> NIGHT
Rule 135   condition_literal -> CHR_LIT
Rule 136   condition_literal -> STR_LIT
Rule 137   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
Rule 138   switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail
Rule 139   switchcond_tail -> empty
Rule 140   switchcond_tail -> switch_condition
Rule 141   loop_statement -> for_loop
Rule 142   loop_statement -> until_loop
Rule 143   loop_statement -> repeat_until
Rule 144   for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
Rule 145   for_loop_condition -> for_loop_condition_factor for_loop_condition_factor_tail
