Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_tail -> empty
Rule 11    global_statement -> data_type IDENT global_statement_tail
Rule 12    global_statement_tail -> empty
Rule 13    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 14    global_statement_tail -> EQ global_dec_value global_tail2
Rule 15    global_tail2 -> empty
Rule 16    global_tail2 -> COMMA IDENT global_statement_tail
Rule 17    global_dec_value -> global_value
Rule 18    global_dec_value -> LBRACKET list_element RBRACKET
Rule 19    global_value -> factor
Rule 20    global_value -> expression
Rule 21    var_statement -> data_type IDENT var_tail
Rule 22    var_tail -> empty
Rule 23    var_tail -> EQ tail_value var_tail2
Rule 24    var_tail -> COMMA IDENT var_tail
Rule 25    var_tail2 -> empty
Rule 26    var_tail2 -> COMMA IDENT var_tail
Rule 27    tail_value -> value
Rule 28    tail_value -> LBRACKET list_element RBRACKET
Rule 29    list_element -> literal element_tail
Rule 30    element_tail -> empty
Rule 31    element_tail -> COMMA list_element
Rule 32    index -> INT_LIT
Rule 33    index -> IDENT
Rule 34    data_type -> INT
Rule 35    data_type -> FLT
Rule 36    data_type -> BLN
Rule 37    data_type -> CHR
Rule 38    data_type -> STR
Rule 39    value -> factor
Rule 40    value -> type_cast
Rule 41    value -> expression
Rule 42    value -> function_call
Rule 43    type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 44    type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 45    type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 46    type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 47    typecast_value -> IDENT
Rule 48    typecast_value -> literal
Rule 49    typecast_value -> expression
Rule 50    typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 51    typecast_value -> input_statement
Rule 52    literal -> INT_LIT
Rule 53    literal -> FLT_LIT
Rule 54    literal -> DAY
Rule 55    literal -> NIGHT
Rule 56    literal -> CHR_LIT
Rule 57    literal -> STR_LIT
Rule 58    expression -> expr_head expr_tail
Rule 59    expr_head -> term term_tail
Rule 60    term -> factor factor_tail
Rule 61    factor -> var_call
Rule 62    factor -> literal
Rule 63    factor -> TILDE literal
Rule 64    factor -> LPAREN expression RPAREN
Rule 65    factor_tail -> empty
Rule 66    factor_tail -> PLUS expression
Rule 67    factor_tail -> MINUS expression
Rule 68    factor_tail -> MULTIPLY expression
Rule 69    factor_tail -> DIVISION expression
Rule 70    factor_tail -> MODULO expression
Rule 71    factor_tail -> EXPONENT expression
Rule 72    term_tail -> empty
Rule 73    term_tail -> GT expression
Rule 74    term_tail -> LT expression
Rule 75    term_tail -> EQ_EQ expression
Rule 76    term_tail -> GT_EQ expression
Rule 77    term_tail -> LT_EQ expression
Rule 78    term_tail -> NOT_EQ expression
Rule 79    expr_tail -> empty
Rule 80    expr_tail -> AND expression
Rule 81    expr_tail -> OR expression
Rule 82    var_call -> IDENT var_call_tail
Rule 83    var_call_tail -> empty
Rule 84    var_call_tail -> LBRACKET index RBRACKET
Rule 85    function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
Rule 86    function_statements -> empty
Rule 87    ret_type -> FUNCTION
Rule 88    ret_type -> function_dtype
Rule 89    function_dtype -> FUNCTION_INT
Rule 90    function_dtype -> FUNCTION_FLT
Rule 91    function_dtype -> FUNCTION_CHR
Rule 92    function_dtype -> FUNCTION_BLN
Rule 93    function_dtype -> FUNCTION_STR
Rule 94    function_dtype -> FUNCTION_LIST_INT
Rule 95    function_dtype -> FUNCTION_LIST_FLT
Rule 96    function_dtype -> FUNCTION_LIST_CHR
Rule 97    function_dtype -> FUNCTION_LIST_STR
Rule 98    function_dtype -> FUNCTION_LIST_BLN
Rule 99    parameters -> data_type IDENT parameters_tail
Rule 100   parameters -> empty
Rule 101   parameters_tail -> empty
Rule 102   parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 103   revive -> REVIVE value
Rule 104   revive -> empty
Rule 105   statements -> empty
Rule 106   statements -> local_dec NEWLINE statements_tail
Rule 107   statements_tail -> empty
Rule 108   statements_tail -> statements
Rule 109   statements_tail -> conditional_statement NEWLINE statements_tail
Rule 110   statements_tail -> switch_statement NEWLINE statements_tail
Rule 111   statements_tail -> loop_statement NEWLINE statements_tail
Rule 112   statements_tail -> function_call NEWLINE statements_tail
Rule 113   statements_tail -> string_operation_statement NEWLINE statements_tail
Rule 114   statements_tail -> output_statement NEWLINE statements_tail
Rule 115   local_dec -> var_statement
Rule 116   local_dec -> empty
Rule 117   conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
Rule 118   conditional_tail -> empty
Rule 119   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE
Rule 120   conditional_tail -> OTHERWISE LBRACE statements RBRACE
Rule 121   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
Rule 122   switch_condition -> SHIFT value COLON statements switchcond_tail
Rule 123   switchcond_tail -> empty
Rule 124   switchcond_tail -> switch_condition
Rule 125   loop_statement -> for_loop
Rule 126   loop_statement -> until_loop
Rule 127   loop_statement -> repeat_until
Rule 128   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
Rule 129   until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
Rule 130   repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
Rule 131   control_variable -> INT IDENT EQ INT_LIT
Rule 132   update -> var_call update_tail
Rule 133   update_tail -> postfix
Rule 134   update_tail -> assign_op value
Rule 135   postfix -> PLUS_PLUS
Rule 136   postfix -> MINUS_MINUS
Rule 137   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 138   function_call -> input_statement
Rule 139   arguments -> empty
Rule 140   arguments -> arg_value arg_tail
Rule 141   arg_tail -> empty
Rule 142   arg_tail -> COMMA arg_value arg_tail
Rule 143   arg_value -> literal
Rule 144   arg_value -> var_call
Rule 145   output_statement -> DISPLAY value next_val
Rule 146   output_statement -> DISPLAY LPAREN value next_val RPAREN
Rule 147   next_val -> empty
Rule 148   next_val -> COMMA value next_val
Rule 149   input_statement -> INPUT LPAREN RPAREN
Rule 150   string_operation_statement -> var_call string_operation_tail
Rule 151   string_operation_tail -> assign_op value
Rule 152   string_operation_tail -> PLUS string_val stringcon_tail
Rule 153   assign_op -> PLUS_EQ
Rule 154   assign_op -> MINUS_EQ
Rule 155   assign_op -> MUL_EQ
Rule 156   assign_op -> DIV_EQ
Rule 157   assign_op -> MOD_EQ
Rule 158   assign_op -> EQ
Rule 159   stringcon_tail -> empty
Rule 160   stringcon_tail -> PLUS string_val stringcon_tail
Rule 161   string_val -> var_call
Rule 162   string_val -> STR_LIT
Rule 163   empty -> <empty>

Terminals, with rules where they appear

AND                  : 80
BIRTH                : 1
BLN                  : 36
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 117
CHR                  : 37
CHR_LIT              : 56
COLON                : 122
COMMA                : 13 16 24 26 31 102 142 148
COMMENT              : 
CONVERT_TO_BLN       : 45
CONVERT_TO_FLT       : 44
CONVERT_TO_INT       : 43
CONVERT_TO_STR       : 46
DAY                  : 54
DISPLAY              : 145 146
DIVISION             : 69
DIV_EQ               : 156
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 14 23 131 158
EQ_EQ                : 75
EXPONENT             : 71
FLT                  : 35
FLT_LIT              : 53
FOR                  : 128
FUNCTION             : 87
FUNCTION_BLN         : 92
FUNCTION_CHR         : 91
FUNCTION_FLT         : 90
FUNCTION_INT         : 89
FUNCTION_LIST_BLN    : 98
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 96
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 95
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 94
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 97
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 50 85 137
FUNCTION_STR         : 93
GHOST                : 1
GT                   : 73
GT_EQ                : 76
IDENT                : 11 13 16 21 24 26 33 47 82 99 102 121 131
ILLEGAL              : 
IN                   : 
INPUT                : 149
INT                  : 34 131
INT_LIT              : 32 52 131
LBRACE               : 6 85 117 119 120 121 128 129 130
LBRACKET             : 18 28 84
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 43 44 45 46 50 64 85 117 119 121 128 129 130 137 146 149
LT                   : 74
LT_EQ                : 77
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 67
MINUS_EQ             : 154
MINUS_MINUS          : 136
MODULO               : 70
MOD_EQ               : 157
MULTIPLY             : 68
MUL_EQ               : 155
NEWLINE              : 3 4 5 106 109 110 111 112 113 114
NIGHT                : 55
NOT                  : 
NOT_EQ               : 78
OR                   : 81
OTHERWISE            : 120 121
OTHERWISE_CHECK      : 119
PLUS                 : 66 152 160
PLUS_EQ              : 153
PLUS_PLUS            : 135
POW                  : 
RBRACE               : 6 85 117 119 120 121 128 129 130
RBRACKET             : 18 28 84
REPEAT               : 130
REVIVE               : 103
RPAREN               : 6 43 44 45 46 50 64 85 117 119 121 128 129 130 137 146 149
SEMICOLON            : 128 128
SHIFT                : 122
SKIP                 : 
STOP                 : 
STR                  : 38
STR_LIT              : 57 162
SWAP                 : 121
TILDE                : 63
TYPE                 : 
UNTIL                : 129 130
error                : 

Nonterminals, with rules where they appear

arg_tail             : 140 142
arg_value            : 140 142
arguments            : 137
assign_op            : 134 151
conditional_statement : 109
conditional_tail     : 117
control_variable     : 128
data_type            : 11 21 99 102
element_tail         : 29
empty                : 2 8 10 12 15 22 25 30 65 72 79 83 86 100 101 104 105 107 116 118 123 139 141 147 159
expr_head            : 58
expr_tail            : 58
expression           : 20 41 49 64 66 67 68 69 70 71 73 74 75 76 77 78 80 81 117 119 128 129 130
factor               : 19 39 60
factor_tail          : 60
for_loop             : 125
function_call        : 42 112
function_dtype       : 88
function_statements  : 1
global_dec           : 1 9
global_dec_value     : 14
global_statement     : 7
global_statement_tail : 11 13 16
global_tail          : 7
global_tail2         : 14
global_value         : 17
index                : 84
input_statement      : 51 138
list_element         : 18 28 31
literal              : 29 48 62 63 143
local_dec            : 106
loop_statement       : 111
main_function        : 1
maybe_newline        : 1 1 3 6 6 85 85 85
next_val             : 145 146 148
output_statement     : 114
parameters           : 85
parameters_tail      : 99 102
postfix              : 133
program              : 0
repeat_until         : 127
ret_type             : 85
revive               : 85
statements           : 6 85 108 117 119 120 121 122 128 129 130
statements_tail      : 106 109 110 111 112 113 114
string_operation_statement : 113
string_operation_tail : 150
string_val           : 152 160
stringcon_tail       : 152 160
switch_condition     : 121 124
switch_statement     : 110
switchcond_tail      : 122
tail_value           : 23
term                 : 59
term_tail            : 59
type_cast            : 40
typecast_value       : 43 44 45 46
unli_newline         : 1 1 5 7 85
until_loop           : 126
update               : 128
update_tail          : 132
value                : 27 103 122 134 145 146 148 151
var_call             : 61 132 144 150 161
var_call_tail        : 82
var_statement        : 115
var_tail             : 21 24 26
var_tail2            : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (11) global_statement -> . data_type IDENT global_statement_tail
    (163) empty -> .
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    MAIN_CASPER     reduce using rule 163 (empty -> .)
    FUNCTION        reduce using rule 163 (empty -> .)
    FUNCTION_INT    reduce using rule 163 (empty -> .)
    FUNCTION_FLT    reduce using rule 163 (empty -> .)
    FUNCTION_CHR    reduce using rule 163 (empty -> .)
    FUNCTION_BLN    reduce using rule 163 (empty -> .)
    FUNCTION_STR    reduce using rule 163 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 14

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (163) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 163 (empty -> .)
    FUNCTION        reduce using rule 163 (empty -> .)
    FUNCTION_INT    reduce using rule 163 (empty -> .)
    FUNCTION_FLT    reduce using rule 163 (empty -> .)
    FUNCTION_CHR    reduce using rule 163 (empty -> .)
    FUNCTION_BLN    reduce using rule 163 (empty -> .)
    FUNCTION_STR    reduce using rule 163 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 163 (empty -> .)

  ! NEWLINE         [ reduce using rule 163 (empty -> .) ]

    maybe_newline                  shift and go to state 15
    empty                          shift and go to state 16

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 18

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)


state 8

    (11) global_statement -> data_type . IDENT global_statement_tail

    IDENT           shift and go to state 19


state 9

    (34) data_type -> INT .

    IDENT           reduce using rule 34 (data_type -> INT .)


state 10

    (35) data_type -> FLT .

    IDENT           reduce using rule 35 (data_type -> FLT .)


state 11

    (36) data_type -> BLN .

    IDENT           reduce using rule 36 (data_type -> BLN .)


state 12

    (37) data_type -> CHR .

    IDENT           reduce using rule 37 (data_type -> CHR .)


state 13

    (38) data_type -> STR .

    IDENT           reduce using rule 38 (data_type -> STR .)


state 14

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 15

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (85) function_statements -> . maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (86) function_statements -> . empty
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (163) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 163 (empty -> .)
    FUNCTION        reduce using rule 163 (empty -> .)
    FUNCTION_INT    reduce using rule 163 (empty -> .)
    FUNCTION_FLT    reduce using rule 163 (empty -> .)
    FUNCTION_CHR    reduce using rule 163 (empty -> .)
    FUNCTION_BLN    reduce using rule 163 (empty -> .)
    FUNCTION_STR    reduce using rule 163 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 163 (empty -> .)

  ! NEWLINE         [ reduce using rule 163 (empty -> .) ]

    maybe_newline                  shift and go to state 20
    function_statements            shift and go to state 21
    empty                          shift and go to state 22

state 16

    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)


state 17

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (163) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 163 (empty -> .)
    FUNCTION        reduce using rule 163 (empty -> .)
    FUNCTION_INT    reduce using rule 163 (empty -> .)
    FUNCTION_FLT    reduce using rule 163 (empty -> .)
    FUNCTION_CHR    reduce using rule 163 (empty -> .)
    FUNCTION_BLN    reduce using rule 163 (empty -> .)
    FUNCTION_STR    reduce using rule 163 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 163 (empty -> .)
    LBRACE          reduce using rule 163 (empty -> .)
    INT             reduce using rule 163 (empty -> .)
    FLT             reduce using rule 163 (empty -> .)
    BLN             reduce using rule 163 (empty -> .)
    CHR             reduce using rule 163 (empty -> .)
    STR             reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)

  ! NEWLINE         [ reduce using rule 163 (empty -> .) ]

    maybe_newline                  shift and go to state 23
    empty                          shift and go to state 16

state 18

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (10) global_tail -> . empty
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (163) empty -> .
    (11) global_statement -> . data_type IDENT global_statement_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    MAIN_CASPER     reduce using rule 163 (empty -> .)
    FUNCTION        reduce using rule 163 (empty -> .)
    FUNCTION_INT    reduce using rule 163 (empty -> .)
    FUNCTION_FLT    reduce using rule 163 (empty -> .)
    FUNCTION_CHR    reduce using rule 163 (empty -> .)
    FUNCTION_BLN    reduce using rule 163 (empty -> .)
    FUNCTION_STR    reduce using rule 163 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 163 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 163 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 24
    global_dec                     shift and go to state 25
    empty                          shift and go to state 26
    data_type                      shift and go to state 8

state 19

    (11) global_statement -> data_type IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (163) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 163 (empty -> .)

    global_statement_tail          shift and go to state 27
    empty                          shift and go to state 28

state 20

    (85) function_statements -> maybe_newline . ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (87) ret_type -> . FUNCTION
    (88) ret_type -> . function_dtype
    (89) function_dtype -> . FUNCTION_INT
    (90) function_dtype -> . FUNCTION_FLT
    (91) function_dtype -> . FUNCTION_CHR
    (92) function_dtype -> . FUNCTION_BLN
    (93) function_dtype -> . FUNCTION_STR
    (94) function_dtype -> . FUNCTION_LIST_INT
    (95) function_dtype -> . FUNCTION_LIST_FLT
    (96) function_dtype -> . FUNCTION_LIST_CHR
    (97) function_dtype -> . FUNCTION_LIST_STR
    (98) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 32
    FUNCTION_INT    shift and go to state 34
    FUNCTION_FLT    shift and go to state 35
    FUNCTION_CHR    shift and go to state 36
    FUNCTION_BLN    shift and go to state 37
    FUNCTION_STR    shift and go to state 38
    FUNCTION_LIST_INT shift and go to state 39
    FUNCTION_LIST_FLT shift and go to state 40
    FUNCTION_LIST_CHR shift and go to state 41
    FUNCTION_LIST_STR shift and go to state 42
    FUNCTION_LIST_BLN shift and go to state 43

    ret_type                       shift and go to state 31
    function_dtype                 shift and go to state 33

state 21

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (163) empty -> .

    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 163 (empty -> .)

    maybe_newline                  shift and go to state 44
    empty                          shift and go to state 16

state 22

    (86) function_statements -> empty .
    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 86 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 86 (function_statements -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)


state 23

    (3) maybe_newline -> NEWLINE maybe_newline .

    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 24

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 25

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)


state 26

    (10) global_tail -> empty .
    (8) global_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_INT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_FLT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_CHR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_BLN resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_STR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_INT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_FLT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_CHR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_STR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_BLN resolved using rule 8 (global_dec -> empty .)
    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)

  ! NEWLINE         [ reduce using rule 10 (global_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION        [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_INT    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_FLT    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_CHR    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_BLN    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_STR    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_INT [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_FLT [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_CHR [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_STR [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_BLN [ reduce using rule 10 (global_tail -> empty .) ]


state 27

    (11) global_statement -> data_type IDENT global_statement_tail .

    NEWLINE         reduce using rule 11 (global_statement -> data_type IDENT global_statement_tail .)


state 28

    (12) global_statement_tail -> empty .

    NEWLINE         reduce using rule 12 (global_statement_tail -> empty .)


state 29

    (13) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 45


state 30

    (14) global_statement_tail -> EQ . global_dec_value global_tail2
    (17) global_dec_value -> . global_value
    (18) global_dec_value -> . LBRACKET list_element RBRACKET
    (19) global_value -> . factor
    (20) global_value -> . expression
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (58) expression -> . expr_head expr_tail
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail

    LBRACKET        shift and go to state 48
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    global_dec_value               shift and go to state 46
    global_value                   shift and go to state 47
    factor                         shift and go to state 49
    expression                     shift and go to state 50
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    term                           shift and go to state 63

state 31

    (85) function_statements -> maybe_newline ret_type . FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    FUNCTION_NAME   shift and go to state 64


state 32

    (87) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 87 (ret_type -> FUNCTION .)


state 33

    (88) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 88 (ret_type -> function_dtype .)


state 34

    (89) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 89 (function_dtype -> FUNCTION_INT .)


state 35

    (90) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 90 (function_dtype -> FUNCTION_FLT .)


state 36

    (91) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 91 (function_dtype -> FUNCTION_CHR .)


state 37

    (92) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 92 (function_dtype -> FUNCTION_BLN .)


state 38

    (93) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 93 (function_dtype -> FUNCTION_STR .)


state 39

    (94) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 94 (function_dtype -> FUNCTION_LIST_INT .)


state 40

    (95) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 95 (function_dtype -> FUNCTION_LIST_FLT .)


state 41

    (96) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 96 (function_dtype -> FUNCTION_LIST_CHR .)


state 42

    (97) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 97 (function_dtype -> FUNCTION_LIST_STR .)


state 43

    (98) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 98 (function_dtype -> FUNCTION_LIST_BLN .)


state 44

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 66

    main_function                  shift and go to state 65

state 45

    (13) global_statement_tail -> COMMA IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (163) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 163 (empty -> .)

    global_statement_tail          shift and go to state 67
    empty                          shift and go to state 28

state 46

    (14) global_statement_tail -> EQ global_dec_value . global_tail2
    (15) global_tail2 -> . empty
    (16) global_tail2 -> . COMMA IDENT global_statement_tail
    (163) empty -> .

    COMMA           shift and go to state 70
    NEWLINE         reduce using rule 163 (empty -> .)

    global_tail2                   shift and go to state 68
    empty                          shift and go to state 69

state 47

    (17) global_dec_value -> global_value .

    COMMA           reduce using rule 17 (global_dec_value -> global_value .)
    NEWLINE         reduce using rule 17 (global_dec_value -> global_value .)


state 48

    (18) global_dec_value -> LBRACKET . list_element RBRACKET
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 71
    literal                        shift and go to state 72

state 49

    (19) global_value -> factor .
    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (163) empty -> .

  ! reduce/reduce conflict for COMMA resolved using rule 19 (global_value -> factor .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 19 (global_value -> factor .)
    COMMA           reduce using rule 19 (global_value -> factor .)
    NEWLINE         reduce using rule 19 (global_value -> factor .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 163 (empty -> .)
    LT              reduce using rule 163 (empty -> .)
    EQ_EQ           reduce using rule 163 (empty -> .)
    GT_EQ           reduce using rule 163 (empty -> .)
    LT_EQ           reduce using rule 163 (empty -> .)
    NOT_EQ          reduce using rule 163 (empty -> .)
    AND             reduce using rule 163 (empty -> .)
    OR              reduce using rule 163 (empty -> .)

  ! COMMA           [ reduce using rule 163 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 163 (empty -> .) ]

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 50

    (20) global_value -> expression .

    COMMA           reduce using rule 20 (global_value -> expression .)
    NEWLINE         reduce using rule 20 (global_value -> expression .)


state 51

    (61) factor -> var_call .

    PLUS            reduce using rule 61 (factor -> var_call .)
    MINUS           reduce using rule 61 (factor -> var_call .)
    MULTIPLY        reduce using rule 61 (factor -> var_call .)
    DIVISION        reduce using rule 61 (factor -> var_call .)
    MODULO          reduce using rule 61 (factor -> var_call .)
    EXPONENT        reduce using rule 61 (factor -> var_call .)
    COMMA           reduce using rule 61 (factor -> var_call .)
    NEWLINE         reduce using rule 61 (factor -> var_call .)
    GT              reduce using rule 61 (factor -> var_call .)
    LT              reduce using rule 61 (factor -> var_call .)
    EQ_EQ           reduce using rule 61 (factor -> var_call .)
    GT_EQ           reduce using rule 61 (factor -> var_call .)
    LT_EQ           reduce using rule 61 (factor -> var_call .)
    NOT_EQ          reduce using rule 61 (factor -> var_call .)
    AND             reduce using rule 61 (factor -> var_call .)
    OR              reduce using rule 61 (factor -> var_call .)
    RPAREN          reduce using rule 61 (factor -> var_call .)
    RBRACE          reduce using rule 61 (factor -> var_call .)
    COLON           reduce using rule 61 (factor -> var_call .)
    SEMICOLON       reduce using rule 61 (factor -> var_call .)


state 52

    (62) factor -> literal .

    PLUS            reduce using rule 62 (factor -> literal .)
    MINUS           reduce using rule 62 (factor -> literal .)
    MULTIPLY        reduce using rule 62 (factor -> literal .)
    DIVISION        reduce using rule 62 (factor -> literal .)
    MODULO          reduce using rule 62 (factor -> literal .)
    EXPONENT        reduce using rule 62 (factor -> literal .)
    COMMA           reduce using rule 62 (factor -> literal .)
    NEWLINE         reduce using rule 62 (factor -> literal .)
    GT              reduce using rule 62 (factor -> literal .)
    LT              reduce using rule 62 (factor -> literal .)
    EQ_EQ           reduce using rule 62 (factor -> literal .)
    GT_EQ           reduce using rule 62 (factor -> literal .)
    LT_EQ           reduce using rule 62 (factor -> literal .)
    NOT_EQ          reduce using rule 62 (factor -> literal .)
    AND             reduce using rule 62 (factor -> literal .)
    OR              reduce using rule 62 (factor -> literal .)
    RPAREN          reduce using rule 62 (factor -> literal .)
    RBRACE          reduce using rule 62 (factor -> literal .)
    COLON           reduce using rule 62 (factor -> literal .)
    SEMICOLON       reduce using rule 62 (factor -> literal .)


state 53

    (63) factor -> TILDE . literal
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    literal                        shift and go to state 81

state 54

    (64) factor -> LPAREN . expression RPAREN
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 82
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 55

    (58) expression -> expr_head . expr_tail
    (79) expr_tail -> . empty
    (80) expr_tail -> . AND expression
    (81) expr_tail -> . OR expression
    (163) empty -> .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    AND             shift and go to state 86
    OR              shift and go to state 87
    GT              reduce using rule 163 (empty -> .)
    LT              reduce using rule 163 (empty -> .)
    EQ_EQ           reduce using rule 163 (empty -> .)
    GT_EQ           reduce using rule 163 (empty -> .)
    LT_EQ           reduce using rule 163 (empty -> .)
    NOT_EQ          reduce using rule 163 (empty -> .)
    COMMA           reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    RPAREN          reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    COLON           reduce using rule 163 (empty -> .)
    SEMICOLON       reduce using rule 163 (empty -> .)

  ! AND             [ reduce using rule 163 (empty -> .) ]
  ! OR              [ reduce using rule 163 (empty -> .) ]

    expr_tail                      shift and go to state 84
    empty                          shift and go to state 85

state 56

    (82) var_call -> IDENT . var_call_tail
    (83) var_call_tail -> . empty
    (84) var_call_tail -> . LBRACKET index RBRACKET
    (163) empty -> .

    LBRACKET        shift and go to state 90
    PLUS            reduce using rule 163 (empty -> .)
    MINUS           reduce using rule 163 (empty -> .)
    MULTIPLY        reduce using rule 163 (empty -> .)
    DIVISION        reduce using rule 163 (empty -> .)
    MODULO          reduce using rule 163 (empty -> .)
    EXPONENT        reduce using rule 163 (empty -> .)
    COMMA           reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    GT              reduce using rule 163 (empty -> .)
    LT              reduce using rule 163 (empty -> .)
    EQ_EQ           reduce using rule 163 (empty -> .)
    GT_EQ           reduce using rule 163 (empty -> .)
    LT_EQ           reduce using rule 163 (empty -> .)
    NOT_EQ          reduce using rule 163 (empty -> .)
    AND             reduce using rule 163 (empty -> .)
    OR              reduce using rule 163 (empty -> .)
    RPAREN          reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    COLON           reduce using rule 163 (empty -> .)
    SEMICOLON       reduce using rule 163 (empty -> .)
    PLUS_EQ         reduce using rule 163 (empty -> .)
    MINUS_EQ        reduce using rule 163 (empty -> .)
    MUL_EQ          reduce using rule 163 (empty -> .)
    DIV_EQ          reduce using rule 163 (empty -> .)
    MOD_EQ          reduce using rule 163 (empty -> .)
    EQ              reduce using rule 163 (empty -> .)
    PLUS_PLUS       reduce using rule 163 (empty -> .)
    MINUS_MINUS     reduce using rule 163 (empty -> .)

    var_call_tail                  shift and go to state 88
    empty                          shift and go to state 89

state 57

    (52) literal -> INT_LIT .

    PLUS            reduce using rule 52 (literal -> INT_LIT .)
    MINUS           reduce using rule 52 (literal -> INT_LIT .)
    MULTIPLY        reduce using rule 52 (literal -> INT_LIT .)
    DIVISION        reduce using rule 52 (literal -> INT_LIT .)
    MODULO          reduce using rule 52 (literal -> INT_LIT .)
    EXPONENT        reduce using rule 52 (literal -> INT_LIT .)
    COMMA           reduce using rule 52 (literal -> INT_LIT .)
    NEWLINE         reduce using rule 52 (literal -> INT_LIT .)
    GT              reduce using rule 52 (literal -> INT_LIT .)
    LT              reduce using rule 52 (literal -> INT_LIT .)
    EQ_EQ           reduce using rule 52 (literal -> INT_LIT .)
    GT_EQ           reduce using rule 52 (literal -> INT_LIT .)
    LT_EQ           reduce using rule 52 (literal -> INT_LIT .)
    NOT_EQ          reduce using rule 52 (literal -> INT_LIT .)
    AND             reduce using rule 52 (literal -> INT_LIT .)
    OR              reduce using rule 52 (literal -> INT_LIT .)
    RBRACKET        reduce using rule 52 (literal -> INT_LIT .)
    RPAREN          reduce using rule 52 (literal -> INT_LIT .)
    RBRACE          reduce using rule 52 (literal -> INT_LIT .)
    COLON           reduce using rule 52 (literal -> INT_LIT .)
    SEMICOLON       reduce using rule 52 (literal -> INT_LIT .)


state 58

    (53) literal -> FLT_LIT .

    PLUS            reduce using rule 53 (literal -> FLT_LIT .)
    MINUS           reduce using rule 53 (literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 53 (literal -> FLT_LIT .)
    DIVISION        reduce using rule 53 (literal -> FLT_LIT .)
    MODULO          reduce using rule 53 (literal -> FLT_LIT .)
    EXPONENT        reduce using rule 53 (literal -> FLT_LIT .)
    COMMA           reduce using rule 53 (literal -> FLT_LIT .)
    NEWLINE         reduce using rule 53 (literal -> FLT_LIT .)
    GT              reduce using rule 53 (literal -> FLT_LIT .)
    LT              reduce using rule 53 (literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    GT_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    LT_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 53 (literal -> FLT_LIT .)
    AND             reduce using rule 53 (literal -> FLT_LIT .)
    OR              reduce using rule 53 (literal -> FLT_LIT .)
    RBRACKET        reduce using rule 53 (literal -> FLT_LIT .)
    RPAREN          reduce using rule 53 (literal -> FLT_LIT .)
    RBRACE          reduce using rule 53 (literal -> FLT_LIT .)
    COLON           reduce using rule 53 (literal -> FLT_LIT .)
    SEMICOLON       reduce using rule 53 (literal -> FLT_LIT .)


state 59

    (54) literal -> DAY .

    PLUS            reduce using rule 54 (literal -> DAY .)
    MINUS           reduce using rule 54 (literal -> DAY .)
    MULTIPLY        reduce using rule 54 (literal -> DAY .)
    DIVISION        reduce using rule 54 (literal -> DAY .)
    MODULO          reduce using rule 54 (literal -> DAY .)
    EXPONENT        reduce using rule 54 (literal -> DAY .)
    COMMA           reduce using rule 54 (literal -> DAY .)
    NEWLINE         reduce using rule 54 (literal -> DAY .)
    GT              reduce using rule 54 (literal -> DAY .)
    LT              reduce using rule 54 (literal -> DAY .)
    EQ_EQ           reduce using rule 54 (literal -> DAY .)
    GT_EQ           reduce using rule 54 (literal -> DAY .)
    LT_EQ           reduce using rule 54 (literal -> DAY .)
    NOT_EQ          reduce using rule 54 (literal -> DAY .)
    AND             reduce using rule 54 (literal -> DAY .)
    OR              reduce using rule 54 (literal -> DAY .)
    RBRACKET        reduce using rule 54 (literal -> DAY .)
    RPAREN          reduce using rule 54 (literal -> DAY .)
    RBRACE          reduce using rule 54 (literal -> DAY .)
    COLON           reduce using rule 54 (literal -> DAY .)
    SEMICOLON       reduce using rule 54 (literal -> DAY .)


state 60

    (55) literal -> NIGHT .

    PLUS            reduce using rule 55 (literal -> NIGHT .)
    MINUS           reduce using rule 55 (literal -> NIGHT .)
    MULTIPLY        reduce using rule 55 (literal -> NIGHT .)
    DIVISION        reduce using rule 55 (literal -> NIGHT .)
    MODULO          reduce using rule 55 (literal -> NIGHT .)
    EXPONENT        reduce using rule 55 (literal -> NIGHT .)
    COMMA           reduce using rule 55 (literal -> NIGHT .)
    NEWLINE         reduce using rule 55 (literal -> NIGHT .)
    GT              reduce using rule 55 (literal -> NIGHT .)
    LT              reduce using rule 55 (literal -> NIGHT .)
    EQ_EQ           reduce using rule 55 (literal -> NIGHT .)
    GT_EQ           reduce using rule 55 (literal -> NIGHT .)
    LT_EQ           reduce using rule 55 (literal -> NIGHT .)
    NOT_EQ          reduce using rule 55 (literal -> NIGHT .)
    AND             reduce using rule 55 (literal -> NIGHT .)
    OR              reduce using rule 55 (literal -> NIGHT .)
    RBRACKET        reduce using rule 55 (literal -> NIGHT .)
    RPAREN          reduce using rule 55 (literal -> NIGHT .)
    RBRACE          reduce using rule 55 (literal -> NIGHT .)
    COLON           reduce using rule 55 (literal -> NIGHT .)
    SEMICOLON       reduce using rule 55 (literal -> NIGHT .)


state 61

    (56) literal -> CHR_LIT .

    PLUS            reduce using rule 56 (literal -> CHR_LIT .)
    MINUS           reduce using rule 56 (literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 56 (literal -> CHR_LIT .)
    DIVISION        reduce using rule 56 (literal -> CHR_LIT .)
    MODULO          reduce using rule 56 (literal -> CHR_LIT .)
    EXPONENT        reduce using rule 56 (literal -> CHR_LIT .)
    COMMA           reduce using rule 56 (literal -> CHR_LIT .)
    NEWLINE         reduce using rule 56 (literal -> CHR_LIT .)
    GT              reduce using rule 56 (literal -> CHR_LIT .)
    LT              reduce using rule 56 (literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    GT_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    LT_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 56 (literal -> CHR_LIT .)
    AND             reduce using rule 56 (literal -> CHR_LIT .)
    OR              reduce using rule 56 (literal -> CHR_LIT .)
    RBRACKET        reduce using rule 56 (literal -> CHR_LIT .)
    RPAREN          reduce using rule 56 (literal -> CHR_LIT .)
    RBRACE          reduce using rule 56 (literal -> CHR_LIT .)
    COLON           reduce using rule 56 (literal -> CHR_LIT .)
    SEMICOLON       reduce using rule 56 (literal -> CHR_LIT .)


state 62

    (57) literal -> STR_LIT .

    PLUS            reduce using rule 57 (literal -> STR_LIT .)
    MINUS           reduce using rule 57 (literal -> STR_LIT .)
    MULTIPLY        reduce using rule 57 (literal -> STR_LIT .)
    DIVISION        reduce using rule 57 (literal -> STR_LIT .)
    MODULO          reduce using rule 57 (literal -> STR_LIT .)
    EXPONENT        reduce using rule 57 (literal -> STR_LIT .)
    COMMA           reduce using rule 57 (literal -> STR_LIT .)
    NEWLINE         reduce using rule 57 (literal -> STR_LIT .)
    GT              reduce using rule 57 (literal -> STR_LIT .)
    LT              reduce using rule 57 (literal -> STR_LIT .)
    EQ_EQ           reduce using rule 57 (literal -> STR_LIT .)
    GT_EQ           reduce using rule 57 (literal -> STR_LIT .)
    LT_EQ           reduce using rule 57 (literal -> STR_LIT .)
    NOT_EQ          reduce using rule 57 (literal -> STR_LIT .)
    AND             reduce using rule 57 (literal -> STR_LIT .)
    OR              reduce using rule 57 (literal -> STR_LIT .)
    RBRACKET        reduce using rule 57 (literal -> STR_LIT .)
    RPAREN          reduce using rule 57 (literal -> STR_LIT .)
    RBRACE          reduce using rule 57 (literal -> STR_LIT .)
    COLON           reduce using rule 57 (literal -> STR_LIT .)
    SEMICOLON       reduce using rule 57 (literal -> STR_LIT .)


state 63

    (59) expr_head -> term . term_tail
    (72) term_tail -> . empty
    (73) term_tail -> . GT expression
    (74) term_tail -> . LT expression
    (75) term_tail -> . EQ_EQ expression
    (76) term_tail -> . GT_EQ expression
    (77) term_tail -> . LT_EQ expression
    (78) term_tail -> . NOT_EQ expression
    (163) empty -> .

  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ_EQ resolved as shift
  ! shift/reduce conflict for GT_EQ resolved as shift
  ! shift/reduce conflict for LT_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
    GT              shift and go to state 93
    LT              shift and go to state 94
    EQ_EQ           shift and go to state 95
    GT_EQ           shift and go to state 96
    LT_EQ           shift and go to state 97
    NOT_EQ          shift and go to state 98
    AND             reduce using rule 163 (empty -> .)
    OR              reduce using rule 163 (empty -> .)
    COMMA           reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    RPAREN          reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    COLON           reduce using rule 163 (empty -> .)
    SEMICOLON       reduce using rule 163 (empty -> .)

  ! GT              [ reduce using rule 163 (empty -> .) ]
  ! LT              [ reduce using rule 163 (empty -> .) ]
  ! EQ_EQ           [ reduce using rule 163 (empty -> .) ]
  ! GT_EQ           [ reduce using rule 163 (empty -> .) ]
  ! LT_EQ           [ reduce using rule 163 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 163 (empty -> .) ]

    term_tail                      shift and go to state 91
    empty                          shift and go to state 92

state 64

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME . LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    LPAREN          shift and go to state 99


state 65

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 100

state 66

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 101


state 67

    (13) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 13 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 68

    (14) global_statement_tail -> EQ global_dec_value global_tail2 .

    NEWLINE         reduce using rule 14 (global_statement_tail -> EQ global_dec_value global_tail2 .)


state 69

    (15) global_tail2 -> empty .

    NEWLINE         reduce using rule 15 (global_tail2 -> empty .)


state 70

    (16) global_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 102


state 71

    (18) global_dec_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 103


state 72

    (29) list_element -> literal . element_tail
    (30) element_tail -> . empty
    (31) element_tail -> . COMMA list_element
    (163) empty -> .

    COMMA           shift and go to state 106
    RBRACKET        reduce using rule 163 (empty -> .)

    element_tail                   shift and go to state 104
    empty                          shift and go to state 105

state 73

    (60) term -> factor factor_tail .

    GT              reduce using rule 60 (term -> factor factor_tail .)
    LT              reduce using rule 60 (term -> factor factor_tail .)
    EQ_EQ           reduce using rule 60 (term -> factor factor_tail .)
    GT_EQ           reduce using rule 60 (term -> factor factor_tail .)
    LT_EQ           reduce using rule 60 (term -> factor factor_tail .)
    NOT_EQ          reduce using rule 60 (term -> factor factor_tail .)
    AND             reduce using rule 60 (term -> factor factor_tail .)
    OR              reduce using rule 60 (term -> factor factor_tail .)
    COMMA           reduce using rule 60 (term -> factor factor_tail .)
    NEWLINE         reduce using rule 60 (term -> factor factor_tail .)
    RPAREN          reduce using rule 60 (term -> factor factor_tail .)
    RBRACE          reduce using rule 60 (term -> factor factor_tail .)
    COLON           reduce using rule 60 (term -> factor factor_tail .)
    SEMICOLON       reduce using rule 60 (term -> factor factor_tail .)


state 74

    (65) factor_tail -> empty .

    GT              reduce using rule 65 (factor_tail -> empty .)
    LT              reduce using rule 65 (factor_tail -> empty .)
    EQ_EQ           reduce using rule 65 (factor_tail -> empty .)
    GT_EQ           reduce using rule 65 (factor_tail -> empty .)
    LT_EQ           reduce using rule 65 (factor_tail -> empty .)
    NOT_EQ          reduce using rule 65 (factor_tail -> empty .)
    AND             reduce using rule 65 (factor_tail -> empty .)
    OR              reduce using rule 65 (factor_tail -> empty .)
    COMMA           reduce using rule 65 (factor_tail -> empty .)
    NEWLINE         reduce using rule 65 (factor_tail -> empty .)
    RPAREN          reduce using rule 65 (factor_tail -> empty .)
    RBRACE          reduce using rule 65 (factor_tail -> empty .)
    COLON           reduce using rule 65 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 65 (factor_tail -> empty .)


state 75

    (66) factor_tail -> PLUS . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 107
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 76

    (67) factor_tail -> MINUS . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 108
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 77

    (68) factor_tail -> MULTIPLY . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 109
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 78

    (69) factor_tail -> DIVISION . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 110
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 79

    (70) factor_tail -> MODULO . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 111
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 80

    (71) factor_tail -> EXPONENT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 112
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 81

    (63) factor -> TILDE literal .

    PLUS            reduce using rule 63 (factor -> TILDE literal .)
    MINUS           reduce using rule 63 (factor -> TILDE literal .)
    MULTIPLY        reduce using rule 63 (factor -> TILDE literal .)
    DIVISION        reduce using rule 63 (factor -> TILDE literal .)
    MODULO          reduce using rule 63 (factor -> TILDE literal .)
    EXPONENT        reduce using rule 63 (factor -> TILDE literal .)
    COMMA           reduce using rule 63 (factor -> TILDE literal .)
    NEWLINE         reduce using rule 63 (factor -> TILDE literal .)
    GT              reduce using rule 63 (factor -> TILDE literal .)
    LT              reduce using rule 63 (factor -> TILDE literal .)
    EQ_EQ           reduce using rule 63 (factor -> TILDE literal .)
    GT_EQ           reduce using rule 63 (factor -> TILDE literal .)
    LT_EQ           reduce using rule 63 (factor -> TILDE literal .)
    NOT_EQ          reduce using rule 63 (factor -> TILDE literal .)
    AND             reduce using rule 63 (factor -> TILDE literal .)
    OR              reduce using rule 63 (factor -> TILDE literal .)
    RPAREN          reduce using rule 63 (factor -> TILDE literal .)
    RBRACE          reduce using rule 63 (factor -> TILDE literal .)
    COLON           reduce using rule 63 (factor -> TILDE literal .)
    SEMICOLON       reduce using rule 63 (factor -> TILDE literal .)


state 82

    (64) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 113


state 83

    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (163) empty -> .

    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 163 (empty -> .)
    LT              reduce using rule 163 (empty -> .)
    EQ_EQ           reduce using rule 163 (empty -> .)
    GT_EQ           reduce using rule 163 (empty -> .)
    LT_EQ           reduce using rule 163 (empty -> .)
    NOT_EQ          reduce using rule 163 (empty -> .)
    AND             reduce using rule 163 (empty -> .)
    OR              reduce using rule 163 (empty -> .)
    COMMA           reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    RPAREN          reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    COLON           reduce using rule 163 (empty -> .)
    SEMICOLON       reduce using rule 163 (empty -> .)

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 84

    (58) expression -> expr_head expr_tail .

    COMMA           reduce using rule 58 (expression -> expr_head expr_tail .)
    NEWLINE         reduce using rule 58 (expression -> expr_head expr_tail .)
    RPAREN          reduce using rule 58 (expression -> expr_head expr_tail .)
    GT              reduce using rule 58 (expression -> expr_head expr_tail .)
    LT              reduce using rule 58 (expression -> expr_head expr_tail .)
    EQ_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    GT_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    LT_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    NOT_EQ          reduce using rule 58 (expression -> expr_head expr_tail .)
    AND             reduce using rule 58 (expression -> expr_head expr_tail .)
    OR              reduce using rule 58 (expression -> expr_head expr_tail .)
    RBRACE          reduce using rule 58 (expression -> expr_head expr_tail .)
    COLON           reduce using rule 58 (expression -> expr_head expr_tail .)
    SEMICOLON       reduce using rule 58 (expression -> expr_head expr_tail .)


state 85

    (79) expr_tail -> empty .

    GT              reduce using rule 79 (expr_tail -> empty .)
    LT              reduce using rule 79 (expr_tail -> empty .)
    EQ_EQ           reduce using rule 79 (expr_tail -> empty .)
    GT_EQ           reduce using rule 79 (expr_tail -> empty .)
    LT_EQ           reduce using rule 79 (expr_tail -> empty .)
    NOT_EQ          reduce using rule 79 (expr_tail -> empty .)
    AND             reduce using rule 79 (expr_tail -> empty .)
    OR              reduce using rule 79 (expr_tail -> empty .)
    COMMA           reduce using rule 79 (expr_tail -> empty .)
    NEWLINE         reduce using rule 79 (expr_tail -> empty .)
    RPAREN          reduce using rule 79 (expr_tail -> empty .)
    RBRACE          reduce using rule 79 (expr_tail -> empty .)
    COLON           reduce using rule 79 (expr_tail -> empty .)
    SEMICOLON       reduce using rule 79 (expr_tail -> empty .)


state 86

    (80) expr_tail -> AND . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 114
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 87

    (81) expr_tail -> OR . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 115
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 88

    (82) var_call -> IDENT var_call_tail .

    PLUS            reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MULTIPLY        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    DIVISION        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MODULO          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EXPONENT        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    COMMA           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    NEWLINE         reduce using rule 82 (var_call -> IDENT var_call_tail .)
    GT              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    LT              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EQ_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    GT_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    LT_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    NOT_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    AND             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    OR              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    RPAREN          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    RBRACE          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    COLON           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    SEMICOLON       reduce using rule 82 (var_call -> IDENT var_call_tail .)
    PLUS_EQ         reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS_EQ        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MUL_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    DIV_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MOD_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EQ              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    PLUS_PLUS       reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS_MINUS     reduce using rule 82 (var_call -> IDENT var_call_tail .)


state 89

    (83) var_call_tail -> empty .

    PLUS            reduce using rule 83 (var_call_tail -> empty .)
    MINUS           reduce using rule 83 (var_call_tail -> empty .)
    MULTIPLY        reduce using rule 83 (var_call_tail -> empty .)
    DIVISION        reduce using rule 83 (var_call_tail -> empty .)
    MODULO          reduce using rule 83 (var_call_tail -> empty .)
    EXPONENT        reduce using rule 83 (var_call_tail -> empty .)
    COMMA           reduce using rule 83 (var_call_tail -> empty .)
    NEWLINE         reduce using rule 83 (var_call_tail -> empty .)
    GT              reduce using rule 83 (var_call_tail -> empty .)
    LT              reduce using rule 83 (var_call_tail -> empty .)
    EQ_EQ           reduce using rule 83 (var_call_tail -> empty .)
    GT_EQ           reduce using rule 83 (var_call_tail -> empty .)
    LT_EQ           reduce using rule 83 (var_call_tail -> empty .)
    NOT_EQ          reduce using rule 83 (var_call_tail -> empty .)
    AND             reduce using rule 83 (var_call_tail -> empty .)
    OR              reduce using rule 83 (var_call_tail -> empty .)
    RPAREN          reduce using rule 83 (var_call_tail -> empty .)
    RBRACE          reduce using rule 83 (var_call_tail -> empty .)
    COLON           reduce using rule 83 (var_call_tail -> empty .)
    SEMICOLON       reduce using rule 83 (var_call_tail -> empty .)
    PLUS_EQ         reduce using rule 83 (var_call_tail -> empty .)
    MINUS_EQ        reduce using rule 83 (var_call_tail -> empty .)
    MUL_EQ          reduce using rule 83 (var_call_tail -> empty .)
    DIV_EQ          reduce using rule 83 (var_call_tail -> empty .)
    MOD_EQ          reduce using rule 83 (var_call_tail -> empty .)
    EQ              reduce using rule 83 (var_call_tail -> empty .)
    PLUS_PLUS       reduce using rule 83 (var_call_tail -> empty .)
    MINUS_MINUS     reduce using rule 83 (var_call_tail -> empty .)


state 90

    (84) var_call_tail -> LBRACKET . index RBRACKET
    (32) index -> . INT_LIT
    (33) index -> . IDENT

    INT_LIT         shift and go to state 117
    IDENT           shift and go to state 118

    index                          shift and go to state 116

state 91

    (59) expr_head -> term term_tail .

    AND             reduce using rule 59 (expr_head -> term term_tail .)
    OR              reduce using rule 59 (expr_head -> term term_tail .)
    COMMA           reduce using rule 59 (expr_head -> term term_tail .)
    NEWLINE         reduce using rule 59 (expr_head -> term term_tail .)
    RPAREN          reduce using rule 59 (expr_head -> term term_tail .)
    GT              reduce using rule 59 (expr_head -> term term_tail .)
    LT              reduce using rule 59 (expr_head -> term term_tail .)
    EQ_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    GT_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    LT_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    NOT_EQ          reduce using rule 59 (expr_head -> term term_tail .)
    RBRACE          reduce using rule 59 (expr_head -> term term_tail .)
    COLON           reduce using rule 59 (expr_head -> term term_tail .)
    SEMICOLON       reduce using rule 59 (expr_head -> term term_tail .)


state 92

    (72) term_tail -> empty .

    GT              reduce using rule 72 (term_tail -> empty .)
    LT              reduce using rule 72 (term_tail -> empty .)
    EQ_EQ           reduce using rule 72 (term_tail -> empty .)
    GT_EQ           reduce using rule 72 (term_tail -> empty .)
    LT_EQ           reduce using rule 72 (term_tail -> empty .)
    NOT_EQ          reduce using rule 72 (term_tail -> empty .)
    AND             reduce using rule 72 (term_tail -> empty .)
    OR              reduce using rule 72 (term_tail -> empty .)
    COMMA           reduce using rule 72 (term_tail -> empty .)
    NEWLINE         reduce using rule 72 (term_tail -> empty .)
    RPAREN          reduce using rule 72 (term_tail -> empty .)
    RBRACE          reduce using rule 72 (term_tail -> empty .)
    COLON           reduce using rule 72 (term_tail -> empty .)
    SEMICOLON       reduce using rule 72 (term_tail -> empty .)


state 93

    (73) term_tail -> GT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 119
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 94

    (74) term_tail -> LT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 120
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 95

    (75) term_tail -> EQ_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 121
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 96

    (76) term_tail -> GT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 122
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 97

    (77) term_tail -> LT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 123
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 98

    (78) term_tail -> NOT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 124
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 99

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN . parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (99) parameters -> . data_type IDENT parameters_tail
    (100) parameters -> . empty
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR
    (163) empty -> .

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13
    RPAREN          reduce using rule 163 (empty -> .)

    parameters                     shift and go to state 125
    data_type                      shift and go to state 126
    empty                          shift and go to state 127

state 100

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 128


state 101

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 129


state 102

    (16) global_tail2 -> COMMA IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (163) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 163 (empty -> .)

    global_statement_tail          shift and go to state 130
    empty                          shift and go to state 28

state 103

    (18) global_dec_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 18 (global_dec_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 18 (global_dec_value -> LBRACKET list_element RBRACKET .)


state 104

    (29) list_element -> literal element_tail .

    RBRACKET        reduce using rule 29 (list_element -> literal element_tail .)


state 105

    (30) element_tail -> empty .

    RBRACKET        reduce using rule 30 (element_tail -> empty .)


state 106

    (31) element_tail -> COMMA . list_element
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 131
    literal                        shift and go to state 72

state 107

    (66) factor_tail -> PLUS expression .

    GT              reduce using rule 66 (factor_tail -> PLUS expression .)
    LT              reduce using rule 66 (factor_tail -> PLUS expression .)
    EQ_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    GT_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    LT_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    NOT_EQ          reduce using rule 66 (factor_tail -> PLUS expression .)
    AND             reduce using rule 66 (factor_tail -> PLUS expression .)
    OR              reduce using rule 66 (factor_tail -> PLUS expression .)
    COMMA           reduce using rule 66 (factor_tail -> PLUS expression .)
    NEWLINE         reduce using rule 66 (factor_tail -> PLUS expression .)
    RPAREN          reduce using rule 66 (factor_tail -> PLUS expression .)
    RBRACE          reduce using rule 66 (factor_tail -> PLUS expression .)
    COLON           reduce using rule 66 (factor_tail -> PLUS expression .)
    SEMICOLON       reduce using rule 66 (factor_tail -> PLUS expression .)


state 108

    (67) factor_tail -> MINUS expression .

    GT              reduce using rule 67 (factor_tail -> MINUS expression .)
    LT              reduce using rule 67 (factor_tail -> MINUS expression .)
    EQ_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    GT_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    LT_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    NOT_EQ          reduce using rule 67 (factor_tail -> MINUS expression .)
    AND             reduce using rule 67 (factor_tail -> MINUS expression .)
    OR              reduce using rule 67 (factor_tail -> MINUS expression .)
    COMMA           reduce using rule 67 (factor_tail -> MINUS expression .)
    NEWLINE         reduce using rule 67 (factor_tail -> MINUS expression .)
    RPAREN          reduce using rule 67 (factor_tail -> MINUS expression .)
    RBRACE          reduce using rule 67 (factor_tail -> MINUS expression .)
    COLON           reduce using rule 67 (factor_tail -> MINUS expression .)
    SEMICOLON       reduce using rule 67 (factor_tail -> MINUS expression .)


state 109

    (68) factor_tail -> MULTIPLY expression .

    GT              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    LT              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    EQ_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    GT_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    LT_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    NOT_EQ          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    AND             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    OR              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    COMMA           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    NEWLINE         reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    RPAREN          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    RBRACE          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    COLON           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    SEMICOLON       reduce using rule 68 (factor_tail -> MULTIPLY expression .)


state 110

    (69) factor_tail -> DIVISION expression .

    GT              reduce using rule 69 (factor_tail -> DIVISION expression .)
    LT              reduce using rule 69 (factor_tail -> DIVISION expression .)
    EQ_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    GT_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    LT_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    NOT_EQ          reduce using rule 69 (factor_tail -> DIVISION expression .)
    AND             reduce using rule 69 (factor_tail -> DIVISION expression .)
    OR              reduce using rule 69 (factor_tail -> DIVISION expression .)
    COMMA           reduce using rule 69 (factor_tail -> DIVISION expression .)
    NEWLINE         reduce using rule 69 (factor_tail -> DIVISION expression .)
    RPAREN          reduce using rule 69 (factor_tail -> DIVISION expression .)
    RBRACE          reduce using rule 69 (factor_tail -> DIVISION expression .)
    COLON           reduce using rule 69 (factor_tail -> DIVISION expression .)
    SEMICOLON       reduce using rule 69 (factor_tail -> DIVISION expression .)


state 111

    (70) factor_tail -> MODULO expression .

    GT              reduce using rule 70 (factor_tail -> MODULO expression .)
    LT              reduce using rule 70 (factor_tail -> MODULO expression .)
    EQ_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    GT_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    LT_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    NOT_EQ          reduce using rule 70 (factor_tail -> MODULO expression .)
    AND             reduce using rule 70 (factor_tail -> MODULO expression .)
    OR              reduce using rule 70 (factor_tail -> MODULO expression .)
    COMMA           reduce using rule 70 (factor_tail -> MODULO expression .)
    NEWLINE         reduce using rule 70 (factor_tail -> MODULO expression .)
    RPAREN          reduce using rule 70 (factor_tail -> MODULO expression .)
    RBRACE          reduce using rule 70 (factor_tail -> MODULO expression .)
    COLON           reduce using rule 70 (factor_tail -> MODULO expression .)
    SEMICOLON       reduce using rule 70 (factor_tail -> MODULO expression .)


state 112

    (71) factor_tail -> EXPONENT expression .

    GT              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    LT              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    EQ_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    GT_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    LT_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    NOT_EQ          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    AND             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    OR              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    COMMA           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    NEWLINE         reduce using rule 71 (factor_tail -> EXPONENT expression .)
    RPAREN          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    RBRACE          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    COLON           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    SEMICOLON       reduce using rule 71 (factor_tail -> EXPONENT expression .)


state 113

    (64) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 64 (factor -> LPAREN expression RPAREN .)


state 114

    (80) expr_tail -> AND expression .

    GT              reduce using rule 80 (expr_tail -> AND expression .)
    LT              reduce using rule 80 (expr_tail -> AND expression .)
    EQ_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    GT_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    LT_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    NOT_EQ          reduce using rule 80 (expr_tail -> AND expression .)
    AND             reduce using rule 80 (expr_tail -> AND expression .)
    OR              reduce using rule 80 (expr_tail -> AND expression .)
    COMMA           reduce using rule 80 (expr_tail -> AND expression .)
    NEWLINE         reduce using rule 80 (expr_tail -> AND expression .)
    RPAREN          reduce using rule 80 (expr_tail -> AND expression .)
    RBRACE          reduce using rule 80 (expr_tail -> AND expression .)
    COLON           reduce using rule 80 (expr_tail -> AND expression .)
    SEMICOLON       reduce using rule 80 (expr_tail -> AND expression .)


state 115

    (81) expr_tail -> OR expression .

    GT              reduce using rule 81 (expr_tail -> OR expression .)
    LT              reduce using rule 81 (expr_tail -> OR expression .)
    EQ_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    GT_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    LT_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    NOT_EQ          reduce using rule 81 (expr_tail -> OR expression .)
    AND             reduce using rule 81 (expr_tail -> OR expression .)
    OR              reduce using rule 81 (expr_tail -> OR expression .)
    COMMA           reduce using rule 81 (expr_tail -> OR expression .)
    NEWLINE         reduce using rule 81 (expr_tail -> OR expression .)
    RPAREN          reduce using rule 81 (expr_tail -> OR expression .)
    RBRACE          reduce using rule 81 (expr_tail -> OR expression .)
    COLON           reduce using rule 81 (expr_tail -> OR expression .)
    SEMICOLON       reduce using rule 81 (expr_tail -> OR expression .)


state 116

    (84) var_call_tail -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 132


state 117

    (32) index -> INT_LIT .

    RBRACKET        reduce using rule 32 (index -> INT_LIT .)


state 118

    (33) index -> IDENT .

    RBRACKET        reduce using rule 33 (index -> IDENT .)


state 119

    (73) term_tail -> GT expression .

    GT              reduce using rule 73 (term_tail -> GT expression .)
    LT              reduce using rule 73 (term_tail -> GT expression .)
    EQ_EQ           reduce using rule 73 (term_tail -> GT expression .)
    GT_EQ           reduce using rule 73 (term_tail -> GT expression .)
    LT_EQ           reduce using rule 73 (term_tail -> GT expression .)
    NOT_EQ          reduce using rule 73 (term_tail -> GT expression .)
    AND             reduce using rule 73 (term_tail -> GT expression .)
    OR              reduce using rule 73 (term_tail -> GT expression .)
    COMMA           reduce using rule 73 (term_tail -> GT expression .)
    NEWLINE         reduce using rule 73 (term_tail -> GT expression .)
    RPAREN          reduce using rule 73 (term_tail -> GT expression .)
    RBRACE          reduce using rule 73 (term_tail -> GT expression .)
    COLON           reduce using rule 73 (term_tail -> GT expression .)
    SEMICOLON       reduce using rule 73 (term_tail -> GT expression .)


state 120

    (74) term_tail -> LT expression .

    GT              reduce using rule 74 (term_tail -> LT expression .)
    LT              reduce using rule 74 (term_tail -> LT expression .)
    EQ_EQ           reduce using rule 74 (term_tail -> LT expression .)
    GT_EQ           reduce using rule 74 (term_tail -> LT expression .)
    LT_EQ           reduce using rule 74 (term_tail -> LT expression .)
    NOT_EQ          reduce using rule 74 (term_tail -> LT expression .)
    AND             reduce using rule 74 (term_tail -> LT expression .)
    OR              reduce using rule 74 (term_tail -> LT expression .)
    COMMA           reduce using rule 74 (term_tail -> LT expression .)
    NEWLINE         reduce using rule 74 (term_tail -> LT expression .)
    RPAREN          reduce using rule 74 (term_tail -> LT expression .)
    RBRACE          reduce using rule 74 (term_tail -> LT expression .)
    COLON           reduce using rule 74 (term_tail -> LT expression .)
    SEMICOLON       reduce using rule 74 (term_tail -> LT expression .)


state 121

    (75) term_tail -> EQ_EQ expression .

    GT              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    LT              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    EQ_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    GT_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    LT_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    NOT_EQ          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    AND             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    OR              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    COMMA           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    NEWLINE         reduce using rule 75 (term_tail -> EQ_EQ expression .)
    RPAREN          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    RBRACE          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    COLON           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    SEMICOLON       reduce using rule 75 (term_tail -> EQ_EQ expression .)


state 122

    (76) term_tail -> GT_EQ expression .

    GT              reduce using rule 76 (term_tail -> GT_EQ expression .)
    LT              reduce using rule 76 (term_tail -> GT_EQ expression .)
    EQ_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    GT_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    LT_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    NOT_EQ          reduce using rule 76 (term_tail -> GT_EQ expression .)
    AND             reduce using rule 76 (term_tail -> GT_EQ expression .)
    OR              reduce using rule 76 (term_tail -> GT_EQ expression .)
    COMMA           reduce using rule 76 (term_tail -> GT_EQ expression .)
    NEWLINE         reduce using rule 76 (term_tail -> GT_EQ expression .)
    RPAREN          reduce using rule 76 (term_tail -> GT_EQ expression .)
    RBRACE          reduce using rule 76 (term_tail -> GT_EQ expression .)
    COLON           reduce using rule 76 (term_tail -> GT_EQ expression .)
    SEMICOLON       reduce using rule 76 (term_tail -> GT_EQ expression .)


state 123

    (77) term_tail -> LT_EQ expression .

    GT              reduce using rule 77 (term_tail -> LT_EQ expression .)
    LT              reduce using rule 77 (term_tail -> LT_EQ expression .)
    EQ_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    GT_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    LT_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    NOT_EQ          reduce using rule 77 (term_tail -> LT_EQ expression .)
    AND             reduce using rule 77 (term_tail -> LT_EQ expression .)
    OR              reduce using rule 77 (term_tail -> LT_EQ expression .)
    COMMA           reduce using rule 77 (term_tail -> LT_EQ expression .)
    NEWLINE         reduce using rule 77 (term_tail -> LT_EQ expression .)
    RPAREN          reduce using rule 77 (term_tail -> LT_EQ expression .)
    RBRACE          reduce using rule 77 (term_tail -> LT_EQ expression .)
    COLON           reduce using rule 77 (term_tail -> LT_EQ expression .)
    SEMICOLON       reduce using rule 77 (term_tail -> LT_EQ expression .)


state 124

    (78) term_tail -> NOT_EQ expression .

    GT              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    LT              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    EQ_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    GT_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    LT_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    NOT_EQ          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    AND             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    OR              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    COMMA           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    NEWLINE         reduce using rule 78 (term_tail -> NOT_EQ expression .)
    RPAREN          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    RBRACE          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    COLON           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    SEMICOLON       reduce using rule 78 (term_tail -> NOT_EQ expression .)


state 125

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters . RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    RPAREN          shift and go to state 133


state 126

    (99) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 134


state 127

    (100) parameters -> empty .

    RPAREN          reduce using rule 100 (parameters -> empty .)


state 128

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 129

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 135


state 130

    (16) global_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 16 (global_tail2 -> COMMA IDENT global_statement_tail .)


state 131

    (31) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 31 (element_tail -> COMMA list_element .)


state 132

    (84) var_call_tail -> LBRACKET index RBRACKET .

    PLUS            reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    GT              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    LT              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    AND             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    OR              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_PLUS       reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)


state 133

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN . maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (163) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 163 (empty -> .)

    maybe_newline                  shift and go to state 136
    empty                          shift and go to state 16

state 134

    (99) parameters -> data_type IDENT . parameters_tail
    (101) parameters_tail -> . empty
    (102) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (163) empty -> .

    COMMA           shift and go to state 139
    RPAREN          reduce using rule 163 (empty -> .)

    parameters_tail                shift and go to state 137
    empty                          shift and go to state 138

state 135

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (163) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 163 (empty -> .)
    FLT             reduce using rule 163 (empty -> .)
    BLN             reduce using rule 163 (empty -> .)
    CHR             reduce using rule 163 (empty -> .)
    STR             reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)

  ! NEWLINE         [ reduce using rule 163 (empty -> .) ]

    maybe_newline                  shift and go to state 140
    empty                          shift and go to state 16

state 136

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline . LBRACE unli_newline statements revive maybe_newline RBRACE

    LBRACE          shift and go to state 141


state 137

    (99) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 99 (parameters -> data_type IDENT parameters_tail .)


state 138

    (101) parameters_tail -> empty .

    RPAREN          reduce using rule 101 (parameters_tail -> empty .)


state 139

    (102) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    data_type                      shift and go to state 142

state 140

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline . statements maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 143
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 141

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE . unli_newline statements revive maybe_newline RBRACE
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 148

state 142

    (102) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 149


state 143

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (163) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 163 (empty -> .)

    maybe_newline                  shift and go to state 150
    empty                          shift and go to state 16

state 144

    (105) statements -> empty .
    (116) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 105 (statements -> empty .)
    NEWLINE         reduce using rule 105 (statements -> empty .)
    RBRACE          reduce using rule 105 (statements -> empty .)
    REVIVE          reduce using rule 105 (statements -> empty .)
    SHIFT           reduce using rule 105 (statements -> empty .)
    OTHERWISE       reduce using rule 105 (statements -> empty .)

  ! NEWLINE         [ reduce using rule 116 (local_dec -> empty .) ]


state 145

    (106) statements -> local_dec . NEWLINE statements_tail

    NEWLINE         shift and go to state 151


state 146

    (115) local_dec -> var_statement .

    NEWLINE         reduce using rule 115 (local_dec -> var_statement .)


state 147

    (21) var_statement -> data_type . IDENT var_tail

    IDENT           shift and go to state 152


state 148

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline . statements revive maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    REVIVE          reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 153
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 149

    (102) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (101) parameters_tail -> . empty
    (102) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (163) empty -> .

    COMMA           shift and go to state 139
    RPAREN          reduce using rule 163 (empty -> .)

    parameters_tail                shift and go to state 154
    empty                          shift and go to state 138

state 150

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 155


state 151

    (106) statements -> local_dec NEWLINE . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . statements
    (109) statements_tail -> . conditional_statement NEWLINE statements_tail
    (110) statements_tail -> . switch_statement NEWLINE statements_tail
    (111) statements_tail -> . loop_statement NEWLINE statements_tail
    (112) statements_tail -> . function_call NEWLINE statements_tail
    (113) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (114) statements_tail -> . output_statement NEWLINE statements_tail
    (163) empty -> .
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (82) var_call -> . IDENT var_call_tail
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    REVIVE          reduce using rule 163 (empty -> .)
    SHIFT           reduce using rule 163 (empty -> .)
    OTHERWISE       reduce using rule 163 (empty -> .)
    CHECK           shift and go to state 165
    SWAP            shift and go to state 166
    FUNCTION_NAME   shift and go to state 170
    DISPLAY         shift and go to state 173
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    IDENT           shift and go to state 56
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    local_dec                      shift and go to state 145
    statements_tail                shift and go to state 156
    empty                          shift and go to state 157
    statements                     shift and go to state 158
    conditional_statement          shift and go to state 159
    switch_statement               shift and go to state 160
    loop_statement                 shift and go to state 161
    function_call                  shift and go to state 162
    string_operation_statement     shift and go to state 163
    output_statement               shift and go to state 164
    for_loop                       shift and go to state 167
    until_loop                     shift and go to state 168
    repeat_until                   shift and go to state 169
    input_statement                shift and go to state 171
    var_call                       shift and go to state 172
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 152

    (21) var_statement -> data_type IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (163) empty -> .

    EQ              shift and go to state 180
    COMMA           shift and go to state 181
    NEWLINE         reduce using rule 163 (empty -> .)

    var_tail                       shift and go to state 178
    empty                          shift and go to state 179

state 153

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements . revive maybe_newline RBRACE
    (103) revive -> . REVIVE value
    (104) revive -> . empty
    (163) empty -> .

    REVIVE          shift and go to state 183
    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)

    revive                         shift and go to state 182
    empty                          shift and go to state 184

state 154

    (102) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 102 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 155

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE .)


state 156

    (106) statements -> local_dec NEWLINE statements_tail .

    NEWLINE         reduce using rule 106 (statements -> local_dec NEWLINE statements_tail .)
    RBRACE          reduce using rule 106 (statements -> local_dec NEWLINE statements_tail .)
    REVIVE          reduce using rule 106 (statements -> local_dec NEWLINE statements_tail .)
    SHIFT           reduce using rule 106 (statements -> local_dec NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 106 (statements -> local_dec NEWLINE statements_tail .)


state 157

    (107) statements_tail -> empty .
    (105) statements -> empty .
    (116) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 105 (statements -> empty .)
    NEWLINE         reduce using rule 105 (statements -> empty .)
    RBRACE          reduce using rule 105 (statements -> empty .)
    REVIVE          reduce using rule 105 (statements -> empty .)
    SHIFT           reduce using rule 105 (statements -> empty .)
    OTHERWISE       reduce using rule 105 (statements -> empty .)

  ! NEWLINE         [ reduce using rule 107 (statements_tail -> empty .) ]
  ! RBRACE          [ reduce using rule 107 (statements_tail -> empty .) ]
  ! REVIVE          [ reduce using rule 107 (statements_tail -> empty .) ]
  ! SHIFT           [ reduce using rule 107 (statements_tail -> empty .) ]
  ! OTHERWISE       [ reduce using rule 107 (statements_tail -> empty .) ]
  ! NEWLINE         [ reduce using rule 116 (local_dec -> empty .) ]


state 158

    (108) statements_tail -> statements .

    NEWLINE         reduce using rule 108 (statements_tail -> statements .)
    RBRACE          reduce using rule 108 (statements_tail -> statements .)
    REVIVE          reduce using rule 108 (statements_tail -> statements .)
    SHIFT           reduce using rule 108 (statements_tail -> statements .)
    OTHERWISE       reduce using rule 108 (statements_tail -> statements .)


state 159

    (109) statements_tail -> conditional_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 185


state 160

    (110) statements_tail -> switch_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 186


state 161

    (111) statements_tail -> loop_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 187


state 162

    (112) statements_tail -> function_call . NEWLINE statements_tail

    NEWLINE         shift and go to state 188


state 163

    (113) statements_tail -> string_operation_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 189


state 164

    (114) statements_tail -> output_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 190


state 165

    (117) conditional_statement -> CHECK . LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail

    LPAREN          shift and go to state 191


state 166

    (121) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE

    LPAREN          shift and go to state 192


state 167

    (125) loop_statement -> for_loop .

    NEWLINE         reduce using rule 125 (loop_statement -> for_loop .)


state 168

    (126) loop_statement -> until_loop .

    NEWLINE         reduce using rule 126 (loop_statement -> until_loop .)


state 169

    (127) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 127 (loop_statement -> repeat_until .)


state 170

    (137) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 193


state 171

    (138) function_call -> input_statement .

    NEWLINE         reduce using rule 138 (function_call -> input_statement .)
    COMMA           reduce using rule 138 (function_call -> input_statement .)
    RBRACE          reduce using rule 138 (function_call -> input_statement .)
    RPAREN          reduce using rule 138 (function_call -> input_statement .)
    COLON           reduce using rule 138 (function_call -> input_statement .)


state 172

    (150) string_operation_statement -> var_call . string_operation_tail
    (151) string_operation_tail -> . assign_op value
    (152) string_operation_tail -> . PLUS string_val stringcon_tail
    (153) assign_op -> . PLUS_EQ
    (154) assign_op -> . MINUS_EQ
    (155) assign_op -> . MUL_EQ
    (156) assign_op -> . DIV_EQ
    (157) assign_op -> . MOD_EQ
    (158) assign_op -> . EQ

    PLUS            shift and go to state 196
    PLUS_EQ         shift and go to state 197
    MINUS_EQ        shift and go to state 198
    MUL_EQ          shift and go to state 199
    DIV_EQ          shift and go to state 200
    MOD_EQ          shift and go to state 201
    EQ              shift and go to state 202

    string_operation_tail          shift and go to state 194
    assign_op                      shift and go to state 195

state 173

    (145) output_statement -> DISPLAY . value next_val
    (146) output_statement -> DISPLAY . LPAREN value next_val RPAREN
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    LPAREN          shift and go to state 204
    TILDE           shift and go to state 53
    CONVERT_TO_INT  shift and go to state 209
    CONVERT_TO_FLT  shift and go to state 210
    CONVERT_TO_BLN  shift and go to state 211
    CONVERT_TO_STR  shift and go to state 212
    FUNCTION_NAME   shift and go to state 170
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 203
    factor                         shift and go to state 205
    type_cast                      shift and go to state 206
    expression                     shift and go to state 207
    function_call                  shift and go to state 208
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 171
    term                           shift and go to state 63

state 174

    (128) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 213


state 175

    (129) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 214


state 176

    (130) repeat_until -> REPEAT . LBRACE statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 215


state 177

    (149) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 216


state 178

    (21) var_statement -> data_type IDENT var_tail .

    NEWLINE         reduce using rule 21 (var_statement -> data_type IDENT var_tail .)


state 179

    (22) var_tail -> empty .

    NEWLINE         reduce using rule 22 (var_tail -> empty .)


state 180

    (23) var_tail -> EQ . tail_value var_tail2
    (27) tail_value -> . value
    (28) tail_value -> . LBRACKET list_element RBRACKET
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    LBRACKET        shift and go to state 219
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 209
    CONVERT_TO_FLT  shift and go to state 210
    CONVERT_TO_BLN  shift and go to state 211
    CONVERT_TO_STR  shift and go to state 212
    FUNCTION_NAME   shift and go to state 170
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    tail_value                     shift and go to state 217
    value                          shift and go to state 218
    factor                         shift and go to state 205
    type_cast                      shift and go to state 206
    expression                     shift and go to state 207
    function_call                  shift and go to state 208
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 171
    term                           shift and go to state 63

state 181

    (24) var_tail -> COMMA . IDENT var_tail

    IDENT           shift and go to state 220


state 182

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (163) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 163 (empty -> .)

    maybe_newline                  shift and go to state 221
    empty                          shift and go to state 16

state 183

    (103) revive -> REVIVE . value
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 209
    CONVERT_TO_FLT  shift and go to state 210
    CONVERT_TO_BLN  shift and go to state 211
    CONVERT_TO_STR  shift and go to state 212
    FUNCTION_NAME   shift and go to state 170
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 222
    factor                         shift and go to state 205
    type_cast                      shift and go to state 206
    expression                     shift and go to state 207
    function_call                  shift and go to state 208
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 171
    term                           shift and go to state 63

state 184

    (104) revive -> empty .

    NEWLINE         reduce using rule 104 (revive -> empty .)
    RBRACE          reduce using rule 104 (revive -> empty .)


state 185

    (109) statements_tail -> conditional_statement NEWLINE . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . statements
    (109) statements_tail -> . conditional_statement NEWLINE statements_tail
    (110) statements_tail -> . switch_statement NEWLINE statements_tail
    (111) statements_tail -> . loop_statement NEWLINE statements_tail
    (112) statements_tail -> . function_call NEWLINE statements_tail
    (113) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (114) statements_tail -> . output_statement NEWLINE statements_tail
    (163) empty -> .
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (82) var_call -> . IDENT var_call_tail
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    REVIVE          reduce using rule 163 (empty -> .)
    SHIFT           reduce using rule 163 (empty -> .)
    OTHERWISE       reduce using rule 163 (empty -> .)
    CHECK           shift and go to state 165
    SWAP            shift and go to state 166
    FUNCTION_NAME   shift and go to state 170
    DISPLAY         shift and go to state 173
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    IDENT           shift and go to state 56
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    conditional_statement          shift and go to state 159
    statements_tail                shift and go to state 223
    empty                          shift and go to state 157
    statements                     shift and go to state 158
    switch_statement               shift and go to state 160
    loop_statement                 shift and go to state 161
    function_call                  shift and go to state 162
    string_operation_statement     shift and go to state 163
    output_statement               shift and go to state 164
    local_dec                      shift and go to state 145
    for_loop                       shift and go to state 167
    until_loop                     shift and go to state 168
    repeat_until                   shift and go to state 169
    input_statement                shift and go to state 171
    var_call                       shift and go to state 172
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 186

    (110) statements_tail -> switch_statement NEWLINE . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . statements
    (109) statements_tail -> . conditional_statement NEWLINE statements_tail
    (110) statements_tail -> . switch_statement NEWLINE statements_tail
    (111) statements_tail -> . loop_statement NEWLINE statements_tail
    (112) statements_tail -> . function_call NEWLINE statements_tail
    (113) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (114) statements_tail -> . output_statement NEWLINE statements_tail
    (163) empty -> .
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (82) var_call -> . IDENT var_call_tail
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    REVIVE          reduce using rule 163 (empty -> .)
    SHIFT           reduce using rule 163 (empty -> .)
    OTHERWISE       reduce using rule 163 (empty -> .)
    CHECK           shift and go to state 165
    SWAP            shift and go to state 166
    FUNCTION_NAME   shift and go to state 170
    DISPLAY         shift and go to state 173
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    IDENT           shift and go to state 56
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    switch_statement               shift and go to state 160
    statements_tail                shift and go to state 224
    empty                          shift and go to state 157
    statements                     shift and go to state 158
    conditional_statement          shift and go to state 159
    loop_statement                 shift and go to state 161
    function_call                  shift and go to state 162
    string_operation_statement     shift and go to state 163
    output_statement               shift and go to state 164
    local_dec                      shift and go to state 145
    for_loop                       shift and go to state 167
    until_loop                     shift and go to state 168
    repeat_until                   shift and go to state 169
    input_statement                shift and go to state 171
    var_call                       shift and go to state 172
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 187

    (111) statements_tail -> loop_statement NEWLINE . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . statements
    (109) statements_tail -> . conditional_statement NEWLINE statements_tail
    (110) statements_tail -> . switch_statement NEWLINE statements_tail
    (111) statements_tail -> . loop_statement NEWLINE statements_tail
    (112) statements_tail -> . function_call NEWLINE statements_tail
    (113) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (114) statements_tail -> . output_statement NEWLINE statements_tail
    (163) empty -> .
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (82) var_call -> . IDENT var_call_tail
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    REVIVE          reduce using rule 163 (empty -> .)
    SHIFT           reduce using rule 163 (empty -> .)
    OTHERWISE       reduce using rule 163 (empty -> .)
    CHECK           shift and go to state 165
    SWAP            shift and go to state 166
    FUNCTION_NAME   shift and go to state 170
    DISPLAY         shift and go to state 173
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    IDENT           shift and go to state 56
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    loop_statement                 shift and go to state 161
    statements_tail                shift and go to state 225
    empty                          shift and go to state 157
    statements                     shift and go to state 158
    conditional_statement          shift and go to state 159
    switch_statement               shift and go to state 160
    function_call                  shift and go to state 162
    string_operation_statement     shift and go to state 163
    output_statement               shift and go to state 164
    local_dec                      shift and go to state 145
    for_loop                       shift and go to state 167
    until_loop                     shift and go to state 168
    repeat_until                   shift and go to state 169
    input_statement                shift and go to state 171
    var_call                       shift and go to state 172
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 188

    (112) statements_tail -> function_call NEWLINE . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . statements
    (109) statements_tail -> . conditional_statement NEWLINE statements_tail
    (110) statements_tail -> . switch_statement NEWLINE statements_tail
    (111) statements_tail -> . loop_statement NEWLINE statements_tail
    (112) statements_tail -> . function_call NEWLINE statements_tail
    (113) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (114) statements_tail -> . output_statement NEWLINE statements_tail
    (163) empty -> .
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (82) var_call -> . IDENT var_call_tail
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    REVIVE          reduce using rule 163 (empty -> .)
    SHIFT           reduce using rule 163 (empty -> .)
    OTHERWISE       reduce using rule 163 (empty -> .)
    CHECK           shift and go to state 165
    SWAP            shift and go to state 166
    FUNCTION_NAME   shift and go to state 170
    DISPLAY         shift and go to state 173
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    IDENT           shift and go to state 56
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    function_call                  shift and go to state 162
    statements_tail                shift and go to state 226
    empty                          shift and go to state 157
    statements                     shift and go to state 158
    conditional_statement          shift and go to state 159
    switch_statement               shift and go to state 160
    loop_statement                 shift and go to state 161
    string_operation_statement     shift and go to state 163
    output_statement               shift and go to state 164
    local_dec                      shift and go to state 145
    for_loop                       shift and go to state 167
    until_loop                     shift and go to state 168
    repeat_until                   shift and go to state 169
    input_statement                shift and go to state 171
    var_call                       shift and go to state 172
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 189

    (113) statements_tail -> string_operation_statement NEWLINE . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . statements
    (109) statements_tail -> . conditional_statement NEWLINE statements_tail
    (110) statements_tail -> . switch_statement NEWLINE statements_tail
    (111) statements_tail -> . loop_statement NEWLINE statements_tail
    (112) statements_tail -> . function_call NEWLINE statements_tail
    (113) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (114) statements_tail -> . output_statement NEWLINE statements_tail
    (163) empty -> .
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (82) var_call -> . IDENT var_call_tail
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    REVIVE          reduce using rule 163 (empty -> .)
    SHIFT           reduce using rule 163 (empty -> .)
    OTHERWISE       reduce using rule 163 (empty -> .)
    CHECK           shift and go to state 165
    SWAP            shift and go to state 166
    FUNCTION_NAME   shift and go to state 170
    DISPLAY         shift and go to state 173
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    IDENT           shift and go to state 56
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    string_operation_statement     shift and go to state 163
    statements_tail                shift and go to state 227
    empty                          shift and go to state 157
    statements                     shift and go to state 158
    conditional_statement          shift and go to state 159
    switch_statement               shift and go to state 160
    loop_statement                 shift and go to state 161
    function_call                  shift and go to state 162
    output_statement               shift and go to state 164
    local_dec                      shift and go to state 145
    for_loop                       shift and go to state 167
    until_loop                     shift and go to state 168
    repeat_until                   shift and go to state 169
    input_statement                shift and go to state 171
    var_call                       shift and go to state 172
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 190

    (114) statements_tail -> output_statement NEWLINE . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . statements
    (109) statements_tail -> . conditional_statement NEWLINE statements_tail
    (110) statements_tail -> . switch_statement NEWLINE statements_tail
    (111) statements_tail -> . loop_statement NEWLINE statements_tail
    (112) statements_tail -> . function_call NEWLINE statements_tail
    (113) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (114) statements_tail -> . output_statement NEWLINE statements_tail
    (163) empty -> .
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (82) var_call -> . IDENT var_call_tail
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 163 (empty -> .)
    RBRACE          reduce using rule 163 (empty -> .)
    REVIVE          reduce using rule 163 (empty -> .)
    SHIFT           reduce using rule 163 (empty -> .)
    OTHERWISE       reduce using rule 163 (empty -> .)
    CHECK           shift and go to state 165
    SWAP            shift and go to state 166
    FUNCTION_NAME   shift and go to state 170
    DISPLAY         shift and go to state 173
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    IDENT           shift and go to state 56
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    output_statement               shift and go to state 164
    statements_tail                shift and go to state 228
    empty                          shift and go to state 157
    statements                     shift and go to state 158
    conditional_statement          shift and go to state 159
    switch_statement               shift and go to state 160
    loop_statement                 shift and go to state 161
    function_call                  shift and go to state 162
    string_operation_statement     shift and go to state 163
    local_dec                      shift and go to state 145
    for_loop                       shift and go to state 167
    until_loop                     shift and go to state 168
    repeat_until                   shift and go to state 169
    input_statement                shift and go to state 171
    var_call                       shift and go to state 172
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 191

    (117) conditional_statement -> CHECK LPAREN . expression RPAREN LBRACE statements RBRACE conditional_tail
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 229
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 192

    (121) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE

    IDENT           shift and go to state 230


state 193

    (137) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (139) arguments -> . empty
    (140) arguments -> . arg_value arg_tail
    (163) empty -> .
    (143) arg_value -> . literal
    (144) arg_value -> . var_call
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    RPAREN          reduce using rule 163 (empty -> .)
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    IDENT           shift and go to state 56

    arguments                      shift and go to state 231
    empty                          shift and go to state 232
    arg_value                      shift and go to state 233
    literal                        shift and go to state 234
    var_call                       shift and go to state 235

state 194

    (150) string_operation_statement -> var_call string_operation_tail .

    NEWLINE         reduce using rule 150 (string_operation_statement -> var_call string_operation_tail .)


state 195

    (151) string_operation_tail -> assign_op . value
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 209
    CONVERT_TO_FLT  shift and go to state 210
    CONVERT_TO_BLN  shift and go to state 211
    CONVERT_TO_STR  shift and go to state 212
    FUNCTION_NAME   shift and go to state 170
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 236
    factor                         shift and go to state 205
    type_cast                      shift and go to state 206
    expression                     shift and go to state 207
    function_call                  shift and go to state 208
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 171
    term                           shift and go to state 63

state 196

    (152) string_operation_tail -> PLUS . string_val stringcon_tail
    (161) string_val -> . var_call
    (162) string_val -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 239
    IDENT           shift and go to state 56

    string_val                     shift and go to state 237
    var_call                       shift and go to state 238

state 197

    (153) assign_op -> PLUS_EQ .

    TILDE           reduce using rule 153 (assign_op -> PLUS_EQ .)
    LPAREN          reduce using rule 153 (assign_op -> PLUS_EQ .)
    CONVERT_TO_INT  reduce using rule 153 (assign_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 153 (assign_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 153 (assign_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 153 (assign_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 153 (assign_op -> PLUS_EQ .)
    IDENT           reduce using rule 153 (assign_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 153 (assign_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 153 (assign_op -> PLUS_EQ .)
    DAY             reduce using rule 153 (assign_op -> PLUS_EQ .)
    NIGHT           reduce using rule 153 (assign_op -> PLUS_EQ .)
    CHR_LIT         reduce using rule 153 (assign_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 153 (assign_op -> PLUS_EQ .)
    INPUT           reduce using rule 153 (assign_op -> PLUS_EQ .)


state 198

    (154) assign_op -> MINUS_EQ .

    TILDE           reduce using rule 154 (assign_op -> MINUS_EQ .)
    LPAREN          reduce using rule 154 (assign_op -> MINUS_EQ .)
    CONVERT_TO_INT  reduce using rule 154 (assign_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 154 (assign_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 154 (assign_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 154 (assign_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 154 (assign_op -> MINUS_EQ .)
    IDENT           reduce using rule 154 (assign_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 154 (assign_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 154 (assign_op -> MINUS_EQ .)
    DAY             reduce using rule 154 (assign_op -> MINUS_EQ .)
    NIGHT           reduce using rule 154 (assign_op -> MINUS_EQ .)
    CHR_LIT         reduce using rule 154 (assign_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 154 (assign_op -> MINUS_EQ .)
    INPUT           reduce using rule 154 (assign_op -> MINUS_EQ .)


state 199

    (155) assign_op -> MUL_EQ .

    TILDE           reduce using rule 155 (assign_op -> MUL_EQ .)
    LPAREN          reduce using rule 155 (assign_op -> MUL_EQ .)
    CONVERT_TO_INT  reduce using rule 155 (assign_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 155 (assign_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 155 (assign_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 155 (assign_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 155 (assign_op -> MUL_EQ .)
    IDENT           reduce using rule 155 (assign_op -> MUL_EQ .)
    INT_LIT         reduce using rule 155 (assign_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 155 (assign_op -> MUL_EQ .)
    DAY             reduce using rule 155 (assign_op -> MUL_EQ .)
    NIGHT           reduce using rule 155 (assign_op -> MUL_EQ .)
    CHR_LIT         reduce using rule 155 (assign_op -> MUL_EQ .)
    STR_LIT         reduce using rule 155 (assign_op -> MUL_EQ .)
    INPUT           reduce using rule 155 (assign_op -> MUL_EQ .)


state 200

    (156) assign_op -> DIV_EQ .

    TILDE           reduce using rule 156 (assign_op -> DIV_EQ .)
    LPAREN          reduce using rule 156 (assign_op -> DIV_EQ .)
    CONVERT_TO_INT  reduce using rule 156 (assign_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 156 (assign_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 156 (assign_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 156 (assign_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 156 (assign_op -> DIV_EQ .)
    IDENT           reduce using rule 156 (assign_op -> DIV_EQ .)
    INT_LIT         reduce using rule 156 (assign_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 156 (assign_op -> DIV_EQ .)
    DAY             reduce using rule 156 (assign_op -> DIV_EQ .)
    NIGHT           reduce using rule 156 (assign_op -> DIV_EQ .)
    CHR_LIT         reduce using rule 156 (assign_op -> DIV_EQ .)
    STR_LIT         reduce using rule 156 (assign_op -> DIV_EQ .)
    INPUT           reduce using rule 156 (assign_op -> DIV_EQ .)


state 201

    (157) assign_op -> MOD_EQ .

    TILDE           reduce using rule 157 (assign_op -> MOD_EQ .)
    LPAREN          reduce using rule 157 (assign_op -> MOD_EQ .)
    CONVERT_TO_INT  reduce using rule 157 (assign_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 157 (assign_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 157 (assign_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 157 (assign_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 157 (assign_op -> MOD_EQ .)
    IDENT           reduce using rule 157 (assign_op -> MOD_EQ .)
    INT_LIT         reduce using rule 157 (assign_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 157 (assign_op -> MOD_EQ .)
    DAY             reduce using rule 157 (assign_op -> MOD_EQ .)
    NIGHT           reduce using rule 157 (assign_op -> MOD_EQ .)
    CHR_LIT         reduce using rule 157 (assign_op -> MOD_EQ .)
    STR_LIT         reduce using rule 157 (assign_op -> MOD_EQ .)
    INPUT           reduce using rule 157 (assign_op -> MOD_EQ .)


state 202

    (158) assign_op -> EQ .

    TILDE           reduce using rule 158 (assign_op -> EQ .)
    LPAREN          reduce using rule 158 (assign_op -> EQ .)
    CONVERT_TO_INT  reduce using rule 158 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 158 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 158 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 158 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 158 (assign_op -> EQ .)
    IDENT           reduce using rule 158 (assign_op -> EQ .)
    INT_LIT         reduce using rule 158 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 158 (assign_op -> EQ .)
    DAY             reduce using rule 158 (assign_op -> EQ .)
    NIGHT           reduce using rule 158 (assign_op -> EQ .)
    CHR_LIT         reduce using rule 158 (assign_op -> EQ .)
    STR_LIT         reduce using rule 158 (assign_op -> EQ .)
    INPUT           reduce using rule 158 (assign_op -> EQ .)


state 203

    (145) output_statement -> DISPLAY value . next_val
    (147) next_val -> . empty
    (148) next_val -> . COMMA value next_val
    (163) empty -> .

    COMMA           shift and go to state 242
    NEWLINE         reduce using rule 163 (empty -> .)

    next_val                       shift and go to state 240
    empty                          shift and go to state 241

state 204

    (146) output_statement -> DISPLAY LPAREN . value next_val RPAREN
    (64) factor -> LPAREN . expression RPAREN
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (58) expression -> . expr_head expr_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (59) expr_head -> . term term_tail
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 209
    CONVERT_TO_FLT  shift and go to state 210
    CONVERT_TO_BLN  shift and go to state 211
    CONVERT_TO_STR  shift and go to state 212
    FUNCTION_NAME   shift and go to state 170
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 243
    expression                     shift and go to state 244
    factor                         shift and go to state 205
    type_cast                      shift and go to state 206
    function_call                  shift and go to state 208
    expr_head                      shift and go to state 55
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    input_statement                shift and go to state 171
    term                           shift and go to state 63

state 205

    (39) value -> factor .
    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (163) empty -> .

  ! reduce/reduce conflict for COMMA resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for RBRACE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for RPAREN resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for COLON resolved using rule 39 (value -> factor .)
    COMMA           reduce using rule 39 (value -> factor .)
    NEWLINE         reduce using rule 39 (value -> factor .)
    RBRACE          reduce using rule 39 (value -> factor .)
    RPAREN          reduce using rule 39 (value -> factor .)
    COLON           reduce using rule 39 (value -> factor .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 163 (empty -> .)
    LT              reduce using rule 163 (empty -> .)
    EQ_EQ           reduce using rule 163 (empty -> .)
    GT_EQ           reduce using rule 163 (empty -> .)
    LT_EQ           reduce using rule 163 (empty -> .)
    NOT_EQ          reduce using rule 163 (empty -> .)
    AND             reduce using rule 163 (empty -> .)
    OR              reduce using rule 163 (empty -> .)

  ! COMMA           [ reduce using rule 163 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 163 (empty -> .) ]
  ! RBRACE          [ reduce using rule 163 (empty -> .) ]
  ! RPAREN          [ reduce using rule 163 (empty -> .) ]
  ! COLON           [ reduce using rule 163 (empty -> .) ]

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 206

    (40) value -> type_cast .

    COMMA           reduce using rule 40 (value -> type_cast .)
    NEWLINE         reduce using rule 40 (value -> type_cast .)
    RBRACE          reduce using rule 40 (value -> type_cast .)
    RPAREN          reduce using rule 40 (value -> type_cast .)
    COLON           reduce using rule 40 (value -> type_cast .)


state 207

    (41) value -> expression .

    COMMA           reduce using rule 41 (value -> expression .)
    NEWLINE         reduce using rule 41 (value -> expression .)
    RBRACE          reduce using rule 41 (value -> expression .)
    RPAREN          reduce using rule 41 (value -> expression .)
    COLON           reduce using rule 41 (value -> expression .)


state 208

    (42) value -> function_call .

    COMMA           reduce using rule 42 (value -> function_call .)
    NEWLINE         reduce using rule 42 (value -> function_call .)
    RBRACE          reduce using rule 42 (value -> function_call .)
    RPAREN          reduce using rule 42 (value -> function_call .)
    COLON           reduce using rule 42 (value -> function_call .)


state 209

    (43) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 245


state 210

    (44) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 246


state 211

    (45) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 247


state 212

    (46) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 248


state 213

    (128) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (131) control_variable -> . INT IDENT EQ INT_LIT

    INT             shift and go to state 250

    control_variable               shift and go to state 249

state 214

    (129) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE statements RBRACE
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 251
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 215

    (130) repeat_until -> REPEAT LBRACE . statements RBRACE UNTIL LPAREN expression RPAREN
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    RBRACE          reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 252
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 216

    (149) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 253


state 217

    (23) var_tail -> EQ tail_value . var_tail2
    (25) var_tail2 -> . empty
    (26) var_tail2 -> . COMMA IDENT var_tail
    (163) empty -> .

    COMMA           shift and go to state 256
    NEWLINE         reduce using rule 163 (empty -> .)

    var_tail2                      shift and go to state 254
    empty                          shift and go to state 255

state 218

    (27) tail_value -> value .

    COMMA           reduce using rule 27 (tail_value -> value .)
    NEWLINE         reduce using rule 27 (tail_value -> value .)


state 219

    (28) tail_value -> LBRACKET . list_element RBRACKET
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 257
    literal                        shift and go to state 72

state 220

    (24) var_tail -> COMMA IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (163) empty -> .

    EQ              shift and go to state 180
    COMMA           shift and go to state 181
    NEWLINE         reduce using rule 163 (empty -> .)

    var_tail                       shift and go to state 258
    empty                          shift and go to state 179

state 221

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline . RBRACE

    RBRACE          shift and go to state 259


state 222

    (103) revive -> REVIVE value .

    NEWLINE         reduce using rule 103 (revive -> REVIVE value .)
    RBRACE          reduce using rule 103 (revive -> REVIVE value .)


state 223

    (109) statements_tail -> conditional_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 109 (statements_tail -> conditional_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 109 (statements_tail -> conditional_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 109 (statements_tail -> conditional_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 109 (statements_tail -> conditional_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 109 (statements_tail -> conditional_statement NEWLINE statements_tail .)


state 224

    (110) statements_tail -> switch_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 110 (statements_tail -> switch_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 110 (statements_tail -> switch_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 110 (statements_tail -> switch_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 110 (statements_tail -> switch_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 110 (statements_tail -> switch_statement NEWLINE statements_tail .)


state 225

    (111) statements_tail -> loop_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 111 (statements_tail -> loop_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 111 (statements_tail -> loop_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 111 (statements_tail -> loop_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 111 (statements_tail -> loop_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 111 (statements_tail -> loop_statement NEWLINE statements_tail .)


state 226

    (112) statements_tail -> function_call NEWLINE statements_tail .

    NEWLINE         reduce using rule 112 (statements_tail -> function_call NEWLINE statements_tail .)
    RBRACE          reduce using rule 112 (statements_tail -> function_call NEWLINE statements_tail .)
    REVIVE          reduce using rule 112 (statements_tail -> function_call NEWLINE statements_tail .)
    SHIFT           reduce using rule 112 (statements_tail -> function_call NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 112 (statements_tail -> function_call NEWLINE statements_tail .)


state 227

    (113) statements_tail -> string_operation_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 113 (statements_tail -> string_operation_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 113 (statements_tail -> string_operation_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 113 (statements_tail -> string_operation_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 113 (statements_tail -> string_operation_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 113 (statements_tail -> string_operation_statement NEWLINE statements_tail .)


state 228

    (114) statements_tail -> output_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 114 (statements_tail -> output_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 114 (statements_tail -> output_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 114 (statements_tail -> output_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 114 (statements_tail -> output_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 114 (statements_tail -> output_statement NEWLINE statements_tail .)


state 229

    (117) conditional_statement -> CHECK LPAREN expression . RPAREN LBRACE statements RBRACE conditional_tail

    RPAREN          shift and go to state 260


state 230

    (121) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE switch_condition OTHERWISE statements RBRACE

    RPAREN          shift and go to state 261


state 231

    (137) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 262


state 232

    (139) arguments -> empty .

    RPAREN          reduce using rule 139 (arguments -> empty .)


state 233

    (140) arguments -> arg_value . arg_tail
    (141) arg_tail -> . empty
    (142) arg_tail -> . COMMA arg_value arg_tail
    (163) empty -> .

    COMMA           shift and go to state 265
    RPAREN          reduce using rule 163 (empty -> .)

    arg_tail                       shift and go to state 263
    empty                          shift and go to state 264

state 234

    (143) arg_value -> literal .

    COMMA           reduce using rule 143 (arg_value -> literal .)
    RPAREN          reduce using rule 143 (arg_value -> literal .)


state 235

    (144) arg_value -> var_call .

    COMMA           reduce using rule 144 (arg_value -> var_call .)
    RPAREN          reduce using rule 144 (arg_value -> var_call .)


state 236

    (151) string_operation_tail -> assign_op value .

    NEWLINE         reduce using rule 151 (string_operation_tail -> assign_op value .)


state 237

    (152) string_operation_tail -> PLUS string_val . stringcon_tail
    (159) stringcon_tail -> . empty
    (160) stringcon_tail -> . PLUS string_val stringcon_tail
    (163) empty -> .

    PLUS            shift and go to state 266
    NEWLINE         reduce using rule 163 (empty -> .)

    stringcon_tail                 shift and go to state 267
    empty                          shift and go to state 268

state 238

    (161) string_val -> var_call .

    PLUS            reduce using rule 161 (string_val -> var_call .)
    NEWLINE         reduce using rule 161 (string_val -> var_call .)


state 239

    (162) string_val -> STR_LIT .

    PLUS            reduce using rule 162 (string_val -> STR_LIT .)
    NEWLINE         reduce using rule 162 (string_val -> STR_LIT .)


state 240

    (145) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 145 (output_statement -> DISPLAY value next_val .)


state 241

    (147) next_val -> empty .

    NEWLINE         reduce using rule 147 (next_val -> empty .)
    RPAREN          reduce using rule 147 (next_val -> empty .)


state 242

    (148) next_val -> COMMA . value next_val
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 209
    CONVERT_TO_FLT  shift and go to state 210
    CONVERT_TO_BLN  shift and go to state 211
    CONVERT_TO_STR  shift and go to state 212
    FUNCTION_NAME   shift and go to state 170
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 269
    factor                         shift and go to state 205
    type_cast                      shift and go to state 206
    expression                     shift and go to state 207
    function_call                  shift and go to state 208
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 171
    term                           shift and go to state 63

state 243

    (146) output_statement -> DISPLAY LPAREN value . next_val RPAREN
    (147) next_val -> . empty
    (148) next_val -> . COMMA value next_val
    (163) empty -> .

    COMMA           shift and go to state 242
    RPAREN          reduce using rule 163 (empty -> .)

    next_val                       shift and go to state 270
    empty                          shift and go to state 241

state 244

    (64) factor -> LPAREN expression . RPAREN
    (41) value -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 113
    COMMA           reduce using rule 41 (value -> expression .)

  ! RPAREN          [ reduce using rule 41 (value -> expression .) ]


state 245

    (43) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 272
    FUNCTION_NAME   shift and go to state 275
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 271
    literal                        shift and go to state 273
    expression                     shift and go to state 274
    input_statement                shift and go to state 276
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 246

    (44) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 272
    FUNCTION_NAME   shift and go to state 275
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 277
    literal                        shift and go to state 273
    expression                     shift and go to state 274
    input_statement                shift and go to state 276
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 247

    (45) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 272
    FUNCTION_NAME   shift and go to state 275
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 278
    literal                        shift and go to state 273
    expression                     shift and go to state 274
    input_statement                shift and go to state 276
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 248

    (46) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 272
    FUNCTION_NAME   shift and go to state 275
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 279
    literal                        shift and go to state 273
    expression                     shift and go to state 274
    input_statement                shift and go to state 276
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 249

    (128) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 280


state 250

    (131) control_variable -> INT . IDENT EQ INT_LIT

    IDENT           shift and go to state 281


state 251

    (129) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 282


state 252

    (130) repeat_until -> REPEAT LBRACE statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 283


state 253

    (149) input_statement -> INPUT LPAREN RPAREN .

    NEWLINE         reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)


state 254

    (23) var_tail -> EQ tail_value var_tail2 .

    NEWLINE         reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)


state 255

    (25) var_tail2 -> empty .

    NEWLINE         reduce using rule 25 (var_tail2 -> empty .)


state 256

    (26) var_tail2 -> COMMA . IDENT var_tail

    IDENT           shift and go to state 284


state 257

    (28) tail_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 285


state 258

    (24) var_tail -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)


state 259

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .

    NEWLINE         reduce using rule 85 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .)
    MAIN_CASPER     reduce using rule 85 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .)


state 260

    (117) conditional_statement -> CHECK LPAREN expression RPAREN . LBRACE statements RBRACE conditional_tail

    LBRACE          shift and go to state 286


state 261

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE switch_condition OTHERWISE statements RBRACE

    LBRACE          shift and go to state 287


state 262

    (137) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 263

    (140) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 140 (arguments -> arg_value arg_tail .)


state 264

    (141) arg_tail -> empty .

    RPAREN          reduce using rule 141 (arg_tail -> empty .)


state 265

    (142) arg_tail -> COMMA . arg_value arg_tail
    (143) arg_value -> . literal
    (144) arg_value -> . var_call
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    IDENT           shift and go to state 56

    arg_value                      shift and go to state 288
    literal                        shift and go to state 234
    var_call                       shift and go to state 235

state 266

    (160) stringcon_tail -> PLUS . string_val stringcon_tail
    (161) string_val -> . var_call
    (162) string_val -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 239
    IDENT           shift and go to state 56

    string_val                     shift and go to state 289
    var_call                       shift and go to state 238

state 267

    (152) string_operation_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 152 (string_operation_tail -> PLUS string_val stringcon_tail .)


state 268

    (159) stringcon_tail -> empty .

    NEWLINE         reduce using rule 159 (stringcon_tail -> empty .)


state 269

    (148) next_val -> COMMA value . next_val
    (147) next_val -> . empty
    (148) next_val -> . COMMA value next_val
    (163) empty -> .

    COMMA           shift and go to state 242
    NEWLINE         reduce using rule 163 (empty -> .)
    RPAREN          reduce using rule 163 (empty -> .)

    next_val                       shift and go to state 290
    empty                          shift and go to state 241

state 270

    (146) output_statement -> DISPLAY LPAREN value next_val . RPAREN

    RPAREN          shift and go to state 291


state 271

    (43) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 292


state 272

    (47) typecast_value -> IDENT .
    (82) var_call -> IDENT . var_call_tail
    (83) var_call_tail -> . empty
    (84) var_call_tail -> . LBRACKET index RBRACKET
    (163) empty -> .

  ! reduce/reduce conflict for RPAREN resolved using rule 47 (typecast_value -> IDENT .)
    RPAREN          reduce using rule 47 (typecast_value -> IDENT .)
    LBRACKET        shift and go to state 90
    PLUS            reduce using rule 163 (empty -> .)
    MINUS           reduce using rule 163 (empty -> .)
    MULTIPLY        reduce using rule 163 (empty -> .)
    DIVISION        reduce using rule 163 (empty -> .)
    MODULO          reduce using rule 163 (empty -> .)
    EXPONENT        reduce using rule 163 (empty -> .)
    GT              reduce using rule 163 (empty -> .)
    LT              reduce using rule 163 (empty -> .)
    EQ_EQ           reduce using rule 163 (empty -> .)
    GT_EQ           reduce using rule 163 (empty -> .)
    LT_EQ           reduce using rule 163 (empty -> .)
    NOT_EQ          reduce using rule 163 (empty -> .)
    AND             reduce using rule 163 (empty -> .)
    OR              reduce using rule 163 (empty -> .)

  ! RPAREN          [ reduce using rule 163 (empty -> .) ]

    var_call_tail                  shift and go to state 88
    empty                          shift and go to state 89

state 273

    (48) typecast_value -> literal .
    (62) factor -> literal .

  ! reduce/reduce conflict for RPAREN resolved using rule 48 (typecast_value -> literal .)
    RPAREN          reduce using rule 48 (typecast_value -> literal .)
    PLUS            reduce using rule 62 (factor -> literal .)
    MINUS           reduce using rule 62 (factor -> literal .)
    MULTIPLY        reduce using rule 62 (factor -> literal .)
    DIVISION        reduce using rule 62 (factor -> literal .)
    MODULO          reduce using rule 62 (factor -> literal .)
    EXPONENT        reduce using rule 62 (factor -> literal .)
    GT              reduce using rule 62 (factor -> literal .)
    LT              reduce using rule 62 (factor -> literal .)
    EQ_EQ           reduce using rule 62 (factor -> literal .)
    GT_EQ           reduce using rule 62 (factor -> literal .)
    LT_EQ           reduce using rule 62 (factor -> literal .)
    NOT_EQ          reduce using rule 62 (factor -> literal .)
    AND             reduce using rule 62 (factor -> literal .)
    OR              reduce using rule 62 (factor -> literal .)

  ! RPAREN          [ reduce using rule 62 (factor -> literal .) ]


state 274

    (49) typecast_value -> expression .

    RPAREN          reduce using rule 49 (typecast_value -> expression .)


state 275

    (50) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 293


state 276

    (51) typecast_value -> input_statement .

    RPAREN          reduce using rule 51 (typecast_value -> input_statement .)


state 277

    (44) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 294


state 278

    (45) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 295


state 279

    (46) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 296


state 280

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 297
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 281

    (131) control_variable -> INT IDENT . EQ INT_LIT

    EQ              shift and go to state 298


state 282

    (129) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 299


state 283

    (130) repeat_until -> REPEAT LBRACE statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 300


state 284

    (26) var_tail2 -> COMMA IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (163) empty -> .

    EQ              shift and go to state 180
    COMMA           shift and go to state 181
    NEWLINE         reduce using rule 163 (empty -> .)

    var_tail                       shift and go to state 301
    empty                          shift and go to state 179

state 285

    (28) tail_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)


state 286

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE . statements RBRACE conditional_tail
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    RBRACE          reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 302
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 287

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . switch_condition OTHERWISE statements RBRACE
    (122) switch_condition -> . SHIFT value COLON statements switchcond_tail

    SHIFT           shift and go to state 304

    switch_condition               shift and go to state 303

state 288

    (142) arg_tail -> COMMA arg_value . arg_tail
    (141) arg_tail -> . empty
    (142) arg_tail -> . COMMA arg_value arg_tail
    (163) empty -> .

    COMMA           shift and go to state 265
    RPAREN          reduce using rule 163 (empty -> .)

    arg_tail                       shift and go to state 305
    empty                          shift and go to state 264

state 289

    (160) stringcon_tail -> PLUS string_val . stringcon_tail
    (159) stringcon_tail -> . empty
    (160) stringcon_tail -> . PLUS string_val stringcon_tail
    (163) empty -> .

    PLUS            shift and go to state 266
    NEWLINE         reduce using rule 163 (empty -> .)

    stringcon_tail                 shift and go to state 306
    empty                          shift and go to state 268

state 290

    (148) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 148 (next_val -> COMMA value next_val .)
    RPAREN          reduce using rule 148 (next_val -> COMMA value next_val .)


state 291

    (146) output_statement -> DISPLAY LPAREN value next_val RPAREN .

    NEWLINE         reduce using rule 146 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)


state 292

    (43) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 293

    (50) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 307


state 294

    (44) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 295

    (45) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 296

    (46) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 297

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 308


state 298

    (131) control_variable -> INT IDENT EQ . INT_LIT

    INT_LIT         shift and go to state 309


state 299

    (129) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    RBRACE          reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 310
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 300

    (130) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 311


state 301

    (26) var_tail2 -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)


state 302

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements . RBRACE conditional_tail

    RBRACE          shift and go to state 312


state 303

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition . OTHERWISE statements RBRACE

    OTHERWISE       shift and go to state 313


state 304

    (122) switch_condition -> SHIFT . value COLON statements switchcond_tail
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 209
    CONVERT_TO_FLT  shift and go to state 210
    CONVERT_TO_BLN  shift and go to state 211
    CONVERT_TO_STR  shift and go to state 212
    FUNCTION_NAME   shift and go to state 170
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 314
    factor                         shift and go to state 205
    type_cast                      shift and go to state 206
    expression                     shift and go to state 207
    function_call                  shift and go to state 208
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 171
    term                           shift and go to state 63

state 305

    (142) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 142 (arg_tail -> COMMA arg_value arg_tail .)


state 306

    (160) stringcon_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 160 (stringcon_tail -> PLUS string_val stringcon_tail .)


state 307

    (50) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 50 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 308

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN LBRACE statements RBRACE
    (132) update -> . var_call update_tail
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 56

    update                         shift and go to state 315
    var_call                       shift and go to state 316

state 309

    (131) control_variable -> INT IDENT EQ INT_LIT .

    SEMICOLON       reduce using rule 131 (control_variable -> INT IDENT EQ INT_LIT .)


state 310

    (129) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 317


state 311

    (130) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN . expression RPAREN
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 318
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 312

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements RBRACE . conditional_tail
    (118) conditional_tail -> . empty
    (119) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE
    (120) conditional_tail -> . OTHERWISE LBRACE statements RBRACE
    (163) empty -> .

    OTHERWISE_CHECK shift and go to state 321
    OTHERWISE       shift and go to state 322
    NEWLINE         reduce using rule 163 (empty -> .)

    conditional_tail               shift and go to state 319
    empty                          shift and go to state 320

state 313

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    RBRACE          reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 323
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 314

    (122) switch_condition -> SHIFT value . COLON statements switchcond_tail

    COLON           shift and go to state 324


state 315

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 325


state 316

    (132) update -> var_call . update_tail
    (133) update_tail -> . postfix
    (134) update_tail -> . assign_op value
    (135) postfix -> . PLUS_PLUS
    (136) postfix -> . MINUS_MINUS
    (153) assign_op -> . PLUS_EQ
    (154) assign_op -> . MINUS_EQ
    (155) assign_op -> . MUL_EQ
    (156) assign_op -> . DIV_EQ
    (157) assign_op -> . MOD_EQ
    (158) assign_op -> . EQ

    PLUS_PLUS       shift and go to state 329
    MINUS_MINUS     shift and go to state 330
    PLUS_EQ         shift and go to state 197
    MINUS_EQ        shift and go to state 198
    MUL_EQ          shift and go to state 199
    DIV_EQ          shift and go to state 200
    MOD_EQ          shift and go to state 201
    EQ              shift and go to state 202

    update_tail                    shift and go to state 326
    postfix                        shift and go to state 327
    assign_op                      shift and go to state 328

state 317

    (129) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 129 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .)


state 318

    (130) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 331


state 319

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .

    NEWLINE         reduce using rule 117 (conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .)


state 320

    (118) conditional_tail -> empty .

    NEWLINE         reduce using rule 118 (conditional_tail -> empty .)


state 321

    (119) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 332


state 322

    (120) conditional_tail -> OTHERWISE . LBRACE statements RBRACE

    LBRACE          shift and go to state 333


state 323

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements . RBRACE

    RBRACE          shift and go to state 334


state 324

    (122) switch_condition -> SHIFT value COLON . statements switchcond_tail
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    SHIFT           reduce using rule 163 (empty -> .)
    OTHERWISE       reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 335
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 325

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 336


state 326

    (132) update -> var_call update_tail .

    RPAREN          reduce using rule 132 (update -> var_call update_tail .)


state 327

    (133) update_tail -> postfix .

    RPAREN          reduce using rule 133 (update_tail -> postfix .)


state 328

    (134) update_tail -> assign_op . value
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 209
    CONVERT_TO_FLT  shift and go to state 210
    CONVERT_TO_BLN  shift and go to state 211
    CONVERT_TO_STR  shift and go to state 212
    FUNCTION_NAME   shift and go to state 170
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 337
    factor                         shift and go to state 205
    type_cast                      shift and go to state 206
    expression                     shift and go to state 207
    function_call                  shift and go to state 208
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 171
    term                           shift and go to state 63

state 329

    (135) postfix -> PLUS_PLUS .

    RPAREN          reduce using rule 135 (postfix -> PLUS_PLUS .)


state 330

    (136) postfix -> MINUS_MINUS .

    RPAREN          reduce using rule 136 (postfix -> MINUS_MINUS .)


state 331

    (130) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 130 (repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .)


state 332

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN LBRACE statements RBRACE
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 338
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 333

    (120) conditional_tail -> OTHERWISE LBRACE . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    RBRACE          reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 339
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 334

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE .

    NEWLINE         reduce using rule 121 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE .)


state 335

    (122) switch_condition -> SHIFT value COLON statements . switchcond_tail
    (123) switchcond_tail -> . empty
    (124) switchcond_tail -> . switch_condition
    (163) empty -> .
    (122) switch_condition -> . SHIFT value COLON statements switchcond_tail

    OTHERWISE       reduce using rule 163 (empty -> .)
    SHIFT           shift and go to state 304

    switchcond_tail                shift and go to state 340
    empty                          shift and go to state 341
    switch_condition               shift and go to state 342

state 336

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    RBRACE          reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 343
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 337

    (134) update_tail -> assign_op value .

    RPAREN          reduce using rule 134 (update_tail -> assign_op value .)


state 338

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 344


state 339

    (120) conditional_tail -> OTHERWISE LBRACE statements . RBRACE

    RBRACE          shift and go to state 345


state 340

    (122) switch_condition -> SHIFT value COLON statements switchcond_tail .

    OTHERWISE       reduce using rule 122 (switch_condition -> SHIFT value COLON statements switchcond_tail .)


state 341

    (123) switchcond_tail -> empty .

    OTHERWISE       reduce using rule 123 (switchcond_tail -> empty .)


state 342

    (124) switchcond_tail -> switch_condition .

    OTHERWISE       reduce using rule 124 (switchcond_tail -> switch_condition .)


state 343

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 346


state 344

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 347


state 345

    (120) conditional_tail -> OTHERWISE LBRACE statements RBRACE .

    NEWLINE         reduce using rule 120 (conditional_tail -> OTHERWISE LBRACE statements RBRACE .)


state 346

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 128 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE .)


state 347

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec NEWLINE statements_tail
    (163) empty -> .
    (115) local_dec -> . var_statement
    (116) local_dec -> . empty
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    RBRACE          reduce using rule 163 (empty -> .)
    NEWLINE         reduce using rule 163 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 348
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 348

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 349


state 349

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 119 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 15 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 17 resolved as shift
WARNING: shift/reduce conflict for AND in state 55 resolved as shift
WARNING: shift/reduce conflict for OR in state 55 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for EQ_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for GT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for LT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 135 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 244 resolved as shift
WARNING: reduce/reduce conflict in state 26 resolved using rule (global_dec -> empty)
WARNING: rejected rule (global_tail -> empty) in state 26
WARNING: reduce/reduce conflict in state 49 resolved using rule (global_value -> factor)
WARNING: rejected rule (empty -> <empty>) in state 49
WARNING: reduce/reduce conflict in state 144 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 144
WARNING: reduce/reduce conflict in state 157 resolved using rule (statements -> empty)
WARNING: rejected rule (statements_tail -> empty) in state 157
WARNING: reduce/reduce conflict in state 157 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 157
WARNING: reduce/reduce conflict in state 205 resolved using rule (value -> factor)
WARNING: rejected rule (empty -> <empty>) in state 205
WARNING: reduce/reduce conflict in state 272 resolved using rule (typecast_value -> IDENT)
WARNING: rejected rule (empty -> <empty>) in state 272
WARNING: reduce/reduce conflict in state 273 resolved using rule (typecast_value -> literal)
WARNING: rejected rule (factor -> literal) in state 273
WARNING: Rule (global_tail -> empty) is never reduced
WARNING: Rule (local_dec -> empty) is never reduced
WARNING: Rule (statements_tail -> empty) is never reduced
