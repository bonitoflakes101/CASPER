Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_tail -> empty
Rule 11    global_statement -> data_type IDENT global_statement_tail
Rule 12    global_statement_tail -> empty
Rule 13    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 14    global_statement_tail -> EQ global_dec_value global_tail2
Rule 15    global_tail2 -> empty
Rule 16    global_tail2 -> COMMA IDENT global_statement_tail
Rule 17    global_dec_value -> global_value
Rule 18    global_dec_value -> LBRACKET list_element RBRACKET
Rule 19    global_value -> factor
Rule 20    global_value -> expression
Rule 21    var_statement -> data_type IDENT var_tail
Rule 22    var_tail -> empty
Rule 23    var_tail -> EQ tail_value var_tail2
Rule 24    var_tail -> COMMA IDENT var_tail
Rule 25    var_tail2 -> empty
Rule 26    var_tail2 -> COMMA IDENT var_tail
Rule 27    tail_value -> value
Rule 28    tail_value -> LBRACKET list_element RBRACKET
Rule 29    list_element -> literal element_tail
Rule 30    element_tail -> empty
Rule 31    element_tail -> COMMA list_element
Rule 32    index -> INT_LIT
Rule 33    index -> IDENT
Rule 34    data_type -> INT
Rule 35    data_type -> FLT
Rule 36    data_type -> BLN
Rule 37    data_type -> CHR
Rule 38    data_type -> STR
Rule 39    value -> factor
Rule 40    value -> type_cast
Rule 41    value -> expression
Rule 42    value -> function_call
Rule 43    type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 44    type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 45    type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 46    type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 47    typecast_value -> IDENT
Rule 48    typecast_value -> literal
Rule 49    typecast_value -> expression
Rule 50    typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 51    typecast_value -> input_statement
Rule 52    literal -> INT_LIT
Rule 53    literal -> FLT_LIT
Rule 54    literal -> DAY
Rule 55    literal -> NIGHT
Rule 56    literal -> CHR_LIT
Rule 57    literal -> STR_LIT
Rule 58    expression -> expr_head expr_tail
Rule 59    expr_head -> term term_tail
Rule 60    term -> factor factor_tail
Rule 61    factor -> var_call
Rule 62    factor -> literal
Rule 63    factor -> TILDE literal
Rule 64    factor -> LPAREN expression RPAREN
Rule 65    factor_tail -> empty
Rule 66    factor_tail -> PLUS expression
Rule 67    factor_tail -> MINUS expression
Rule 68    factor_tail -> MULTIPLY expression
Rule 69    factor_tail -> DIVISION expression
Rule 70    factor_tail -> MODULO expression
Rule 71    factor_tail -> EXPONENT expression
Rule 72    term_tail -> empty
Rule 73    term_tail -> GT expression
Rule 74    term_tail -> LT expression
Rule 75    term_tail -> EQ_EQ expression
Rule 76    term_tail -> GT_EQ expression
Rule 77    term_tail -> LT_EQ expression
Rule 78    term_tail -> NOT_EQ expression
Rule 79    expr_tail -> empty
Rule 80    expr_tail -> AND expression
Rule 81    expr_tail -> OR expression
Rule 82    var_call -> IDENT var_call_tail
Rule 83    var_call_tail -> empty
Rule 84    var_call_tail -> LBRACKET index RBRACKET
Rule 85    function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
Rule 86    function_statements -> empty
Rule 87    ret_type -> FUNCTION
Rule 88    ret_type -> function_dtype
Rule 89    function_dtype -> FUNCTION_INT
Rule 90    function_dtype -> FUNCTION_FLT
Rule 91    function_dtype -> FUNCTION_CHR
Rule 92    function_dtype -> FUNCTION_BLN
Rule 93    function_dtype -> FUNCTION_STR
Rule 94    function_dtype -> FUNCTION_LIST_INT
Rule 95    function_dtype -> FUNCTION_LIST_FLT
Rule 96    function_dtype -> FUNCTION_LIST_CHR
Rule 97    function_dtype -> FUNCTION_LIST_STR
Rule 98    function_dtype -> FUNCTION_LIST_BLN
Rule 99    parameters -> data_type IDENT parameters_tail
Rule 100   parameters -> empty
Rule 101   parameters_tail -> empty
Rule 102   parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 103   revive -> REVIVE value
Rule 104   revive -> empty
Rule 105   statements -> empty
Rule 106   statements -> local_dec maybe_newline statements_tail
Rule 107   statements_tail -> empty
Rule 108   statements_tail -> local_dec maybe_newline statements_tail
Rule 109   statements_tail -> string_operation_statement unli_newline statements_tail
Rule 110   statements_tail -> conditional_statement unli_newline statements_tail
Rule 111   statements_tail -> switch_statement unli_newline statements_tail
Rule 112   statements_tail -> loop_statement unli_newline statements_tail
Rule 113   statements_tail -> function_call unli_newline statements_tail
Rule 114   statements_tail -> output_statement unli_newline statements_tail
Rule 115   local_dec -> empty
Rule 116   local_dec -> var_statement
Rule 117   conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
Rule 118   conditional_tail -> empty
Rule 119   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
Rule 120   conditional_tail -> OTHERWISE LBRACE maybe_newline statements RBRACE
Rule 121   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
Rule 122   switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail
Rule 123   switchcond_tail -> empty
Rule 124   switchcond_tail -> switch_condition
Rule 125   loop_statement -> for_loop
Rule 126   loop_statement -> until_loop
Rule 127   loop_statement -> repeat_until
Rule 128   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
Rule 129   until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
Rule 130   repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
Rule 131   control_variable -> INT IDENT EQ INT_LIT
Rule 132   update -> var_call update_tail
Rule 133   update_tail -> postfix
Rule 134   update_tail -> assign_op value
Rule 135   postfix -> PLUS_PLUS
Rule 136   postfix -> MINUS_MINUS
Rule 137   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 138   function_call -> input_statement
Rule 139   arguments -> empty
Rule 140   arguments -> arg_value arg_tail
Rule 141   arg_tail -> empty
Rule 142   arg_tail -> COMMA arg_value arg_tail
Rule 143   arg_value -> literal
Rule 144   arg_value -> var_call
Rule 145   output_statement -> DISPLAY value next_val
Rule 146   output_statement -> DISPLAY LPAREN value next_val RPAREN
Rule 147   next_val -> empty
Rule 148   next_val -> COMMA value next_val
Rule 149   input_statement -> INPUT LPAREN RPAREN
Rule 150   string_operation_statement -> var_call string_operation_tail
Rule 151   string_operation_tail -> assign_op value
Rule 152   string_operation_tail -> PLUS string_val stringcon_tail
Rule 153   string_operation_tail -> update_tail
Rule 154   assign_op -> PLUS_EQ
Rule 155   assign_op -> MINUS_EQ
Rule 156   assign_op -> MUL_EQ
Rule 157   assign_op -> DIV_EQ
Rule 158   assign_op -> MOD_EQ
Rule 159   assign_op -> EQ
Rule 160   stringcon_tail -> empty
Rule 161   stringcon_tail -> PLUS string_val stringcon_tail
Rule 162   string_val -> var_call
Rule 163   string_val -> STR_LIT
Rule 164   empty -> <empty>

Terminals, with rules where they appear

AND                  : 80
BIRTH                : 1
BLN                  : 36
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 117
CHR                  : 37
CHR_LIT              : 56
COLON                : 122
COMMA                : 13 16 24 26 31 102 142 148
COMMENT              : 
CONVERT_TO_BLN       : 45
CONVERT_TO_FLT       : 44
CONVERT_TO_INT       : 43
CONVERT_TO_STR       : 46
DAY                  : 54
DISPLAY              : 145 146
DIVISION             : 69
DIV_EQ               : 157
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 14 23 131 159
EQ_EQ                : 75
EXPONENT             : 71
FLT                  : 35
FLT_LIT              : 53
FOR                  : 128
FUNCTION             : 87
FUNCTION_BLN         : 92
FUNCTION_CHR         : 91
FUNCTION_FLT         : 90
FUNCTION_INT         : 89
FUNCTION_LIST_BLN    : 98
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 96
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 95
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 94
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 97
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 50 85 137
FUNCTION_STR         : 93
GHOST                : 1
GT                   : 73
GT_EQ                : 76
IDENT                : 11 13 16 21 24 26 33 47 82 99 102 121 131
ILLEGAL              : 
IN                   : 
INPUT                : 149
INT                  : 34 131
INT_LIT              : 32 52 131
LBRACE               : 6 85 117 119 120 121 121 128 129 130
LBRACKET             : 18 28 84
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 43 44 45 46 50 64 85 117 119 121 128 129 130 137 146 149
LT                   : 74
LT_EQ                : 77
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 67
MINUS_EQ             : 155
MINUS_MINUS          : 136
MODULO               : 70
MOD_EQ               : 158
MULTIPLY             : 68
MUL_EQ               : 156
NEWLINE              : 3 4 5
NIGHT                : 55
NOT                  : 
NOT_EQ               : 78
OR                   : 81
OTHERWISE            : 120 121
OTHERWISE_CHECK      : 119
PLUS                 : 66 152 161
PLUS_EQ              : 154
PLUS_PLUS            : 135
POW                  : 
RBRACE               : 6 85 117 119 120 121 121 128 129 130
RBRACKET             : 18 28 84
REPEAT               : 130
REVIVE               : 103
RPAREN               : 6 43 44 45 46 50 64 85 117 119 121 128 129 130 137 146 149
SEMICOLON            : 128 128
SHIFT                : 122
SKIP                 : 
STOP                 : 
STR                  : 38
STR_LIT              : 57 163
SWAP                 : 121
TILDE                : 63
TYPE                 : 
UNTIL                : 129 130
error                : 

Nonterminals, with rules where they appear

arg_tail             : 140 142
arg_value            : 140 142
arguments            : 137
assign_op            : 134 151
conditional_statement : 110
conditional_tail     : 117
control_variable     : 128
data_type            : 11 21 99 102
element_tail         : 29
empty                : 2 8 10 12 15 22 25 30 65 72 79 83 86 100 101 104 105 107 115 118 123 139 141 147 160
expr_head            : 58
expr_tail            : 58
expression           : 20 41 49 64 66 67 68 69 70 71 73 74 75 76 77 78 80 81 117 119 128 129 130
factor               : 19 39 60
factor_tail          : 60
for_loop             : 125
function_call        : 42 113
function_dtype       : 88
function_statements  : 1
global_dec           : 1 9
global_dec_value     : 14
global_statement     : 7
global_statement_tail : 11 13 16
global_tail          : 7
global_tail2         : 14
global_value         : 17
index                : 84
input_statement      : 51 138
list_element         : 18 28 31
literal              : 29 48 62 63 143
local_dec            : 106 108
loop_statement       : 112
main_function        : 1
maybe_newline        : 1 1 3 6 6 85 85 85 106 108 117 119 120 121 121 121 121 121 121 122 128 128 129 130
next_val             : 145 146 148
output_statement     : 114
parameters           : 85
parameters_tail      : 99 102
postfix              : 133
program              : 0
repeat_until         : 127
ret_type             : 85
revive               : 85
statements           : 6 85 117 119 120 121 122 128 129 130
statements_tail      : 106 108 109 110 111 112 113 114
string_operation_statement : 109
string_operation_tail : 150
string_val           : 152 161
stringcon_tail       : 152 161
switch_condition     : 121 124
switch_statement     : 111
switchcond_tail      : 122
tail_value           : 23
term                 : 59
term_tail            : 59
type_cast            : 40
typecast_value       : 43 44 45 46
unli_newline         : 1 1 5 7 85 109 110 111 112 113 114
until_loop           : 126
update               : 128
update_tail          : 132 153
value                : 27 103 122 134 145 146 148 151
var_call             : 61 132 144 150 162
var_call_tail        : 82
var_statement        : 116
var_tail             : 21 24 26
var_tail2            : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (11) global_statement -> . data_type IDENT global_statement_tail
    (164) empty -> .
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 164 (empty -> .)
    MAIN_CASPER     reduce using rule 164 (empty -> .)
    FUNCTION        reduce using rule 164 (empty -> .)
    FUNCTION_INT    reduce using rule 164 (empty -> .)
    FUNCTION_FLT    reduce using rule 164 (empty -> .)
    FUNCTION_CHR    reduce using rule 164 (empty -> .)
    FUNCTION_BLN    reduce using rule 164 (empty -> .)
    FUNCTION_STR    reduce using rule 164 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    INPUT           reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 14

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 164 (empty -> .)
    FUNCTION        reduce using rule 164 (empty -> .)
    FUNCTION_INT    reduce using rule 164 (empty -> .)
    FUNCTION_FLT    reduce using rule 164 (empty -> .)
    FUNCTION_CHR    reduce using rule 164 (empty -> .)
    FUNCTION_BLN    reduce using rule 164 (empty -> .)
    FUNCTION_STR    reduce using rule 164 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 15
    empty                          shift and go to state 16

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 18

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)


state 8

    (11) global_statement -> data_type . IDENT global_statement_tail

    IDENT           shift and go to state 19


state 9

    (34) data_type -> INT .

    IDENT           reduce using rule 34 (data_type -> INT .)


state 10

    (35) data_type -> FLT .

    IDENT           reduce using rule 35 (data_type -> FLT .)


state 11

    (36) data_type -> BLN .

    IDENT           reduce using rule 36 (data_type -> BLN .)


state 12

    (37) data_type -> CHR .

    IDENT           reduce using rule 37 (data_type -> CHR .)


state 13

    (38) data_type -> STR .

    IDENT           reduce using rule 38 (data_type -> STR .)


state 14

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    INPUT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 15

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (85) function_statements -> . maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (86) function_statements -> . empty
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 164 (empty -> .)
    FUNCTION        reduce using rule 164 (empty -> .)
    FUNCTION_INT    reduce using rule 164 (empty -> .)
    FUNCTION_FLT    reduce using rule 164 (empty -> .)
    FUNCTION_CHR    reduce using rule 164 (empty -> .)
    FUNCTION_BLN    reduce using rule 164 (empty -> .)
    FUNCTION_STR    reduce using rule 164 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 20
    function_statements            shift and go to state 21
    empty                          shift and go to state 22

state 16

    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    INPUT           reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)


state 17

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 164 (empty -> .)
    FUNCTION        reduce using rule 164 (empty -> .)
    FUNCTION_INT    reduce using rule 164 (empty -> .)
    FUNCTION_FLT    reduce using rule 164 (empty -> .)
    FUNCTION_CHR    reduce using rule 164 (empty -> .)
    FUNCTION_BLN    reduce using rule 164 (empty -> .)
    FUNCTION_STR    reduce using rule 164 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 164 (empty -> .)
    LBRACE          reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 23
    empty                          shift and go to state 16

state 18

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (10) global_tail -> . empty
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (164) empty -> .
    (11) global_statement -> . data_type IDENT global_statement_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 164 (empty -> .)
    MAIN_CASPER     reduce using rule 164 (empty -> .)
    FUNCTION        reduce using rule 164 (empty -> .)
    FUNCTION_INT    reduce using rule 164 (empty -> .)
    FUNCTION_FLT    reduce using rule 164 (empty -> .)
    FUNCTION_CHR    reduce using rule 164 (empty -> .)
    FUNCTION_BLN    reduce using rule 164 (empty -> .)
    FUNCTION_STR    reduce using rule 164 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 164 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 164 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 24
    global_dec                     shift and go to state 25
    empty                          shift and go to state 26
    data_type                      shift and go to state 8

state 19

    (11) global_statement -> data_type IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (164) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 164 (empty -> .)

    global_statement_tail          shift and go to state 27
    empty                          shift and go to state 28

state 20

    (85) function_statements -> maybe_newline . ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (87) ret_type -> . FUNCTION
    (88) ret_type -> . function_dtype
    (89) function_dtype -> . FUNCTION_INT
    (90) function_dtype -> . FUNCTION_FLT
    (91) function_dtype -> . FUNCTION_CHR
    (92) function_dtype -> . FUNCTION_BLN
    (93) function_dtype -> . FUNCTION_STR
    (94) function_dtype -> . FUNCTION_LIST_INT
    (95) function_dtype -> . FUNCTION_LIST_FLT
    (96) function_dtype -> . FUNCTION_LIST_CHR
    (97) function_dtype -> . FUNCTION_LIST_STR
    (98) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 32
    FUNCTION_INT    shift and go to state 34
    FUNCTION_FLT    shift and go to state 35
    FUNCTION_CHR    shift and go to state 36
    FUNCTION_BLN    shift and go to state 37
    FUNCTION_STR    shift and go to state 38
    FUNCTION_LIST_INT shift and go to state 39
    FUNCTION_LIST_FLT shift and go to state 40
    FUNCTION_LIST_CHR shift and go to state 41
    FUNCTION_LIST_STR shift and go to state 42
    FUNCTION_LIST_BLN shift and go to state 43

    ret_type                       shift and go to state 31
    function_dtype                 shift and go to state 33

state 21

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 44
    empty                          shift and go to state 16

state 22

    (86) function_statements -> empty .
    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 86 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 86 (function_statements -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)


state 23

    (3) maybe_newline -> NEWLINE maybe_newline .

    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INPUT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 24

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 25

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)


state 26

    (10) global_tail -> empty .
    (8) global_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_INT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_FLT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_CHR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_BLN resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_STR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_INT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_FLT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_CHR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_STR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_BLN resolved using rule 8 (global_dec -> empty .)
    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)

  ! NEWLINE         [ reduce using rule 10 (global_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION        [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_INT    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_FLT    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_CHR    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_BLN    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_STR    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_INT [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_FLT [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_CHR [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_STR [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_BLN [ reduce using rule 10 (global_tail -> empty .) ]


state 27

    (11) global_statement -> data_type IDENT global_statement_tail .

    NEWLINE         reduce using rule 11 (global_statement -> data_type IDENT global_statement_tail .)


state 28

    (12) global_statement_tail -> empty .

    NEWLINE         reduce using rule 12 (global_statement_tail -> empty .)


state 29

    (13) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 45


state 30

    (14) global_statement_tail -> EQ . global_dec_value global_tail2
    (17) global_dec_value -> . global_value
    (18) global_dec_value -> . LBRACKET list_element RBRACKET
    (19) global_value -> . factor
    (20) global_value -> . expression
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (58) expression -> . expr_head expr_tail
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail

    LBRACKET        shift and go to state 48
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    global_dec_value               shift and go to state 46
    global_value                   shift and go to state 47
    factor                         shift and go to state 49
    expression                     shift and go to state 50
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    term                           shift and go to state 63

state 31

    (85) function_statements -> maybe_newline ret_type . FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    FUNCTION_NAME   shift and go to state 64


state 32

    (87) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 87 (ret_type -> FUNCTION .)


state 33

    (88) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 88 (ret_type -> function_dtype .)


state 34

    (89) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 89 (function_dtype -> FUNCTION_INT .)


state 35

    (90) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 90 (function_dtype -> FUNCTION_FLT .)


state 36

    (91) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 91 (function_dtype -> FUNCTION_CHR .)


state 37

    (92) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 92 (function_dtype -> FUNCTION_BLN .)


state 38

    (93) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 93 (function_dtype -> FUNCTION_STR .)


state 39

    (94) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 94 (function_dtype -> FUNCTION_LIST_INT .)


state 40

    (95) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 95 (function_dtype -> FUNCTION_LIST_FLT .)


state 41

    (96) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 96 (function_dtype -> FUNCTION_LIST_CHR .)


state 42

    (97) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 97 (function_dtype -> FUNCTION_LIST_STR .)


state 43

    (98) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 98 (function_dtype -> FUNCTION_LIST_BLN .)


state 44

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 66

    main_function                  shift and go to state 65

state 45

    (13) global_statement_tail -> COMMA IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (164) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 164 (empty -> .)

    global_statement_tail          shift and go to state 67
    empty                          shift and go to state 28

state 46

    (14) global_statement_tail -> EQ global_dec_value . global_tail2
    (15) global_tail2 -> . empty
    (16) global_tail2 -> . COMMA IDENT global_statement_tail
    (164) empty -> .

    COMMA           shift and go to state 70
    NEWLINE         reduce using rule 164 (empty -> .)

    global_tail2                   shift and go to state 68
    empty                          shift and go to state 69

state 47

    (17) global_dec_value -> global_value .

    COMMA           reduce using rule 17 (global_dec_value -> global_value .)
    NEWLINE         reduce using rule 17 (global_dec_value -> global_value .)


state 48

    (18) global_dec_value -> LBRACKET . list_element RBRACKET
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 71
    literal                        shift and go to state 72

state 49

    (19) global_value -> factor .
    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (164) empty -> .

  ! reduce/reduce conflict for COMMA resolved using rule 19 (global_value -> factor .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 19 (global_value -> factor .)
    COMMA           reduce using rule 19 (global_value -> factor .)
    NEWLINE         reduce using rule 19 (global_value -> factor .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 164 (empty -> .)
    LT              reduce using rule 164 (empty -> .)
    EQ_EQ           reduce using rule 164 (empty -> .)
    GT_EQ           reduce using rule 164 (empty -> .)
    LT_EQ           reduce using rule 164 (empty -> .)
    NOT_EQ          reduce using rule 164 (empty -> .)
    AND             reduce using rule 164 (empty -> .)
    OR              reduce using rule 164 (empty -> .)

  ! COMMA           [ reduce using rule 164 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 50

    (20) global_value -> expression .

    COMMA           reduce using rule 20 (global_value -> expression .)
    NEWLINE         reduce using rule 20 (global_value -> expression .)


state 51

    (61) factor -> var_call .

    PLUS            reduce using rule 61 (factor -> var_call .)
    MINUS           reduce using rule 61 (factor -> var_call .)
    MULTIPLY        reduce using rule 61 (factor -> var_call .)
    DIVISION        reduce using rule 61 (factor -> var_call .)
    MODULO          reduce using rule 61 (factor -> var_call .)
    EXPONENT        reduce using rule 61 (factor -> var_call .)
    COMMA           reduce using rule 61 (factor -> var_call .)
    NEWLINE         reduce using rule 61 (factor -> var_call .)
    GT              reduce using rule 61 (factor -> var_call .)
    LT              reduce using rule 61 (factor -> var_call .)
    EQ_EQ           reduce using rule 61 (factor -> var_call .)
    GT_EQ           reduce using rule 61 (factor -> var_call .)
    LT_EQ           reduce using rule 61 (factor -> var_call .)
    NOT_EQ          reduce using rule 61 (factor -> var_call .)
    AND             reduce using rule 61 (factor -> var_call .)
    OR              reduce using rule 61 (factor -> var_call .)
    RPAREN          reduce using rule 61 (factor -> var_call .)
    CHECK           reduce using rule 61 (factor -> var_call .)
    SWAP            reduce using rule 61 (factor -> var_call .)
    FUNCTION_NAME   reduce using rule 61 (factor -> var_call .)
    DISPLAY         reduce using rule 61 (factor -> var_call .)
    IDENT           reduce using rule 61 (factor -> var_call .)
    FOR             reduce using rule 61 (factor -> var_call .)
    UNTIL           reduce using rule 61 (factor -> var_call .)
    REPEAT          reduce using rule 61 (factor -> var_call .)
    INPUT           reduce using rule 61 (factor -> var_call .)
    INT             reduce using rule 61 (factor -> var_call .)
    FLT             reduce using rule 61 (factor -> var_call .)
    BLN             reduce using rule 61 (factor -> var_call .)
    CHR             reduce using rule 61 (factor -> var_call .)
    STR             reduce using rule 61 (factor -> var_call .)
    RBRACE          reduce using rule 61 (factor -> var_call .)
    REVIVE          reduce using rule 61 (factor -> var_call .)
    SHIFT           reduce using rule 61 (factor -> var_call .)
    OTHERWISE       reduce using rule 61 (factor -> var_call .)
    COLON           reduce using rule 61 (factor -> var_call .)
    SEMICOLON       reduce using rule 61 (factor -> var_call .)


state 52

    (62) factor -> literal .

    PLUS            reduce using rule 62 (factor -> literal .)
    MINUS           reduce using rule 62 (factor -> literal .)
    MULTIPLY        reduce using rule 62 (factor -> literal .)
    DIVISION        reduce using rule 62 (factor -> literal .)
    MODULO          reduce using rule 62 (factor -> literal .)
    EXPONENT        reduce using rule 62 (factor -> literal .)
    COMMA           reduce using rule 62 (factor -> literal .)
    NEWLINE         reduce using rule 62 (factor -> literal .)
    GT              reduce using rule 62 (factor -> literal .)
    LT              reduce using rule 62 (factor -> literal .)
    EQ_EQ           reduce using rule 62 (factor -> literal .)
    GT_EQ           reduce using rule 62 (factor -> literal .)
    LT_EQ           reduce using rule 62 (factor -> literal .)
    NOT_EQ          reduce using rule 62 (factor -> literal .)
    AND             reduce using rule 62 (factor -> literal .)
    OR              reduce using rule 62 (factor -> literal .)
    RPAREN          reduce using rule 62 (factor -> literal .)
    CHECK           reduce using rule 62 (factor -> literal .)
    SWAP            reduce using rule 62 (factor -> literal .)
    FUNCTION_NAME   reduce using rule 62 (factor -> literal .)
    DISPLAY         reduce using rule 62 (factor -> literal .)
    IDENT           reduce using rule 62 (factor -> literal .)
    FOR             reduce using rule 62 (factor -> literal .)
    UNTIL           reduce using rule 62 (factor -> literal .)
    REPEAT          reduce using rule 62 (factor -> literal .)
    INPUT           reduce using rule 62 (factor -> literal .)
    INT             reduce using rule 62 (factor -> literal .)
    FLT             reduce using rule 62 (factor -> literal .)
    BLN             reduce using rule 62 (factor -> literal .)
    CHR             reduce using rule 62 (factor -> literal .)
    STR             reduce using rule 62 (factor -> literal .)
    RBRACE          reduce using rule 62 (factor -> literal .)
    REVIVE          reduce using rule 62 (factor -> literal .)
    SHIFT           reduce using rule 62 (factor -> literal .)
    OTHERWISE       reduce using rule 62 (factor -> literal .)
    COLON           reduce using rule 62 (factor -> literal .)
    SEMICOLON       reduce using rule 62 (factor -> literal .)


state 53

    (63) factor -> TILDE . literal
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    literal                        shift and go to state 81

state 54

    (64) factor -> LPAREN . expression RPAREN
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 82
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 55

    (58) expression -> expr_head . expr_tail
    (79) expr_tail -> . empty
    (80) expr_tail -> . AND expression
    (81) expr_tail -> . OR expression
    (164) empty -> .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    AND             shift and go to state 86
    OR              shift and go to state 87
    GT              reduce using rule 164 (empty -> .)
    LT              reduce using rule 164 (empty -> .)
    EQ_EQ           reduce using rule 164 (empty -> .)
    GT_EQ           reduce using rule 164 (empty -> .)
    LT_EQ           reduce using rule 164 (empty -> .)
    NOT_EQ          reduce using rule 164 (empty -> .)
    COMMA           reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    RPAREN          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    COLON           reduce using rule 164 (empty -> .)
    SEMICOLON       reduce using rule 164 (empty -> .)

  ! AND             [ reduce using rule 164 (empty -> .) ]
  ! OR              [ reduce using rule 164 (empty -> .) ]

    expr_tail                      shift and go to state 84
    empty                          shift and go to state 85

state 56

    (82) var_call -> IDENT . var_call_tail
    (83) var_call_tail -> . empty
    (84) var_call_tail -> . LBRACKET index RBRACKET
    (164) empty -> .

    LBRACKET        shift and go to state 90
    PLUS            reduce using rule 164 (empty -> .)
    MINUS           reduce using rule 164 (empty -> .)
    MULTIPLY        reduce using rule 164 (empty -> .)
    DIVISION        reduce using rule 164 (empty -> .)
    MODULO          reduce using rule 164 (empty -> .)
    EXPONENT        reduce using rule 164 (empty -> .)
    COMMA           reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    GT              reduce using rule 164 (empty -> .)
    LT              reduce using rule 164 (empty -> .)
    EQ_EQ           reduce using rule 164 (empty -> .)
    GT_EQ           reduce using rule 164 (empty -> .)
    LT_EQ           reduce using rule 164 (empty -> .)
    NOT_EQ          reduce using rule 164 (empty -> .)
    AND             reduce using rule 164 (empty -> .)
    OR              reduce using rule 164 (empty -> .)
    RPAREN          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    COLON           reduce using rule 164 (empty -> .)
    SEMICOLON       reduce using rule 164 (empty -> .)
    PLUS_EQ         reduce using rule 164 (empty -> .)
    MINUS_EQ        reduce using rule 164 (empty -> .)
    MUL_EQ          reduce using rule 164 (empty -> .)
    DIV_EQ          reduce using rule 164 (empty -> .)
    MOD_EQ          reduce using rule 164 (empty -> .)
    EQ              reduce using rule 164 (empty -> .)
    PLUS_PLUS       reduce using rule 164 (empty -> .)
    MINUS_MINUS     reduce using rule 164 (empty -> .)

    var_call_tail                  shift and go to state 88
    empty                          shift and go to state 89

state 57

    (52) literal -> INT_LIT .

    PLUS            reduce using rule 52 (literal -> INT_LIT .)
    MINUS           reduce using rule 52 (literal -> INT_LIT .)
    MULTIPLY        reduce using rule 52 (literal -> INT_LIT .)
    DIVISION        reduce using rule 52 (literal -> INT_LIT .)
    MODULO          reduce using rule 52 (literal -> INT_LIT .)
    EXPONENT        reduce using rule 52 (literal -> INT_LIT .)
    COMMA           reduce using rule 52 (literal -> INT_LIT .)
    NEWLINE         reduce using rule 52 (literal -> INT_LIT .)
    GT              reduce using rule 52 (literal -> INT_LIT .)
    LT              reduce using rule 52 (literal -> INT_LIT .)
    EQ_EQ           reduce using rule 52 (literal -> INT_LIT .)
    GT_EQ           reduce using rule 52 (literal -> INT_LIT .)
    LT_EQ           reduce using rule 52 (literal -> INT_LIT .)
    NOT_EQ          reduce using rule 52 (literal -> INT_LIT .)
    AND             reduce using rule 52 (literal -> INT_LIT .)
    OR              reduce using rule 52 (literal -> INT_LIT .)
    RBRACKET        reduce using rule 52 (literal -> INT_LIT .)
    RPAREN          reduce using rule 52 (literal -> INT_LIT .)
    CHECK           reduce using rule 52 (literal -> INT_LIT .)
    SWAP            reduce using rule 52 (literal -> INT_LIT .)
    FUNCTION_NAME   reduce using rule 52 (literal -> INT_LIT .)
    DISPLAY         reduce using rule 52 (literal -> INT_LIT .)
    IDENT           reduce using rule 52 (literal -> INT_LIT .)
    FOR             reduce using rule 52 (literal -> INT_LIT .)
    UNTIL           reduce using rule 52 (literal -> INT_LIT .)
    REPEAT          reduce using rule 52 (literal -> INT_LIT .)
    INPUT           reduce using rule 52 (literal -> INT_LIT .)
    INT             reduce using rule 52 (literal -> INT_LIT .)
    FLT             reduce using rule 52 (literal -> INT_LIT .)
    BLN             reduce using rule 52 (literal -> INT_LIT .)
    CHR             reduce using rule 52 (literal -> INT_LIT .)
    STR             reduce using rule 52 (literal -> INT_LIT .)
    RBRACE          reduce using rule 52 (literal -> INT_LIT .)
    REVIVE          reduce using rule 52 (literal -> INT_LIT .)
    SHIFT           reduce using rule 52 (literal -> INT_LIT .)
    OTHERWISE       reduce using rule 52 (literal -> INT_LIT .)
    COLON           reduce using rule 52 (literal -> INT_LIT .)
    SEMICOLON       reduce using rule 52 (literal -> INT_LIT .)


state 58

    (53) literal -> FLT_LIT .

    PLUS            reduce using rule 53 (literal -> FLT_LIT .)
    MINUS           reduce using rule 53 (literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 53 (literal -> FLT_LIT .)
    DIVISION        reduce using rule 53 (literal -> FLT_LIT .)
    MODULO          reduce using rule 53 (literal -> FLT_LIT .)
    EXPONENT        reduce using rule 53 (literal -> FLT_LIT .)
    COMMA           reduce using rule 53 (literal -> FLT_LIT .)
    NEWLINE         reduce using rule 53 (literal -> FLT_LIT .)
    GT              reduce using rule 53 (literal -> FLT_LIT .)
    LT              reduce using rule 53 (literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    GT_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    LT_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 53 (literal -> FLT_LIT .)
    AND             reduce using rule 53 (literal -> FLT_LIT .)
    OR              reduce using rule 53 (literal -> FLT_LIT .)
    RBRACKET        reduce using rule 53 (literal -> FLT_LIT .)
    RPAREN          reduce using rule 53 (literal -> FLT_LIT .)
    CHECK           reduce using rule 53 (literal -> FLT_LIT .)
    SWAP            reduce using rule 53 (literal -> FLT_LIT .)
    FUNCTION_NAME   reduce using rule 53 (literal -> FLT_LIT .)
    DISPLAY         reduce using rule 53 (literal -> FLT_LIT .)
    IDENT           reduce using rule 53 (literal -> FLT_LIT .)
    FOR             reduce using rule 53 (literal -> FLT_LIT .)
    UNTIL           reduce using rule 53 (literal -> FLT_LIT .)
    REPEAT          reduce using rule 53 (literal -> FLT_LIT .)
    INPUT           reduce using rule 53 (literal -> FLT_LIT .)
    INT             reduce using rule 53 (literal -> FLT_LIT .)
    FLT             reduce using rule 53 (literal -> FLT_LIT .)
    BLN             reduce using rule 53 (literal -> FLT_LIT .)
    CHR             reduce using rule 53 (literal -> FLT_LIT .)
    STR             reduce using rule 53 (literal -> FLT_LIT .)
    RBRACE          reduce using rule 53 (literal -> FLT_LIT .)
    REVIVE          reduce using rule 53 (literal -> FLT_LIT .)
    SHIFT           reduce using rule 53 (literal -> FLT_LIT .)
    OTHERWISE       reduce using rule 53 (literal -> FLT_LIT .)
    COLON           reduce using rule 53 (literal -> FLT_LIT .)
    SEMICOLON       reduce using rule 53 (literal -> FLT_LIT .)


state 59

    (54) literal -> DAY .

    PLUS            reduce using rule 54 (literal -> DAY .)
    MINUS           reduce using rule 54 (literal -> DAY .)
    MULTIPLY        reduce using rule 54 (literal -> DAY .)
    DIVISION        reduce using rule 54 (literal -> DAY .)
    MODULO          reduce using rule 54 (literal -> DAY .)
    EXPONENT        reduce using rule 54 (literal -> DAY .)
    COMMA           reduce using rule 54 (literal -> DAY .)
    NEWLINE         reduce using rule 54 (literal -> DAY .)
    GT              reduce using rule 54 (literal -> DAY .)
    LT              reduce using rule 54 (literal -> DAY .)
    EQ_EQ           reduce using rule 54 (literal -> DAY .)
    GT_EQ           reduce using rule 54 (literal -> DAY .)
    LT_EQ           reduce using rule 54 (literal -> DAY .)
    NOT_EQ          reduce using rule 54 (literal -> DAY .)
    AND             reduce using rule 54 (literal -> DAY .)
    OR              reduce using rule 54 (literal -> DAY .)
    RBRACKET        reduce using rule 54 (literal -> DAY .)
    RPAREN          reduce using rule 54 (literal -> DAY .)
    CHECK           reduce using rule 54 (literal -> DAY .)
    SWAP            reduce using rule 54 (literal -> DAY .)
    FUNCTION_NAME   reduce using rule 54 (literal -> DAY .)
    DISPLAY         reduce using rule 54 (literal -> DAY .)
    IDENT           reduce using rule 54 (literal -> DAY .)
    FOR             reduce using rule 54 (literal -> DAY .)
    UNTIL           reduce using rule 54 (literal -> DAY .)
    REPEAT          reduce using rule 54 (literal -> DAY .)
    INPUT           reduce using rule 54 (literal -> DAY .)
    INT             reduce using rule 54 (literal -> DAY .)
    FLT             reduce using rule 54 (literal -> DAY .)
    BLN             reduce using rule 54 (literal -> DAY .)
    CHR             reduce using rule 54 (literal -> DAY .)
    STR             reduce using rule 54 (literal -> DAY .)
    RBRACE          reduce using rule 54 (literal -> DAY .)
    REVIVE          reduce using rule 54 (literal -> DAY .)
    SHIFT           reduce using rule 54 (literal -> DAY .)
    OTHERWISE       reduce using rule 54 (literal -> DAY .)
    COLON           reduce using rule 54 (literal -> DAY .)
    SEMICOLON       reduce using rule 54 (literal -> DAY .)


state 60

    (55) literal -> NIGHT .

    PLUS            reduce using rule 55 (literal -> NIGHT .)
    MINUS           reduce using rule 55 (literal -> NIGHT .)
    MULTIPLY        reduce using rule 55 (literal -> NIGHT .)
    DIVISION        reduce using rule 55 (literal -> NIGHT .)
    MODULO          reduce using rule 55 (literal -> NIGHT .)
    EXPONENT        reduce using rule 55 (literal -> NIGHT .)
    COMMA           reduce using rule 55 (literal -> NIGHT .)
    NEWLINE         reduce using rule 55 (literal -> NIGHT .)
    GT              reduce using rule 55 (literal -> NIGHT .)
    LT              reduce using rule 55 (literal -> NIGHT .)
    EQ_EQ           reduce using rule 55 (literal -> NIGHT .)
    GT_EQ           reduce using rule 55 (literal -> NIGHT .)
    LT_EQ           reduce using rule 55 (literal -> NIGHT .)
    NOT_EQ          reduce using rule 55 (literal -> NIGHT .)
    AND             reduce using rule 55 (literal -> NIGHT .)
    OR              reduce using rule 55 (literal -> NIGHT .)
    RBRACKET        reduce using rule 55 (literal -> NIGHT .)
    RPAREN          reduce using rule 55 (literal -> NIGHT .)
    CHECK           reduce using rule 55 (literal -> NIGHT .)
    SWAP            reduce using rule 55 (literal -> NIGHT .)
    FUNCTION_NAME   reduce using rule 55 (literal -> NIGHT .)
    DISPLAY         reduce using rule 55 (literal -> NIGHT .)
    IDENT           reduce using rule 55 (literal -> NIGHT .)
    FOR             reduce using rule 55 (literal -> NIGHT .)
    UNTIL           reduce using rule 55 (literal -> NIGHT .)
    REPEAT          reduce using rule 55 (literal -> NIGHT .)
    INPUT           reduce using rule 55 (literal -> NIGHT .)
    INT             reduce using rule 55 (literal -> NIGHT .)
    FLT             reduce using rule 55 (literal -> NIGHT .)
    BLN             reduce using rule 55 (literal -> NIGHT .)
    CHR             reduce using rule 55 (literal -> NIGHT .)
    STR             reduce using rule 55 (literal -> NIGHT .)
    RBRACE          reduce using rule 55 (literal -> NIGHT .)
    REVIVE          reduce using rule 55 (literal -> NIGHT .)
    SHIFT           reduce using rule 55 (literal -> NIGHT .)
    OTHERWISE       reduce using rule 55 (literal -> NIGHT .)
    COLON           reduce using rule 55 (literal -> NIGHT .)
    SEMICOLON       reduce using rule 55 (literal -> NIGHT .)


state 61

    (56) literal -> CHR_LIT .

    PLUS            reduce using rule 56 (literal -> CHR_LIT .)
    MINUS           reduce using rule 56 (literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 56 (literal -> CHR_LIT .)
    DIVISION        reduce using rule 56 (literal -> CHR_LIT .)
    MODULO          reduce using rule 56 (literal -> CHR_LIT .)
    EXPONENT        reduce using rule 56 (literal -> CHR_LIT .)
    COMMA           reduce using rule 56 (literal -> CHR_LIT .)
    NEWLINE         reduce using rule 56 (literal -> CHR_LIT .)
    GT              reduce using rule 56 (literal -> CHR_LIT .)
    LT              reduce using rule 56 (literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    GT_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    LT_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 56 (literal -> CHR_LIT .)
    AND             reduce using rule 56 (literal -> CHR_LIT .)
    OR              reduce using rule 56 (literal -> CHR_LIT .)
    RBRACKET        reduce using rule 56 (literal -> CHR_LIT .)
    RPAREN          reduce using rule 56 (literal -> CHR_LIT .)
    CHECK           reduce using rule 56 (literal -> CHR_LIT .)
    SWAP            reduce using rule 56 (literal -> CHR_LIT .)
    FUNCTION_NAME   reduce using rule 56 (literal -> CHR_LIT .)
    DISPLAY         reduce using rule 56 (literal -> CHR_LIT .)
    IDENT           reduce using rule 56 (literal -> CHR_LIT .)
    FOR             reduce using rule 56 (literal -> CHR_LIT .)
    UNTIL           reduce using rule 56 (literal -> CHR_LIT .)
    REPEAT          reduce using rule 56 (literal -> CHR_LIT .)
    INPUT           reduce using rule 56 (literal -> CHR_LIT .)
    INT             reduce using rule 56 (literal -> CHR_LIT .)
    FLT             reduce using rule 56 (literal -> CHR_LIT .)
    BLN             reduce using rule 56 (literal -> CHR_LIT .)
    CHR             reduce using rule 56 (literal -> CHR_LIT .)
    STR             reduce using rule 56 (literal -> CHR_LIT .)
    RBRACE          reduce using rule 56 (literal -> CHR_LIT .)
    REVIVE          reduce using rule 56 (literal -> CHR_LIT .)
    SHIFT           reduce using rule 56 (literal -> CHR_LIT .)
    OTHERWISE       reduce using rule 56 (literal -> CHR_LIT .)
    COLON           reduce using rule 56 (literal -> CHR_LIT .)
    SEMICOLON       reduce using rule 56 (literal -> CHR_LIT .)


state 62

    (57) literal -> STR_LIT .

    PLUS            reduce using rule 57 (literal -> STR_LIT .)
    MINUS           reduce using rule 57 (literal -> STR_LIT .)
    MULTIPLY        reduce using rule 57 (literal -> STR_LIT .)
    DIVISION        reduce using rule 57 (literal -> STR_LIT .)
    MODULO          reduce using rule 57 (literal -> STR_LIT .)
    EXPONENT        reduce using rule 57 (literal -> STR_LIT .)
    COMMA           reduce using rule 57 (literal -> STR_LIT .)
    NEWLINE         reduce using rule 57 (literal -> STR_LIT .)
    GT              reduce using rule 57 (literal -> STR_LIT .)
    LT              reduce using rule 57 (literal -> STR_LIT .)
    EQ_EQ           reduce using rule 57 (literal -> STR_LIT .)
    GT_EQ           reduce using rule 57 (literal -> STR_LIT .)
    LT_EQ           reduce using rule 57 (literal -> STR_LIT .)
    NOT_EQ          reduce using rule 57 (literal -> STR_LIT .)
    AND             reduce using rule 57 (literal -> STR_LIT .)
    OR              reduce using rule 57 (literal -> STR_LIT .)
    RBRACKET        reduce using rule 57 (literal -> STR_LIT .)
    RPAREN          reduce using rule 57 (literal -> STR_LIT .)
    CHECK           reduce using rule 57 (literal -> STR_LIT .)
    SWAP            reduce using rule 57 (literal -> STR_LIT .)
    FUNCTION_NAME   reduce using rule 57 (literal -> STR_LIT .)
    DISPLAY         reduce using rule 57 (literal -> STR_LIT .)
    IDENT           reduce using rule 57 (literal -> STR_LIT .)
    FOR             reduce using rule 57 (literal -> STR_LIT .)
    UNTIL           reduce using rule 57 (literal -> STR_LIT .)
    REPEAT          reduce using rule 57 (literal -> STR_LIT .)
    INPUT           reduce using rule 57 (literal -> STR_LIT .)
    INT             reduce using rule 57 (literal -> STR_LIT .)
    FLT             reduce using rule 57 (literal -> STR_LIT .)
    BLN             reduce using rule 57 (literal -> STR_LIT .)
    CHR             reduce using rule 57 (literal -> STR_LIT .)
    STR             reduce using rule 57 (literal -> STR_LIT .)
    RBRACE          reduce using rule 57 (literal -> STR_LIT .)
    REVIVE          reduce using rule 57 (literal -> STR_LIT .)
    SHIFT           reduce using rule 57 (literal -> STR_LIT .)
    OTHERWISE       reduce using rule 57 (literal -> STR_LIT .)
    COLON           reduce using rule 57 (literal -> STR_LIT .)
    SEMICOLON       reduce using rule 57 (literal -> STR_LIT .)


state 63

    (59) expr_head -> term . term_tail
    (72) term_tail -> . empty
    (73) term_tail -> . GT expression
    (74) term_tail -> . LT expression
    (75) term_tail -> . EQ_EQ expression
    (76) term_tail -> . GT_EQ expression
    (77) term_tail -> . LT_EQ expression
    (78) term_tail -> . NOT_EQ expression
    (164) empty -> .

  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ_EQ resolved as shift
  ! shift/reduce conflict for GT_EQ resolved as shift
  ! shift/reduce conflict for LT_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
    GT              shift and go to state 93
    LT              shift and go to state 94
    EQ_EQ           shift and go to state 95
    GT_EQ           shift and go to state 96
    LT_EQ           shift and go to state 97
    NOT_EQ          shift and go to state 98
    AND             reduce using rule 164 (empty -> .)
    OR              reduce using rule 164 (empty -> .)
    COMMA           reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    RPAREN          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    COLON           reduce using rule 164 (empty -> .)
    SEMICOLON       reduce using rule 164 (empty -> .)

  ! GT              [ reduce using rule 164 (empty -> .) ]
  ! LT              [ reduce using rule 164 (empty -> .) ]
  ! EQ_EQ           [ reduce using rule 164 (empty -> .) ]
  ! GT_EQ           [ reduce using rule 164 (empty -> .) ]
  ! LT_EQ           [ reduce using rule 164 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 164 (empty -> .) ]

    term_tail                      shift and go to state 91
    empty                          shift and go to state 92

state 64

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME . LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    LPAREN          shift and go to state 99


state 65

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 100

state 66

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 101


state 67

    (13) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 13 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 68

    (14) global_statement_tail -> EQ global_dec_value global_tail2 .

    NEWLINE         reduce using rule 14 (global_statement_tail -> EQ global_dec_value global_tail2 .)


state 69

    (15) global_tail2 -> empty .

    NEWLINE         reduce using rule 15 (global_tail2 -> empty .)


state 70

    (16) global_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 102


state 71

    (18) global_dec_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 103


state 72

    (29) list_element -> literal . element_tail
    (30) element_tail -> . empty
    (31) element_tail -> . COMMA list_element
    (164) empty -> .

    COMMA           shift and go to state 106
    RBRACKET        reduce using rule 164 (empty -> .)

    element_tail                   shift and go to state 104
    empty                          shift and go to state 105

state 73

    (60) term -> factor factor_tail .

    GT              reduce using rule 60 (term -> factor factor_tail .)
    LT              reduce using rule 60 (term -> factor factor_tail .)
    EQ_EQ           reduce using rule 60 (term -> factor factor_tail .)
    GT_EQ           reduce using rule 60 (term -> factor factor_tail .)
    LT_EQ           reduce using rule 60 (term -> factor factor_tail .)
    NOT_EQ          reduce using rule 60 (term -> factor factor_tail .)
    AND             reduce using rule 60 (term -> factor factor_tail .)
    OR              reduce using rule 60 (term -> factor factor_tail .)
    COMMA           reduce using rule 60 (term -> factor factor_tail .)
    NEWLINE         reduce using rule 60 (term -> factor factor_tail .)
    RPAREN          reduce using rule 60 (term -> factor factor_tail .)
    CHECK           reduce using rule 60 (term -> factor factor_tail .)
    SWAP            reduce using rule 60 (term -> factor factor_tail .)
    FUNCTION_NAME   reduce using rule 60 (term -> factor factor_tail .)
    DISPLAY         reduce using rule 60 (term -> factor factor_tail .)
    IDENT           reduce using rule 60 (term -> factor factor_tail .)
    FOR             reduce using rule 60 (term -> factor factor_tail .)
    UNTIL           reduce using rule 60 (term -> factor factor_tail .)
    REPEAT          reduce using rule 60 (term -> factor factor_tail .)
    INPUT           reduce using rule 60 (term -> factor factor_tail .)
    INT             reduce using rule 60 (term -> factor factor_tail .)
    FLT             reduce using rule 60 (term -> factor factor_tail .)
    BLN             reduce using rule 60 (term -> factor factor_tail .)
    CHR             reduce using rule 60 (term -> factor factor_tail .)
    STR             reduce using rule 60 (term -> factor factor_tail .)
    RBRACE          reduce using rule 60 (term -> factor factor_tail .)
    REVIVE          reduce using rule 60 (term -> factor factor_tail .)
    SHIFT           reduce using rule 60 (term -> factor factor_tail .)
    OTHERWISE       reduce using rule 60 (term -> factor factor_tail .)
    COLON           reduce using rule 60 (term -> factor factor_tail .)
    SEMICOLON       reduce using rule 60 (term -> factor factor_tail .)


state 74

    (65) factor_tail -> empty .

    GT              reduce using rule 65 (factor_tail -> empty .)
    LT              reduce using rule 65 (factor_tail -> empty .)
    EQ_EQ           reduce using rule 65 (factor_tail -> empty .)
    GT_EQ           reduce using rule 65 (factor_tail -> empty .)
    LT_EQ           reduce using rule 65 (factor_tail -> empty .)
    NOT_EQ          reduce using rule 65 (factor_tail -> empty .)
    AND             reduce using rule 65 (factor_tail -> empty .)
    OR              reduce using rule 65 (factor_tail -> empty .)
    COMMA           reduce using rule 65 (factor_tail -> empty .)
    NEWLINE         reduce using rule 65 (factor_tail -> empty .)
    RPAREN          reduce using rule 65 (factor_tail -> empty .)
    CHECK           reduce using rule 65 (factor_tail -> empty .)
    SWAP            reduce using rule 65 (factor_tail -> empty .)
    FUNCTION_NAME   reduce using rule 65 (factor_tail -> empty .)
    DISPLAY         reduce using rule 65 (factor_tail -> empty .)
    IDENT           reduce using rule 65 (factor_tail -> empty .)
    FOR             reduce using rule 65 (factor_tail -> empty .)
    UNTIL           reduce using rule 65 (factor_tail -> empty .)
    REPEAT          reduce using rule 65 (factor_tail -> empty .)
    INPUT           reduce using rule 65 (factor_tail -> empty .)
    INT             reduce using rule 65 (factor_tail -> empty .)
    FLT             reduce using rule 65 (factor_tail -> empty .)
    BLN             reduce using rule 65 (factor_tail -> empty .)
    CHR             reduce using rule 65 (factor_tail -> empty .)
    STR             reduce using rule 65 (factor_tail -> empty .)
    RBRACE          reduce using rule 65 (factor_tail -> empty .)
    REVIVE          reduce using rule 65 (factor_tail -> empty .)
    SHIFT           reduce using rule 65 (factor_tail -> empty .)
    OTHERWISE       reduce using rule 65 (factor_tail -> empty .)
    COLON           reduce using rule 65 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 65 (factor_tail -> empty .)


state 75

    (66) factor_tail -> PLUS . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 107
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 76

    (67) factor_tail -> MINUS . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 108
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 77

    (68) factor_tail -> MULTIPLY . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 109
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 78

    (69) factor_tail -> DIVISION . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 110
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 79

    (70) factor_tail -> MODULO . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 111
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 80

    (71) factor_tail -> EXPONENT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 112
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 81

    (63) factor -> TILDE literal .

    PLUS            reduce using rule 63 (factor -> TILDE literal .)
    MINUS           reduce using rule 63 (factor -> TILDE literal .)
    MULTIPLY        reduce using rule 63 (factor -> TILDE literal .)
    DIVISION        reduce using rule 63 (factor -> TILDE literal .)
    MODULO          reduce using rule 63 (factor -> TILDE literal .)
    EXPONENT        reduce using rule 63 (factor -> TILDE literal .)
    COMMA           reduce using rule 63 (factor -> TILDE literal .)
    NEWLINE         reduce using rule 63 (factor -> TILDE literal .)
    GT              reduce using rule 63 (factor -> TILDE literal .)
    LT              reduce using rule 63 (factor -> TILDE literal .)
    EQ_EQ           reduce using rule 63 (factor -> TILDE literal .)
    GT_EQ           reduce using rule 63 (factor -> TILDE literal .)
    LT_EQ           reduce using rule 63 (factor -> TILDE literal .)
    NOT_EQ          reduce using rule 63 (factor -> TILDE literal .)
    AND             reduce using rule 63 (factor -> TILDE literal .)
    OR              reduce using rule 63 (factor -> TILDE literal .)
    RPAREN          reduce using rule 63 (factor -> TILDE literal .)
    CHECK           reduce using rule 63 (factor -> TILDE literal .)
    SWAP            reduce using rule 63 (factor -> TILDE literal .)
    FUNCTION_NAME   reduce using rule 63 (factor -> TILDE literal .)
    DISPLAY         reduce using rule 63 (factor -> TILDE literal .)
    IDENT           reduce using rule 63 (factor -> TILDE literal .)
    FOR             reduce using rule 63 (factor -> TILDE literal .)
    UNTIL           reduce using rule 63 (factor -> TILDE literal .)
    REPEAT          reduce using rule 63 (factor -> TILDE literal .)
    INPUT           reduce using rule 63 (factor -> TILDE literal .)
    INT             reduce using rule 63 (factor -> TILDE literal .)
    FLT             reduce using rule 63 (factor -> TILDE literal .)
    BLN             reduce using rule 63 (factor -> TILDE literal .)
    CHR             reduce using rule 63 (factor -> TILDE literal .)
    STR             reduce using rule 63 (factor -> TILDE literal .)
    RBRACE          reduce using rule 63 (factor -> TILDE literal .)
    REVIVE          reduce using rule 63 (factor -> TILDE literal .)
    SHIFT           reduce using rule 63 (factor -> TILDE literal .)
    OTHERWISE       reduce using rule 63 (factor -> TILDE literal .)
    COLON           reduce using rule 63 (factor -> TILDE literal .)
    SEMICOLON       reduce using rule 63 (factor -> TILDE literal .)


state 82

    (64) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 113


state 83

    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (164) empty -> .

    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 164 (empty -> .)
    LT              reduce using rule 164 (empty -> .)
    EQ_EQ           reduce using rule 164 (empty -> .)
    GT_EQ           reduce using rule 164 (empty -> .)
    LT_EQ           reduce using rule 164 (empty -> .)
    NOT_EQ          reduce using rule 164 (empty -> .)
    AND             reduce using rule 164 (empty -> .)
    OR              reduce using rule 164 (empty -> .)
    COMMA           reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    RPAREN          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    COLON           reduce using rule 164 (empty -> .)
    SEMICOLON       reduce using rule 164 (empty -> .)

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 84

    (58) expression -> expr_head expr_tail .

    COMMA           reduce using rule 58 (expression -> expr_head expr_tail .)
    NEWLINE         reduce using rule 58 (expression -> expr_head expr_tail .)
    RPAREN          reduce using rule 58 (expression -> expr_head expr_tail .)
    GT              reduce using rule 58 (expression -> expr_head expr_tail .)
    LT              reduce using rule 58 (expression -> expr_head expr_tail .)
    EQ_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    GT_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    LT_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    NOT_EQ          reduce using rule 58 (expression -> expr_head expr_tail .)
    AND             reduce using rule 58 (expression -> expr_head expr_tail .)
    OR              reduce using rule 58 (expression -> expr_head expr_tail .)
    CHECK           reduce using rule 58 (expression -> expr_head expr_tail .)
    SWAP            reduce using rule 58 (expression -> expr_head expr_tail .)
    FUNCTION_NAME   reduce using rule 58 (expression -> expr_head expr_tail .)
    DISPLAY         reduce using rule 58 (expression -> expr_head expr_tail .)
    IDENT           reduce using rule 58 (expression -> expr_head expr_tail .)
    FOR             reduce using rule 58 (expression -> expr_head expr_tail .)
    UNTIL           reduce using rule 58 (expression -> expr_head expr_tail .)
    REPEAT          reduce using rule 58 (expression -> expr_head expr_tail .)
    INPUT           reduce using rule 58 (expression -> expr_head expr_tail .)
    INT             reduce using rule 58 (expression -> expr_head expr_tail .)
    FLT             reduce using rule 58 (expression -> expr_head expr_tail .)
    BLN             reduce using rule 58 (expression -> expr_head expr_tail .)
    CHR             reduce using rule 58 (expression -> expr_head expr_tail .)
    STR             reduce using rule 58 (expression -> expr_head expr_tail .)
    RBRACE          reduce using rule 58 (expression -> expr_head expr_tail .)
    REVIVE          reduce using rule 58 (expression -> expr_head expr_tail .)
    SHIFT           reduce using rule 58 (expression -> expr_head expr_tail .)
    OTHERWISE       reduce using rule 58 (expression -> expr_head expr_tail .)
    COLON           reduce using rule 58 (expression -> expr_head expr_tail .)
    SEMICOLON       reduce using rule 58 (expression -> expr_head expr_tail .)


state 85

    (79) expr_tail -> empty .

    GT              reduce using rule 79 (expr_tail -> empty .)
    LT              reduce using rule 79 (expr_tail -> empty .)
    EQ_EQ           reduce using rule 79 (expr_tail -> empty .)
    GT_EQ           reduce using rule 79 (expr_tail -> empty .)
    LT_EQ           reduce using rule 79 (expr_tail -> empty .)
    NOT_EQ          reduce using rule 79 (expr_tail -> empty .)
    AND             reduce using rule 79 (expr_tail -> empty .)
    OR              reduce using rule 79 (expr_tail -> empty .)
    COMMA           reduce using rule 79 (expr_tail -> empty .)
    NEWLINE         reduce using rule 79 (expr_tail -> empty .)
    RPAREN          reduce using rule 79 (expr_tail -> empty .)
    CHECK           reduce using rule 79 (expr_tail -> empty .)
    SWAP            reduce using rule 79 (expr_tail -> empty .)
    FUNCTION_NAME   reduce using rule 79 (expr_tail -> empty .)
    DISPLAY         reduce using rule 79 (expr_tail -> empty .)
    IDENT           reduce using rule 79 (expr_tail -> empty .)
    FOR             reduce using rule 79 (expr_tail -> empty .)
    UNTIL           reduce using rule 79 (expr_tail -> empty .)
    REPEAT          reduce using rule 79 (expr_tail -> empty .)
    INPUT           reduce using rule 79 (expr_tail -> empty .)
    INT             reduce using rule 79 (expr_tail -> empty .)
    FLT             reduce using rule 79 (expr_tail -> empty .)
    BLN             reduce using rule 79 (expr_tail -> empty .)
    CHR             reduce using rule 79 (expr_tail -> empty .)
    STR             reduce using rule 79 (expr_tail -> empty .)
    RBRACE          reduce using rule 79 (expr_tail -> empty .)
    REVIVE          reduce using rule 79 (expr_tail -> empty .)
    SHIFT           reduce using rule 79 (expr_tail -> empty .)
    OTHERWISE       reduce using rule 79 (expr_tail -> empty .)
    COLON           reduce using rule 79 (expr_tail -> empty .)
    SEMICOLON       reduce using rule 79 (expr_tail -> empty .)


state 86

    (80) expr_tail -> AND . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 114
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 87

    (81) expr_tail -> OR . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 115
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 88

    (82) var_call -> IDENT var_call_tail .

    PLUS            reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MULTIPLY        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    DIVISION        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MODULO          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EXPONENT        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    COMMA           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    NEWLINE         reduce using rule 82 (var_call -> IDENT var_call_tail .)
    GT              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    LT              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EQ_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    GT_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    LT_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    NOT_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    AND             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    OR              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    RPAREN          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    CHECK           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    SWAP            reduce using rule 82 (var_call -> IDENT var_call_tail .)
    FUNCTION_NAME   reduce using rule 82 (var_call -> IDENT var_call_tail .)
    DISPLAY         reduce using rule 82 (var_call -> IDENT var_call_tail .)
    IDENT           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    FOR             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    UNTIL           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    REPEAT          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    INPUT           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    INT             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    FLT             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    BLN             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    CHR             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    STR             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    RBRACE          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    REVIVE          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    SHIFT           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    OTHERWISE       reduce using rule 82 (var_call -> IDENT var_call_tail .)
    COLON           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    SEMICOLON       reduce using rule 82 (var_call -> IDENT var_call_tail .)
    PLUS_EQ         reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS_EQ        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MUL_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    DIV_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MOD_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EQ              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    PLUS_PLUS       reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS_MINUS     reduce using rule 82 (var_call -> IDENT var_call_tail .)


state 89

    (83) var_call_tail -> empty .

    PLUS            reduce using rule 83 (var_call_tail -> empty .)
    MINUS           reduce using rule 83 (var_call_tail -> empty .)
    MULTIPLY        reduce using rule 83 (var_call_tail -> empty .)
    DIVISION        reduce using rule 83 (var_call_tail -> empty .)
    MODULO          reduce using rule 83 (var_call_tail -> empty .)
    EXPONENT        reduce using rule 83 (var_call_tail -> empty .)
    COMMA           reduce using rule 83 (var_call_tail -> empty .)
    NEWLINE         reduce using rule 83 (var_call_tail -> empty .)
    GT              reduce using rule 83 (var_call_tail -> empty .)
    LT              reduce using rule 83 (var_call_tail -> empty .)
    EQ_EQ           reduce using rule 83 (var_call_tail -> empty .)
    GT_EQ           reduce using rule 83 (var_call_tail -> empty .)
    LT_EQ           reduce using rule 83 (var_call_tail -> empty .)
    NOT_EQ          reduce using rule 83 (var_call_tail -> empty .)
    AND             reduce using rule 83 (var_call_tail -> empty .)
    OR              reduce using rule 83 (var_call_tail -> empty .)
    RPAREN          reduce using rule 83 (var_call_tail -> empty .)
    CHECK           reduce using rule 83 (var_call_tail -> empty .)
    SWAP            reduce using rule 83 (var_call_tail -> empty .)
    FUNCTION_NAME   reduce using rule 83 (var_call_tail -> empty .)
    DISPLAY         reduce using rule 83 (var_call_tail -> empty .)
    IDENT           reduce using rule 83 (var_call_tail -> empty .)
    FOR             reduce using rule 83 (var_call_tail -> empty .)
    UNTIL           reduce using rule 83 (var_call_tail -> empty .)
    REPEAT          reduce using rule 83 (var_call_tail -> empty .)
    INPUT           reduce using rule 83 (var_call_tail -> empty .)
    INT             reduce using rule 83 (var_call_tail -> empty .)
    FLT             reduce using rule 83 (var_call_tail -> empty .)
    BLN             reduce using rule 83 (var_call_tail -> empty .)
    CHR             reduce using rule 83 (var_call_tail -> empty .)
    STR             reduce using rule 83 (var_call_tail -> empty .)
    RBRACE          reduce using rule 83 (var_call_tail -> empty .)
    REVIVE          reduce using rule 83 (var_call_tail -> empty .)
    SHIFT           reduce using rule 83 (var_call_tail -> empty .)
    OTHERWISE       reduce using rule 83 (var_call_tail -> empty .)
    COLON           reduce using rule 83 (var_call_tail -> empty .)
    SEMICOLON       reduce using rule 83 (var_call_tail -> empty .)
    PLUS_EQ         reduce using rule 83 (var_call_tail -> empty .)
    MINUS_EQ        reduce using rule 83 (var_call_tail -> empty .)
    MUL_EQ          reduce using rule 83 (var_call_tail -> empty .)
    DIV_EQ          reduce using rule 83 (var_call_tail -> empty .)
    MOD_EQ          reduce using rule 83 (var_call_tail -> empty .)
    EQ              reduce using rule 83 (var_call_tail -> empty .)
    PLUS_PLUS       reduce using rule 83 (var_call_tail -> empty .)
    MINUS_MINUS     reduce using rule 83 (var_call_tail -> empty .)


state 90

    (84) var_call_tail -> LBRACKET . index RBRACKET
    (32) index -> . INT_LIT
    (33) index -> . IDENT

    INT_LIT         shift and go to state 117
    IDENT           shift and go to state 118

    index                          shift and go to state 116

state 91

    (59) expr_head -> term term_tail .

    AND             reduce using rule 59 (expr_head -> term term_tail .)
    OR              reduce using rule 59 (expr_head -> term term_tail .)
    COMMA           reduce using rule 59 (expr_head -> term term_tail .)
    NEWLINE         reduce using rule 59 (expr_head -> term term_tail .)
    RPAREN          reduce using rule 59 (expr_head -> term term_tail .)
    GT              reduce using rule 59 (expr_head -> term term_tail .)
    LT              reduce using rule 59 (expr_head -> term term_tail .)
    EQ_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    GT_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    LT_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    NOT_EQ          reduce using rule 59 (expr_head -> term term_tail .)
    CHECK           reduce using rule 59 (expr_head -> term term_tail .)
    SWAP            reduce using rule 59 (expr_head -> term term_tail .)
    FUNCTION_NAME   reduce using rule 59 (expr_head -> term term_tail .)
    DISPLAY         reduce using rule 59 (expr_head -> term term_tail .)
    IDENT           reduce using rule 59 (expr_head -> term term_tail .)
    FOR             reduce using rule 59 (expr_head -> term term_tail .)
    UNTIL           reduce using rule 59 (expr_head -> term term_tail .)
    REPEAT          reduce using rule 59 (expr_head -> term term_tail .)
    INPUT           reduce using rule 59 (expr_head -> term term_tail .)
    INT             reduce using rule 59 (expr_head -> term term_tail .)
    FLT             reduce using rule 59 (expr_head -> term term_tail .)
    BLN             reduce using rule 59 (expr_head -> term term_tail .)
    CHR             reduce using rule 59 (expr_head -> term term_tail .)
    STR             reduce using rule 59 (expr_head -> term term_tail .)
    RBRACE          reduce using rule 59 (expr_head -> term term_tail .)
    REVIVE          reduce using rule 59 (expr_head -> term term_tail .)
    SHIFT           reduce using rule 59 (expr_head -> term term_tail .)
    OTHERWISE       reduce using rule 59 (expr_head -> term term_tail .)
    COLON           reduce using rule 59 (expr_head -> term term_tail .)
    SEMICOLON       reduce using rule 59 (expr_head -> term term_tail .)


state 92

    (72) term_tail -> empty .

    GT              reduce using rule 72 (term_tail -> empty .)
    LT              reduce using rule 72 (term_tail -> empty .)
    EQ_EQ           reduce using rule 72 (term_tail -> empty .)
    GT_EQ           reduce using rule 72 (term_tail -> empty .)
    LT_EQ           reduce using rule 72 (term_tail -> empty .)
    NOT_EQ          reduce using rule 72 (term_tail -> empty .)
    AND             reduce using rule 72 (term_tail -> empty .)
    OR              reduce using rule 72 (term_tail -> empty .)
    COMMA           reduce using rule 72 (term_tail -> empty .)
    NEWLINE         reduce using rule 72 (term_tail -> empty .)
    RPAREN          reduce using rule 72 (term_tail -> empty .)
    CHECK           reduce using rule 72 (term_tail -> empty .)
    SWAP            reduce using rule 72 (term_tail -> empty .)
    FUNCTION_NAME   reduce using rule 72 (term_tail -> empty .)
    DISPLAY         reduce using rule 72 (term_tail -> empty .)
    IDENT           reduce using rule 72 (term_tail -> empty .)
    FOR             reduce using rule 72 (term_tail -> empty .)
    UNTIL           reduce using rule 72 (term_tail -> empty .)
    REPEAT          reduce using rule 72 (term_tail -> empty .)
    INPUT           reduce using rule 72 (term_tail -> empty .)
    INT             reduce using rule 72 (term_tail -> empty .)
    FLT             reduce using rule 72 (term_tail -> empty .)
    BLN             reduce using rule 72 (term_tail -> empty .)
    CHR             reduce using rule 72 (term_tail -> empty .)
    STR             reduce using rule 72 (term_tail -> empty .)
    RBRACE          reduce using rule 72 (term_tail -> empty .)
    REVIVE          reduce using rule 72 (term_tail -> empty .)
    SHIFT           reduce using rule 72 (term_tail -> empty .)
    OTHERWISE       reduce using rule 72 (term_tail -> empty .)
    COLON           reduce using rule 72 (term_tail -> empty .)
    SEMICOLON       reduce using rule 72 (term_tail -> empty .)


state 93

    (73) term_tail -> GT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 119
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 94

    (74) term_tail -> LT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 120
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 95

    (75) term_tail -> EQ_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 121
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 96

    (76) term_tail -> GT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 122
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 97

    (77) term_tail -> LT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 123
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 98

    (78) term_tail -> NOT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 124
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 99

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN . parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (99) parameters -> . data_type IDENT parameters_tail
    (100) parameters -> . empty
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR
    (164) empty -> .

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13
    RPAREN          reduce using rule 164 (empty -> .)

    parameters                     shift and go to state 125
    data_type                      shift and go to state 126
    empty                          shift and go to state 127

state 100

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 128


state 101

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 129


state 102

    (16) global_tail2 -> COMMA IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (164) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 164 (empty -> .)

    global_statement_tail          shift and go to state 130
    empty                          shift and go to state 28

state 103

    (18) global_dec_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 18 (global_dec_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 18 (global_dec_value -> LBRACKET list_element RBRACKET .)


state 104

    (29) list_element -> literal element_tail .

    RBRACKET        reduce using rule 29 (list_element -> literal element_tail .)


state 105

    (30) element_tail -> empty .

    RBRACKET        reduce using rule 30 (element_tail -> empty .)


state 106

    (31) element_tail -> COMMA . list_element
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 131
    literal                        shift and go to state 72

state 107

    (66) factor_tail -> PLUS expression .

    GT              reduce using rule 66 (factor_tail -> PLUS expression .)
    LT              reduce using rule 66 (factor_tail -> PLUS expression .)
    EQ_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    GT_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    LT_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    NOT_EQ          reduce using rule 66 (factor_tail -> PLUS expression .)
    AND             reduce using rule 66 (factor_tail -> PLUS expression .)
    OR              reduce using rule 66 (factor_tail -> PLUS expression .)
    COMMA           reduce using rule 66 (factor_tail -> PLUS expression .)
    NEWLINE         reduce using rule 66 (factor_tail -> PLUS expression .)
    RPAREN          reduce using rule 66 (factor_tail -> PLUS expression .)
    CHECK           reduce using rule 66 (factor_tail -> PLUS expression .)
    SWAP            reduce using rule 66 (factor_tail -> PLUS expression .)
    FUNCTION_NAME   reduce using rule 66 (factor_tail -> PLUS expression .)
    DISPLAY         reduce using rule 66 (factor_tail -> PLUS expression .)
    IDENT           reduce using rule 66 (factor_tail -> PLUS expression .)
    FOR             reduce using rule 66 (factor_tail -> PLUS expression .)
    UNTIL           reduce using rule 66 (factor_tail -> PLUS expression .)
    REPEAT          reduce using rule 66 (factor_tail -> PLUS expression .)
    INPUT           reduce using rule 66 (factor_tail -> PLUS expression .)
    INT             reduce using rule 66 (factor_tail -> PLUS expression .)
    FLT             reduce using rule 66 (factor_tail -> PLUS expression .)
    BLN             reduce using rule 66 (factor_tail -> PLUS expression .)
    CHR             reduce using rule 66 (factor_tail -> PLUS expression .)
    STR             reduce using rule 66 (factor_tail -> PLUS expression .)
    RBRACE          reduce using rule 66 (factor_tail -> PLUS expression .)
    REVIVE          reduce using rule 66 (factor_tail -> PLUS expression .)
    SHIFT           reduce using rule 66 (factor_tail -> PLUS expression .)
    OTHERWISE       reduce using rule 66 (factor_tail -> PLUS expression .)
    COLON           reduce using rule 66 (factor_tail -> PLUS expression .)
    SEMICOLON       reduce using rule 66 (factor_tail -> PLUS expression .)


state 108

    (67) factor_tail -> MINUS expression .

    GT              reduce using rule 67 (factor_tail -> MINUS expression .)
    LT              reduce using rule 67 (factor_tail -> MINUS expression .)
    EQ_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    GT_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    LT_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    NOT_EQ          reduce using rule 67 (factor_tail -> MINUS expression .)
    AND             reduce using rule 67 (factor_tail -> MINUS expression .)
    OR              reduce using rule 67 (factor_tail -> MINUS expression .)
    COMMA           reduce using rule 67 (factor_tail -> MINUS expression .)
    NEWLINE         reduce using rule 67 (factor_tail -> MINUS expression .)
    RPAREN          reduce using rule 67 (factor_tail -> MINUS expression .)
    CHECK           reduce using rule 67 (factor_tail -> MINUS expression .)
    SWAP            reduce using rule 67 (factor_tail -> MINUS expression .)
    FUNCTION_NAME   reduce using rule 67 (factor_tail -> MINUS expression .)
    DISPLAY         reduce using rule 67 (factor_tail -> MINUS expression .)
    IDENT           reduce using rule 67 (factor_tail -> MINUS expression .)
    FOR             reduce using rule 67 (factor_tail -> MINUS expression .)
    UNTIL           reduce using rule 67 (factor_tail -> MINUS expression .)
    REPEAT          reduce using rule 67 (factor_tail -> MINUS expression .)
    INPUT           reduce using rule 67 (factor_tail -> MINUS expression .)
    INT             reduce using rule 67 (factor_tail -> MINUS expression .)
    FLT             reduce using rule 67 (factor_tail -> MINUS expression .)
    BLN             reduce using rule 67 (factor_tail -> MINUS expression .)
    CHR             reduce using rule 67 (factor_tail -> MINUS expression .)
    STR             reduce using rule 67 (factor_tail -> MINUS expression .)
    RBRACE          reduce using rule 67 (factor_tail -> MINUS expression .)
    REVIVE          reduce using rule 67 (factor_tail -> MINUS expression .)
    SHIFT           reduce using rule 67 (factor_tail -> MINUS expression .)
    OTHERWISE       reduce using rule 67 (factor_tail -> MINUS expression .)
    COLON           reduce using rule 67 (factor_tail -> MINUS expression .)
    SEMICOLON       reduce using rule 67 (factor_tail -> MINUS expression .)


state 109

    (68) factor_tail -> MULTIPLY expression .

    GT              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    LT              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    EQ_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    GT_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    LT_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    NOT_EQ          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    AND             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    OR              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    COMMA           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    NEWLINE         reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    RPAREN          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    CHECK           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    SWAP            reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    FUNCTION_NAME   reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    DISPLAY         reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    IDENT           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    FOR             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    UNTIL           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    REPEAT          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    INPUT           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    INT             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    FLT             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    BLN             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    CHR             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    STR             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    RBRACE          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    REVIVE          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    SHIFT           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    OTHERWISE       reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    COLON           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    SEMICOLON       reduce using rule 68 (factor_tail -> MULTIPLY expression .)


state 110

    (69) factor_tail -> DIVISION expression .

    GT              reduce using rule 69 (factor_tail -> DIVISION expression .)
    LT              reduce using rule 69 (factor_tail -> DIVISION expression .)
    EQ_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    GT_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    LT_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    NOT_EQ          reduce using rule 69 (factor_tail -> DIVISION expression .)
    AND             reduce using rule 69 (factor_tail -> DIVISION expression .)
    OR              reduce using rule 69 (factor_tail -> DIVISION expression .)
    COMMA           reduce using rule 69 (factor_tail -> DIVISION expression .)
    NEWLINE         reduce using rule 69 (factor_tail -> DIVISION expression .)
    RPAREN          reduce using rule 69 (factor_tail -> DIVISION expression .)
    CHECK           reduce using rule 69 (factor_tail -> DIVISION expression .)
    SWAP            reduce using rule 69 (factor_tail -> DIVISION expression .)
    FUNCTION_NAME   reduce using rule 69 (factor_tail -> DIVISION expression .)
    DISPLAY         reduce using rule 69 (factor_tail -> DIVISION expression .)
    IDENT           reduce using rule 69 (factor_tail -> DIVISION expression .)
    FOR             reduce using rule 69 (factor_tail -> DIVISION expression .)
    UNTIL           reduce using rule 69 (factor_tail -> DIVISION expression .)
    REPEAT          reduce using rule 69 (factor_tail -> DIVISION expression .)
    INPUT           reduce using rule 69 (factor_tail -> DIVISION expression .)
    INT             reduce using rule 69 (factor_tail -> DIVISION expression .)
    FLT             reduce using rule 69 (factor_tail -> DIVISION expression .)
    BLN             reduce using rule 69 (factor_tail -> DIVISION expression .)
    CHR             reduce using rule 69 (factor_tail -> DIVISION expression .)
    STR             reduce using rule 69 (factor_tail -> DIVISION expression .)
    RBRACE          reduce using rule 69 (factor_tail -> DIVISION expression .)
    REVIVE          reduce using rule 69 (factor_tail -> DIVISION expression .)
    SHIFT           reduce using rule 69 (factor_tail -> DIVISION expression .)
    OTHERWISE       reduce using rule 69 (factor_tail -> DIVISION expression .)
    COLON           reduce using rule 69 (factor_tail -> DIVISION expression .)
    SEMICOLON       reduce using rule 69 (factor_tail -> DIVISION expression .)


state 111

    (70) factor_tail -> MODULO expression .

    GT              reduce using rule 70 (factor_tail -> MODULO expression .)
    LT              reduce using rule 70 (factor_tail -> MODULO expression .)
    EQ_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    GT_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    LT_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    NOT_EQ          reduce using rule 70 (factor_tail -> MODULO expression .)
    AND             reduce using rule 70 (factor_tail -> MODULO expression .)
    OR              reduce using rule 70 (factor_tail -> MODULO expression .)
    COMMA           reduce using rule 70 (factor_tail -> MODULO expression .)
    NEWLINE         reduce using rule 70 (factor_tail -> MODULO expression .)
    RPAREN          reduce using rule 70 (factor_tail -> MODULO expression .)
    CHECK           reduce using rule 70 (factor_tail -> MODULO expression .)
    SWAP            reduce using rule 70 (factor_tail -> MODULO expression .)
    FUNCTION_NAME   reduce using rule 70 (factor_tail -> MODULO expression .)
    DISPLAY         reduce using rule 70 (factor_tail -> MODULO expression .)
    IDENT           reduce using rule 70 (factor_tail -> MODULO expression .)
    FOR             reduce using rule 70 (factor_tail -> MODULO expression .)
    UNTIL           reduce using rule 70 (factor_tail -> MODULO expression .)
    REPEAT          reduce using rule 70 (factor_tail -> MODULO expression .)
    INPUT           reduce using rule 70 (factor_tail -> MODULO expression .)
    INT             reduce using rule 70 (factor_tail -> MODULO expression .)
    FLT             reduce using rule 70 (factor_tail -> MODULO expression .)
    BLN             reduce using rule 70 (factor_tail -> MODULO expression .)
    CHR             reduce using rule 70 (factor_tail -> MODULO expression .)
    STR             reduce using rule 70 (factor_tail -> MODULO expression .)
    RBRACE          reduce using rule 70 (factor_tail -> MODULO expression .)
    REVIVE          reduce using rule 70 (factor_tail -> MODULO expression .)
    SHIFT           reduce using rule 70 (factor_tail -> MODULO expression .)
    OTHERWISE       reduce using rule 70 (factor_tail -> MODULO expression .)
    COLON           reduce using rule 70 (factor_tail -> MODULO expression .)
    SEMICOLON       reduce using rule 70 (factor_tail -> MODULO expression .)


state 112

    (71) factor_tail -> EXPONENT expression .

    GT              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    LT              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    EQ_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    GT_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    LT_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    NOT_EQ          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    AND             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    OR              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    COMMA           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    NEWLINE         reduce using rule 71 (factor_tail -> EXPONENT expression .)
    RPAREN          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    CHECK           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    SWAP            reduce using rule 71 (factor_tail -> EXPONENT expression .)
    FUNCTION_NAME   reduce using rule 71 (factor_tail -> EXPONENT expression .)
    DISPLAY         reduce using rule 71 (factor_tail -> EXPONENT expression .)
    IDENT           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    FOR             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    UNTIL           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    REPEAT          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    INPUT           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    INT             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    FLT             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    BLN             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    CHR             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    STR             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    RBRACE          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    REVIVE          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    SHIFT           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    OTHERWISE       reduce using rule 71 (factor_tail -> EXPONENT expression .)
    COLON           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    SEMICOLON       reduce using rule 71 (factor_tail -> EXPONENT expression .)


state 113

    (64) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    CHECK           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    SWAP            reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    FUNCTION_NAME   reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    DISPLAY         reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    IDENT           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    REPEAT          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    INPUT           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    INT             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    FLT             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    BLN             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    CHR             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    STR             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    REVIVE          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    SHIFT           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    OTHERWISE       reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 64 (factor -> LPAREN expression RPAREN .)


state 114

    (80) expr_tail -> AND expression .

    GT              reduce using rule 80 (expr_tail -> AND expression .)
    LT              reduce using rule 80 (expr_tail -> AND expression .)
    EQ_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    GT_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    LT_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    NOT_EQ          reduce using rule 80 (expr_tail -> AND expression .)
    AND             reduce using rule 80 (expr_tail -> AND expression .)
    OR              reduce using rule 80 (expr_tail -> AND expression .)
    COMMA           reduce using rule 80 (expr_tail -> AND expression .)
    NEWLINE         reduce using rule 80 (expr_tail -> AND expression .)
    RPAREN          reduce using rule 80 (expr_tail -> AND expression .)
    CHECK           reduce using rule 80 (expr_tail -> AND expression .)
    SWAP            reduce using rule 80 (expr_tail -> AND expression .)
    FUNCTION_NAME   reduce using rule 80 (expr_tail -> AND expression .)
    DISPLAY         reduce using rule 80 (expr_tail -> AND expression .)
    IDENT           reduce using rule 80 (expr_tail -> AND expression .)
    FOR             reduce using rule 80 (expr_tail -> AND expression .)
    UNTIL           reduce using rule 80 (expr_tail -> AND expression .)
    REPEAT          reduce using rule 80 (expr_tail -> AND expression .)
    INPUT           reduce using rule 80 (expr_tail -> AND expression .)
    INT             reduce using rule 80 (expr_tail -> AND expression .)
    FLT             reduce using rule 80 (expr_tail -> AND expression .)
    BLN             reduce using rule 80 (expr_tail -> AND expression .)
    CHR             reduce using rule 80 (expr_tail -> AND expression .)
    STR             reduce using rule 80 (expr_tail -> AND expression .)
    RBRACE          reduce using rule 80 (expr_tail -> AND expression .)
    REVIVE          reduce using rule 80 (expr_tail -> AND expression .)
    SHIFT           reduce using rule 80 (expr_tail -> AND expression .)
    OTHERWISE       reduce using rule 80 (expr_tail -> AND expression .)
    COLON           reduce using rule 80 (expr_tail -> AND expression .)
    SEMICOLON       reduce using rule 80 (expr_tail -> AND expression .)


state 115

    (81) expr_tail -> OR expression .

    GT              reduce using rule 81 (expr_tail -> OR expression .)
    LT              reduce using rule 81 (expr_tail -> OR expression .)
    EQ_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    GT_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    LT_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    NOT_EQ          reduce using rule 81 (expr_tail -> OR expression .)
    AND             reduce using rule 81 (expr_tail -> OR expression .)
    OR              reduce using rule 81 (expr_tail -> OR expression .)
    COMMA           reduce using rule 81 (expr_tail -> OR expression .)
    NEWLINE         reduce using rule 81 (expr_tail -> OR expression .)
    RPAREN          reduce using rule 81 (expr_tail -> OR expression .)
    CHECK           reduce using rule 81 (expr_tail -> OR expression .)
    SWAP            reduce using rule 81 (expr_tail -> OR expression .)
    FUNCTION_NAME   reduce using rule 81 (expr_tail -> OR expression .)
    DISPLAY         reduce using rule 81 (expr_tail -> OR expression .)
    IDENT           reduce using rule 81 (expr_tail -> OR expression .)
    FOR             reduce using rule 81 (expr_tail -> OR expression .)
    UNTIL           reduce using rule 81 (expr_tail -> OR expression .)
    REPEAT          reduce using rule 81 (expr_tail -> OR expression .)
    INPUT           reduce using rule 81 (expr_tail -> OR expression .)
    INT             reduce using rule 81 (expr_tail -> OR expression .)
    FLT             reduce using rule 81 (expr_tail -> OR expression .)
    BLN             reduce using rule 81 (expr_tail -> OR expression .)
    CHR             reduce using rule 81 (expr_tail -> OR expression .)
    STR             reduce using rule 81 (expr_tail -> OR expression .)
    RBRACE          reduce using rule 81 (expr_tail -> OR expression .)
    REVIVE          reduce using rule 81 (expr_tail -> OR expression .)
    SHIFT           reduce using rule 81 (expr_tail -> OR expression .)
    OTHERWISE       reduce using rule 81 (expr_tail -> OR expression .)
    COLON           reduce using rule 81 (expr_tail -> OR expression .)
    SEMICOLON       reduce using rule 81 (expr_tail -> OR expression .)


state 116

    (84) var_call_tail -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 132


state 117

    (32) index -> INT_LIT .

    RBRACKET        reduce using rule 32 (index -> INT_LIT .)


state 118

    (33) index -> IDENT .

    RBRACKET        reduce using rule 33 (index -> IDENT .)


state 119

    (73) term_tail -> GT expression .

    GT              reduce using rule 73 (term_tail -> GT expression .)
    LT              reduce using rule 73 (term_tail -> GT expression .)
    EQ_EQ           reduce using rule 73 (term_tail -> GT expression .)
    GT_EQ           reduce using rule 73 (term_tail -> GT expression .)
    LT_EQ           reduce using rule 73 (term_tail -> GT expression .)
    NOT_EQ          reduce using rule 73 (term_tail -> GT expression .)
    AND             reduce using rule 73 (term_tail -> GT expression .)
    OR              reduce using rule 73 (term_tail -> GT expression .)
    COMMA           reduce using rule 73 (term_tail -> GT expression .)
    NEWLINE         reduce using rule 73 (term_tail -> GT expression .)
    RPAREN          reduce using rule 73 (term_tail -> GT expression .)
    CHECK           reduce using rule 73 (term_tail -> GT expression .)
    SWAP            reduce using rule 73 (term_tail -> GT expression .)
    FUNCTION_NAME   reduce using rule 73 (term_tail -> GT expression .)
    DISPLAY         reduce using rule 73 (term_tail -> GT expression .)
    IDENT           reduce using rule 73 (term_tail -> GT expression .)
    FOR             reduce using rule 73 (term_tail -> GT expression .)
    UNTIL           reduce using rule 73 (term_tail -> GT expression .)
    REPEAT          reduce using rule 73 (term_tail -> GT expression .)
    INPUT           reduce using rule 73 (term_tail -> GT expression .)
    INT             reduce using rule 73 (term_tail -> GT expression .)
    FLT             reduce using rule 73 (term_tail -> GT expression .)
    BLN             reduce using rule 73 (term_tail -> GT expression .)
    CHR             reduce using rule 73 (term_tail -> GT expression .)
    STR             reduce using rule 73 (term_tail -> GT expression .)
    RBRACE          reduce using rule 73 (term_tail -> GT expression .)
    REVIVE          reduce using rule 73 (term_tail -> GT expression .)
    SHIFT           reduce using rule 73 (term_tail -> GT expression .)
    OTHERWISE       reduce using rule 73 (term_tail -> GT expression .)
    COLON           reduce using rule 73 (term_tail -> GT expression .)
    SEMICOLON       reduce using rule 73 (term_tail -> GT expression .)


state 120

    (74) term_tail -> LT expression .

    GT              reduce using rule 74 (term_tail -> LT expression .)
    LT              reduce using rule 74 (term_tail -> LT expression .)
    EQ_EQ           reduce using rule 74 (term_tail -> LT expression .)
    GT_EQ           reduce using rule 74 (term_tail -> LT expression .)
    LT_EQ           reduce using rule 74 (term_tail -> LT expression .)
    NOT_EQ          reduce using rule 74 (term_tail -> LT expression .)
    AND             reduce using rule 74 (term_tail -> LT expression .)
    OR              reduce using rule 74 (term_tail -> LT expression .)
    COMMA           reduce using rule 74 (term_tail -> LT expression .)
    NEWLINE         reduce using rule 74 (term_tail -> LT expression .)
    RPAREN          reduce using rule 74 (term_tail -> LT expression .)
    CHECK           reduce using rule 74 (term_tail -> LT expression .)
    SWAP            reduce using rule 74 (term_tail -> LT expression .)
    FUNCTION_NAME   reduce using rule 74 (term_tail -> LT expression .)
    DISPLAY         reduce using rule 74 (term_tail -> LT expression .)
    IDENT           reduce using rule 74 (term_tail -> LT expression .)
    FOR             reduce using rule 74 (term_tail -> LT expression .)
    UNTIL           reduce using rule 74 (term_tail -> LT expression .)
    REPEAT          reduce using rule 74 (term_tail -> LT expression .)
    INPUT           reduce using rule 74 (term_tail -> LT expression .)
    INT             reduce using rule 74 (term_tail -> LT expression .)
    FLT             reduce using rule 74 (term_tail -> LT expression .)
    BLN             reduce using rule 74 (term_tail -> LT expression .)
    CHR             reduce using rule 74 (term_tail -> LT expression .)
    STR             reduce using rule 74 (term_tail -> LT expression .)
    RBRACE          reduce using rule 74 (term_tail -> LT expression .)
    REVIVE          reduce using rule 74 (term_tail -> LT expression .)
    SHIFT           reduce using rule 74 (term_tail -> LT expression .)
    OTHERWISE       reduce using rule 74 (term_tail -> LT expression .)
    COLON           reduce using rule 74 (term_tail -> LT expression .)
    SEMICOLON       reduce using rule 74 (term_tail -> LT expression .)


state 121

    (75) term_tail -> EQ_EQ expression .

    GT              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    LT              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    EQ_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    GT_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    LT_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    NOT_EQ          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    AND             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    OR              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    COMMA           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    NEWLINE         reduce using rule 75 (term_tail -> EQ_EQ expression .)
    RPAREN          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    CHECK           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    SWAP            reduce using rule 75 (term_tail -> EQ_EQ expression .)
    FUNCTION_NAME   reduce using rule 75 (term_tail -> EQ_EQ expression .)
    DISPLAY         reduce using rule 75 (term_tail -> EQ_EQ expression .)
    IDENT           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    FOR             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    UNTIL           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    REPEAT          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    INPUT           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    INT             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    FLT             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    BLN             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    CHR             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    STR             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    RBRACE          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    REVIVE          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    SHIFT           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    OTHERWISE       reduce using rule 75 (term_tail -> EQ_EQ expression .)
    COLON           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    SEMICOLON       reduce using rule 75 (term_tail -> EQ_EQ expression .)


state 122

    (76) term_tail -> GT_EQ expression .

    GT              reduce using rule 76 (term_tail -> GT_EQ expression .)
    LT              reduce using rule 76 (term_tail -> GT_EQ expression .)
    EQ_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    GT_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    LT_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    NOT_EQ          reduce using rule 76 (term_tail -> GT_EQ expression .)
    AND             reduce using rule 76 (term_tail -> GT_EQ expression .)
    OR              reduce using rule 76 (term_tail -> GT_EQ expression .)
    COMMA           reduce using rule 76 (term_tail -> GT_EQ expression .)
    NEWLINE         reduce using rule 76 (term_tail -> GT_EQ expression .)
    RPAREN          reduce using rule 76 (term_tail -> GT_EQ expression .)
    CHECK           reduce using rule 76 (term_tail -> GT_EQ expression .)
    SWAP            reduce using rule 76 (term_tail -> GT_EQ expression .)
    FUNCTION_NAME   reduce using rule 76 (term_tail -> GT_EQ expression .)
    DISPLAY         reduce using rule 76 (term_tail -> GT_EQ expression .)
    IDENT           reduce using rule 76 (term_tail -> GT_EQ expression .)
    FOR             reduce using rule 76 (term_tail -> GT_EQ expression .)
    UNTIL           reduce using rule 76 (term_tail -> GT_EQ expression .)
    REPEAT          reduce using rule 76 (term_tail -> GT_EQ expression .)
    INPUT           reduce using rule 76 (term_tail -> GT_EQ expression .)
    INT             reduce using rule 76 (term_tail -> GT_EQ expression .)
    FLT             reduce using rule 76 (term_tail -> GT_EQ expression .)
    BLN             reduce using rule 76 (term_tail -> GT_EQ expression .)
    CHR             reduce using rule 76 (term_tail -> GT_EQ expression .)
    STR             reduce using rule 76 (term_tail -> GT_EQ expression .)
    RBRACE          reduce using rule 76 (term_tail -> GT_EQ expression .)
    REVIVE          reduce using rule 76 (term_tail -> GT_EQ expression .)
    SHIFT           reduce using rule 76 (term_tail -> GT_EQ expression .)
    OTHERWISE       reduce using rule 76 (term_tail -> GT_EQ expression .)
    COLON           reduce using rule 76 (term_tail -> GT_EQ expression .)
    SEMICOLON       reduce using rule 76 (term_tail -> GT_EQ expression .)


state 123

    (77) term_tail -> LT_EQ expression .

    GT              reduce using rule 77 (term_tail -> LT_EQ expression .)
    LT              reduce using rule 77 (term_tail -> LT_EQ expression .)
    EQ_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    GT_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    LT_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    NOT_EQ          reduce using rule 77 (term_tail -> LT_EQ expression .)
    AND             reduce using rule 77 (term_tail -> LT_EQ expression .)
    OR              reduce using rule 77 (term_tail -> LT_EQ expression .)
    COMMA           reduce using rule 77 (term_tail -> LT_EQ expression .)
    NEWLINE         reduce using rule 77 (term_tail -> LT_EQ expression .)
    RPAREN          reduce using rule 77 (term_tail -> LT_EQ expression .)
    CHECK           reduce using rule 77 (term_tail -> LT_EQ expression .)
    SWAP            reduce using rule 77 (term_tail -> LT_EQ expression .)
    FUNCTION_NAME   reduce using rule 77 (term_tail -> LT_EQ expression .)
    DISPLAY         reduce using rule 77 (term_tail -> LT_EQ expression .)
    IDENT           reduce using rule 77 (term_tail -> LT_EQ expression .)
    FOR             reduce using rule 77 (term_tail -> LT_EQ expression .)
    UNTIL           reduce using rule 77 (term_tail -> LT_EQ expression .)
    REPEAT          reduce using rule 77 (term_tail -> LT_EQ expression .)
    INPUT           reduce using rule 77 (term_tail -> LT_EQ expression .)
    INT             reduce using rule 77 (term_tail -> LT_EQ expression .)
    FLT             reduce using rule 77 (term_tail -> LT_EQ expression .)
    BLN             reduce using rule 77 (term_tail -> LT_EQ expression .)
    CHR             reduce using rule 77 (term_tail -> LT_EQ expression .)
    STR             reduce using rule 77 (term_tail -> LT_EQ expression .)
    RBRACE          reduce using rule 77 (term_tail -> LT_EQ expression .)
    REVIVE          reduce using rule 77 (term_tail -> LT_EQ expression .)
    SHIFT           reduce using rule 77 (term_tail -> LT_EQ expression .)
    OTHERWISE       reduce using rule 77 (term_tail -> LT_EQ expression .)
    COLON           reduce using rule 77 (term_tail -> LT_EQ expression .)
    SEMICOLON       reduce using rule 77 (term_tail -> LT_EQ expression .)


state 124

    (78) term_tail -> NOT_EQ expression .

    GT              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    LT              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    EQ_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    GT_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    LT_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    NOT_EQ          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    AND             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    OR              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    COMMA           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    NEWLINE         reduce using rule 78 (term_tail -> NOT_EQ expression .)
    RPAREN          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    CHECK           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    SWAP            reduce using rule 78 (term_tail -> NOT_EQ expression .)
    FUNCTION_NAME   reduce using rule 78 (term_tail -> NOT_EQ expression .)
    DISPLAY         reduce using rule 78 (term_tail -> NOT_EQ expression .)
    IDENT           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    FOR             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    UNTIL           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    REPEAT          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    INPUT           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    INT             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    FLT             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    BLN             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    CHR             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    STR             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    RBRACE          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    REVIVE          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    SHIFT           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    OTHERWISE       reduce using rule 78 (term_tail -> NOT_EQ expression .)
    COLON           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    SEMICOLON       reduce using rule 78 (term_tail -> NOT_EQ expression .)


state 125

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters . RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    RPAREN          shift and go to state 133


state 126

    (99) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 134


state 127

    (100) parameters -> empty .

    RPAREN          reduce using rule 100 (parameters -> empty .)


state 128

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 129

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 135


state 130

    (16) global_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 16 (global_tail2 -> COMMA IDENT global_statement_tail .)


state 131

    (31) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 31 (element_tail -> COMMA list_element .)


state 132

    (84) var_call_tail -> LBRACKET index RBRACKET .

    PLUS            reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    GT              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    LT              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    AND             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    OR              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    CHECK           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    SWAP            reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_NAME   reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    DISPLAY         reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    IDENT           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    FOR             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    UNTIL           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    REPEAT          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    INPUT           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    INT             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    FLT             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    BLN             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    CHR             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    STR             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    REVIVE          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    SHIFT           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    OTHERWISE       reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_PLUS       reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)


state 133

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN . maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 136
    empty                          shift and go to state 16

state 134

    (99) parameters -> data_type IDENT . parameters_tail
    (101) parameters_tail -> . empty
    (102) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (164) empty -> .

    COMMA           shift and go to state 139
    RPAREN          reduce using rule 164 (empty -> .)

    parameters_tail                shift and go to state 137
    empty                          shift and go to state 138

state 135

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 140
    empty                          shift and go to state 16

state 136

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline . LBRACE unli_newline statements revive maybe_newline RBRACE

    LBRACE          shift and go to state 141


state 137

    (99) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 99 (parameters -> data_type IDENT parameters_tail .)


state 138

    (101) parameters_tail -> empty .

    RPAREN          reduce using rule 101 (parameters_tail -> empty .)


state 139

    (102) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    data_type                      shift and go to state 142

state 140

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline . statements maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 143
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 141

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE . unli_newline statements revive maybe_newline RBRACE
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 148

state 142

    (102) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 149


state 143

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 150
    empty                          shift and go to state 16

state 144

    (105) statements -> empty .
    (115) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 105 (statements -> empty .)
    NEWLINE         reduce using rule 105 (statements -> empty .)
    RBRACE          reduce using rule 105 (statements -> empty .)
    REVIVE          reduce using rule 105 (statements -> empty .)
    SHIFT           reduce using rule 105 (statements -> empty .)
    OTHERWISE       reduce using rule 105 (statements -> empty .)
    CHECK           reduce using rule 115 (local_dec -> empty .)
    SWAP            reduce using rule 115 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 115 (local_dec -> empty .)
    DISPLAY         reduce using rule 115 (local_dec -> empty .)
    IDENT           reduce using rule 115 (local_dec -> empty .)
    FOR             reduce using rule 115 (local_dec -> empty .)
    UNTIL           reduce using rule 115 (local_dec -> empty .)
    REPEAT          reduce using rule 115 (local_dec -> empty .)
    INPUT           reduce using rule 115 (local_dec -> empty .)
    INT             reduce using rule 115 (local_dec -> empty .)
    FLT             reduce using rule 115 (local_dec -> empty .)
    BLN             reduce using rule 115 (local_dec -> empty .)
    CHR             reduce using rule 115 (local_dec -> empty .)
    STR             reduce using rule 115 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 115 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 115 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 115 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 115 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 115 (local_dec -> empty .) ]


state 145

    (106) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 151
    empty                          shift and go to state 16

state 146

    (116) local_dec -> var_statement .

    NEWLINE         reduce using rule 116 (local_dec -> var_statement .)
    CHECK           reduce using rule 116 (local_dec -> var_statement .)
    SWAP            reduce using rule 116 (local_dec -> var_statement .)
    FUNCTION_NAME   reduce using rule 116 (local_dec -> var_statement .)
    DISPLAY         reduce using rule 116 (local_dec -> var_statement .)
    IDENT           reduce using rule 116 (local_dec -> var_statement .)
    FOR             reduce using rule 116 (local_dec -> var_statement .)
    UNTIL           reduce using rule 116 (local_dec -> var_statement .)
    REPEAT          reduce using rule 116 (local_dec -> var_statement .)
    INPUT           reduce using rule 116 (local_dec -> var_statement .)
    INT             reduce using rule 116 (local_dec -> var_statement .)
    FLT             reduce using rule 116 (local_dec -> var_statement .)
    BLN             reduce using rule 116 (local_dec -> var_statement .)
    CHR             reduce using rule 116 (local_dec -> var_statement .)
    STR             reduce using rule 116 (local_dec -> var_statement .)
    RBRACE          reduce using rule 116 (local_dec -> var_statement .)
    REVIVE          reduce using rule 116 (local_dec -> var_statement .)
    SHIFT           reduce using rule 116 (local_dec -> var_statement .)
    OTHERWISE       reduce using rule 116 (local_dec -> var_statement .)


state 147

    (21) var_statement -> data_type . IDENT var_tail

    IDENT           shift and go to state 152


state 148

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline . statements revive maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 153
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 149

    (102) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (101) parameters_tail -> . empty
    (102) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (164) empty -> .

    COMMA           shift and go to state 139
    RPAREN          reduce using rule 164 (empty -> .)

    parameters_tail                shift and go to state 154
    empty                          shift and go to state 138

state 150

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 155


state 151

    (106) statements -> local_dec maybe_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 173
    IDENT           shift and go to state 56
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    local_dec                      shift and go to state 156
    statements_tail                shift and go to state 157
    empty                          shift and go to state 158
    string_operation_statement     shift and go to state 159
    conditional_statement          shift and go to state 160
    switch_statement               shift and go to state 161
    loop_statement                 shift and go to state 162
    function_call                  shift and go to state 163
    output_statement               shift and go to state 164
    var_statement                  shift and go to state 146
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170
    input_statement                shift and go to state 172
    data_type                      shift and go to state 147

state 152

    (21) var_statement -> data_type IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (164) empty -> .

    EQ              shift and go to state 180
    COMMA           shift and go to state 181
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)

    var_tail                       shift and go to state 178
    empty                          shift and go to state 179

state 153

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements . revive maybe_newline RBRACE
    (103) revive -> . REVIVE value
    (104) revive -> . empty
    (164) empty -> .

    REVIVE          shift and go to state 183
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)

    revive                         shift and go to state 182
    empty                          shift and go to state 184

state 154

    (102) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 102 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 155

    (6) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE .)


state 156

    (108) statements_tail -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 185
    empty                          shift and go to state 16

state 157

    (106) statements -> local_dec maybe_newline statements_tail .

    NEWLINE         reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    REVIVE          reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)


state 158

    (107) statements_tail -> empty .
    (115) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 107 (statements_tail -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 107 (statements_tail -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 107 (statements_tail -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 107 (statements_tail -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 107 (statements_tail -> empty .)
    NEWLINE         reduce using rule 107 (statements_tail -> empty .)
    RBRACE          reduce using rule 107 (statements_tail -> empty .)
    REVIVE          reduce using rule 107 (statements_tail -> empty .)
    SHIFT           reduce using rule 107 (statements_tail -> empty .)
    OTHERWISE       reduce using rule 107 (statements_tail -> empty .)
    CHECK           reduce using rule 115 (local_dec -> empty .)
    SWAP            reduce using rule 115 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 115 (local_dec -> empty .)
    DISPLAY         reduce using rule 115 (local_dec -> empty .)
    IDENT           reduce using rule 115 (local_dec -> empty .)
    FOR             reduce using rule 115 (local_dec -> empty .)
    UNTIL           reduce using rule 115 (local_dec -> empty .)
    REPEAT          reduce using rule 115 (local_dec -> empty .)
    INPUT           reduce using rule 115 (local_dec -> empty .)
    INT             reduce using rule 115 (local_dec -> empty .)
    FLT             reduce using rule 115 (local_dec -> empty .)
    BLN             reduce using rule 115 (local_dec -> empty .)
    CHR             reduce using rule 115 (local_dec -> empty .)
    STR             reduce using rule 115 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 115 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 115 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 115 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 115 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 115 (local_dec -> empty .) ]


state 159

    (109) statements_tail -> string_operation_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 186

state 160

    (110) statements_tail -> conditional_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 187

state 161

    (111) statements_tail -> switch_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 188

state 162

    (112) statements_tail -> loop_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 189

state 163

    (113) statements_tail -> function_call . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 190

state 164

    (114) statements_tail -> output_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 191

state 165

    (150) string_operation_statement -> var_call . string_operation_tail
    (151) string_operation_tail -> . assign_op value
    (152) string_operation_tail -> . PLUS string_val stringcon_tail
    (153) string_operation_tail -> . update_tail
    (154) assign_op -> . PLUS_EQ
    (155) assign_op -> . MINUS_EQ
    (156) assign_op -> . MUL_EQ
    (157) assign_op -> . DIV_EQ
    (158) assign_op -> . MOD_EQ
    (159) assign_op -> . EQ
    (133) update_tail -> . postfix
    (134) update_tail -> . assign_op value
    (135) postfix -> . PLUS_PLUS
    (136) postfix -> . MINUS_MINUS

    PLUS            shift and go to state 194
    PLUS_EQ         shift and go to state 196
    MINUS_EQ        shift and go to state 197
    MUL_EQ          shift and go to state 198
    DIV_EQ          shift and go to state 199
    MOD_EQ          shift and go to state 200
    EQ              shift and go to state 201
    PLUS_PLUS       shift and go to state 203
    MINUS_MINUS     shift and go to state 204

    string_operation_tail          shift and go to state 192
    assign_op                      shift and go to state 193
    update_tail                    shift and go to state 195
    postfix                        shift and go to state 202

state 166

    (117) conditional_statement -> CHECK . LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail

    LPAREN          shift and go to state 205


state 167

    (121) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LPAREN          shift and go to state 206


state 168

    (125) loop_statement -> for_loop .

    NEWLINE         reduce using rule 125 (loop_statement -> for_loop .)


state 169

    (126) loop_statement -> until_loop .

    NEWLINE         reduce using rule 126 (loop_statement -> until_loop .)


state 170

    (127) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 127 (loop_statement -> repeat_until .)


state 171

    (137) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 207


state 172

    (138) function_call -> input_statement .

    NEWLINE         reduce using rule 138 (function_call -> input_statement .)
    COMMA           reduce using rule 138 (function_call -> input_statement .)
    CHECK           reduce using rule 138 (function_call -> input_statement .)
    SWAP            reduce using rule 138 (function_call -> input_statement .)
    FUNCTION_NAME   reduce using rule 138 (function_call -> input_statement .)
    DISPLAY         reduce using rule 138 (function_call -> input_statement .)
    IDENT           reduce using rule 138 (function_call -> input_statement .)
    FOR             reduce using rule 138 (function_call -> input_statement .)
    UNTIL           reduce using rule 138 (function_call -> input_statement .)
    REPEAT          reduce using rule 138 (function_call -> input_statement .)
    INPUT           reduce using rule 138 (function_call -> input_statement .)
    INT             reduce using rule 138 (function_call -> input_statement .)
    FLT             reduce using rule 138 (function_call -> input_statement .)
    BLN             reduce using rule 138 (function_call -> input_statement .)
    CHR             reduce using rule 138 (function_call -> input_statement .)
    STR             reduce using rule 138 (function_call -> input_statement .)
    RBRACE          reduce using rule 138 (function_call -> input_statement .)
    REVIVE          reduce using rule 138 (function_call -> input_statement .)
    SHIFT           reduce using rule 138 (function_call -> input_statement .)
    OTHERWISE       reduce using rule 138 (function_call -> input_statement .)
    RPAREN          reduce using rule 138 (function_call -> input_statement .)
    COLON           reduce using rule 138 (function_call -> input_statement .)


state 173

    (145) output_statement -> DISPLAY . value next_val
    (146) output_statement -> DISPLAY . LPAREN value next_val RPAREN
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    LPAREN          shift and go to state 209
    TILDE           shift and go to state 53
    CONVERT_TO_INT  shift and go to state 214
    CONVERT_TO_FLT  shift and go to state 215
    CONVERT_TO_BLN  shift and go to state 216
    CONVERT_TO_STR  shift and go to state 217
    FUNCTION_NAME   shift and go to state 171
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 208
    factor                         shift and go to state 210
    type_cast                      shift and go to state 211
    expression                     shift and go to state 212
    function_call                  shift and go to state 213
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 172
    term                           shift and go to state 63

state 174

    (128) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 218


state 175

    (129) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 219


state 176

    (130) repeat_until -> REPEAT . LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 220


state 177

    (149) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 221


state 178

    (21) var_statement -> data_type IDENT var_tail .

    NEWLINE         reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    CHECK           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    SWAP            reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    FUNCTION_NAME   reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    DISPLAY         reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    IDENT           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    FOR             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    UNTIL           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    REPEAT          reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    INPUT           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    INT             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    FLT             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    BLN             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    CHR             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    STR             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    RBRACE          reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    REVIVE          reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    SHIFT           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    OTHERWISE       reduce using rule 21 (var_statement -> data_type IDENT var_tail .)


state 179

    (22) var_tail -> empty .

    NEWLINE         reduce using rule 22 (var_tail -> empty .)
    CHECK           reduce using rule 22 (var_tail -> empty .)
    SWAP            reduce using rule 22 (var_tail -> empty .)
    FUNCTION_NAME   reduce using rule 22 (var_tail -> empty .)
    DISPLAY         reduce using rule 22 (var_tail -> empty .)
    IDENT           reduce using rule 22 (var_tail -> empty .)
    FOR             reduce using rule 22 (var_tail -> empty .)
    UNTIL           reduce using rule 22 (var_tail -> empty .)
    REPEAT          reduce using rule 22 (var_tail -> empty .)
    INPUT           reduce using rule 22 (var_tail -> empty .)
    INT             reduce using rule 22 (var_tail -> empty .)
    FLT             reduce using rule 22 (var_tail -> empty .)
    BLN             reduce using rule 22 (var_tail -> empty .)
    CHR             reduce using rule 22 (var_tail -> empty .)
    STR             reduce using rule 22 (var_tail -> empty .)
    RBRACE          reduce using rule 22 (var_tail -> empty .)
    REVIVE          reduce using rule 22 (var_tail -> empty .)
    SHIFT           reduce using rule 22 (var_tail -> empty .)
    OTHERWISE       reduce using rule 22 (var_tail -> empty .)


state 180

    (23) var_tail -> EQ . tail_value var_tail2
    (27) tail_value -> . value
    (28) tail_value -> . LBRACKET list_element RBRACKET
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    LBRACKET        shift and go to state 224
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 214
    CONVERT_TO_FLT  shift and go to state 215
    CONVERT_TO_BLN  shift and go to state 216
    CONVERT_TO_STR  shift and go to state 217
    FUNCTION_NAME   shift and go to state 171
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    tail_value                     shift and go to state 222
    value                          shift and go to state 223
    factor                         shift and go to state 210
    type_cast                      shift and go to state 211
    expression                     shift and go to state 212
    function_call                  shift and go to state 213
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 172
    term                           shift and go to state 63

state 181

    (24) var_tail -> COMMA . IDENT var_tail

    IDENT           shift and go to state 225


state 182

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 226
    empty                          shift and go to state 16

state 183

    (103) revive -> REVIVE . value
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 214
    CONVERT_TO_FLT  shift and go to state 215
    CONVERT_TO_BLN  shift and go to state 216
    CONVERT_TO_STR  shift and go to state 217
    FUNCTION_NAME   shift and go to state 171
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 227
    factor                         shift and go to state 210
    type_cast                      shift and go to state 211
    expression                     shift and go to state 212
    function_call                  shift and go to state 213
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 172
    term                           shift and go to state 63

state 184

    (104) revive -> empty .

    NEWLINE         reduce using rule 104 (revive -> empty .)
    RBRACE          reduce using rule 104 (revive -> empty .)


state 185

    (108) statements_tail -> local_dec maybe_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 173
    IDENT           shift and go to state 56
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    local_dec                      shift and go to state 156
    statements_tail                shift and go to state 228
    empty                          shift and go to state 158
    string_operation_statement     shift and go to state 159
    conditional_statement          shift and go to state 160
    switch_statement               shift and go to state 161
    loop_statement                 shift and go to state 162
    function_call                  shift and go to state 163
    output_statement               shift and go to state 164
    var_statement                  shift and go to state 146
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170
    input_statement                shift and go to state 172
    data_type                      shift and go to state 147

state 186

    (109) statements_tail -> string_operation_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 173
    IDENT           shift and go to state 56
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    string_operation_statement     shift and go to state 159
    statements_tail                shift and go to state 229
    empty                          shift and go to state 158
    local_dec                      shift and go to state 156
    conditional_statement          shift and go to state 160
    switch_statement               shift and go to state 161
    loop_statement                 shift and go to state 162
    function_call                  shift and go to state 163
    output_statement               shift and go to state 164
    var_statement                  shift and go to state 146
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170
    input_statement                shift and go to state 172
    data_type                      shift and go to state 147

state 187

    (110) statements_tail -> conditional_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 173
    IDENT           shift and go to state 56
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    conditional_statement          shift and go to state 160
    statements_tail                shift and go to state 230
    empty                          shift and go to state 158
    local_dec                      shift and go to state 156
    string_operation_statement     shift and go to state 159
    switch_statement               shift and go to state 161
    loop_statement                 shift and go to state 162
    function_call                  shift and go to state 163
    output_statement               shift and go to state 164
    var_statement                  shift and go to state 146
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170
    input_statement                shift and go to state 172
    data_type                      shift and go to state 147

state 188

    (111) statements_tail -> switch_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 173
    IDENT           shift and go to state 56
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    switch_statement               shift and go to state 161
    statements_tail                shift and go to state 231
    empty                          shift and go to state 158
    local_dec                      shift and go to state 156
    string_operation_statement     shift and go to state 159
    conditional_statement          shift and go to state 160
    loop_statement                 shift and go to state 162
    function_call                  shift and go to state 163
    output_statement               shift and go to state 164
    var_statement                  shift and go to state 146
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170
    input_statement                shift and go to state 172
    data_type                      shift and go to state 147

state 189

    (112) statements_tail -> loop_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 173
    IDENT           shift and go to state 56
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    loop_statement                 shift and go to state 162
    statements_tail                shift and go to state 232
    empty                          shift and go to state 158
    local_dec                      shift and go to state 156
    string_operation_statement     shift and go to state 159
    conditional_statement          shift and go to state 160
    switch_statement               shift and go to state 161
    function_call                  shift and go to state 163
    output_statement               shift and go to state 164
    var_statement                  shift and go to state 146
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170
    input_statement                shift and go to state 172
    data_type                      shift and go to state 147

state 190

    (113) statements_tail -> function_call unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 173
    IDENT           shift and go to state 56
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    function_call                  shift and go to state 163
    statements_tail                shift and go to state 233
    empty                          shift and go to state 158
    local_dec                      shift and go to state 156
    string_operation_statement     shift and go to state 159
    conditional_statement          shift and go to state 160
    switch_statement               shift and go to state 161
    loop_statement                 shift and go to state 162
    output_statement               shift and go to state 164
    var_statement                  shift and go to state 146
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170
    input_statement                shift and go to state 172
    data_type                      shift and go to state 147

state 191

    (114) statements_tail -> output_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (150) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (121) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (125) loop_statement -> . for_loop
    (126) loop_statement -> . until_loop
    (127) loop_statement -> . repeat_until
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (145) output_statement -> . DISPLAY value next_val
    (146) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (128) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (129) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (130) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (149) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 173
    IDENT           shift and go to state 56
    FOR             shift and go to state 174
    UNTIL           shift and go to state 175
    REPEAT          shift and go to state 176
    INPUT           shift and go to state 177
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    output_statement               shift and go to state 164
    statements_tail                shift and go to state 234
    empty                          shift and go to state 158
    local_dec                      shift and go to state 156
    string_operation_statement     shift and go to state 159
    conditional_statement          shift and go to state 160
    switch_statement               shift and go to state 161
    loop_statement                 shift and go to state 162
    function_call                  shift and go to state 163
    var_statement                  shift and go to state 146
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170
    input_statement                shift and go to state 172
    data_type                      shift and go to state 147

state 192

    (150) string_operation_statement -> var_call string_operation_tail .

    NEWLINE         reduce using rule 150 (string_operation_statement -> var_call string_operation_tail .)


state 193

    (151) string_operation_tail -> assign_op . value
    (134) update_tail -> assign_op . value
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 214
    CONVERT_TO_FLT  shift and go to state 215
    CONVERT_TO_BLN  shift and go to state 216
    CONVERT_TO_STR  shift and go to state 217
    FUNCTION_NAME   shift and go to state 171
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 235
    factor                         shift and go to state 210
    type_cast                      shift and go to state 211
    expression                     shift and go to state 212
    function_call                  shift and go to state 213
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 172
    term                           shift and go to state 63

state 194

    (152) string_operation_tail -> PLUS . string_val stringcon_tail
    (162) string_val -> . var_call
    (163) string_val -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 238
    IDENT           shift and go to state 56

    string_val                     shift and go to state 236
    var_call                       shift and go to state 237

state 195

    (153) string_operation_tail -> update_tail .

    NEWLINE         reduce using rule 153 (string_operation_tail -> update_tail .)


state 196

    (154) assign_op -> PLUS_EQ .

    TILDE           reduce using rule 154 (assign_op -> PLUS_EQ .)
    LPAREN          reduce using rule 154 (assign_op -> PLUS_EQ .)
    CONVERT_TO_INT  reduce using rule 154 (assign_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 154 (assign_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 154 (assign_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 154 (assign_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 154 (assign_op -> PLUS_EQ .)
    IDENT           reduce using rule 154 (assign_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 154 (assign_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 154 (assign_op -> PLUS_EQ .)
    DAY             reduce using rule 154 (assign_op -> PLUS_EQ .)
    NIGHT           reduce using rule 154 (assign_op -> PLUS_EQ .)
    CHR_LIT         reduce using rule 154 (assign_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 154 (assign_op -> PLUS_EQ .)
    INPUT           reduce using rule 154 (assign_op -> PLUS_EQ .)


state 197

    (155) assign_op -> MINUS_EQ .

    TILDE           reduce using rule 155 (assign_op -> MINUS_EQ .)
    LPAREN          reduce using rule 155 (assign_op -> MINUS_EQ .)
    CONVERT_TO_INT  reduce using rule 155 (assign_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 155 (assign_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 155 (assign_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 155 (assign_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 155 (assign_op -> MINUS_EQ .)
    IDENT           reduce using rule 155 (assign_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 155 (assign_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 155 (assign_op -> MINUS_EQ .)
    DAY             reduce using rule 155 (assign_op -> MINUS_EQ .)
    NIGHT           reduce using rule 155 (assign_op -> MINUS_EQ .)
    CHR_LIT         reduce using rule 155 (assign_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 155 (assign_op -> MINUS_EQ .)
    INPUT           reduce using rule 155 (assign_op -> MINUS_EQ .)


state 198

    (156) assign_op -> MUL_EQ .

    TILDE           reduce using rule 156 (assign_op -> MUL_EQ .)
    LPAREN          reduce using rule 156 (assign_op -> MUL_EQ .)
    CONVERT_TO_INT  reduce using rule 156 (assign_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 156 (assign_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 156 (assign_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 156 (assign_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 156 (assign_op -> MUL_EQ .)
    IDENT           reduce using rule 156 (assign_op -> MUL_EQ .)
    INT_LIT         reduce using rule 156 (assign_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 156 (assign_op -> MUL_EQ .)
    DAY             reduce using rule 156 (assign_op -> MUL_EQ .)
    NIGHT           reduce using rule 156 (assign_op -> MUL_EQ .)
    CHR_LIT         reduce using rule 156 (assign_op -> MUL_EQ .)
    STR_LIT         reduce using rule 156 (assign_op -> MUL_EQ .)
    INPUT           reduce using rule 156 (assign_op -> MUL_EQ .)


state 199

    (157) assign_op -> DIV_EQ .

    TILDE           reduce using rule 157 (assign_op -> DIV_EQ .)
    LPAREN          reduce using rule 157 (assign_op -> DIV_EQ .)
    CONVERT_TO_INT  reduce using rule 157 (assign_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 157 (assign_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 157 (assign_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 157 (assign_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 157 (assign_op -> DIV_EQ .)
    IDENT           reduce using rule 157 (assign_op -> DIV_EQ .)
    INT_LIT         reduce using rule 157 (assign_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 157 (assign_op -> DIV_EQ .)
    DAY             reduce using rule 157 (assign_op -> DIV_EQ .)
    NIGHT           reduce using rule 157 (assign_op -> DIV_EQ .)
    CHR_LIT         reduce using rule 157 (assign_op -> DIV_EQ .)
    STR_LIT         reduce using rule 157 (assign_op -> DIV_EQ .)
    INPUT           reduce using rule 157 (assign_op -> DIV_EQ .)


state 200

    (158) assign_op -> MOD_EQ .

    TILDE           reduce using rule 158 (assign_op -> MOD_EQ .)
    LPAREN          reduce using rule 158 (assign_op -> MOD_EQ .)
    CONVERT_TO_INT  reduce using rule 158 (assign_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 158 (assign_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 158 (assign_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 158 (assign_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 158 (assign_op -> MOD_EQ .)
    IDENT           reduce using rule 158 (assign_op -> MOD_EQ .)
    INT_LIT         reduce using rule 158 (assign_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 158 (assign_op -> MOD_EQ .)
    DAY             reduce using rule 158 (assign_op -> MOD_EQ .)
    NIGHT           reduce using rule 158 (assign_op -> MOD_EQ .)
    CHR_LIT         reduce using rule 158 (assign_op -> MOD_EQ .)
    STR_LIT         reduce using rule 158 (assign_op -> MOD_EQ .)
    INPUT           reduce using rule 158 (assign_op -> MOD_EQ .)


state 201

    (159) assign_op -> EQ .

    TILDE           reduce using rule 159 (assign_op -> EQ .)
    LPAREN          reduce using rule 159 (assign_op -> EQ .)
    CONVERT_TO_INT  reduce using rule 159 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 159 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 159 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 159 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 159 (assign_op -> EQ .)
    IDENT           reduce using rule 159 (assign_op -> EQ .)
    INT_LIT         reduce using rule 159 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 159 (assign_op -> EQ .)
    DAY             reduce using rule 159 (assign_op -> EQ .)
    NIGHT           reduce using rule 159 (assign_op -> EQ .)
    CHR_LIT         reduce using rule 159 (assign_op -> EQ .)
    STR_LIT         reduce using rule 159 (assign_op -> EQ .)
    INPUT           reduce using rule 159 (assign_op -> EQ .)


state 202

    (133) update_tail -> postfix .

    NEWLINE         reduce using rule 133 (update_tail -> postfix .)
    RPAREN          reduce using rule 133 (update_tail -> postfix .)


state 203

    (135) postfix -> PLUS_PLUS .

    NEWLINE         reduce using rule 135 (postfix -> PLUS_PLUS .)
    RPAREN          reduce using rule 135 (postfix -> PLUS_PLUS .)


state 204

    (136) postfix -> MINUS_MINUS .

    NEWLINE         reduce using rule 136 (postfix -> MINUS_MINUS .)
    RPAREN          reduce using rule 136 (postfix -> MINUS_MINUS .)


state 205

    (117) conditional_statement -> CHECK LPAREN . expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 239
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 206

    (121) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    IDENT           shift and go to state 240


state 207

    (137) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (139) arguments -> . empty
    (140) arguments -> . arg_value arg_tail
    (164) empty -> .
    (143) arg_value -> . literal
    (144) arg_value -> . var_call
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    RPAREN          reduce using rule 164 (empty -> .)
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    IDENT           shift and go to state 56

    arguments                      shift and go to state 241
    empty                          shift and go to state 242
    arg_value                      shift and go to state 243
    literal                        shift and go to state 244
    var_call                       shift and go to state 245

state 208

    (145) output_statement -> DISPLAY value . next_val
    (147) next_val -> . empty
    (148) next_val -> . COMMA value next_val
    (164) empty -> .

    COMMA           shift and go to state 248
    NEWLINE         reduce using rule 164 (empty -> .)

    next_val                       shift and go to state 246
    empty                          shift and go to state 247

state 209

    (146) output_statement -> DISPLAY LPAREN . value next_val RPAREN
    (64) factor -> LPAREN . expression RPAREN
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (58) expression -> . expr_head expr_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (59) expr_head -> . term term_tail
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 214
    CONVERT_TO_FLT  shift and go to state 215
    CONVERT_TO_BLN  shift and go to state 216
    CONVERT_TO_STR  shift and go to state 217
    FUNCTION_NAME   shift and go to state 171
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 249
    expression                     shift and go to state 250
    factor                         shift and go to state 210
    type_cast                      shift and go to state 211
    function_call                  shift and go to state 213
    expr_head                      shift and go to state 55
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    input_statement                shift and go to state 172
    term                           shift and go to state 63

state 210

    (39) value -> factor .
    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (164) empty -> .

  ! reduce/reduce conflict for COMMA resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for CHECK resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for SWAP resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for FUNCTION_NAME resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for DISPLAY resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for IDENT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for FOR resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for UNTIL resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for REPEAT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for INPUT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for INT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for FLT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for BLN resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for CHR resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for STR resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for RBRACE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for REVIVE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for SHIFT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for RPAREN resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for COLON resolved using rule 39 (value -> factor .)
    COMMA           reduce using rule 39 (value -> factor .)
    NEWLINE         reduce using rule 39 (value -> factor .)
    CHECK           reduce using rule 39 (value -> factor .)
    SWAP            reduce using rule 39 (value -> factor .)
    FUNCTION_NAME   reduce using rule 39 (value -> factor .)
    DISPLAY         reduce using rule 39 (value -> factor .)
    IDENT           reduce using rule 39 (value -> factor .)
    FOR             reduce using rule 39 (value -> factor .)
    UNTIL           reduce using rule 39 (value -> factor .)
    REPEAT          reduce using rule 39 (value -> factor .)
    INPUT           reduce using rule 39 (value -> factor .)
    INT             reduce using rule 39 (value -> factor .)
    FLT             reduce using rule 39 (value -> factor .)
    BLN             reduce using rule 39 (value -> factor .)
    CHR             reduce using rule 39 (value -> factor .)
    STR             reduce using rule 39 (value -> factor .)
    RBRACE          reduce using rule 39 (value -> factor .)
    REVIVE          reduce using rule 39 (value -> factor .)
    SHIFT           reduce using rule 39 (value -> factor .)
    OTHERWISE       reduce using rule 39 (value -> factor .)
    RPAREN          reduce using rule 39 (value -> factor .)
    COLON           reduce using rule 39 (value -> factor .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 164 (empty -> .)
    LT              reduce using rule 164 (empty -> .)
    EQ_EQ           reduce using rule 164 (empty -> .)
    GT_EQ           reduce using rule 164 (empty -> .)
    LT_EQ           reduce using rule 164 (empty -> .)
    NOT_EQ          reduce using rule 164 (empty -> .)
    AND             reduce using rule 164 (empty -> .)
    OR              reduce using rule 164 (empty -> .)

  ! COMMA           [ reduce using rule 164 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]
  ! CHECK           [ reduce using rule 164 (empty -> .) ]
  ! SWAP            [ reduce using rule 164 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 164 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 164 (empty -> .) ]
  ! IDENT           [ reduce using rule 164 (empty -> .) ]
  ! FOR             [ reduce using rule 164 (empty -> .) ]
  ! UNTIL           [ reduce using rule 164 (empty -> .) ]
  ! REPEAT          [ reduce using rule 164 (empty -> .) ]
  ! INPUT           [ reduce using rule 164 (empty -> .) ]
  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]
  ! RBRACE          [ reduce using rule 164 (empty -> .) ]
  ! REVIVE          [ reduce using rule 164 (empty -> .) ]
  ! SHIFT           [ reduce using rule 164 (empty -> .) ]
  ! OTHERWISE       [ reduce using rule 164 (empty -> .) ]
  ! RPAREN          [ reduce using rule 164 (empty -> .) ]
  ! COLON           [ reduce using rule 164 (empty -> .) ]

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 211

    (40) value -> type_cast .

    COMMA           reduce using rule 40 (value -> type_cast .)
    NEWLINE         reduce using rule 40 (value -> type_cast .)
    CHECK           reduce using rule 40 (value -> type_cast .)
    SWAP            reduce using rule 40 (value -> type_cast .)
    FUNCTION_NAME   reduce using rule 40 (value -> type_cast .)
    DISPLAY         reduce using rule 40 (value -> type_cast .)
    IDENT           reduce using rule 40 (value -> type_cast .)
    FOR             reduce using rule 40 (value -> type_cast .)
    UNTIL           reduce using rule 40 (value -> type_cast .)
    REPEAT          reduce using rule 40 (value -> type_cast .)
    INPUT           reduce using rule 40 (value -> type_cast .)
    INT             reduce using rule 40 (value -> type_cast .)
    FLT             reduce using rule 40 (value -> type_cast .)
    BLN             reduce using rule 40 (value -> type_cast .)
    CHR             reduce using rule 40 (value -> type_cast .)
    STR             reduce using rule 40 (value -> type_cast .)
    RBRACE          reduce using rule 40 (value -> type_cast .)
    REVIVE          reduce using rule 40 (value -> type_cast .)
    SHIFT           reduce using rule 40 (value -> type_cast .)
    OTHERWISE       reduce using rule 40 (value -> type_cast .)
    RPAREN          reduce using rule 40 (value -> type_cast .)
    COLON           reduce using rule 40 (value -> type_cast .)


state 212

    (41) value -> expression .

    COMMA           reduce using rule 41 (value -> expression .)
    NEWLINE         reduce using rule 41 (value -> expression .)
    CHECK           reduce using rule 41 (value -> expression .)
    SWAP            reduce using rule 41 (value -> expression .)
    FUNCTION_NAME   reduce using rule 41 (value -> expression .)
    DISPLAY         reduce using rule 41 (value -> expression .)
    IDENT           reduce using rule 41 (value -> expression .)
    FOR             reduce using rule 41 (value -> expression .)
    UNTIL           reduce using rule 41 (value -> expression .)
    REPEAT          reduce using rule 41 (value -> expression .)
    INPUT           reduce using rule 41 (value -> expression .)
    INT             reduce using rule 41 (value -> expression .)
    FLT             reduce using rule 41 (value -> expression .)
    BLN             reduce using rule 41 (value -> expression .)
    CHR             reduce using rule 41 (value -> expression .)
    STR             reduce using rule 41 (value -> expression .)
    RBRACE          reduce using rule 41 (value -> expression .)
    REVIVE          reduce using rule 41 (value -> expression .)
    SHIFT           reduce using rule 41 (value -> expression .)
    OTHERWISE       reduce using rule 41 (value -> expression .)
    RPAREN          reduce using rule 41 (value -> expression .)
    COLON           reduce using rule 41 (value -> expression .)


state 213

    (42) value -> function_call .

    COMMA           reduce using rule 42 (value -> function_call .)
    NEWLINE         reduce using rule 42 (value -> function_call .)
    CHECK           reduce using rule 42 (value -> function_call .)
    SWAP            reduce using rule 42 (value -> function_call .)
    FUNCTION_NAME   reduce using rule 42 (value -> function_call .)
    DISPLAY         reduce using rule 42 (value -> function_call .)
    IDENT           reduce using rule 42 (value -> function_call .)
    FOR             reduce using rule 42 (value -> function_call .)
    UNTIL           reduce using rule 42 (value -> function_call .)
    REPEAT          reduce using rule 42 (value -> function_call .)
    INPUT           reduce using rule 42 (value -> function_call .)
    INT             reduce using rule 42 (value -> function_call .)
    FLT             reduce using rule 42 (value -> function_call .)
    BLN             reduce using rule 42 (value -> function_call .)
    CHR             reduce using rule 42 (value -> function_call .)
    STR             reduce using rule 42 (value -> function_call .)
    RBRACE          reduce using rule 42 (value -> function_call .)
    REVIVE          reduce using rule 42 (value -> function_call .)
    SHIFT           reduce using rule 42 (value -> function_call .)
    OTHERWISE       reduce using rule 42 (value -> function_call .)
    RPAREN          reduce using rule 42 (value -> function_call .)
    COLON           reduce using rule 42 (value -> function_call .)


state 214

    (43) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 251


state 215

    (44) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 252


state 216

    (45) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 253


state 217

    (46) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 254


state 218

    (128) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) control_variable -> . INT IDENT EQ INT_LIT

    INT             shift and go to state 256

    control_variable               shift and go to state 255

state 219

    (129) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE maybe_newline statements RBRACE
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 257
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 220

    (130) repeat_until -> REPEAT LBRACE . maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 258
    empty                          shift and go to state 16

state 221

    (149) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 259


state 222

    (23) var_tail -> EQ tail_value . var_tail2
    (25) var_tail2 -> . empty
    (26) var_tail2 -> . COMMA IDENT var_tail
    (164) empty -> .

    COMMA           shift and go to state 262
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)

    var_tail2                      shift and go to state 260
    empty                          shift and go to state 261

state 223

    (27) tail_value -> value .

    COMMA           reduce using rule 27 (tail_value -> value .)
    NEWLINE         reduce using rule 27 (tail_value -> value .)
    CHECK           reduce using rule 27 (tail_value -> value .)
    SWAP            reduce using rule 27 (tail_value -> value .)
    FUNCTION_NAME   reduce using rule 27 (tail_value -> value .)
    DISPLAY         reduce using rule 27 (tail_value -> value .)
    IDENT           reduce using rule 27 (tail_value -> value .)
    FOR             reduce using rule 27 (tail_value -> value .)
    UNTIL           reduce using rule 27 (tail_value -> value .)
    REPEAT          reduce using rule 27 (tail_value -> value .)
    INPUT           reduce using rule 27 (tail_value -> value .)
    INT             reduce using rule 27 (tail_value -> value .)
    FLT             reduce using rule 27 (tail_value -> value .)
    BLN             reduce using rule 27 (tail_value -> value .)
    CHR             reduce using rule 27 (tail_value -> value .)
    STR             reduce using rule 27 (tail_value -> value .)
    RBRACE          reduce using rule 27 (tail_value -> value .)
    REVIVE          reduce using rule 27 (tail_value -> value .)
    SHIFT           reduce using rule 27 (tail_value -> value .)
    OTHERWISE       reduce using rule 27 (tail_value -> value .)


state 224

    (28) tail_value -> LBRACKET . list_element RBRACKET
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 263
    literal                        shift and go to state 72

state 225

    (24) var_tail -> COMMA IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (164) empty -> .

    EQ              shift and go to state 180
    COMMA           shift and go to state 181
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)

    var_tail                       shift and go to state 264
    empty                          shift and go to state 179

state 226

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline . RBRACE

    RBRACE          shift and go to state 265


state 227

    (103) revive -> REVIVE value .

    NEWLINE         reduce using rule 103 (revive -> REVIVE value .)
    RBRACE          reduce using rule 103 (revive -> REVIVE value .)


state 228

    (108) statements_tail -> local_dec maybe_newline statements_tail .

    NEWLINE         reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)
    REVIVE          reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)


state 229

    (109) statements_tail -> string_operation_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)


state 230

    (110) statements_tail -> conditional_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)


state 231

    (111) statements_tail -> switch_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)


state 232

    (112) statements_tail -> loop_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)


state 233

    (113) statements_tail -> function_call unli_newline statements_tail .

    NEWLINE         reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)
    RBRACE          reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)
    REVIVE          reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)
    SHIFT           reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)
    OTHERWISE       reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)


state 234

    (114) statements_tail -> output_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)


state 235

    (151) string_operation_tail -> assign_op value .
    (134) update_tail -> assign_op value .

  ! reduce/reduce conflict for NEWLINE resolved using rule 134 (update_tail -> assign_op value .)
    NEWLINE         reduce using rule 134 (update_tail -> assign_op value .)

  ! NEWLINE         [ reduce using rule 151 (string_operation_tail -> assign_op value .) ]


state 236

    (152) string_operation_tail -> PLUS string_val . stringcon_tail
    (160) stringcon_tail -> . empty
    (161) stringcon_tail -> . PLUS string_val stringcon_tail
    (164) empty -> .

    PLUS            shift and go to state 266
    NEWLINE         reduce using rule 164 (empty -> .)

    stringcon_tail                 shift and go to state 267
    empty                          shift and go to state 268

state 237

    (162) string_val -> var_call .

    PLUS            reduce using rule 162 (string_val -> var_call .)
    NEWLINE         reduce using rule 162 (string_val -> var_call .)


state 238

    (163) string_val -> STR_LIT .

    PLUS            reduce using rule 163 (string_val -> STR_LIT .)
    NEWLINE         reduce using rule 163 (string_val -> STR_LIT .)


state 239

    (117) conditional_statement -> CHECK LPAREN expression . RPAREN LBRACE maybe_newline statements RBRACE conditional_tail

    RPAREN          shift and go to state 269


state 240

    (121) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    RPAREN          shift and go to state 270


state 241

    (137) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 271


state 242

    (139) arguments -> empty .

    RPAREN          reduce using rule 139 (arguments -> empty .)


state 243

    (140) arguments -> arg_value . arg_tail
    (141) arg_tail -> . empty
    (142) arg_tail -> . COMMA arg_value arg_tail
    (164) empty -> .

    COMMA           shift and go to state 274
    RPAREN          reduce using rule 164 (empty -> .)

    arg_tail                       shift and go to state 272
    empty                          shift and go to state 273

state 244

    (143) arg_value -> literal .

    COMMA           reduce using rule 143 (arg_value -> literal .)
    RPAREN          reduce using rule 143 (arg_value -> literal .)


state 245

    (144) arg_value -> var_call .

    COMMA           reduce using rule 144 (arg_value -> var_call .)
    RPAREN          reduce using rule 144 (arg_value -> var_call .)


state 246

    (145) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 145 (output_statement -> DISPLAY value next_val .)


state 247

    (147) next_val -> empty .

    NEWLINE         reduce using rule 147 (next_val -> empty .)
    RPAREN          reduce using rule 147 (next_val -> empty .)


state 248

    (148) next_val -> COMMA . value next_val
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 214
    CONVERT_TO_FLT  shift and go to state 215
    CONVERT_TO_BLN  shift and go to state 216
    CONVERT_TO_STR  shift and go to state 217
    FUNCTION_NAME   shift and go to state 171
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 275
    factor                         shift and go to state 210
    type_cast                      shift and go to state 211
    expression                     shift and go to state 212
    function_call                  shift and go to state 213
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 172
    term                           shift and go to state 63

state 249

    (146) output_statement -> DISPLAY LPAREN value . next_val RPAREN
    (147) next_val -> . empty
    (148) next_val -> . COMMA value next_val
    (164) empty -> .

    COMMA           shift and go to state 248
    RPAREN          reduce using rule 164 (empty -> .)

    next_val                       shift and go to state 276
    empty                          shift and go to state 247

state 250

    (64) factor -> LPAREN expression . RPAREN
    (41) value -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 113
    COMMA           reduce using rule 41 (value -> expression .)

  ! RPAREN          [ reduce using rule 41 (value -> expression .) ]


state 251

    (43) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 278
    FUNCTION_NAME   shift and go to state 281
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 277
    literal                        shift and go to state 279
    expression                     shift and go to state 280
    input_statement                shift and go to state 282
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 252

    (44) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 278
    FUNCTION_NAME   shift and go to state 281
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 283
    literal                        shift and go to state 279
    expression                     shift and go to state 280
    input_statement                shift and go to state 282
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 253

    (45) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 278
    FUNCTION_NAME   shift and go to state 281
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 284
    literal                        shift and go to state 279
    expression                     shift and go to state 280
    input_statement                shift and go to state 282
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 254

    (46) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 278
    FUNCTION_NAME   shift and go to state 281
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 285
    literal                        shift and go to state 279
    expression                     shift and go to state 280
    input_statement                shift and go to state 282
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 255

    (128) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 286


state 256

    (131) control_variable -> INT . IDENT EQ INT_LIT

    IDENT           shift and go to state 287


state 257

    (129) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 288


state 258

    (130) repeat_until -> REPEAT LBRACE maybe_newline . statements RBRACE UNTIL LPAREN expression RPAREN
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 289
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 259

    (149) input_statement -> INPUT LPAREN RPAREN .

    NEWLINE         reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    CHECK           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    SWAP            reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION_NAME   reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    DISPLAY         reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    IDENT           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    UNTIL           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    REPEAT          reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    FLT             reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    BLN             reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    CHR             reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    STR             reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    REVIVE          reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    SHIFT           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    OTHERWISE       reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 149 (input_statement -> INPUT LPAREN RPAREN .)


state 260

    (23) var_tail -> EQ tail_value var_tail2 .

    NEWLINE         reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    CHECK           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    SWAP            reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    FUNCTION_NAME   reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    DISPLAY         reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    IDENT           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    FOR             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    UNTIL           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    REPEAT          reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    INPUT           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    INT             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    FLT             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    BLN             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    CHR             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    STR             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    RBRACE          reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    REVIVE          reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    SHIFT           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    OTHERWISE       reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)


state 261

    (25) var_tail2 -> empty .

    NEWLINE         reduce using rule 25 (var_tail2 -> empty .)
    CHECK           reduce using rule 25 (var_tail2 -> empty .)
    SWAP            reduce using rule 25 (var_tail2 -> empty .)
    FUNCTION_NAME   reduce using rule 25 (var_tail2 -> empty .)
    DISPLAY         reduce using rule 25 (var_tail2 -> empty .)
    IDENT           reduce using rule 25 (var_tail2 -> empty .)
    FOR             reduce using rule 25 (var_tail2 -> empty .)
    UNTIL           reduce using rule 25 (var_tail2 -> empty .)
    REPEAT          reduce using rule 25 (var_tail2 -> empty .)
    INPUT           reduce using rule 25 (var_tail2 -> empty .)
    INT             reduce using rule 25 (var_tail2 -> empty .)
    FLT             reduce using rule 25 (var_tail2 -> empty .)
    BLN             reduce using rule 25 (var_tail2 -> empty .)
    CHR             reduce using rule 25 (var_tail2 -> empty .)
    STR             reduce using rule 25 (var_tail2 -> empty .)
    RBRACE          reduce using rule 25 (var_tail2 -> empty .)
    REVIVE          reduce using rule 25 (var_tail2 -> empty .)
    SHIFT           reduce using rule 25 (var_tail2 -> empty .)
    OTHERWISE       reduce using rule 25 (var_tail2 -> empty .)


state 262

    (26) var_tail2 -> COMMA . IDENT var_tail

    IDENT           shift and go to state 290


state 263

    (28) tail_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 291


state 264

    (24) var_tail -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    CHECK           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    SWAP            reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    FUNCTION_NAME   reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    DISPLAY         reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    IDENT           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    FOR             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    UNTIL           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    REPEAT          reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    INPUT           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    INT             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    FLT             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    BLN             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    CHR             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    STR             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    RBRACE          reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    REVIVE          reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    SHIFT           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    OTHERWISE       reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)


state 265

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .

    NEWLINE         reduce using rule 85 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .)
    MAIN_CASPER     reduce using rule 85 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .)


state 266

    (161) stringcon_tail -> PLUS . string_val stringcon_tail
    (162) string_val -> . var_call
    (163) string_val -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 238
    IDENT           shift and go to state 56

    string_val                     shift and go to state 292
    var_call                       shift and go to state 237

state 267

    (152) string_operation_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 152 (string_operation_tail -> PLUS string_val stringcon_tail .)


state 268

    (160) stringcon_tail -> empty .

    NEWLINE         reduce using rule 160 (stringcon_tail -> empty .)


state 269

    (117) conditional_statement -> CHECK LPAREN expression RPAREN . LBRACE maybe_newline statements RBRACE conditional_tail

    LBRACE          shift and go to state 293


state 270

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 294


state 271

    (137) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHECK           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SWAP            reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FUNCTION_NAME   reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    DISPLAY         reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    IDENT           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FOR             reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    UNTIL           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REPEAT          reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INPUT           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INT             reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FLT             reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    BLN             reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHR             reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    STR             reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REVIVE          reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SHIFT           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    OTHERWISE       reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 137 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 272

    (140) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 140 (arguments -> arg_value arg_tail .)


state 273

    (141) arg_tail -> empty .

    RPAREN          reduce using rule 141 (arg_tail -> empty .)


state 274

    (142) arg_tail -> COMMA . arg_value arg_tail
    (143) arg_value -> . literal
    (144) arg_value -> . var_call
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    IDENT           shift and go to state 56

    arg_value                      shift and go to state 295
    literal                        shift and go to state 244
    var_call                       shift and go to state 245

state 275

    (148) next_val -> COMMA value . next_val
    (147) next_val -> . empty
    (148) next_val -> . COMMA value next_val
    (164) empty -> .

    COMMA           shift and go to state 248
    NEWLINE         reduce using rule 164 (empty -> .)
    RPAREN          reduce using rule 164 (empty -> .)

    next_val                       shift and go to state 296
    empty                          shift and go to state 247

state 276

    (146) output_statement -> DISPLAY LPAREN value next_val . RPAREN

    RPAREN          shift and go to state 297


state 277

    (43) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 298


state 278

    (47) typecast_value -> IDENT .
    (82) var_call -> IDENT . var_call_tail
    (83) var_call_tail -> . empty
    (84) var_call_tail -> . LBRACKET index RBRACKET
    (164) empty -> .

  ! reduce/reduce conflict for RPAREN resolved using rule 47 (typecast_value -> IDENT .)
    RPAREN          reduce using rule 47 (typecast_value -> IDENT .)
    LBRACKET        shift and go to state 90
    PLUS            reduce using rule 164 (empty -> .)
    MINUS           reduce using rule 164 (empty -> .)
    MULTIPLY        reduce using rule 164 (empty -> .)
    DIVISION        reduce using rule 164 (empty -> .)
    MODULO          reduce using rule 164 (empty -> .)
    EXPONENT        reduce using rule 164 (empty -> .)
    GT              reduce using rule 164 (empty -> .)
    LT              reduce using rule 164 (empty -> .)
    EQ_EQ           reduce using rule 164 (empty -> .)
    GT_EQ           reduce using rule 164 (empty -> .)
    LT_EQ           reduce using rule 164 (empty -> .)
    NOT_EQ          reduce using rule 164 (empty -> .)
    AND             reduce using rule 164 (empty -> .)
    OR              reduce using rule 164 (empty -> .)

  ! RPAREN          [ reduce using rule 164 (empty -> .) ]

    var_call_tail                  shift and go to state 88
    empty                          shift and go to state 89

state 279

    (48) typecast_value -> literal .
    (62) factor -> literal .

  ! reduce/reduce conflict for RPAREN resolved using rule 48 (typecast_value -> literal .)
    RPAREN          reduce using rule 48 (typecast_value -> literal .)
    PLUS            reduce using rule 62 (factor -> literal .)
    MINUS           reduce using rule 62 (factor -> literal .)
    MULTIPLY        reduce using rule 62 (factor -> literal .)
    DIVISION        reduce using rule 62 (factor -> literal .)
    MODULO          reduce using rule 62 (factor -> literal .)
    EXPONENT        reduce using rule 62 (factor -> literal .)
    GT              reduce using rule 62 (factor -> literal .)
    LT              reduce using rule 62 (factor -> literal .)
    EQ_EQ           reduce using rule 62 (factor -> literal .)
    GT_EQ           reduce using rule 62 (factor -> literal .)
    LT_EQ           reduce using rule 62 (factor -> literal .)
    NOT_EQ          reduce using rule 62 (factor -> literal .)
    AND             reduce using rule 62 (factor -> literal .)
    OR              reduce using rule 62 (factor -> literal .)

  ! RPAREN          [ reduce using rule 62 (factor -> literal .) ]


state 280

    (49) typecast_value -> expression .

    RPAREN          reduce using rule 49 (typecast_value -> expression .)


state 281

    (50) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 299


state 282

    (51) typecast_value -> input_statement .

    RPAREN          reduce using rule 51 (typecast_value -> input_statement .)


state 283

    (44) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 300


state 284

    (45) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 301


state 285

    (46) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 302


state 286

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 303
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 287

    (131) control_variable -> INT IDENT . EQ INT_LIT

    EQ              shift and go to state 304


state 288

    (129) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 305


state 289

    (130) repeat_until -> REPEAT LBRACE maybe_newline statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 306


state 290

    (26) var_tail2 -> COMMA IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (164) empty -> .

    EQ              shift and go to state 180
    COMMA           shift and go to state 181
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    REVIVE          reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)

    var_tail                       shift and go to state 307
    empty                          shift and go to state 179

state 291

    (28) tail_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    CHECK           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    SWAP            reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_NAME   reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    DISPLAY         reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    IDENT           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    FOR             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    UNTIL           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    REPEAT          reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    INPUT           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    INT             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    FLT             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    BLN             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    CHR             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    STR             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    RBRACE          reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    REVIVE          reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    SHIFT           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    OTHERWISE       reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)


state 292

    (161) stringcon_tail -> PLUS string_val . stringcon_tail
    (160) stringcon_tail -> . empty
    (161) stringcon_tail -> . PLUS string_val stringcon_tail
    (164) empty -> .

    PLUS            shift and go to state 266
    NEWLINE         reduce using rule 164 (empty -> .)

    stringcon_tail                 shift and go to state 308
    empty                          shift and go to state 268

state 293

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE . maybe_newline statements RBRACE conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 309
    empty                          shift and go to state 16

state 294

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    SHIFT           reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 310
    empty                          shift and go to state 16

state 295

    (142) arg_tail -> COMMA arg_value . arg_tail
    (141) arg_tail -> . empty
    (142) arg_tail -> . COMMA arg_value arg_tail
    (164) empty -> .

    COMMA           shift and go to state 274
    RPAREN          reduce using rule 164 (empty -> .)

    arg_tail                       shift and go to state 311
    empty                          shift and go to state 273

state 296

    (148) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 148 (next_val -> COMMA value next_val .)
    RPAREN          reduce using rule 148 (next_val -> COMMA value next_val .)


state 297

    (146) output_statement -> DISPLAY LPAREN value next_val RPAREN .

    NEWLINE         reduce using rule 146 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)


state 298

    (43) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 299

    (50) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 312


state 300

    (44) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 301

    (45) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INT             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    STR             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 302

    (46) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INT             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    STR             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 303

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 313


state 304

    (131) control_variable -> INT IDENT EQ . INT_LIT

    INT_LIT         shift and go to state 314


state 305

    (129) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 315
    empty                          shift and go to state 16

state 306

    (130) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 316


state 307

    (26) var_tail2 -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    CHECK           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    SWAP            reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    FUNCTION_NAME   reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    DISPLAY         reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    IDENT           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    FOR             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    UNTIL           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    REPEAT          reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    INPUT           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    INT             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    FLT             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    BLN             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    CHR             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    STR             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    RBRACE          reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    REVIVE          reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    SHIFT           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    OTHERWISE       reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)


state 308

    (161) stringcon_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 161 (stringcon_tail -> PLUS string_val stringcon_tail .)


state 309

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline . statements RBRACE conditional_tail
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 317
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 310

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline . switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (122) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    SHIFT           shift and go to state 319

    switch_condition               shift and go to state 318

state 311

    (142) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 142 (arg_tail -> COMMA arg_value arg_tail .)


state 312

    (50) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 50 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 313

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (132) update -> . var_call update_tail
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 56

    update                         shift and go to state 320
    var_call                       shift and go to state 321

state 314

    (131) control_variable -> INT IDENT EQ INT_LIT .

    SEMICOLON       reduce using rule 131 (control_variable -> INT IDENT EQ INT_LIT .)


state 315

    (129) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 322
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 316

    (130) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 323


state 317

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements . RBRACE conditional_tail

    RBRACE          shift and go to state 324


state 318

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE       reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 325
    empty                          shift and go to state 16

state 319

    (122) switch_condition -> SHIFT . value COLON maybe_newline statements switchcond_tail
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 214
    CONVERT_TO_FLT  shift and go to state 215
    CONVERT_TO_BLN  shift and go to state 216
    CONVERT_TO_STR  shift and go to state 217
    FUNCTION_NAME   shift and go to state 171
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 326
    factor                         shift and go to state 210
    type_cast                      shift and go to state 211
    expression                     shift and go to state 212
    function_call                  shift and go to state 213
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 172
    term                           shift and go to state 63

state 320

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 327


state 321

    (132) update -> var_call . update_tail
    (133) update_tail -> . postfix
    (134) update_tail -> . assign_op value
    (135) postfix -> . PLUS_PLUS
    (136) postfix -> . MINUS_MINUS
    (154) assign_op -> . PLUS_EQ
    (155) assign_op -> . MINUS_EQ
    (156) assign_op -> . MUL_EQ
    (157) assign_op -> . DIV_EQ
    (158) assign_op -> . MOD_EQ
    (159) assign_op -> . EQ

    PLUS_PLUS       shift and go to state 203
    MINUS_MINUS     shift and go to state 204
    PLUS_EQ         shift and go to state 196
    MINUS_EQ        shift and go to state 197
    MUL_EQ          shift and go to state 198
    DIV_EQ          shift and go to state 199
    MOD_EQ          shift and go to state 200
    EQ              shift and go to state 201

    update_tail                    shift and go to state 328
    postfix                        shift and go to state 202
    assign_op                      shift and go to state 329

state 322

    (129) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 330


state 323

    (130) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN . expression RPAREN
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 331
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 324

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE . conditional_tail
    (118) conditional_tail -> . empty
    (119) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (120) conditional_tail -> . OTHERWISE LBRACE maybe_newline statements RBRACE
    (164) empty -> .

    OTHERWISE_CHECK shift and go to state 334
    OTHERWISE       shift and go to state 335
    NEWLINE         reduce using rule 164 (empty -> .)

    conditional_tail               shift and go to state 332
    empty                          shift and go to state 333

state 325

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    OTHERWISE       shift and go to state 336


state 326

    (122) switch_condition -> SHIFT value . COLON maybe_newline statements switchcond_tail

    COLON           shift and go to state 337


state 327

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 338
    empty                          shift and go to state 16

state 328

    (132) update -> var_call update_tail .

    RPAREN          reduce using rule 132 (update -> var_call update_tail .)


state 329

    (134) update_tail -> assign_op . value
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (137) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (138) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (149) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 214
    CONVERT_TO_FLT  shift and go to state 215
    CONVERT_TO_BLN  shift and go to state 216
    CONVERT_TO_STR  shift and go to state 217
    FUNCTION_NAME   shift and go to state 171
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 177

    value                          shift and go to state 339
    factor                         shift and go to state 210
    type_cast                      shift and go to state 211
    expression                     shift and go to state 212
    function_call                  shift and go to state 213
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 172
    term                           shift and go to state 63

state 330

    (129) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 129 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .)


state 331

    (130) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 340


state 332

    (117) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail .

    NEWLINE         reduce using rule 117 (conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE conditional_tail .)


state 333

    (118) conditional_tail -> empty .

    NEWLINE         reduce using rule 118 (conditional_tail -> empty .)


state 334

    (119) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 341


state 335

    (120) conditional_tail -> OTHERWISE . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 342


state 336

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 343
    empty                          shift and go to state 16

state 337

    (122) switch_condition -> SHIFT value COLON . maybe_newline statements switchcond_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    SHIFT           reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 344
    empty                          shift and go to state 16

state 338

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 345


state 339

    (134) update_tail -> assign_op value .

    RPAREN          reduce using rule 134 (update_tail -> assign_op value .)


state 340

    (130) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 130 (repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN .)


state 341

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN LBRACE maybe_newline statements RBRACE
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 346
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 342

    (120) conditional_tail -> OTHERWISE LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 347
    empty                          shift and go to state 16

state 343

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 348


state 344

    (122) switch_condition -> SHIFT value COLON maybe_newline . statements switchcond_tail
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SHIFT           reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 349
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 345

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 350
    empty                          shift and go to state 16

state 346

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 351


state 347

    (120) conditional_tail -> OTHERWISE LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 352
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 348

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 353
    empty                          shift and go to state 16

state 349

    (122) switch_condition -> SHIFT value COLON maybe_newline statements . switchcond_tail
    (123) switchcond_tail -> . empty
    (124) switchcond_tail -> . switch_condition
    (164) empty -> .
    (122) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    NEWLINE         reduce using rule 164 (empty -> .)
    OTHERWISE       reduce using rule 164 (empty -> .)
    SHIFT           shift and go to state 319

    switchcond_tail                shift and go to state 354
    empty                          shift and go to state 355
    switch_condition               shift and go to state 356

state 350

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 357
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 351

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 358


state 352

    (120) conditional_tail -> OTHERWISE LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 359


state 353

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 360
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 354

    (122) switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .

    NEWLINE         reduce using rule 122 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)
    OTHERWISE       reduce using rule 122 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)


state 355

    (123) switchcond_tail -> empty .

    NEWLINE         reduce using rule 123 (switchcond_tail -> empty .)
    OTHERWISE       reduce using rule 123 (switchcond_tail -> empty .)


state 356

    (124) switchcond_tail -> switch_condition .

    NEWLINE         reduce using rule 124 (switchcond_tail -> switch_condition .)
    OTHERWISE       reduce using rule 124 (switchcond_tail -> switch_condition .)


state 357

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 361


state 358

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 164 (empty -> .)
    FLT             reduce using rule 164 (empty -> .)
    BLN             reduce using rule 164 (empty -> .)
    CHR             reduce using rule 164 (empty -> .)
    STR             reduce using rule 164 (empty -> .)
    RBRACE          reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)

  ! NEWLINE         [ reduce using rule 164 (empty -> .) ]

    maybe_newline                  shift and go to state 362
    empty                          shift and go to state 16

state 359

    (120) conditional_tail -> OTHERWISE LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 120 (conditional_tail -> OTHERWISE LBRACE maybe_newline statements RBRACE .)


state 360

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 363
    empty                          shift and go to state 16

state 361

    (128) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 128 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .)


state 362

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (164) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 164 (empty -> .)
    NEWLINE         reduce using rule 164 (empty -> .)
    CHECK           reduce using rule 164 (empty -> .)
    SWAP            reduce using rule 164 (empty -> .)
    FUNCTION_NAME   reduce using rule 164 (empty -> .)
    DISPLAY         reduce using rule 164 (empty -> .)
    IDENT           reduce using rule 164 (empty -> .)
    FOR             reduce using rule 164 (empty -> .)
    UNTIL           reduce using rule 164 (empty -> .)
    REPEAT          reduce using rule 164 (empty -> .)
    INPUT           reduce using rule 164 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 164 (empty -> .) ]
  ! FLT             [ reduce using rule 164 (empty -> .) ]
  ! BLN             [ reduce using rule 164 (empty -> .) ]
  ! CHR             [ reduce using rule 164 (empty -> .) ]
  ! STR             [ reduce using rule 164 (empty -> .) ]

    statements                     shift and go to state 364
    empty                          shift and go to state 144
    local_dec                      shift and go to state 145
    var_statement                  shift and go to state 146
    data_type                      shift and go to state 147

state 363

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline RBRACE

    RBRACE          shift and go to state 365


state 364

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 366


state 365

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (164) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 164 (empty -> .)

    maybe_newline                  shift and go to state 367
    empty                          shift and go to state 16

state 366

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 119 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .)


state 367

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . RBRACE

    RBRACE          shift and go to state 368


state 368

    (121) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .

    NEWLINE         reduce using rule 121 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 15 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 17 resolved as shift
WARNING: shift/reduce conflict for AND in state 55 resolved as shift
WARNING: shift/reduce conflict for OR in state 55 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for EQ_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for GT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for LT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 135 resolved as shift
WARNING: shift/reduce conflict for INT in state 140 resolved as shift
WARNING: shift/reduce conflict for FLT in state 140 resolved as shift
WARNING: shift/reduce conflict for BLN in state 140 resolved as shift
WARNING: shift/reduce conflict for CHR in state 140 resolved as shift
WARNING: shift/reduce conflict for STR in state 140 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 145 resolved as shift
WARNING: shift/reduce conflict for INT in state 148 resolved as shift
WARNING: shift/reduce conflict for FLT in state 148 resolved as shift
WARNING: shift/reduce conflict for BLN in state 148 resolved as shift
WARNING: shift/reduce conflict for CHR in state 148 resolved as shift
WARNING: shift/reduce conflict for STR in state 148 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 151 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 151 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 151 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 151 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 151 resolved as shift
WARNING: shift/reduce conflict for FOR in state 151 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 151 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 151 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 151 resolved as shift
WARNING: shift/reduce conflict for INT in state 151 resolved as shift
WARNING: shift/reduce conflict for FLT in state 151 resolved as shift
WARNING: shift/reduce conflict for BLN in state 151 resolved as shift
WARNING: shift/reduce conflict for CHR in state 151 resolved as shift
WARNING: shift/reduce conflict for STR in state 151 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 156 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 185 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 185 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 185 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 185 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 185 resolved as shift
WARNING: shift/reduce conflict for FOR in state 185 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 185 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 185 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 185 resolved as shift
WARNING: shift/reduce conflict for INT in state 185 resolved as shift
WARNING: shift/reduce conflict for FLT in state 185 resolved as shift
WARNING: shift/reduce conflict for BLN in state 185 resolved as shift
WARNING: shift/reduce conflict for CHR in state 185 resolved as shift
WARNING: shift/reduce conflict for STR in state 185 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 186 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 186 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 186 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 186 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 186 resolved as shift
WARNING: shift/reduce conflict for FOR in state 186 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 186 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 186 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 186 resolved as shift
WARNING: shift/reduce conflict for INT in state 186 resolved as shift
WARNING: shift/reduce conflict for FLT in state 186 resolved as shift
WARNING: shift/reduce conflict for BLN in state 186 resolved as shift
WARNING: shift/reduce conflict for CHR in state 186 resolved as shift
WARNING: shift/reduce conflict for STR in state 186 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 187 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 187 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 187 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 187 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 187 resolved as shift
WARNING: shift/reduce conflict for FOR in state 187 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 187 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 187 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 187 resolved as shift
WARNING: shift/reduce conflict for INT in state 187 resolved as shift
WARNING: shift/reduce conflict for FLT in state 187 resolved as shift
WARNING: shift/reduce conflict for BLN in state 187 resolved as shift
WARNING: shift/reduce conflict for CHR in state 187 resolved as shift
WARNING: shift/reduce conflict for STR in state 187 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 188 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 188 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 188 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 188 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 188 resolved as shift
WARNING: shift/reduce conflict for FOR in state 188 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 188 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 188 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 188 resolved as shift
WARNING: shift/reduce conflict for INT in state 188 resolved as shift
WARNING: shift/reduce conflict for FLT in state 188 resolved as shift
WARNING: shift/reduce conflict for BLN in state 188 resolved as shift
WARNING: shift/reduce conflict for CHR in state 188 resolved as shift
WARNING: shift/reduce conflict for STR in state 188 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 189 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 189 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 189 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 189 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 189 resolved as shift
WARNING: shift/reduce conflict for FOR in state 189 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 189 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 189 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 189 resolved as shift
WARNING: shift/reduce conflict for INT in state 189 resolved as shift
WARNING: shift/reduce conflict for FLT in state 189 resolved as shift
WARNING: shift/reduce conflict for BLN in state 189 resolved as shift
WARNING: shift/reduce conflict for CHR in state 189 resolved as shift
WARNING: shift/reduce conflict for STR in state 189 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 190 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 190 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 190 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 190 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 190 resolved as shift
WARNING: shift/reduce conflict for FOR in state 190 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 190 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 190 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 190 resolved as shift
WARNING: shift/reduce conflict for INT in state 190 resolved as shift
WARNING: shift/reduce conflict for FLT in state 190 resolved as shift
WARNING: shift/reduce conflict for BLN in state 190 resolved as shift
WARNING: shift/reduce conflict for CHR in state 190 resolved as shift
WARNING: shift/reduce conflict for STR in state 190 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 191 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 191 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 191 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 191 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 191 resolved as shift
WARNING: shift/reduce conflict for FOR in state 191 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 191 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 191 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 191 resolved as shift
WARNING: shift/reduce conflict for INT in state 191 resolved as shift
WARNING: shift/reduce conflict for FLT in state 191 resolved as shift
WARNING: shift/reduce conflict for BLN in state 191 resolved as shift
WARNING: shift/reduce conflict for CHR in state 191 resolved as shift
WARNING: shift/reduce conflict for STR in state 191 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 220 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 250 resolved as shift
WARNING: shift/reduce conflict for INT in state 258 resolved as shift
WARNING: shift/reduce conflict for FLT in state 258 resolved as shift
WARNING: shift/reduce conflict for BLN in state 258 resolved as shift
WARNING: shift/reduce conflict for CHR in state 258 resolved as shift
WARNING: shift/reduce conflict for STR in state 258 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 293 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 305 resolved as shift
WARNING: shift/reduce conflict for INT in state 309 resolved as shift
WARNING: shift/reduce conflict for FLT in state 309 resolved as shift
WARNING: shift/reduce conflict for BLN in state 309 resolved as shift
WARNING: shift/reduce conflict for CHR in state 309 resolved as shift
WARNING: shift/reduce conflict for STR in state 309 resolved as shift
WARNING: shift/reduce conflict for INT in state 315 resolved as shift
WARNING: shift/reduce conflict for FLT in state 315 resolved as shift
WARNING: shift/reduce conflict for BLN in state 315 resolved as shift
WARNING: shift/reduce conflict for CHR in state 315 resolved as shift
WARNING: shift/reduce conflict for STR in state 315 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 337 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 342 resolved as shift
WARNING: shift/reduce conflict for INT in state 344 resolved as shift
WARNING: shift/reduce conflict for FLT in state 344 resolved as shift
WARNING: shift/reduce conflict for BLN in state 344 resolved as shift
WARNING: shift/reduce conflict for CHR in state 344 resolved as shift
WARNING: shift/reduce conflict for STR in state 344 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 345 resolved as shift
WARNING: shift/reduce conflict for INT in state 347 resolved as shift
WARNING: shift/reduce conflict for FLT in state 347 resolved as shift
WARNING: shift/reduce conflict for BLN in state 347 resolved as shift
WARNING: shift/reduce conflict for CHR in state 347 resolved as shift
WARNING: shift/reduce conflict for STR in state 347 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 348 resolved as shift
WARNING: shift/reduce conflict for INT in state 350 resolved as shift
WARNING: shift/reduce conflict for FLT in state 350 resolved as shift
WARNING: shift/reduce conflict for BLN in state 350 resolved as shift
WARNING: shift/reduce conflict for CHR in state 350 resolved as shift
WARNING: shift/reduce conflict for STR in state 350 resolved as shift
WARNING: shift/reduce conflict for INT in state 353 resolved as shift
WARNING: shift/reduce conflict for FLT in state 353 resolved as shift
WARNING: shift/reduce conflict for BLN in state 353 resolved as shift
WARNING: shift/reduce conflict for CHR in state 353 resolved as shift
WARNING: shift/reduce conflict for STR in state 353 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 358 resolved as shift
WARNING: shift/reduce conflict for INT in state 362 resolved as shift
WARNING: shift/reduce conflict for FLT in state 362 resolved as shift
WARNING: shift/reduce conflict for BLN in state 362 resolved as shift
WARNING: shift/reduce conflict for CHR in state 362 resolved as shift
WARNING: shift/reduce conflict for STR in state 362 resolved as shift
WARNING: reduce/reduce conflict in state 26 resolved using rule (global_dec -> empty)
WARNING: rejected rule (global_tail -> empty) in state 26
WARNING: reduce/reduce conflict in state 49 resolved using rule (global_value -> factor)
WARNING: rejected rule (empty -> <empty>) in state 49
WARNING: reduce/reduce conflict in state 144 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 144
WARNING: reduce/reduce conflict in state 158 resolved using rule (statements_tail -> empty)
WARNING: rejected rule (local_dec -> empty) in state 158
WARNING: reduce/reduce conflict in state 210 resolved using rule (value -> factor)
WARNING: rejected rule (empty -> <empty>) in state 210
WARNING: reduce/reduce conflict in state 235 resolved using rule (update_tail -> assign_op value)
WARNING: rejected rule (string_operation_tail -> assign_op value) in state 235
WARNING: reduce/reduce conflict in state 278 resolved using rule (typecast_value -> IDENT)
WARNING: rejected rule (empty -> <empty>) in state 278
WARNING: reduce/reduce conflict in state 279 resolved using rule (typecast_value -> literal)
WARNING: rejected rule (factor -> literal) in state 279
WARNING: Rule (global_tail -> empty) is never reduced
WARNING: Rule (string_operation_tail -> assign_op value) is never reduced
