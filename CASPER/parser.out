Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_statement -> var_statement global_statement_tail
Rule 11    var_statement -> data_type IDENT list_dec
Rule 12    list_dec -> empty
Rule 13    list_dec -> LBRACKET RBRACKET _2d_list
Rule 14    _2d_list -> empty
Rule 15    _2d_list -> LBRACKET RBRACKET
Rule 16    global_statement_tail -> empty
Rule 17    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 18    global_statement_tail -> EQ global_value global_statement_tail2
Rule 19    global_statement_tail2 -> COMMA IDENT global_statement_tail
Rule 20    global_statement_tail2 -> empty
Rule 21    global_value -> expression
Rule 22    global_value -> list_value
Rule 23    list_value -> LBRACKET list_element RBRACKET
Rule 24    list_element -> literal element_tail
Rule 25    element_tail -> COMMA list_element
Rule 26    element_tail -> empty
Rule 27    data_type -> INT
Rule 28    data_type -> FLT
Rule 29    data_type -> BLN
Rule 30    data_type -> CHR
Rule 31    data_type -> STR
Rule 32    expression -> factor factor_tail
Rule 33    factor -> var_call postfix
Rule 34    factor -> literal1
Rule 35    factor -> TILDE INT_LIT
Rule 36    factor -> TILDE FLT_LIT
Rule 37    factor -> LPAREN expression RPAREN
Rule 38    factor_tail -> PLUS factor factor_tail
Rule 39    factor_tail -> MINUS factor factor_tail
Rule 40    factor_tail -> MULTIPLY factor factor_tail
Rule 41    factor_tail -> DIVISION factor factor_tail
Rule 42    factor_tail -> MODULO factor factor_tail
Rule 43    factor_tail -> EXPONENT factor factor_tail
Rule 44    factor_tail -> GT factor factor_tail
Rule 45    factor_tail -> LT factor factor_tail
Rule 46    factor_tail -> EQ_EQ factor factor_tail
Rule 47    factor_tail -> GT_EQ factor factor_tail
Rule 48    factor_tail -> LT_EQ factor factor_tail
Rule 49    factor_tail -> NOT_EQ factor factor_tail
Rule 50    factor_tail -> AND factor factor_tail
Rule 51    factor_tail -> OR factor factor_tail
Rule 52    factor_tail -> empty
Rule 53    literal -> literal1
Rule 54    literal -> literal2
Rule 55    literal1 -> INT_LIT
Rule 56    literal1 -> FLT_LIT
Rule 57    literal1 -> DAY
Rule 58    literal1 -> NIGHT
Rule 59    literal1 -> STR_LIT
Rule 60    literal2 -> CHR_LIT
Rule 61    function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
Rule 62    function_statements -> empty
Rule 63    function_statements_tail -> function_statements
Rule 64    function_statements_tail -> empty
Rule 65    ret_type -> FUNCTION
Rule 66    ret_type -> function_dtype
Rule 67    function_dtype -> FUNCTION_INT
Rule 68    function_dtype -> FUNCTION_FLT
Rule 69    function_dtype -> FUNCTION_CHR
Rule 70    function_dtype -> FUNCTION_BLN
Rule 71    function_dtype -> FUNCTION_STR
Rule 72    function_dtype -> FUNCTION_LIST_INT
Rule 73    function_dtype -> FUNCTION_LIST_FLT
Rule 74    function_dtype -> FUNCTION_LIST_CHR
Rule 75    function_dtype -> FUNCTION_LIST_STR
Rule 76    function_dtype -> FUNCTION_LIST_BLN
Rule 77    parameters -> data_type IDENT parameters_tail
Rule 78    parameters -> empty
Rule 79    parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 80    parameters_tail -> empty
Rule 81    revive -> REVIVE revive_value
Rule 82    revive -> empty
Rule 83    revive_value -> revive_type_cast
Rule 84    revive_value -> expression
Rule 85    revive_value -> function_call
Rule 86    revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 87    revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 88    revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 89    revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 90    statements -> empty
Rule 91    statements -> local_dec maybe_newline statements_tail
Rule 92    statements_tail -> switch_statement unli_newline statements
Rule 93    statements_tail -> loop_statement unli_newline statements
Rule 94    statements_tail -> function_call unli_newline statements
Rule 95    statements_tail -> assignment_statement unli_newline statements
Rule 96    statements_tail -> output_statement unli_newline statements
Rule 97    statements_tail -> conditional_statement unli_newline statements
Rule 98    statements_tail -> statements
Rule 99    local_dec -> var_statement local_dec_tail
Rule 100   local_dec -> empty
Rule 101   local_dec_tail -> empty
Rule 102   local_dec_tail -> COMMA IDENT local_dec_tail
Rule 103   local_dec_tail -> EQ local_value local_dec_tail2
Rule 104   local_dec_tail2 -> COMMA IDENT local_dec_tail
Rule 105   local_dec_tail2 -> empty
Rule 106   local_value -> local_value_value
Rule 107   local_value -> list_value
Rule 108   local_value_value -> local_type_cast
Rule 109   local_value_value -> expression
Rule 110   local_value_value -> function_call
Rule 111   local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 112   local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 113   local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 114   local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 115   conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 116   condition -> factor factor_tail
Rule 117   condition_factor -> var_call postfix
Rule 118   condition_factor -> literal1
Rule 119   condition_factor -> TILDE INT_LIT
Rule 120   condition_factor -> TILDE FLT_LIT
Rule 121   condition_factor -> LPAREN condition RPAREN
Rule 122   condition_tail -> PLUS condition_factor condition_tail
Rule 123   condition_tail -> MINUS condition_factor condition_tail
Rule 124   condition_tail -> MULTIPLY condition_factor condition_tail
Rule 125   condition_tail -> DIVISION condition_factor condition_tail
Rule 126   condition_tail -> MODULO condition_factor condition_tail
Rule 127   condition_tail -> EXPONENT condition_factor condition_tail
Rule 128   condition_tail -> GT condition_factor condition_tail
Rule 129   condition_tail -> LT condition_factor condition_tail
Rule 130   condition_tail -> EQ_EQ condition_factor condition_tail
Rule 131   condition_tail -> GT_EQ condition_factor condition_tail
Rule 132   condition_tail -> LT_EQ condition_factor condition_tail
Rule 133   condition_tail -> NOT_EQ condition_factor condition_tail
Rule 134   condition_tail -> AND condition_factor condition_tail
Rule 135   condition_tail -> OR condition_factor condition_tail
Rule 136   condition_tail -> empty
Rule 137   condition_ -> condition_literal1
Rule 138   condition_ -> literal2
Rule 139   condition_literal1 -> INT_LIT
Rule 140   condition_literal1 -> FLT_LIT
Rule 141   condition_literal1 -> DAY
Rule 142   condition_literal1 -> NIGHT
Rule 143   condition_literal1 -> STR_LIT
Rule 144   condition_literal2 -> CHR_LIT
Rule 145   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
Rule 146   conditional_tail -> empty
Rule 147   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
Rule 148   switch_condition -> SHIFT switch_value COLON statements switchcond_tail
Rule 149   switch_value -> switch_type_cast
Rule 150   switch_value -> expression
Rule 151   switch_value -> function_call
Rule 152   switch_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 153   switch_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 154   switch_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 155   switch_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 156   switchcond_tail -> switch_condition
Rule 157   switchcond_tail -> empty
Rule 158   loop_statement -> for_loop
Rule 159   loop_statement -> until_loop
Rule 160   loop_statement -> repeat_until
Rule 161   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE
Rule 162   until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
Rule 163   repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
Rule 164   control_variable -> INT IDENT EQ control_var_tail
Rule 165   control_var_tail -> INT_LIT
Rule 166   control_var_tail -> var_call
Rule 167   update -> var_call update_tail
Rule 168   update_tail -> postfix_op
Rule 169   update_tail -> compound_op value
Rule 170   postfix_op -> PLUS_PLUS
Rule 171   postfix_op -> MINUS_MINUS
Rule 172   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 173   function_call -> input_statement
Rule 174   arguments -> empty
Rule 175   arguments -> arg_value arg_tail
Rule 176   arg_tail -> COMMA arg_value arg_tail
Rule 177   arg_tail -> empty
Rule 178   arg_value -> literal
Rule 179   arg_value -> var_call
Rule 180   output_statement -> DISPLAY value next_val
Rule 181   next_val -> COMMA value next_val
Rule 182   next_val -> empty
Rule 183   assignment_statement -> IDENT assign_tail
Rule 184   assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
Rule 185   assign_tail -> DOT PUSH LPAREN list_element RPAREN
Rule 186   assign_tail -> assign_op value
Rule 187   assign_op -> compound_op
Rule 188   assign_op -> EQ
Rule 189   compound_op -> PLUS_EQ
Rule 190   compound_op -> MINUS_EQ
Rule 191   compound_op -> MUL_EQ
Rule 192   compound_op -> DIV_EQ
Rule 193   compound_op -> MOD_EQ
Rule 194   start -> INT_LIT
Rule 195   deleteCount -> empty
Rule 196   deleteCount -> INT_LIT
Rule 197   splice_items -> empty
Rule 198   splice_items -> list_element
Rule 199   var_call -> IDENT list_index
Rule 200   list_index -> LBRACKET index RBRACKET list_index2
Rule 201   list_index -> empty
Rule 202   list_index2 -> LBRACKET index RBRACKET
Rule 203   list_index2 -> empty
Rule 204   index -> INT_LIT
Rule 205   index -> IDENT
Rule 206   postfix -> empty
Rule 207   postfix -> postfix_op
Rule 208   value -> type_cast
Rule 209   value -> expression
Rule 210   value -> function_call
Rule 211   type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 212   type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 213   type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 214   type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 215   typecast_value -> expression
Rule 216   typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 217   typecast_value -> input_statement
Rule 218   input_statement -> INPUT LPAREN RPAREN
Rule 219   empty -> <empty>

Terminals, with rules where they appear

AND                  : 50 134
BIRTH                : 1
BLN                  : 29
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 115
CHR                  : 30
CHR_LIT              : 60 144
COLON                : 148
COMMA                : 17 19 25 79 102 104 176 181 184 184
COMMENT              : 
CONVERT_TO_BLN       : 88 113 154 213
CONVERT_TO_FLT       : 87 112 153 212
CONVERT_TO_INT       : 86 111 152 211
CONVERT_TO_STR       : 89 114 155 214
DAY                  : 57 141
DISPLAY              : 180
DIVISION             : 41 125
DIV_EQ               : 192
DOT                  : 184 185
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 18 103 164 188
EQ_EQ                : 46 130
EXPONENT             : 43 127
FLT                  : 28
FLT_LIT              : 36 56 120 140
FOR                  : 161
FUNCTION             : 65
FUNCTION_BLN         : 70
FUNCTION_CHR         : 69
FUNCTION_FLT         : 68
FUNCTION_INT         : 67
FUNCTION_LIST_BLN    : 76
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 74
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 73
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 72
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 75
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 61 172 216
FUNCTION_STR         : 71
GHOST                : 1
GT                   : 44 128
GT_EQ                : 47 131
IDENT                : 11 17 19 77 79 102 104 147 164 183 199 205
ILLEGAL              : 
IN                   : 
INPUT                : 218
INT                  : 27 164
INT_LIT              : 35 55 119 139 165 194 196 204
LBRACE               : 6 61 115 115 145 147 147 161 162 163
LBRACKET             : 13 15 23 200 202
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 37 61 86 87 88 89 111 112 113 114 115 121 145 147 152 153 154 155 161 162 163 172 184 185 211 212 213 214 216 218
LT                   : 45 129
LT_EQ                : 48 132
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 39 123
MINUS_EQ             : 190
MINUS_MINUS          : 171
MODULO               : 42 126
MOD_EQ               : 193
MULTIPLY             : 40 124
MUL_EQ               : 191
NEWLINE              : 3 4 5
NIGHT                : 58 142
NOT                  : 
NOT_EQ               : 49 133
OR                   : 51 135
OTHERWISE            : 115 147
OTHERWISE_CHECK      : 145
PLUS                 : 38 122
PLUS_EQ              : 189
PLUS_PLUS            : 170
POW                  : 
PUSH                 : 185
RBRACE               : 6 61 115 115 145 147 147 161 162 163
RBRACKET             : 13 15 23 200 202
REPEAT               : 163
REVIVE               : 81
RPAREN               : 6 37 61 86 87 88 89 111 112 113 114 115 121 145 147 152 153 154 155 161 162 163 172 184 185 211 212 213 214 216 218
SEMICOLON            : 161 161
SHIFT                : 148
SKIP                 : 
SPLICE               : 184
STOP                 : 
STR                  : 31
STR_LIT              : 59 143
SWAP                 : 147
TILDE                : 35 36 119 120
TYPE                 : 
UNTIL                : 162 163
error                : 

Nonterminals, with rules where they appear

_2d_list             : 13
arg_tail             : 175 176
arg_value            : 175 176
arguments            : 172
assign_op            : 186
assign_tail          : 183
assignment_statement : 95
compound_op          : 169 187
condition            : 115 121
condition_           : 
condition_factor     : 122 123 124 125 126 127 128 129 130 131 132 133 134 135
condition_literal1   : 137
condition_literal2   : 
condition_tail       : 122 123 124 125 126 127 128 129 130 131 132 133 134 135
conditional_statement : 97
conditional_tail     : 115 145
control_var_tail     : 164
control_variable     : 161
data_type            : 11 77 79
deleteCount          : 184
element_tail         : 24
empty                : 2 8 12 14 16 20 26 52 62 64 78 80 82 90 100 101 105 136 146 157 174 177 182 195 197 201 203 206
expression           : 21 37 84 109 145 150 161 162 163 209 215
factor               : 32 38 39 40 41 42 43 44 45 46 47 48 49 50 51 116
factor_tail          : 32 38 39 40 41 42 43 44 45 46 47 48 49 50 51 116
for_loop             : 158
function_call        : 85 94 110 151 210
function_dtype       : 66
function_statements  : 1 63
function_statements_tail : 61
global_dec           : 1 9
global_statement     : 7
global_statement_tail : 10 17 19
global_statement_tail2 : 18
global_tail          : 7
global_value         : 18
index                : 200 202
input_statement      : 173 217
list_dec             : 11
list_element         : 23 25 185 198
list_index           : 199
list_index2          : 200
list_value           : 22 107
literal              : 24 178
literal1             : 34 53 118
literal2             : 54 138
local_dec            : 91
local_dec_tail       : 99 102 104
local_dec_tail2      : 103
local_type_cast      : 108
local_value          : 103
local_value_value    : 106
loop_statement       : 93
main_function        : 1
maybe_newline        : 1 1 3 6 6 6 61 61 91 115 115 115 115 115 115 115
next_val             : 180 181
output_statement     : 96
parameters           : 61
parameters_tail      : 77 79
postfix              : 33 117
postfix_op           : 168 207
program              : 0
repeat_until         : 160
ret_type             : 61
revive               : 61
revive_type_cast     : 83
revive_value         : 81
splice_items         : 184
start                : 184
statements           : 6 61 92 93 94 95 96 97 98 115 115 145 147 148 161 162 163
statements_tail      : 91
switch_condition     : 147 156
switch_statement     : 92
switch_type_cast     : 149
switch_value         : 148
switchcond_tail      : 148
type_cast            : 208
typecast_value       : 86 87 88 89 111 112 113 114 152 153 154 155 211 212 213 214
unli_newline         : 1 1 5 7 61 92 93 94 95 96 97 161 161
until_loop           : 159
update               : 161
update_tail          : 167
value                : 169 180 181 186
var_call             : 33 117 166 167 179
var_statement        : 10 99

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . var_statement global_statement_tail
    (219) empty -> .
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    NEWLINE         reduce using rule 219 (empty -> .)
    FUNCTION        reduce using rule 219 (empty -> .)
    FUNCTION_INT    reduce using rule 219 (empty -> .)
    FUNCTION_FLT    reduce using rule 219 (empty -> .)
    FUNCTION_CHR    reduce using rule 219 (empty -> .)
    FUNCTION_BLN    reduce using rule 219 (empty -> .)
    FUNCTION_STR    reduce using rule 219 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 219 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 219 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 219 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 219 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 219 (empty -> .)
    MAIN_CASPER     reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    var_statement                  shift and go to state 8
    data_type                      shift and go to state 9

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    INPUT           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 15

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    FUNCTION        reduce using rule 219 (empty -> .)
    FUNCTION_INT    reduce using rule 219 (empty -> .)
    FUNCTION_FLT    reduce using rule 219 (empty -> .)
    FUNCTION_CHR    reduce using rule 219 (empty -> .)
    FUNCTION_BLN    reduce using rule 219 (empty -> .)
    FUNCTION_STR    reduce using rule 219 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 219 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 219 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 219 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 219 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 219 (empty -> .)
    MAIN_CASPER     reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 16
    empty                          shift and go to state 17

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 19

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)


state 8

    (10) global_statement -> var_statement . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (219) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 219 (empty -> .)

    global_statement_tail          shift and go to state 20
    empty                          shift and go to state 21

state 9

    (11) var_statement -> data_type . IDENT list_dec

    IDENT           shift and go to state 24


state 10

    (27) data_type -> INT .

    IDENT           reduce using rule 27 (data_type -> INT .)


state 11

    (28) data_type -> FLT .

    IDENT           reduce using rule 28 (data_type -> FLT .)


state 12

    (29) data_type -> BLN .

    IDENT           reduce using rule 29 (data_type -> BLN .)


state 13

    (30) data_type -> CHR .

    IDENT           reduce using rule 30 (data_type -> CHR .)


state 14

    (31) data_type -> STR .

    IDENT           reduce using rule 31 (data_type -> STR .)


state 15

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    INPUT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 16

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (61) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (62) function_statements -> . empty
    (65) ret_type -> . FUNCTION
    (66) ret_type -> . function_dtype
    (219) empty -> .
    (67) function_dtype -> . FUNCTION_INT
    (68) function_dtype -> . FUNCTION_FLT
    (69) function_dtype -> . FUNCTION_CHR
    (70) function_dtype -> . FUNCTION_BLN
    (71) function_dtype -> . FUNCTION_STR
    (72) function_dtype -> . FUNCTION_LIST_INT
    (73) function_dtype -> . FUNCTION_LIST_FLT
    (74) function_dtype -> . FUNCTION_LIST_CHR
    (75) function_dtype -> . FUNCTION_LIST_STR
    (76) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 28
    NEWLINE         reduce using rule 219 (empty -> .)
    MAIN_CASPER     reduce using rule 219 (empty -> .)
    FUNCTION_INT    shift and go to state 30
    FUNCTION_FLT    shift and go to state 31
    FUNCTION_CHR    shift and go to state 32
    FUNCTION_BLN    shift and go to state 33
    FUNCTION_STR    shift and go to state 34
    FUNCTION_LIST_INT shift and go to state 35
    FUNCTION_LIST_FLT shift and go to state 36
    FUNCTION_LIST_CHR shift and go to state 37
    FUNCTION_LIST_STR shift and go to state 38
    FUNCTION_LIST_BLN shift and go to state 39

    function_statements            shift and go to state 25
    ret_type                       shift and go to state 26
    empty                          shift and go to state 27
    function_dtype                 shift and go to state 29

state 17

    (2) maybe_newline -> empty .

    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    INPUT           reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE_CHECK reduce using rule 2 (maybe_newline -> empty .)


state 18

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    FUNCTION        reduce using rule 219 (empty -> .)
    FUNCTION_INT    reduce using rule 219 (empty -> .)
    FUNCTION_FLT    reduce using rule 219 (empty -> .)
    FUNCTION_CHR    reduce using rule 219 (empty -> .)
    FUNCTION_BLN    reduce using rule 219 (empty -> .)
    FUNCTION_STR    reduce using rule 219 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 219 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 219 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 219 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 219 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 219 (empty -> .)
    MAIN_CASPER     reduce using rule 219 (empty -> .)
    LBRACE          reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    OTHERWISE_CHECK reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 40
    empty                          shift and go to state 17

state 19

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . var_statement global_statement_tail
    (219) empty -> .
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    NEWLINE         reduce using rule 219 (empty -> .)
    FUNCTION        reduce using rule 219 (empty -> .)
    FUNCTION_INT    reduce using rule 219 (empty -> .)
    FUNCTION_FLT    reduce using rule 219 (empty -> .)
    FUNCTION_CHR    reduce using rule 219 (empty -> .)
    FUNCTION_BLN    reduce using rule 219 (empty -> .)
    FUNCTION_STR    reduce using rule 219 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 219 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 219 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 219 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 219 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 219 (empty -> .)
    MAIN_CASPER     reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 41
    global_dec                     shift and go to state 42
    empty                          shift and go to state 7
    var_statement                  shift and go to state 8
    data_type                      shift and go to state 9

state 20

    (10) global_statement -> var_statement global_statement_tail .

    NEWLINE         reduce using rule 10 (global_statement -> var_statement global_statement_tail .)


state 21

    (16) global_statement_tail -> empty .

    NEWLINE         reduce using rule 16 (global_statement_tail -> empty .)


state 22

    (17) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 43


state 23

    (18) global_statement_tail -> EQ . global_value global_statement_tail2
    (21) global_value -> . expression
    (22) global_value -> . list_value
    (32) expression -> . factor factor_tail
    (23) list_value -> . LBRACKET list_element RBRACKET
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    LBRACKET        shift and go to state 48
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    global_value                   shift and go to state 44
    expression                     shift and go to state 45
    list_value                     shift and go to state 46
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 24

    (11) var_statement -> data_type IDENT . list_dec
    (12) list_dec -> . empty
    (13) list_dec -> . LBRACKET RBRACKET _2d_list
    (219) empty -> .

    LBRACKET        shift and go to state 61
    COMMA           reduce using rule 219 (empty -> .)
    EQ              reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

    list_dec                       shift and go to state 59
    empty                          shift and go to state 60

state 25

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

    NEWLINE         shift and go to state 18
    MAIN_CASPER     reduce using rule 219 (empty -> .)

    maybe_newline                  shift and go to state 62
    empty                          shift and go to state 17

state 26

    (61) function_statements -> ret_type . FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail

    FUNCTION_NAME   shift and go to state 63


state 27

    (62) function_statements -> empty .

    NEWLINE         reduce using rule 62 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 62 (function_statements -> empty .)


state 28

    (65) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 65 (ret_type -> FUNCTION .)


state 29

    (66) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 66 (ret_type -> function_dtype .)


state 30

    (67) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 67 (function_dtype -> FUNCTION_INT .)


state 31

    (68) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 68 (function_dtype -> FUNCTION_FLT .)


state 32

    (69) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 69 (function_dtype -> FUNCTION_CHR .)


state 33

    (70) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 70 (function_dtype -> FUNCTION_BLN .)


state 34

    (71) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 71 (function_dtype -> FUNCTION_STR .)


state 35

    (72) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 72 (function_dtype -> FUNCTION_LIST_INT .)


state 36

    (73) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 73 (function_dtype -> FUNCTION_LIST_FLT .)


state 37

    (74) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 74 (function_dtype -> FUNCTION_LIST_CHR .)


state 38

    (75) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 75 (function_dtype -> FUNCTION_LIST_STR .)


state 39

    (76) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 76 (function_dtype -> FUNCTION_LIST_BLN .)


state 40

    (3) maybe_newline -> NEWLINE maybe_newline .

    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INPUT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE_CHECK reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 41

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 42

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)


state 43

    (17) global_statement_tail -> COMMA IDENT . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (219) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 219 (empty -> .)

    global_statement_tail          shift and go to state 64
    empty                          shift and go to state 21

state 44

    (18) global_statement_tail -> EQ global_value . global_statement_tail2
    (19) global_statement_tail2 -> . COMMA IDENT global_statement_tail
    (20) global_statement_tail2 -> . empty
    (219) empty -> .

    COMMA           shift and go to state 66
    NEWLINE         reduce using rule 219 (empty -> .)

    global_statement_tail2         shift and go to state 65
    empty                          shift and go to state 67

state 45

    (21) global_value -> expression .

    COMMA           reduce using rule 21 (global_value -> expression .)
    NEWLINE         reduce using rule 21 (global_value -> expression .)


state 46

    (22) global_value -> list_value .

    COMMA           reduce using rule 22 (global_value -> list_value .)
    NEWLINE         reduce using rule 22 (global_value -> list_value .)


state 47

    (32) expression -> factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 68
    empty                          shift and go to state 83

state 48

    (23) list_value -> LBRACKET . list_element RBRACKET
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 84
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 49

    (33) factor -> var_call . postfix
    (206) postfix -> . empty
    (207) postfix -> . postfix_op
    (219) empty -> .
    (170) postfix_op -> . PLUS_PLUS
    (171) postfix_op -> . MINUS_MINUS

    PLUS            reduce using rule 219 (empty -> .)
    MINUS           reduce using rule 219 (empty -> .)
    MULTIPLY        reduce using rule 219 (empty -> .)
    DIVISION        reduce using rule 219 (empty -> .)
    MODULO          reduce using rule 219 (empty -> .)
    EXPONENT        reduce using rule 219 (empty -> .)
    GT              reduce using rule 219 (empty -> .)
    LT              reduce using rule 219 (empty -> .)
    EQ_EQ           reduce using rule 219 (empty -> .)
    GT_EQ           reduce using rule 219 (empty -> .)
    LT_EQ           reduce using rule 219 (empty -> .)
    NOT_EQ          reduce using rule 219 (empty -> .)
    AND             reduce using rule 219 (empty -> .)
    OR              reduce using rule 219 (empty -> .)
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)
    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93

    postfix                        shift and go to state 89
    empty                          shift and go to state 90
    postfix_op                     shift and go to state 91

state 50

    (34) factor -> literal1 .

    PLUS            reduce using rule 34 (factor -> literal1 .)
    MINUS           reduce using rule 34 (factor -> literal1 .)
    MULTIPLY        reduce using rule 34 (factor -> literal1 .)
    DIVISION        reduce using rule 34 (factor -> literal1 .)
    MODULO          reduce using rule 34 (factor -> literal1 .)
    EXPONENT        reduce using rule 34 (factor -> literal1 .)
    GT              reduce using rule 34 (factor -> literal1 .)
    LT              reduce using rule 34 (factor -> literal1 .)
    EQ_EQ           reduce using rule 34 (factor -> literal1 .)
    GT_EQ           reduce using rule 34 (factor -> literal1 .)
    LT_EQ           reduce using rule 34 (factor -> literal1 .)
    NOT_EQ          reduce using rule 34 (factor -> literal1 .)
    AND             reduce using rule 34 (factor -> literal1 .)
    OR              reduce using rule 34 (factor -> literal1 .)
    COMMA           reduce using rule 34 (factor -> literal1 .)
    NEWLINE         reduce using rule 34 (factor -> literal1 .)
    RPAREN          reduce using rule 34 (factor -> literal1 .)
    SWAP            reduce using rule 34 (factor -> literal1 .)
    FUNCTION_NAME   reduce using rule 34 (factor -> literal1 .)
    IDENT           reduce using rule 34 (factor -> literal1 .)
    DISPLAY         reduce using rule 34 (factor -> literal1 .)
    CHECK           reduce using rule 34 (factor -> literal1 .)
    FOR             reduce using rule 34 (factor -> literal1 .)
    UNTIL           reduce using rule 34 (factor -> literal1 .)
    REPEAT          reduce using rule 34 (factor -> literal1 .)
    INPUT           reduce using rule 34 (factor -> literal1 .)
    INT             reduce using rule 34 (factor -> literal1 .)
    FLT             reduce using rule 34 (factor -> literal1 .)
    BLN             reduce using rule 34 (factor -> literal1 .)
    CHR             reduce using rule 34 (factor -> literal1 .)
    STR             reduce using rule 34 (factor -> literal1 .)
    REVIVE          reduce using rule 34 (factor -> literal1 .)
    RBRACE          reduce using rule 34 (factor -> literal1 .)
    SHIFT           reduce using rule 34 (factor -> literal1 .)
    OTHERWISE       reduce using rule 34 (factor -> literal1 .)
    SEMICOLON       reduce using rule 34 (factor -> literal1 .)
    COLON           reduce using rule 34 (factor -> literal1 .)


state 51

    (35) factor -> TILDE . INT_LIT
    (36) factor -> TILDE . FLT_LIT

    INT_LIT         shift and go to state 94
    FLT_LIT         shift and go to state 95


state 52

    (55) literal1 -> INT_LIT .

    PLUS            reduce using rule 55 (literal1 -> INT_LIT .)
    MINUS           reduce using rule 55 (literal1 -> INT_LIT .)
    MULTIPLY        reduce using rule 55 (literal1 -> INT_LIT .)
    DIVISION        reduce using rule 55 (literal1 -> INT_LIT .)
    MODULO          reduce using rule 55 (literal1 -> INT_LIT .)
    EXPONENT        reduce using rule 55 (literal1 -> INT_LIT .)
    GT              reduce using rule 55 (literal1 -> INT_LIT .)
    LT              reduce using rule 55 (literal1 -> INT_LIT .)
    EQ_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    GT_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    LT_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    NOT_EQ          reduce using rule 55 (literal1 -> INT_LIT .)
    AND             reduce using rule 55 (literal1 -> INT_LIT .)
    OR              reduce using rule 55 (literal1 -> INT_LIT .)
    COMMA           reduce using rule 55 (literal1 -> INT_LIT .)
    NEWLINE         reduce using rule 55 (literal1 -> INT_LIT .)
    RBRACKET        reduce using rule 55 (literal1 -> INT_LIT .)
    RPAREN          reduce using rule 55 (literal1 -> INT_LIT .)
    SWAP            reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_NAME   reduce using rule 55 (literal1 -> INT_LIT .)
    IDENT           reduce using rule 55 (literal1 -> INT_LIT .)
    DISPLAY         reduce using rule 55 (literal1 -> INT_LIT .)
    CHECK           reduce using rule 55 (literal1 -> INT_LIT .)
    FOR             reduce using rule 55 (literal1 -> INT_LIT .)
    UNTIL           reduce using rule 55 (literal1 -> INT_LIT .)
    REPEAT          reduce using rule 55 (literal1 -> INT_LIT .)
    INPUT           reduce using rule 55 (literal1 -> INT_LIT .)
    INT             reduce using rule 55 (literal1 -> INT_LIT .)
    FLT             reduce using rule 55 (literal1 -> INT_LIT .)
    BLN             reduce using rule 55 (literal1 -> INT_LIT .)
    CHR             reduce using rule 55 (literal1 -> INT_LIT .)
    STR             reduce using rule 55 (literal1 -> INT_LIT .)
    REVIVE          reduce using rule 55 (literal1 -> INT_LIT .)
    RBRACE          reduce using rule 55 (literal1 -> INT_LIT .)
    SHIFT           reduce using rule 55 (literal1 -> INT_LIT .)
    OTHERWISE       reduce using rule 55 (literal1 -> INT_LIT .)
    SEMICOLON       reduce using rule 55 (literal1 -> INT_LIT .)
    COLON           reduce using rule 55 (literal1 -> INT_LIT .)


state 53

    (56) literal1 -> FLT_LIT .

    PLUS            reduce using rule 56 (literal1 -> FLT_LIT .)
    MINUS           reduce using rule 56 (literal1 -> FLT_LIT .)
    MULTIPLY        reduce using rule 56 (literal1 -> FLT_LIT .)
    DIVISION        reduce using rule 56 (literal1 -> FLT_LIT .)
    MODULO          reduce using rule 56 (literal1 -> FLT_LIT .)
    EXPONENT        reduce using rule 56 (literal1 -> FLT_LIT .)
    GT              reduce using rule 56 (literal1 -> FLT_LIT .)
    LT              reduce using rule 56 (literal1 -> FLT_LIT .)
    EQ_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    GT_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    LT_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    NOT_EQ          reduce using rule 56 (literal1 -> FLT_LIT .)
    AND             reduce using rule 56 (literal1 -> FLT_LIT .)
    OR              reduce using rule 56 (literal1 -> FLT_LIT .)
    COMMA           reduce using rule 56 (literal1 -> FLT_LIT .)
    NEWLINE         reduce using rule 56 (literal1 -> FLT_LIT .)
    RBRACKET        reduce using rule 56 (literal1 -> FLT_LIT .)
    RPAREN          reduce using rule 56 (literal1 -> FLT_LIT .)
    SWAP            reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_NAME   reduce using rule 56 (literal1 -> FLT_LIT .)
    IDENT           reduce using rule 56 (literal1 -> FLT_LIT .)
    DISPLAY         reduce using rule 56 (literal1 -> FLT_LIT .)
    CHECK           reduce using rule 56 (literal1 -> FLT_LIT .)
    FOR             reduce using rule 56 (literal1 -> FLT_LIT .)
    UNTIL           reduce using rule 56 (literal1 -> FLT_LIT .)
    REPEAT          reduce using rule 56 (literal1 -> FLT_LIT .)
    INPUT           reduce using rule 56 (literal1 -> FLT_LIT .)
    INT             reduce using rule 56 (literal1 -> FLT_LIT .)
    FLT             reduce using rule 56 (literal1 -> FLT_LIT .)
    BLN             reduce using rule 56 (literal1 -> FLT_LIT .)
    CHR             reduce using rule 56 (literal1 -> FLT_LIT .)
    STR             reduce using rule 56 (literal1 -> FLT_LIT .)
    REVIVE          reduce using rule 56 (literal1 -> FLT_LIT .)
    RBRACE          reduce using rule 56 (literal1 -> FLT_LIT .)
    SHIFT           reduce using rule 56 (literal1 -> FLT_LIT .)
    OTHERWISE       reduce using rule 56 (literal1 -> FLT_LIT .)
    SEMICOLON       reduce using rule 56 (literal1 -> FLT_LIT .)
    COLON           reduce using rule 56 (literal1 -> FLT_LIT .)


state 54

    (37) factor -> LPAREN . expression RPAREN
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 96
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 55

    (199) var_call -> IDENT . list_index
    (200) list_index -> . LBRACKET index RBRACKET list_index2
    (201) list_index -> . empty
    (219) empty -> .

    LBRACKET        shift and go to state 98
    PLUS_PLUS       reduce using rule 219 (empty -> .)
    MINUS_MINUS     reduce using rule 219 (empty -> .)
    PLUS            reduce using rule 219 (empty -> .)
    MINUS           reduce using rule 219 (empty -> .)
    MULTIPLY        reduce using rule 219 (empty -> .)
    DIVISION        reduce using rule 219 (empty -> .)
    MODULO          reduce using rule 219 (empty -> .)
    EXPONENT        reduce using rule 219 (empty -> .)
    GT              reduce using rule 219 (empty -> .)
    LT              reduce using rule 219 (empty -> .)
    EQ_EQ           reduce using rule 219 (empty -> .)
    GT_EQ           reduce using rule 219 (empty -> .)
    LT_EQ           reduce using rule 219 (empty -> .)
    NOT_EQ          reduce using rule 219 (empty -> .)
    AND             reduce using rule 219 (empty -> .)
    OR              reduce using rule 219 (empty -> .)
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)
    PLUS_EQ         reduce using rule 219 (empty -> .)
    MINUS_EQ        reduce using rule 219 (empty -> .)
    MUL_EQ          reduce using rule 219 (empty -> .)
    DIV_EQ          reduce using rule 219 (empty -> .)
    MOD_EQ          reduce using rule 219 (empty -> .)

    list_index                     shift and go to state 97
    empty                          shift and go to state 99

state 56

    (57) literal1 -> DAY .

    PLUS            reduce using rule 57 (literal1 -> DAY .)
    MINUS           reduce using rule 57 (literal1 -> DAY .)
    MULTIPLY        reduce using rule 57 (literal1 -> DAY .)
    DIVISION        reduce using rule 57 (literal1 -> DAY .)
    MODULO          reduce using rule 57 (literal1 -> DAY .)
    EXPONENT        reduce using rule 57 (literal1 -> DAY .)
    GT              reduce using rule 57 (literal1 -> DAY .)
    LT              reduce using rule 57 (literal1 -> DAY .)
    EQ_EQ           reduce using rule 57 (literal1 -> DAY .)
    GT_EQ           reduce using rule 57 (literal1 -> DAY .)
    LT_EQ           reduce using rule 57 (literal1 -> DAY .)
    NOT_EQ          reduce using rule 57 (literal1 -> DAY .)
    AND             reduce using rule 57 (literal1 -> DAY .)
    OR              reduce using rule 57 (literal1 -> DAY .)
    COMMA           reduce using rule 57 (literal1 -> DAY .)
    NEWLINE         reduce using rule 57 (literal1 -> DAY .)
    RBRACKET        reduce using rule 57 (literal1 -> DAY .)
    RPAREN          reduce using rule 57 (literal1 -> DAY .)
    SWAP            reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_NAME   reduce using rule 57 (literal1 -> DAY .)
    IDENT           reduce using rule 57 (literal1 -> DAY .)
    DISPLAY         reduce using rule 57 (literal1 -> DAY .)
    CHECK           reduce using rule 57 (literal1 -> DAY .)
    FOR             reduce using rule 57 (literal1 -> DAY .)
    UNTIL           reduce using rule 57 (literal1 -> DAY .)
    REPEAT          reduce using rule 57 (literal1 -> DAY .)
    INPUT           reduce using rule 57 (literal1 -> DAY .)
    INT             reduce using rule 57 (literal1 -> DAY .)
    FLT             reduce using rule 57 (literal1 -> DAY .)
    BLN             reduce using rule 57 (literal1 -> DAY .)
    CHR             reduce using rule 57 (literal1 -> DAY .)
    STR             reduce using rule 57 (literal1 -> DAY .)
    REVIVE          reduce using rule 57 (literal1 -> DAY .)
    RBRACE          reduce using rule 57 (literal1 -> DAY .)
    SHIFT           reduce using rule 57 (literal1 -> DAY .)
    OTHERWISE       reduce using rule 57 (literal1 -> DAY .)
    SEMICOLON       reduce using rule 57 (literal1 -> DAY .)
    COLON           reduce using rule 57 (literal1 -> DAY .)


state 57

    (58) literal1 -> NIGHT .

    PLUS            reduce using rule 58 (literal1 -> NIGHT .)
    MINUS           reduce using rule 58 (literal1 -> NIGHT .)
    MULTIPLY        reduce using rule 58 (literal1 -> NIGHT .)
    DIVISION        reduce using rule 58 (literal1 -> NIGHT .)
    MODULO          reduce using rule 58 (literal1 -> NIGHT .)
    EXPONENT        reduce using rule 58 (literal1 -> NIGHT .)
    GT              reduce using rule 58 (literal1 -> NIGHT .)
    LT              reduce using rule 58 (literal1 -> NIGHT .)
    EQ_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    GT_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    LT_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    NOT_EQ          reduce using rule 58 (literal1 -> NIGHT .)
    AND             reduce using rule 58 (literal1 -> NIGHT .)
    OR              reduce using rule 58 (literal1 -> NIGHT .)
    COMMA           reduce using rule 58 (literal1 -> NIGHT .)
    NEWLINE         reduce using rule 58 (literal1 -> NIGHT .)
    RBRACKET        reduce using rule 58 (literal1 -> NIGHT .)
    RPAREN          reduce using rule 58 (literal1 -> NIGHT .)
    SWAP            reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_NAME   reduce using rule 58 (literal1 -> NIGHT .)
    IDENT           reduce using rule 58 (literal1 -> NIGHT .)
    DISPLAY         reduce using rule 58 (literal1 -> NIGHT .)
    CHECK           reduce using rule 58 (literal1 -> NIGHT .)
    FOR             reduce using rule 58 (literal1 -> NIGHT .)
    UNTIL           reduce using rule 58 (literal1 -> NIGHT .)
    REPEAT          reduce using rule 58 (literal1 -> NIGHT .)
    INPUT           reduce using rule 58 (literal1 -> NIGHT .)
    INT             reduce using rule 58 (literal1 -> NIGHT .)
    FLT             reduce using rule 58 (literal1 -> NIGHT .)
    BLN             reduce using rule 58 (literal1 -> NIGHT .)
    CHR             reduce using rule 58 (literal1 -> NIGHT .)
    STR             reduce using rule 58 (literal1 -> NIGHT .)
    REVIVE          reduce using rule 58 (literal1 -> NIGHT .)
    RBRACE          reduce using rule 58 (literal1 -> NIGHT .)
    SHIFT           reduce using rule 58 (literal1 -> NIGHT .)
    OTHERWISE       reduce using rule 58 (literal1 -> NIGHT .)
    SEMICOLON       reduce using rule 58 (literal1 -> NIGHT .)
    COLON           reduce using rule 58 (literal1 -> NIGHT .)


state 58

    (59) literal1 -> STR_LIT .

    PLUS            reduce using rule 59 (literal1 -> STR_LIT .)
    MINUS           reduce using rule 59 (literal1 -> STR_LIT .)
    MULTIPLY        reduce using rule 59 (literal1 -> STR_LIT .)
    DIVISION        reduce using rule 59 (literal1 -> STR_LIT .)
    MODULO          reduce using rule 59 (literal1 -> STR_LIT .)
    EXPONENT        reduce using rule 59 (literal1 -> STR_LIT .)
    GT              reduce using rule 59 (literal1 -> STR_LIT .)
    LT              reduce using rule 59 (literal1 -> STR_LIT .)
    EQ_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    GT_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    LT_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    NOT_EQ          reduce using rule 59 (literal1 -> STR_LIT .)
    AND             reduce using rule 59 (literal1 -> STR_LIT .)
    OR              reduce using rule 59 (literal1 -> STR_LIT .)
    COMMA           reduce using rule 59 (literal1 -> STR_LIT .)
    NEWLINE         reduce using rule 59 (literal1 -> STR_LIT .)
    RBRACKET        reduce using rule 59 (literal1 -> STR_LIT .)
    RPAREN          reduce using rule 59 (literal1 -> STR_LIT .)
    SWAP            reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_NAME   reduce using rule 59 (literal1 -> STR_LIT .)
    IDENT           reduce using rule 59 (literal1 -> STR_LIT .)
    DISPLAY         reduce using rule 59 (literal1 -> STR_LIT .)
    CHECK           reduce using rule 59 (literal1 -> STR_LIT .)
    FOR             reduce using rule 59 (literal1 -> STR_LIT .)
    UNTIL           reduce using rule 59 (literal1 -> STR_LIT .)
    REPEAT          reduce using rule 59 (literal1 -> STR_LIT .)
    INPUT           reduce using rule 59 (literal1 -> STR_LIT .)
    INT             reduce using rule 59 (literal1 -> STR_LIT .)
    FLT             reduce using rule 59 (literal1 -> STR_LIT .)
    BLN             reduce using rule 59 (literal1 -> STR_LIT .)
    CHR             reduce using rule 59 (literal1 -> STR_LIT .)
    STR             reduce using rule 59 (literal1 -> STR_LIT .)
    REVIVE          reduce using rule 59 (literal1 -> STR_LIT .)
    RBRACE          reduce using rule 59 (literal1 -> STR_LIT .)
    SHIFT           reduce using rule 59 (literal1 -> STR_LIT .)
    OTHERWISE       reduce using rule 59 (literal1 -> STR_LIT .)
    SEMICOLON       reduce using rule 59 (literal1 -> STR_LIT .)
    COLON           reduce using rule 59 (literal1 -> STR_LIT .)


state 59

    (11) var_statement -> data_type IDENT list_dec .

    COMMA           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    EQ              reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    NEWLINE         reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    SWAP            reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_NAME   reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    IDENT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    DISPLAY         reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    CHECK           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FOR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    UNTIL           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    REPEAT          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    INPUT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    INT             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FLT             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    BLN             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    CHR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    STR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    REVIVE          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    RBRACE          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    SHIFT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    OTHERWISE       reduce using rule 11 (var_statement -> data_type IDENT list_dec .)


state 60

    (12) list_dec -> empty .

    COMMA           reduce using rule 12 (list_dec -> empty .)
    EQ              reduce using rule 12 (list_dec -> empty .)
    NEWLINE         reduce using rule 12 (list_dec -> empty .)
    SWAP            reduce using rule 12 (list_dec -> empty .)
    FUNCTION_NAME   reduce using rule 12 (list_dec -> empty .)
    IDENT           reduce using rule 12 (list_dec -> empty .)
    DISPLAY         reduce using rule 12 (list_dec -> empty .)
    CHECK           reduce using rule 12 (list_dec -> empty .)
    FOR             reduce using rule 12 (list_dec -> empty .)
    UNTIL           reduce using rule 12 (list_dec -> empty .)
    REPEAT          reduce using rule 12 (list_dec -> empty .)
    INPUT           reduce using rule 12 (list_dec -> empty .)
    INT             reduce using rule 12 (list_dec -> empty .)
    FLT             reduce using rule 12 (list_dec -> empty .)
    BLN             reduce using rule 12 (list_dec -> empty .)
    CHR             reduce using rule 12 (list_dec -> empty .)
    STR             reduce using rule 12 (list_dec -> empty .)
    REVIVE          reduce using rule 12 (list_dec -> empty .)
    RBRACE          reduce using rule 12 (list_dec -> empty .)
    SHIFT           reduce using rule 12 (list_dec -> empty .)
    OTHERWISE       reduce using rule 12 (list_dec -> empty .)


state 61

    (13) list_dec -> LBRACKET . RBRACKET _2d_list

    RBRACKET        shift and go to state 100


state 62

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 102

    main_function                  shift and go to state 101

state 63

    (61) function_statements -> ret_type FUNCTION_NAME . LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail

    LPAREN          shift and go to state 103


state 64

    (17) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 65

    (18) global_statement_tail -> EQ global_value global_statement_tail2 .

    NEWLINE         reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)


state 66

    (19) global_statement_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 104


state 67

    (20) global_statement_tail2 -> empty .

    NEWLINE         reduce using rule 20 (global_statement_tail2 -> empty .)


state 68

    (32) expression -> factor factor_tail .

    COMMA           reduce using rule 32 (expression -> factor factor_tail .)
    NEWLINE         reduce using rule 32 (expression -> factor factor_tail .)
    RPAREN          reduce using rule 32 (expression -> factor factor_tail .)
    SWAP            reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_NAME   reduce using rule 32 (expression -> factor factor_tail .)
    IDENT           reduce using rule 32 (expression -> factor factor_tail .)
    DISPLAY         reduce using rule 32 (expression -> factor factor_tail .)
    CHECK           reduce using rule 32 (expression -> factor factor_tail .)
    FOR             reduce using rule 32 (expression -> factor factor_tail .)
    UNTIL           reduce using rule 32 (expression -> factor factor_tail .)
    REPEAT          reduce using rule 32 (expression -> factor factor_tail .)
    INPUT           reduce using rule 32 (expression -> factor factor_tail .)
    INT             reduce using rule 32 (expression -> factor factor_tail .)
    FLT             reduce using rule 32 (expression -> factor factor_tail .)
    BLN             reduce using rule 32 (expression -> factor factor_tail .)
    CHR             reduce using rule 32 (expression -> factor factor_tail .)
    STR             reduce using rule 32 (expression -> factor factor_tail .)
    REVIVE          reduce using rule 32 (expression -> factor factor_tail .)
    RBRACE          reduce using rule 32 (expression -> factor factor_tail .)
    SHIFT           reduce using rule 32 (expression -> factor factor_tail .)
    OTHERWISE       reduce using rule 32 (expression -> factor factor_tail .)
    SEMICOLON       reduce using rule 32 (expression -> factor factor_tail .)
    COLON           reduce using rule 32 (expression -> factor factor_tail .)


state 69

    (38) factor_tail -> PLUS . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 105
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 70

    (39) factor_tail -> MINUS . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 106
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 71

    (40) factor_tail -> MULTIPLY . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 107
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 72

    (41) factor_tail -> DIVISION . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 108
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 73

    (42) factor_tail -> MODULO . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 109
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 74

    (43) factor_tail -> EXPONENT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 110
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 75

    (44) factor_tail -> GT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 111
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 76

    (45) factor_tail -> LT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 112
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 77

    (46) factor_tail -> EQ_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 113
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 78

    (47) factor_tail -> GT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 114
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 79

    (48) factor_tail -> LT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 115
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 80

    (49) factor_tail -> NOT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 116
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 81

    (50) factor_tail -> AND . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 117
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 82

    (51) factor_tail -> OR . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 118
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 83

    (52) factor_tail -> empty .

    COMMA           reduce using rule 52 (factor_tail -> empty .)
    NEWLINE         reduce using rule 52 (factor_tail -> empty .)
    RPAREN          reduce using rule 52 (factor_tail -> empty .)
    SWAP            reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_NAME   reduce using rule 52 (factor_tail -> empty .)
    IDENT           reduce using rule 52 (factor_tail -> empty .)
    DISPLAY         reduce using rule 52 (factor_tail -> empty .)
    CHECK           reduce using rule 52 (factor_tail -> empty .)
    FOR             reduce using rule 52 (factor_tail -> empty .)
    UNTIL           reduce using rule 52 (factor_tail -> empty .)
    REPEAT          reduce using rule 52 (factor_tail -> empty .)
    INPUT           reduce using rule 52 (factor_tail -> empty .)
    INT             reduce using rule 52 (factor_tail -> empty .)
    FLT             reduce using rule 52 (factor_tail -> empty .)
    BLN             reduce using rule 52 (factor_tail -> empty .)
    CHR             reduce using rule 52 (factor_tail -> empty .)
    STR             reduce using rule 52 (factor_tail -> empty .)
    REVIVE          reduce using rule 52 (factor_tail -> empty .)
    RBRACE          reduce using rule 52 (factor_tail -> empty .)
    SHIFT           reduce using rule 52 (factor_tail -> empty .)
    OTHERWISE       reduce using rule 52 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 52 (factor_tail -> empty .)
    COLON           reduce using rule 52 (factor_tail -> empty .)


state 84

    (23) list_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 119


state 85

    (24) list_element -> literal . element_tail
    (25) element_tail -> . COMMA list_element
    (26) element_tail -> . empty
    (219) empty -> .

    COMMA           shift and go to state 121
    RBRACKET        reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)

    element_tail                   shift and go to state 120
    empty                          shift and go to state 122

state 86

    (53) literal -> literal1 .

    COMMA           reduce using rule 53 (literal -> literal1 .)
    RBRACKET        reduce using rule 53 (literal -> literal1 .)
    RPAREN          reduce using rule 53 (literal -> literal1 .)


state 87

    (54) literal -> literal2 .

    COMMA           reduce using rule 54 (literal -> literal2 .)
    RBRACKET        reduce using rule 54 (literal -> literal2 .)
    RPAREN          reduce using rule 54 (literal -> literal2 .)


state 88

    (60) literal2 -> CHR_LIT .

    COMMA           reduce using rule 60 (literal2 -> CHR_LIT .)
    RBRACKET        reduce using rule 60 (literal2 -> CHR_LIT .)
    RPAREN          reduce using rule 60 (literal2 -> CHR_LIT .)


state 89

    (33) factor -> var_call postfix .

    PLUS            reduce using rule 33 (factor -> var_call postfix .)
    MINUS           reduce using rule 33 (factor -> var_call postfix .)
    MULTIPLY        reduce using rule 33 (factor -> var_call postfix .)
    DIVISION        reduce using rule 33 (factor -> var_call postfix .)
    MODULO          reduce using rule 33 (factor -> var_call postfix .)
    EXPONENT        reduce using rule 33 (factor -> var_call postfix .)
    GT              reduce using rule 33 (factor -> var_call postfix .)
    LT              reduce using rule 33 (factor -> var_call postfix .)
    EQ_EQ           reduce using rule 33 (factor -> var_call postfix .)
    GT_EQ           reduce using rule 33 (factor -> var_call postfix .)
    LT_EQ           reduce using rule 33 (factor -> var_call postfix .)
    NOT_EQ          reduce using rule 33 (factor -> var_call postfix .)
    AND             reduce using rule 33 (factor -> var_call postfix .)
    OR              reduce using rule 33 (factor -> var_call postfix .)
    COMMA           reduce using rule 33 (factor -> var_call postfix .)
    NEWLINE         reduce using rule 33 (factor -> var_call postfix .)
    RPAREN          reduce using rule 33 (factor -> var_call postfix .)
    SWAP            reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_NAME   reduce using rule 33 (factor -> var_call postfix .)
    IDENT           reduce using rule 33 (factor -> var_call postfix .)
    DISPLAY         reduce using rule 33 (factor -> var_call postfix .)
    CHECK           reduce using rule 33 (factor -> var_call postfix .)
    FOR             reduce using rule 33 (factor -> var_call postfix .)
    UNTIL           reduce using rule 33 (factor -> var_call postfix .)
    REPEAT          reduce using rule 33 (factor -> var_call postfix .)
    INPUT           reduce using rule 33 (factor -> var_call postfix .)
    INT             reduce using rule 33 (factor -> var_call postfix .)
    FLT             reduce using rule 33 (factor -> var_call postfix .)
    BLN             reduce using rule 33 (factor -> var_call postfix .)
    CHR             reduce using rule 33 (factor -> var_call postfix .)
    STR             reduce using rule 33 (factor -> var_call postfix .)
    REVIVE          reduce using rule 33 (factor -> var_call postfix .)
    RBRACE          reduce using rule 33 (factor -> var_call postfix .)
    SHIFT           reduce using rule 33 (factor -> var_call postfix .)
    OTHERWISE       reduce using rule 33 (factor -> var_call postfix .)
    SEMICOLON       reduce using rule 33 (factor -> var_call postfix .)
    COLON           reduce using rule 33 (factor -> var_call postfix .)


state 90

    (206) postfix -> empty .

    PLUS            reduce using rule 206 (postfix -> empty .)
    MINUS           reduce using rule 206 (postfix -> empty .)
    MULTIPLY        reduce using rule 206 (postfix -> empty .)
    DIVISION        reduce using rule 206 (postfix -> empty .)
    MODULO          reduce using rule 206 (postfix -> empty .)
    EXPONENT        reduce using rule 206 (postfix -> empty .)
    GT              reduce using rule 206 (postfix -> empty .)
    LT              reduce using rule 206 (postfix -> empty .)
    EQ_EQ           reduce using rule 206 (postfix -> empty .)
    GT_EQ           reduce using rule 206 (postfix -> empty .)
    LT_EQ           reduce using rule 206 (postfix -> empty .)
    NOT_EQ          reduce using rule 206 (postfix -> empty .)
    AND             reduce using rule 206 (postfix -> empty .)
    OR              reduce using rule 206 (postfix -> empty .)
    COMMA           reduce using rule 206 (postfix -> empty .)
    NEWLINE         reduce using rule 206 (postfix -> empty .)
    RPAREN          reduce using rule 206 (postfix -> empty .)
    SWAP            reduce using rule 206 (postfix -> empty .)
    FUNCTION_NAME   reduce using rule 206 (postfix -> empty .)
    IDENT           reduce using rule 206 (postfix -> empty .)
    DISPLAY         reduce using rule 206 (postfix -> empty .)
    CHECK           reduce using rule 206 (postfix -> empty .)
    FOR             reduce using rule 206 (postfix -> empty .)
    UNTIL           reduce using rule 206 (postfix -> empty .)
    REPEAT          reduce using rule 206 (postfix -> empty .)
    INPUT           reduce using rule 206 (postfix -> empty .)
    INT             reduce using rule 206 (postfix -> empty .)
    FLT             reduce using rule 206 (postfix -> empty .)
    BLN             reduce using rule 206 (postfix -> empty .)
    CHR             reduce using rule 206 (postfix -> empty .)
    STR             reduce using rule 206 (postfix -> empty .)
    REVIVE          reduce using rule 206 (postfix -> empty .)
    RBRACE          reduce using rule 206 (postfix -> empty .)
    SHIFT           reduce using rule 206 (postfix -> empty .)
    OTHERWISE       reduce using rule 206 (postfix -> empty .)
    SEMICOLON       reduce using rule 206 (postfix -> empty .)
    COLON           reduce using rule 206 (postfix -> empty .)


state 91

    (207) postfix -> postfix_op .

    PLUS            reduce using rule 207 (postfix -> postfix_op .)
    MINUS           reduce using rule 207 (postfix -> postfix_op .)
    MULTIPLY        reduce using rule 207 (postfix -> postfix_op .)
    DIVISION        reduce using rule 207 (postfix -> postfix_op .)
    MODULO          reduce using rule 207 (postfix -> postfix_op .)
    EXPONENT        reduce using rule 207 (postfix -> postfix_op .)
    GT              reduce using rule 207 (postfix -> postfix_op .)
    LT              reduce using rule 207 (postfix -> postfix_op .)
    EQ_EQ           reduce using rule 207 (postfix -> postfix_op .)
    GT_EQ           reduce using rule 207 (postfix -> postfix_op .)
    LT_EQ           reduce using rule 207 (postfix -> postfix_op .)
    NOT_EQ          reduce using rule 207 (postfix -> postfix_op .)
    AND             reduce using rule 207 (postfix -> postfix_op .)
    OR              reduce using rule 207 (postfix -> postfix_op .)
    COMMA           reduce using rule 207 (postfix -> postfix_op .)
    NEWLINE         reduce using rule 207 (postfix -> postfix_op .)
    RPAREN          reduce using rule 207 (postfix -> postfix_op .)
    SWAP            reduce using rule 207 (postfix -> postfix_op .)
    FUNCTION_NAME   reduce using rule 207 (postfix -> postfix_op .)
    IDENT           reduce using rule 207 (postfix -> postfix_op .)
    DISPLAY         reduce using rule 207 (postfix -> postfix_op .)
    CHECK           reduce using rule 207 (postfix -> postfix_op .)
    FOR             reduce using rule 207 (postfix -> postfix_op .)
    UNTIL           reduce using rule 207 (postfix -> postfix_op .)
    REPEAT          reduce using rule 207 (postfix -> postfix_op .)
    INPUT           reduce using rule 207 (postfix -> postfix_op .)
    INT             reduce using rule 207 (postfix -> postfix_op .)
    FLT             reduce using rule 207 (postfix -> postfix_op .)
    BLN             reduce using rule 207 (postfix -> postfix_op .)
    CHR             reduce using rule 207 (postfix -> postfix_op .)
    STR             reduce using rule 207 (postfix -> postfix_op .)
    REVIVE          reduce using rule 207 (postfix -> postfix_op .)
    RBRACE          reduce using rule 207 (postfix -> postfix_op .)
    SHIFT           reduce using rule 207 (postfix -> postfix_op .)
    OTHERWISE       reduce using rule 207 (postfix -> postfix_op .)
    SEMICOLON       reduce using rule 207 (postfix -> postfix_op .)
    COLON           reduce using rule 207 (postfix -> postfix_op .)


state 92

    (170) postfix_op -> PLUS_PLUS .

    PLUS            reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    MINUS           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    MULTIPLY        reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    DIVISION        reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    MODULO          reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    EXPONENT        reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    GT              reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    LT              reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    EQ_EQ           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    GT_EQ           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    LT_EQ           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    NOT_EQ          reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    AND             reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    OR              reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    COMMA           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    NEWLINE         reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    RPAREN          reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    SWAP            reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    FUNCTION_NAME   reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    IDENT           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    DISPLAY         reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    CHECK           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    FOR             reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    UNTIL           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    REPEAT          reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    INPUT           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    INT             reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    FLT             reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    BLN             reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    CHR             reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    STR             reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    REVIVE          reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    RBRACE          reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    SHIFT           reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    OTHERWISE       reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    SEMICOLON       reduce using rule 170 (postfix_op -> PLUS_PLUS .)
    COLON           reduce using rule 170 (postfix_op -> PLUS_PLUS .)


state 93

    (171) postfix_op -> MINUS_MINUS .

    PLUS            reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    MINUS           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    MULTIPLY        reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    DIVISION        reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    MODULO          reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    EXPONENT        reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    GT              reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    LT              reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    EQ_EQ           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    GT_EQ           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    LT_EQ           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    NOT_EQ          reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    AND             reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    OR              reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    COMMA           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    NEWLINE         reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    RPAREN          reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    SWAP            reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    FUNCTION_NAME   reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    IDENT           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    DISPLAY         reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    CHECK           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    FOR             reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    UNTIL           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    REPEAT          reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    INPUT           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    INT             reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    FLT             reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    BLN             reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    CHR             reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    STR             reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    REVIVE          reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    RBRACE          reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    SHIFT           reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    OTHERWISE       reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    SEMICOLON       reduce using rule 171 (postfix_op -> MINUS_MINUS .)
    COLON           reduce using rule 171 (postfix_op -> MINUS_MINUS .)


state 94

    (35) factor -> TILDE INT_LIT .

    PLUS            reduce using rule 35 (factor -> TILDE INT_LIT .)
    MINUS           reduce using rule 35 (factor -> TILDE INT_LIT .)
    MULTIPLY        reduce using rule 35 (factor -> TILDE INT_LIT .)
    DIVISION        reduce using rule 35 (factor -> TILDE INT_LIT .)
    MODULO          reduce using rule 35 (factor -> TILDE INT_LIT .)
    EXPONENT        reduce using rule 35 (factor -> TILDE INT_LIT .)
    GT              reduce using rule 35 (factor -> TILDE INT_LIT .)
    LT              reduce using rule 35 (factor -> TILDE INT_LIT .)
    EQ_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    GT_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    LT_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    NOT_EQ          reduce using rule 35 (factor -> TILDE INT_LIT .)
    AND             reduce using rule 35 (factor -> TILDE INT_LIT .)
    OR              reduce using rule 35 (factor -> TILDE INT_LIT .)
    COMMA           reduce using rule 35 (factor -> TILDE INT_LIT .)
    NEWLINE         reduce using rule 35 (factor -> TILDE INT_LIT .)
    RPAREN          reduce using rule 35 (factor -> TILDE INT_LIT .)
    SWAP            reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_NAME   reduce using rule 35 (factor -> TILDE INT_LIT .)
    IDENT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    DISPLAY         reduce using rule 35 (factor -> TILDE INT_LIT .)
    CHECK           reduce using rule 35 (factor -> TILDE INT_LIT .)
    FOR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    UNTIL           reduce using rule 35 (factor -> TILDE INT_LIT .)
    REPEAT          reduce using rule 35 (factor -> TILDE INT_LIT .)
    INPUT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    INT             reduce using rule 35 (factor -> TILDE INT_LIT .)
    FLT             reduce using rule 35 (factor -> TILDE INT_LIT .)
    BLN             reduce using rule 35 (factor -> TILDE INT_LIT .)
    CHR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    STR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    REVIVE          reduce using rule 35 (factor -> TILDE INT_LIT .)
    RBRACE          reduce using rule 35 (factor -> TILDE INT_LIT .)
    SHIFT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    OTHERWISE       reduce using rule 35 (factor -> TILDE INT_LIT .)
    SEMICOLON       reduce using rule 35 (factor -> TILDE INT_LIT .)
    COLON           reduce using rule 35 (factor -> TILDE INT_LIT .)


state 95

    (36) factor -> TILDE FLT_LIT .

    PLUS            reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MINUS           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MULTIPLY        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    DIVISION        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MODULO          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    EXPONENT        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    GT              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    LT              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    EQ_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    GT_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    LT_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    NOT_EQ          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    AND             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    OR              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    COMMA           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    NEWLINE         reduce using rule 36 (factor -> TILDE FLT_LIT .)
    RPAREN          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SWAP            reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_NAME   reduce using rule 36 (factor -> TILDE FLT_LIT .)
    IDENT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    DISPLAY         reduce using rule 36 (factor -> TILDE FLT_LIT .)
    CHECK           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FOR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    UNTIL           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    REPEAT          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    INPUT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    INT             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FLT             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    BLN             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    CHR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    STR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    REVIVE          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    RBRACE          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SHIFT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    OTHERWISE       reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SEMICOLON       reduce using rule 36 (factor -> TILDE FLT_LIT .)
    COLON           reduce using rule 36 (factor -> TILDE FLT_LIT .)


state 96

    (37) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 123


state 97

    (199) var_call -> IDENT list_index .

    PLUS_PLUS       reduce using rule 199 (var_call -> IDENT list_index .)
    MINUS_MINUS     reduce using rule 199 (var_call -> IDENT list_index .)
    PLUS            reduce using rule 199 (var_call -> IDENT list_index .)
    MINUS           reduce using rule 199 (var_call -> IDENT list_index .)
    MULTIPLY        reduce using rule 199 (var_call -> IDENT list_index .)
    DIVISION        reduce using rule 199 (var_call -> IDENT list_index .)
    MODULO          reduce using rule 199 (var_call -> IDENT list_index .)
    EXPONENT        reduce using rule 199 (var_call -> IDENT list_index .)
    GT              reduce using rule 199 (var_call -> IDENT list_index .)
    LT              reduce using rule 199 (var_call -> IDENT list_index .)
    EQ_EQ           reduce using rule 199 (var_call -> IDENT list_index .)
    GT_EQ           reduce using rule 199 (var_call -> IDENT list_index .)
    LT_EQ           reduce using rule 199 (var_call -> IDENT list_index .)
    NOT_EQ          reduce using rule 199 (var_call -> IDENT list_index .)
    AND             reduce using rule 199 (var_call -> IDENT list_index .)
    OR              reduce using rule 199 (var_call -> IDENT list_index .)
    COMMA           reduce using rule 199 (var_call -> IDENT list_index .)
    NEWLINE         reduce using rule 199 (var_call -> IDENT list_index .)
    RPAREN          reduce using rule 199 (var_call -> IDENT list_index .)
    SWAP            reduce using rule 199 (var_call -> IDENT list_index .)
    FUNCTION_NAME   reduce using rule 199 (var_call -> IDENT list_index .)
    IDENT           reduce using rule 199 (var_call -> IDENT list_index .)
    DISPLAY         reduce using rule 199 (var_call -> IDENT list_index .)
    CHECK           reduce using rule 199 (var_call -> IDENT list_index .)
    FOR             reduce using rule 199 (var_call -> IDENT list_index .)
    UNTIL           reduce using rule 199 (var_call -> IDENT list_index .)
    REPEAT          reduce using rule 199 (var_call -> IDENT list_index .)
    INPUT           reduce using rule 199 (var_call -> IDENT list_index .)
    INT             reduce using rule 199 (var_call -> IDENT list_index .)
    FLT             reduce using rule 199 (var_call -> IDENT list_index .)
    BLN             reduce using rule 199 (var_call -> IDENT list_index .)
    CHR             reduce using rule 199 (var_call -> IDENT list_index .)
    STR             reduce using rule 199 (var_call -> IDENT list_index .)
    REVIVE          reduce using rule 199 (var_call -> IDENT list_index .)
    RBRACE          reduce using rule 199 (var_call -> IDENT list_index .)
    SHIFT           reduce using rule 199 (var_call -> IDENT list_index .)
    OTHERWISE       reduce using rule 199 (var_call -> IDENT list_index .)
    SEMICOLON       reduce using rule 199 (var_call -> IDENT list_index .)
    COLON           reduce using rule 199 (var_call -> IDENT list_index .)
    PLUS_EQ         reduce using rule 199 (var_call -> IDENT list_index .)
    MINUS_EQ        reduce using rule 199 (var_call -> IDENT list_index .)
    MUL_EQ          reduce using rule 199 (var_call -> IDENT list_index .)
    DIV_EQ          reduce using rule 199 (var_call -> IDENT list_index .)
    MOD_EQ          reduce using rule 199 (var_call -> IDENT list_index .)


state 98

    (200) list_index -> LBRACKET . index RBRACKET list_index2
    (204) index -> . INT_LIT
    (205) index -> . IDENT

    INT_LIT         shift and go to state 125
    IDENT           shift and go to state 126

    index                          shift and go to state 124

state 99

    (201) list_index -> empty .

    PLUS_PLUS       reduce using rule 201 (list_index -> empty .)
    MINUS_MINUS     reduce using rule 201 (list_index -> empty .)
    PLUS            reduce using rule 201 (list_index -> empty .)
    MINUS           reduce using rule 201 (list_index -> empty .)
    MULTIPLY        reduce using rule 201 (list_index -> empty .)
    DIVISION        reduce using rule 201 (list_index -> empty .)
    MODULO          reduce using rule 201 (list_index -> empty .)
    EXPONENT        reduce using rule 201 (list_index -> empty .)
    GT              reduce using rule 201 (list_index -> empty .)
    LT              reduce using rule 201 (list_index -> empty .)
    EQ_EQ           reduce using rule 201 (list_index -> empty .)
    GT_EQ           reduce using rule 201 (list_index -> empty .)
    LT_EQ           reduce using rule 201 (list_index -> empty .)
    NOT_EQ          reduce using rule 201 (list_index -> empty .)
    AND             reduce using rule 201 (list_index -> empty .)
    OR              reduce using rule 201 (list_index -> empty .)
    COMMA           reduce using rule 201 (list_index -> empty .)
    NEWLINE         reduce using rule 201 (list_index -> empty .)
    RPAREN          reduce using rule 201 (list_index -> empty .)
    SWAP            reduce using rule 201 (list_index -> empty .)
    FUNCTION_NAME   reduce using rule 201 (list_index -> empty .)
    IDENT           reduce using rule 201 (list_index -> empty .)
    DISPLAY         reduce using rule 201 (list_index -> empty .)
    CHECK           reduce using rule 201 (list_index -> empty .)
    FOR             reduce using rule 201 (list_index -> empty .)
    UNTIL           reduce using rule 201 (list_index -> empty .)
    REPEAT          reduce using rule 201 (list_index -> empty .)
    INPUT           reduce using rule 201 (list_index -> empty .)
    INT             reduce using rule 201 (list_index -> empty .)
    FLT             reduce using rule 201 (list_index -> empty .)
    BLN             reduce using rule 201 (list_index -> empty .)
    CHR             reduce using rule 201 (list_index -> empty .)
    STR             reduce using rule 201 (list_index -> empty .)
    REVIVE          reduce using rule 201 (list_index -> empty .)
    RBRACE          reduce using rule 201 (list_index -> empty .)
    SHIFT           reduce using rule 201 (list_index -> empty .)
    OTHERWISE       reduce using rule 201 (list_index -> empty .)
    SEMICOLON       reduce using rule 201 (list_index -> empty .)
    COLON           reduce using rule 201 (list_index -> empty .)
    PLUS_EQ         reduce using rule 201 (list_index -> empty .)
    MINUS_EQ        reduce using rule 201 (list_index -> empty .)
    MUL_EQ          reduce using rule 201 (list_index -> empty .)
    DIV_EQ          reduce using rule 201 (list_index -> empty .)
    MOD_EQ          reduce using rule 201 (list_index -> empty .)


state 100

    (13) list_dec -> LBRACKET RBRACKET . _2d_list
    (14) _2d_list -> . empty
    (15) _2d_list -> . LBRACKET RBRACKET
    (219) empty -> .

    LBRACKET        shift and go to state 127
    COMMA           reduce using rule 219 (empty -> .)
    EQ              reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

    _2d_list                       shift and go to state 128
    empty                          shift and go to state 129

state 101

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 130

state 102

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 131


state 103

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN . parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (77) parameters -> . data_type IDENT parameters_tail
    (78) parameters -> . empty
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR
    (219) empty -> .

    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14
    RPAREN          reduce using rule 219 (empty -> .)

    parameters                     shift and go to state 132
    data_type                      shift and go to state 133
    empty                          shift and go to state 134

state 104

    (19) global_statement_tail2 -> COMMA IDENT . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (219) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 219 (empty -> .)

    global_statement_tail          shift and go to state 135
    empty                          shift and go to state 21

state 105

    (38) factor_tail -> PLUS factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 136
    empty                          shift and go to state 83

state 106

    (39) factor_tail -> MINUS factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 137
    empty                          shift and go to state 83

state 107

    (40) factor_tail -> MULTIPLY factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 138
    empty                          shift and go to state 83

state 108

    (41) factor_tail -> DIVISION factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 139
    empty                          shift and go to state 83

state 109

    (42) factor_tail -> MODULO factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 140
    empty                          shift and go to state 83

state 110

    (43) factor_tail -> EXPONENT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 141
    empty                          shift and go to state 83

state 111

    (44) factor_tail -> GT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 142
    empty                          shift and go to state 83

state 112

    (45) factor_tail -> LT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 143
    empty                          shift and go to state 83

state 113

    (46) factor_tail -> EQ_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 144
    empty                          shift and go to state 83

state 114

    (47) factor_tail -> GT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 145
    empty                          shift and go to state 83

state 115

    (48) factor_tail -> LT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 146
    empty                          shift and go to state 83

state 116

    (49) factor_tail -> NOT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 147
    empty                          shift and go to state 83

state 117

    (50) factor_tail -> AND factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 148
    empty                          shift and go to state 83

state 118

    (51) factor_tail -> OR factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 149
    empty                          shift and go to state 83

state 119

    (23) list_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    SWAP            reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_NAME   reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    IDENT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    DISPLAY         reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    CHECK           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FOR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    UNTIL           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    REPEAT          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    INPUT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    INT             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FLT             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    BLN             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    CHR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    STR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    REVIVE          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    RBRACE          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    SHIFT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    OTHERWISE       reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)


state 120

    (24) list_element -> literal element_tail .

    RBRACKET        reduce using rule 24 (list_element -> literal element_tail .)
    RPAREN          reduce using rule 24 (list_element -> literal element_tail .)


state 121

    (25) element_tail -> COMMA . list_element
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 150
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 122

    (26) element_tail -> empty .

    RBRACKET        reduce using rule 26 (element_tail -> empty .)
    RPAREN          reduce using rule 26 (element_tail -> empty .)


state 123

    (37) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SWAP            reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_NAME   reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    IDENT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    DISPLAY         reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    CHECK           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    REPEAT          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    INPUT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    INT             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FLT             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    BLN             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    CHR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    STR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    REVIVE          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SHIFT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    OTHERWISE       reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 37 (factor -> LPAREN expression RPAREN .)


state 124

    (200) list_index -> LBRACKET index . RBRACKET list_index2

    RBRACKET        shift and go to state 151


state 125

    (204) index -> INT_LIT .

    RBRACKET        reduce using rule 204 (index -> INT_LIT .)


state 126

    (205) index -> IDENT .

    RBRACKET        reduce using rule 205 (index -> IDENT .)


state 127

    (15) _2d_list -> LBRACKET . RBRACKET

    RBRACKET        shift and go to state 152


state 128

    (13) list_dec -> LBRACKET RBRACKET _2d_list .

    COMMA           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    EQ              reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    NEWLINE         reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    SWAP            reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_NAME   reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    IDENT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    DISPLAY         reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    CHECK           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FOR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    UNTIL           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    REPEAT          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    INPUT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    INT             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FLT             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    BLN             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    CHR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    STR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    REVIVE          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    RBRACE          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    SHIFT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    OTHERWISE       reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)


state 129

    (14) _2d_list -> empty .

    COMMA           reduce using rule 14 (_2d_list -> empty .)
    EQ              reduce using rule 14 (_2d_list -> empty .)
    NEWLINE         reduce using rule 14 (_2d_list -> empty .)
    SWAP            reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_NAME   reduce using rule 14 (_2d_list -> empty .)
    IDENT           reduce using rule 14 (_2d_list -> empty .)
    DISPLAY         reduce using rule 14 (_2d_list -> empty .)
    CHECK           reduce using rule 14 (_2d_list -> empty .)
    FOR             reduce using rule 14 (_2d_list -> empty .)
    UNTIL           reduce using rule 14 (_2d_list -> empty .)
    REPEAT          reduce using rule 14 (_2d_list -> empty .)
    INPUT           reduce using rule 14 (_2d_list -> empty .)
    INT             reduce using rule 14 (_2d_list -> empty .)
    FLT             reduce using rule 14 (_2d_list -> empty .)
    BLN             reduce using rule 14 (_2d_list -> empty .)
    CHR             reduce using rule 14 (_2d_list -> empty .)
    STR             reduce using rule 14 (_2d_list -> empty .)
    REVIVE          reduce using rule 14 (_2d_list -> empty .)
    RBRACE          reduce using rule 14 (_2d_list -> empty .)
    SHIFT           reduce using rule 14 (_2d_list -> empty .)
    OTHERWISE       reduce using rule 14 (_2d_list -> empty .)


state 130

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 153


state 131

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 154


state 132

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters . RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail

    RPAREN          shift and go to state 155


state 133

    (77) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 156


state 134

    (78) parameters -> empty .

    RPAREN          reduce using rule 78 (parameters -> empty .)


state 135

    (19) global_statement_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)


state 136

    (38) factor_tail -> PLUS factor factor_tail .

    COMMA           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    NEWLINE         reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    RPAREN          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SWAP            reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_NAME   reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    IDENT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    DISPLAY         reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    CHECK           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FOR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    UNTIL           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    REPEAT          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    INPUT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    INT             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FLT             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    BLN             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    CHR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    STR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    REVIVE          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    RBRACE          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SHIFT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    OTHERWISE       reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SEMICOLON       reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    COLON           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)


state 137

    (39) factor_tail -> MINUS factor factor_tail .

    COMMA           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    NEWLINE         reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    RPAREN          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SWAP            reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_NAME   reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    IDENT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    DISPLAY         reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    CHECK           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FOR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    UNTIL           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    REPEAT          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    INPUT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    INT             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FLT             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    BLN             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    CHR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    STR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    REVIVE          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    RBRACE          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SHIFT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    OTHERWISE       reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SEMICOLON       reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    COLON           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)


state 138

    (40) factor_tail -> MULTIPLY factor factor_tail .

    COMMA           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    NEWLINE         reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    RPAREN          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SWAP            reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_NAME   reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    IDENT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    DISPLAY         reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    CHECK           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FOR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    UNTIL           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    REPEAT          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    INPUT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    INT             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FLT             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    BLN             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    CHR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    STR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    REVIVE          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    RBRACE          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SHIFT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    OTHERWISE       reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SEMICOLON       reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    COLON           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)


state 139

    (41) factor_tail -> DIVISION factor factor_tail .

    COMMA           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    NEWLINE         reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    RPAREN          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SWAP            reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_NAME   reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    IDENT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    DISPLAY         reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    CHECK           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FOR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    UNTIL           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    REPEAT          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    INPUT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    INT             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FLT             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    BLN             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    CHR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    STR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    REVIVE          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    RBRACE          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SHIFT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    OTHERWISE       reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SEMICOLON       reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    COLON           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)


state 140

    (42) factor_tail -> MODULO factor factor_tail .

    COMMA           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    NEWLINE         reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    RPAREN          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SWAP            reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_NAME   reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    IDENT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    DISPLAY         reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    CHECK           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FOR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    UNTIL           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    REPEAT          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    INPUT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    INT             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FLT             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    BLN             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    CHR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    STR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    REVIVE          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    RBRACE          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SHIFT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    OTHERWISE       reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SEMICOLON       reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    COLON           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)


state 141

    (43) factor_tail -> EXPONENT factor factor_tail .

    COMMA           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    NEWLINE         reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    RPAREN          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SWAP            reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    IDENT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    DISPLAY         reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    CHECK           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FOR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    UNTIL           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    REPEAT          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    INPUT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    INT             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FLT             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    BLN             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    CHR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    STR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    REVIVE          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    RBRACE          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SHIFT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    OTHERWISE       reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SEMICOLON       reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    COLON           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)


state 142

    (44) factor_tail -> GT factor factor_tail .

    COMMA           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    NEWLINE         reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    RPAREN          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SWAP            reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    IDENT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    DISPLAY         reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    CHECK           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FOR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    UNTIL           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    REPEAT          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    INPUT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    INT             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FLT             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    BLN             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    CHR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    STR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    REVIVE          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    RBRACE          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SHIFT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    OTHERWISE       reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SEMICOLON       reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    COLON           reduce using rule 44 (factor_tail -> GT factor factor_tail .)


state 143

    (45) factor_tail -> LT factor factor_tail .

    COMMA           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    NEWLINE         reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    RPAREN          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SWAP            reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    IDENT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    DISPLAY         reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    CHECK           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FOR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    UNTIL           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    REPEAT          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    INPUT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    INT             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FLT             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    BLN             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    CHR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    STR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    REVIVE          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    RBRACE          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SHIFT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    OTHERWISE       reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SEMICOLON       reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    COLON           reduce using rule 45 (factor_tail -> LT factor factor_tail .)


state 144

    (46) factor_tail -> EQ_EQ factor factor_tail .

    COMMA           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    NEWLINE         reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    RPAREN          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SWAP            reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    IDENT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    DISPLAY         reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    CHECK           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FOR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    UNTIL           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    REPEAT          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    INPUT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    INT             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FLT             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    BLN             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    CHR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    STR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    REVIVE          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    RBRACE          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SHIFT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    COLON           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)


state 145

    (47) factor_tail -> GT_EQ factor factor_tail .

    COMMA           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    RPAREN          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SWAP            reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    IDENT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    CHECK           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FOR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    UNTIL           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    REPEAT          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    INPUT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    INT             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FLT             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    BLN             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    CHR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    STR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    REVIVE          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    RBRACE          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SHIFT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    COLON           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)


state 146

    (48) factor_tail -> LT_EQ factor factor_tail .

    COMMA           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    RPAREN          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SWAP            reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    IDENT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    CHECK           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FOR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    UNTIL           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    REPEAT          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    INPUT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    INT             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FLT             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    BLN             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    CHR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    STR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    REVIVE          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    RBRACE          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SHIFT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    COLON           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)


state 147

    (49) factor_tail -> NOT_EQ factor factor_tail .

    COMMA           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    RPAREN          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SWAP            reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    IDENT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    CHECK           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FOR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    UNTIL           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    REPEAT          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    INPUT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    INT             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FLT             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    BLN             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    CHR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    STR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    REVIVE          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    RBRACE          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SHIFT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    COLON           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)


state 148

    (50) factor_tail -> AND factor factor_tail .

    COMMA           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    NEWLINE         reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    RPAREN          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SWAP            reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_NAME   reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    IDENT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    DISPLAY         reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    CHECK           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FOR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    UNTIL           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    REPEAT          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    INPUT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    INT             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FLT             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    BLN             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    CHR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    STR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    REVIVE          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    RBRACE          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SHIFT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    OTHERWISE       reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SEMICOLON       reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    COLON           reduce using rule 50 (factor_tail -> AND factor factor_tail .)


state 149

    (51) factor_tail -> OR factor factor_tail .

    COMMA           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    NEWLINE         reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    RPAREN          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SWAP            reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_NAME   reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    IDENT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    DISPLAY         reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    CHECK           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FOR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    UNTIL           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    REPEAT          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    INPUT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    INT             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FLT             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    BLN             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    CHR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    STR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    REVIVE          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    RBRACE          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SHIFT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    OTHERWISE       reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SEMICOLON       reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    COLON           reduce using rule 51 (factor_tail -> OR factor factor_tail .)


state 150

    (25) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 25 (element_tail -> COMMA list_element .)
    RPAREN          reduce using rule 25 (element_tail -> COMMA list_element .)


state 151

    (200) list_index -> LBRACKET index RBRACKET . list_index2
    (202) list_index2 -> . LBRACKET index RBRACKET
    (203) list_index2 -> . empty
    (219) empty -> .

    LBRACKET        shift and go to state 157
    PLUS_PLUS       reduce using rule 219 (empty -> .)
    MINUS_MINUS     reduce using rule 219 (empty -> .)
    PLUS            reduce using rule 219 (empty -> .)
    MINUS           reduce using rule 219 (empty -> .)
    MULTIPLY        reduce using rule 219 (empty -> .)
    DIVISION        reduce using rule 219 (empty -> .)
    MODULO          reduce using rule 219 (empty -> .)
    EXPONENT        reduce using rule 219 (empty -> .)
    GT              reduce using rule 219 (empty -> .)
    LT              reduce using rule 219 (empty -> .)
    EQ_EQ           reduce using rule 219 (empty -> .)
    GT_EQ           reduce using rule 219 (empty -> .)
    LT_EQ           reduce using rule 219 (empty -> .)
    NOT_EQ          reduce using rule 219 (empty -> .)
    AND             reduce using rule 219 (empty -> .)
    OR              reduce using rule 219 (empty -> .)
    COMMA           reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    RPAREN          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SEMICOLON       reduce using rule 219 (empty -> .)
    COLON           reduce using rule 219 (empty -> .)
    PLUS_EQ         reduce using rule 219 (empty -> .)
    MINUS_EQ        reduce using rule 219 (empty -> .)
    MUL_EQ          reduce using rule 219 (empty -> .)
    DIV_EQ          reduce using rule 219 (empty -> .)
    MOD_EQ          reduce using rule 219 (empty -> .)

    list_index2                    shift and go to state 158
    empty                          shift and go to state 159

state 152

    (15) _2d_list -> LBRACKET RBRACKET .

    COMMA           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    EQ              reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    NEWLINE         reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    SWAP            reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_NAME   reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    IDENT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    DISPLAY         reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    CHECK           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FOR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    UNTIL           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    REPEAT          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    INPUT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    INT             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FLT             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    BLN             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    CHR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    STR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    REVIVE          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    SHIFT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    OTHERWISE       reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)


state 153

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 154

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

    NEWLINE         shift and go to state 18
    LBRACE          reduce using rule 219 (empty -> .)

    maybe_newline                  shift and go to state 160
    empty                          shift and go to state 17

state 155

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN . LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail

    LBRACE          shift and go to state 161


state 156

    (77) parameters -> data_type IDENT . parameters_tail
    (79) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (80) parameters_tail -> . empty
    (219) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 219 (empty -> .)

    parameters_tail                shift and go to state 162
    empty                          shift and go to state 164

state 157

    (202) list_index2 -> LBRACKET . index RBRACKET
    (204) index -> . INT_LIT
    (205) index -> . IDENT

    INT_LIT         shift and go to state 125
    IDENT           shift and go to state 126

    index                          shift and go to state 165

state 158

    (200) list_index -> LBRACKET index RBRACKET list_index2 .

    PLUS_PLUS       reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS_MINUS     reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    PLUS            reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MULTIPLY        reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DIVISION        reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MODULO          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    EXPONENT        reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    GT              reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    LT              reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    EQ_EQ           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    GT_EQ           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    LT_EQ           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    NOT_EQ          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    AND             reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    OR              reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    COMMA           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    NEWLINE         reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    RPAREN          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SWAP            reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_NAME   reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    IDENT           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DISPLAY         reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    CHECK           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FOR             reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    UNTIL           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    REPEAT          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    INPUT           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    INT             reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FLT             reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    BLN             reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    CHR             reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    STR             reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    REVIVE          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    RBRACE          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SHIFT           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    OTHERWISE       reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SEMICOLON       reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    COLON           reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    PLUS_EQ         reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS_EQ        reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MUL_EQ          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DIV_EQ          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MOD_EQ          reduce using rule 200 (list_index -> LBRACKET index RBRACKET list_index2 .)


state 159

    (203) list_index2 -> empty .

    PLUS_PLUS       reduce using rule 203 (list_index2 -> empty .)
    MINUS_MINUS     reduce using rule 203 (list_index2 -> empty .)
    PLUS            reduce using rule 203 (list_index2 -> empty .)
    MINUS           reduce using rule 203 (list_index2 -> empty .)
    MULTIPLY        reduce using rule 203 (list_index2 -> empty .)
    DIVISION        reduce using rule 203 (list_index2 -> empty .)
    MODULO          reduce using rule 203 (list_index2 -> empty .)
    EXPONENT        reduce using rule 203 (list_index2 -> empty .)
    GT              reduce using rule 203 (list_index2 -> empty .)
    LT              reduce using rule 203 (list_index2 -> empty .)
    EQ_EQ           reduce using rule 203 (list_index2 -> empty .)
    GT_EQ           reduce using rule 203 (list_index2 -> empty .)
    LT_EQ           reduce using rule 203 (list_index2 -> empty .)
    NOT_EQ          reduce using rule 203 (list_index2 -> empty .)
    AND             reduce using rule 203 (list_index2 -> empty .)
    OR              reduce using rule 203 (list_index2 -> empty .)
    COMMA           reduce using rule 203 (list_index2 -> empty .)
    NEWLINE         reduce using rule 203 (list_index2 -> empty .)
    RPAREN          reduce using rule 203 (list_index2 -> empty .)
    SWAP            reduce using rule 203 (list_index2 -> empty .)
    FUNCTION_NAME   reduce using rule 203 (list_index2 -> empty .)
    IDENT           reduce using rule 203 (list_index2 -> empty .)
    DISPLAY         reduce using rule 203 (list_index2 -> empty .)
    CHECK           reduce using rule 203 (list_index2 -> empty .)
    FOR             reduce using rule 203 (list_index2 -> empty .)
    UNTIL           reduce using rule 203 (list_index2 -> empty .)
    REPEAT          reduce using rule 203 (list_index2 -> empty .)
    INPUT           reduce using rule 203 (list_index2 -> empty .)
    INT             reduce using rule 203 (list_index2 -> empty .)
    FLT             reduce using rule 203 (list_index2 -> empty .)
    BLN             reduce using rule 203 (list_index2 -> empty .)
    CHR             reduce using rule 203 (list_index2 -> empty .)
    STR             reduce using rule 203 (list_index2 -> empty .)
    REVIVE          reduce using rule 203 (list_index2 -> empty .)
    RBRACE          reduce using rule 203 (list_index2 -> empty .)
    SHIFT           reduce using rule 203 (list_index2 -> empty .)
    OTHERWISE       reduce using rule 203 (list_index2 -> empty .)
    SEMICOLON       reduce using rule 203 (list_index2 -> empty .)
    COLON           reduce using rule 203 (list_index2 -> empty .)
    PLUS_EQ         reduce using rule 203 (list_index2 -> empty .)
    MINUS_EQ        reduce using rule 203 (list_index2 -> empty .)
    MUL_EQ          reduce using rule 203 (list_index2 -> empty .)
    DIV_EQ          reduce using rule 203 (list_index2 -> empty .)
    MOD_EQ          reduce using rule 203 (list_index2 -> empty .)


state 160

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 166


state 161

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE . maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 167
    empty                          shift and go to state 17

state 162

    (77) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 77 (parameters -> data_type IDENT parameters_tail .)


state 163

    (79) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    data_type                      shift and go to state 168

state 164

    (80) parameters_tail -> empty .

    RPAREN          reduce using rule 80 (parameters_tail -> empty .)


state 165

    (202) list_index2 -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 169


state 166

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 170
    empty                          shift and go to state 17

state 167

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline . statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 171
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 168

    (79) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 175


state 169

    (202) list_index2 -> LBRACKET index RBRACKET .

    PLUS_PLUS       reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    PLUS            reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    GT              reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    LT              reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    AND             reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    OR              reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    SWAP            reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_NAME   reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    IDENT           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    DISPLAY         reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    CHECK           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    FOR             reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    UNTIL           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    REPEAT          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    INPUT           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    INT             reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    FLT             reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    BLN             reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    CHR             reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    STR             reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    REVIVE          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    SHIFT           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    OTHERWISE       reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 202 (list_index2 -> LBRACKET index RBRACKET .)


state 170

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 176
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 171

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements . maybe_newline revive unli_newline RBRACE function_statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    REVIVE          reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 177
    empty                          shift and go to state 17

state 172

    (90) statements -> empty .
    (100) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 90 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 90 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 90 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 90 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 90 (statements -> empty .)
    NEWLINE         reduce using rule 90 (statements -> empty .)
    REVIVE          reduce using rule 90 (statements -> empty .)
    RBRACE          reduce using rule 90 (statements -> empty .)
    SHIFT           reduce using rule 90 (statements -> empty .)
    OTHERWISE       reduce using rule 90 (statements -> empty .)
    SWAP            reduce using rule 100 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 100 (local_dec -> empty .)
    IDENT           reduce using rule 100 (local_dec -> empty .)
    DISPLAY         reduce using rule 100 (local_dec -> empty .)
    CHECK           reduce using rule 100 (local_dec -> empty .)
    FOR             reduce using rule 100 (local_dec -> empty .)
    UNTIL           reduce using rule 100 (local_dec -> empty .)
    REPEAT          reduce using rule 100 (local_dec -> empty .)
    INPUT           reduce using rule 100 (local_dec -> empty .)
    INT             reduce using rule 100 (local_dec -> empty .)
    FLT             reduce using rule 100 (local_dec -> empty .)
    BLN             reduce using rule 100 (local_dec -> empty .)
    CHR             reduce using rule 100 (local_dec -> empty .)
    STR             reduce using rule 100 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 100 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 100 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 100 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 100 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 100 (local_dec -> empty .) ]


state 173

    (91) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 178
    empty                          shift and go to state 17

state 174

    (99) local_dec -> var_statement . local_dec_tail
    (101) local_dec_tail -> . empty
    (102) local_dec_tail -> . COMMA IDENT local_dec_tail
    (103) local_dec_tail -> . EQ local_value local_dec_tail2
    (219) empty -> .

    COMMA           shift and go to state 181
    EQ              shift and go to state 182
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

    local_dec_tail                 shift and go to state 179
    empty                          shift and go to state 180

state 175

    (79) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (79) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (80) parameters_tail -> . empty
    (219) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 219 (empty -> .)

    parameters_tail                shift and go to state 183
    empty                          shift and go to state 164

state 176

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 219 (empty -> .)

    maybe_newline                  shift and go to state 184
    empty                          shift and go to state 17

state 177

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline . revive unli_newline RBRACE function_statements_tail
    (81) revive -> . REVIVE revive_value
    (82) revive -> . empty
    (219) empty -> .

    REVIVE          shift and go to state 186
    NEWLINE         reduce using rule 219 (empty -> .)

    revive                         shift and go to state 185
    empty                          shift and go to state 187

state 178

    (91) statements -> local_dec maybe_newline . statements_tail
    (92) statements_tail -> . switch_statement unli_newline statements
    (93) statements_tail -> . loop_statement unli_newline statements
    (94) statements_tail -> . function_call unli_newline statements
    (95) statements_tail -> . assignment_statement unli_newline statements
    (96) statements_tail -> . output_statement unli_newline statements
    (97) statements_tail -> . conditional_statement unli_newline statements
    (98) statements_tail -> . statements
    (147) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
    (158) loop_statement -> . for_loop
    (159) loop_statement -> . until_loop
    (160) loop_statement -> . repeat_until
    (172) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (173) function_call -> . input_statement
    (183) assignment_statement -> . IDENT assign_tail
    (180) output_statement -> . DISPLAY value next_val
    (115) conditional_statement -> . CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (161) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE
    (162) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (163) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (218) input_statement -> . INPUT LPAREN RPAREN
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SWAP            shift and go to state 196
    FUNCTION_NAME   shift and go to state 201
    IDENT           shift and go to state 197
    DISPLAY         shift and go to state 203
    CHECK           shift and go to state 204
    FOR             shift and go to state 205
    UNTIL           shift and go to state 206
    REPEAT          shift and go to state 207
    INPUT           shift and go to state 208
    NEWLINE         reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! SWAP            [ reduce using rule 219 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 219 (empty -> .) ]
  ! IDENT           [ reduce using rule 219 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 219 (empty -> .) ]
  ! CHECK           [ reduce using rule 219 (empty -> .) ]
  ! FOR             [ reduce using rule 219 (empty -> .) ]
  ! UNTIL           [ reduce using rule 219 (empty -> .) ]
  ! REPEAT          [ reduce using rule 219 (empty -> .) ]
  ! INPUT           [ reduce using rule 219 (empty -> .) ]
  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    local_dec                      shift and go to state 173
    statements_tail                shift and go to state 188
    switch_statement               shift and go to state 189
    statements                     shift and go to state 190
    loop_statement                 shift and go to state 191
    function_call                  shift and go to state 192
    assignment_statement           shift and go to state 193
    output_statement               shift and go to state 194
    conditional_statement          shift and go to state 195
    for_loop                       shift and go to state 198
    until_loop                     shift and go to state 199
    repeat_until                   shift and go to state 200
    input_statement                shift and go to state 202
    empty                          shift and go to state 172
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 179

    (99) local_dec -> var_statement local_dec_tail .

    NEWLINE         reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    SWAP            reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    FUNCTION_NAME   reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    IDENT           reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    DISPLAY         reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    CHECK           reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    FOR             reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    UNTIL           reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    REPEAT          reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    INPUT           reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    INT             reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    FLT             reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    BLN             reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    CHR             reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    STR             reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    REVIVE          reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    RBRACE          reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    SHIFT           reduce using rule 99 (local_dec -> var_statement local_dec_tail .)
    OTHERWISE       reduce using rule 99 (local_dec -> var_statement local_dec_tail .)


state 180

    (101) local_dec_tail -> empty .

    NEWLINE         reduce using rule 101 (local_dec_tail -> empty .)
    SWAP            reduce using rule 101 (local_dec_tail -> empty .)
    FUNCTION_NAME   reduce using rule 101 (local_dec_tail -> empty .)
    IDENT           reduce using rule 101 (local_dec_tail -> empty .)
    DISPLAY         reduce using rule 101 (local_dec_tail -> empty .)
    CHECK           reduce using rule 101 (local_dec_tail -> empty .)
    FOR             reduce using rule 101 (local_dec_tail -> empty .)
    UNTIL           reduce using rule 101 (local_dec_tail -> empty .)
    REPEAT          reduce using rule 101 (local_dec_tail -> empty .)
    INPUT           reduce using rule 101 (local_dec_tail -> empty .)
    INT             reduce using rule 101 (local_dec_tail -> empty .)
    FLT             reduce using rule 101 (local_dec_tail -> empty .)
    BLN             reduce using rule 101 (local_dec_tail -> empty .)
    CHR             reduce using rule 101 (local_dec_tail -> empty .)
    STR             reduce using rule 101 (local_dec_tail -> empty .)
    REVIVE          reduce using rule 101 (local_dec_tail -> empty .)
    RBRACE          reduce using rule 101 (local_dec_tail -> empty .)
    SHIFT           reduce using rule 101 (local_dec_tail -> empty .)
    OTHERWISE       reduce using rule 101 (local_dec_tail -> empty .)


state 181

    (102) local_dec_tail -> COMMA . IDENT local_dec_tail

    IDENT           shift and go to state 209


state 182

    (103) local_dec_tail -> EQ . local_value local_dec_tail2
    (106) local_value -> . local_value_value
    (107) local_value -> . list_value
    (108) local_value_value -> . local_type_cast
    (109) local_value_value -> . expression
    (110) local_value_value -> . function_call
    (23) list_value -> . LBRACKET list_element RBRACKET
    (111) local_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (112) local_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (113) local_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (114) local_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (172) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (173) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (218) input_statement -> . INPUT LPAREN RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    LBRACKET        shift and go to state 48
    CONVERT_TO_INT  shift and go to state 216
    CONVERT_TO_FLT  shift and go to state 217
    CONVERT_TO_BLN  shift and go to state 218
    CONVERT_TO_STR  shift and go to state 219
    FUNCTION_NAME   shift and go to state 201
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 208
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    local_value                    shift and go to state 210
    local_value_value              shift and go to state 211
    list_value                     shift and go to state 212
    local_type_cast                shift and go to state 213
    expression                     shift and go to state 214
    function_call                  shift and go to state 215
    factor                         shift and go to state 47
    input_statement                shift and go to state 202
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 183

    (79) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 79 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 184

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 220


state 185

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive . unli_newline RBRACE function_statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 221

state 186

    (81) revive -> REVIVE . revive_value
    (83) revive_value -> . revive_type_cast
    (84) revive_value -> . expression
    (85) revive_value -> . function_call
    (86) revive_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (87) revive_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (88) revive_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (89) revive_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (172) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (173) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (218) input_statement -> . INPUT LPAREN RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 226
    CONVERT_TO_FLT  shift and go to state 227
    CONVERT_TO_BLN  shift and go to state 228
    CONVERT_TO_STR  shift and go to state 229
    FUNCTION_NAME   shift and go to state 201
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 208
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    revive_value                   shift and go to state 222
    revive_type_cast               shift and go to state 223
    expression                     shift and go to state 224
    function_call                  shift and go to state 225
    factor                         shift and go to state 47
    input_statement                shift and go to state 202
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 187

    (82) revive -> empty .

    NEWLINE         reduce using rule 82 (revive -> empty .)


state 188

    (91) statements -> local_dec maybe_newline statements_tail .

    NEWLINE         reduce using rule 91 (statements -> local_dec maybe_newline statements_tail .)
    REVIVE          reduce using rule 91 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 91 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 91 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 91 (statements -> local_dec maybe_newline statements_tail .)


state 189

    (92) statements_tail -> switch_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 230

state 190

    (98) statements_tail -> statements .

    NEWLINE         reduce using rule 98 (statements_tail -> statements .)
    REVIVE          reduce using rule 98 (statements_tail -> statements .)
    RBRACE          reduce using rule 98 (statements_tail -> statements .)
    SHIFT           reduce using rule 98 (statements_tail -> statements .)
    OTHERWISE       reduce using rule 98 (statements_tail -> statements .)


state 191

    (93) statements_tail -> loop_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 231

state 192

    (94) statements_tail -> function_call . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 232

state 193

    (95) statements_tail -> assignment_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 233

state 194

    (96) statements_tail -> output_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 234

state 195

    (97) statements_tail -> conditional_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 235

state 196

    (147) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    LPAREN          shift and go to state 236


state 197

    (183) assignment_statement -> IDENT . assign_tail
    (184) assign_tail -> . DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
    (185) assign_tail -> . DOT PUSH LPAREN list_element RPAREN
    (186) assign_tail -> . assign_op value
    (187) assign_op -> . compound_op
    (188) assign_op -> . EQ
    (189) compound_op -> . PLUS_EQ
    (190) compound_op -> . MINUS_EQ
    (191) compound_op -> . MUL_EQ
    (192) compound_op -> . DIV_EQ
    (193) compound_op -> . MOD_EQ

    DOT             shift and go to state 238
    EQ              shift and go to state 241
    PLUS_EQ         shift and go to state 242
    MINUS_EQ        shift and go to state 243
    MUL_EQ          shift and go to state 244
    DIV_EQ          shift and go to state 245
    MOD_EQ          shift and go to state 246

    assign_tail                    shift and go to state 237
    assign_op                      shift and go to state 239
    compound_op                    shift and go to state 240

state 198

    (158) loop_statement -> for_loop .

    NEWLINE         reduce using rule 158 (loop_statement -> for_loop .)


state 199

    (159) loop_statement -> until_loop .

    NEWLINE         reduce using rule 159 (loop_statement -> until_loop .)


state 200

    (160) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 160 (loop_statement -> repeat_until .)


state 201

    (172) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 247


state 202

    (173) function_call -> input_statement .

    NEWLINE         reduce using rule 173 (function_call -> input_statement .)
    COMMA           reduce using rule 173 (function_call -> input_statement .)
    SWAP            reduce using rule 173 (function_call -> input_statement .)
    FUNCTION_NAME   reduce using rule 173 (function_call -> input_statement .)
    IDENT           reduce using rule 173 (function_call -> input_statement .)
    DISPLAY         reduce using rule 173 (function_call -> input_statement .)
    CHECK           reduce using rule 173 (function_call -> input_statement .)
    FOR             reduce using rule 173 (function_call -> input_statement .)
    UNTIL           reduce using rule 173 (function_call -> input_statement .)
    REPEAT          reduce using rule 173 (function_call -> input_statement .)
    INPUT           reduce using rule 173 (function_call -> input_statement .)
    INT             reduce using rule 173 (function_call -> input_statement .)
    FLT             reduce using rule 173 (function_call -> input_statement .)
    BLN             reduce using rule 173 (function_call -> input_statement .)
    CHR             reduce using rule 173 (function_call -> input_statement .)
    STR             reduce using rule 173 (function_call -> input_statement .)
    REVIVE          reduce using rule 173 (function_call -> input_statement .)
    RBRACE          reduce using rule 173 (function_call -> input_statement .)
    SHIFT           reduce using rule 173 (function_call -> input_statement .)
    OTHERWISE       reduce using rule 173 (function_call -> input_statement .)
    COLON           reduce using rule 173 (function_call -> input_statement .)
    RPAREN          reduce using rule 173 (function_call -> input_statement .)


state 203

    (180) output_statement -> DISPLAY . value next_val
    (208) value -> . type_cast
    (209) value -> . expression
    (210) value -> . function_call
    (211) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (212) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (213) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (214) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (172) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (173) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (218) input_statement -> . INPUT LPAREN RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 252
    CONVERT_TO_FLT  shift and go to state 253
    CONVERT_TO_BLN  shift and go to state 254
    CONVERT_TO_STR  shift and go to state 255
    FUNCTION_NAME   shift and go to state 201
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 208
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 248
    type_cast                      shift and go to state 249
    expression                     shift and go to state 250
    function_call                  shift and go to state 251
    factor                         shift and go to state 47
    input_statement                shift and go to state 202
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 204

    (115) conditional_statement -> CHECK . LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 256


state 205

    (161) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE

    LPAREN          shift and go to state 257


state 206

    (162) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 258


state 207

    (163) repeat_until -> REPEAT . LBRACE statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 259


state 208

    (218) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 260


state 209

    (102) local_dec_tail -> COMMA IDENT . local_dec_tail
    (101) local_dec_tail -> . empty
    (102) local_dec_tail -> . COMMA IDENT local_dec_tail
    (103) local_dec_tail -> . EQ local_value local_dec_tail2
    (219) empty -> .

    COMMA           shift and go to state 181
    EQ              shift and go to state 182
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

    local_dec_tail                 shift and go to state 261
    empty                          shift and go to state 180

state 210

    (103) local_dec_tail -> EQ local_value . local_dec_tail2
    (104) local_dec_tail2 -> . COMMA IDENT local_dec_tail
    (105) local_dec_tail2 -> . empty
    (219) empty -> .

    COMMA           shift and go to state 263
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

    local_dec_tail2                shift and go to state 262
    empty                          shift and go to state 264

state 211

    (106) local_value -> local_value_value .

    COMMA           reduce using rule 106 (local_value -> local_value_value .)
    NEWLINE         reduce using rule 106 (local_value -> local_value_value .)
    SWAP            reduce using rule 106 (local_value -> local_value_value .)
    FUNCTION_NAME   reduce using rule 106 (local_value -> local_value_value .)
    IDENT           reduce using rule 106 (local_value -> local_value_value .)
    DISPLAY         reduce using rule 106 (local_value -> local_value_value .)
    CHECK           reduce using rule 106 (local_value -> local_value_value .)
    FOR             reduce using rule 106 (local_value -> local_value_value .)
    UNTIL           reduce using rule 106 (local_value -> local_value_value .)
    REPEAT          reduce using rule 106 (local_value -> local_value_value .)
    INPUT           reduce using rule 106 (local_value -> local_value_value .)
    INT             reduce using rule 106 (local_value -> local_value_value .)
    FLT             reduce using rule 106 (local_value -> local_value_value .)
    BLN             reduce using rule 106 (local_value -> local_value_value .)
    CHR             reduce using rule 106 (local_value -> local_value_value .)
    STR             reduce using rule 106 (local_value -> local_value_value .)
    REVIVE          reduce using rule 106 (local_value -> local_value_value .)
    RBRACE          reduce using rule 106 (local_value -> local_value_value .)
    SHIFT           reduce using rule 106 (local_value -> local_value_value .)
    OTHERWISE       reduce using rule 106 (local_value -> local_value_value .)


state 212

    (107) local_value -> list_value .

    COMMA           reduce using rule 107 (local_value -> list_value .)
    NEWLINE         reduce using rule 107 (local_value -> list_value .)
    SWAP            reduce using rule 107 (local_value -> list_value .)
    FUNCTION_NAME   reduce using rule 107 (local_value -> list_value .)
    IDENT           reduce using rule 107 (local_value -> list_value .)
    DISPLAY         reduce using rule 107 (local_value -> list_value .)
    CHECK           reduce using rule 107 (local_value -> list_value .)
    FOR             reduce using rule 107 (local_value -> list_value .)
    UNTIL           reduce using rule 107 (local_value -> list_value .)
    REPEAT          reduce using rule 107 (local_value -> list_value .)
    INPUT           reduce using rule 107 (local_value -> list_value .)
    INT             reduce using rule 107 (local_value -> list_value .)
    FLT             reduce using rule 107 (local_value -> list_value .)
    BLN             reduce using rule 107 (local_value -> list_value .)
    CHR             reduce using rule 107 (local_value -> list_value .)
    STR             reduce using rule 107 (local_value -> list_value .)
    REVIVE          reduce using rule 107 (local_value -> list_value .)
    RBRACE          reduce using rule 107 (local_value -> list_value .)
    SHIFT           reduce using rule 107 (local_value -> list_value .)
    OTHERWISE       reduce using rule 107 (local_value -> list_value .)


state 213

    (108) local_value_value -> local_type_cast .

    COMMA           reduce using rule 108 (local_value_value -> local_type_cast .)
    NEWLINE         reduce using rule 108 (local_value_value -> local_type_cast .)
    SWAP            reduce using rule 108 (local_value_value -> local_type_cast .)
    FUNCTION_NAME   reduce using rule 108 (local_value_value -> local_type_cast .)
    IDENT           reduce using rule 108 (local_value_value -> local_type_cast .)
    DISPLAY         reduce using rule 108 (local_value_value -> local_type_cast .)
    CHECK           reduce using rule 108 (local_value_value -> local_type_cast .)
    FOR             reduce using rule 108 (local_value_value -> local_type_cast .)
    UNTIL           reduce using rule 108 (local_value_value -> local_type_cast .)
    REPEAT          reduce using rule 108 (local_value_value -> local_type_cast .)
    INPUT           reduce using rule 108 (local_value_value -> local_type_cast .)
    INT             reduce using rule 108 (local_value_value -> local_type_cast .)
    FLT             reduce using rule 108 (local_value_value -> local_type_cast .)
    BLN             reduce using rule 108 (local_value_value -> local_type_cast .)
    CHR             reduce using rule 108 (local_value_value -> local_type_cast .)
    STR             reduce using rule 108 (local_value_value -> local_type_cast .)
    REVIVE          reduce using rule 108 (local_value_value -> local_type_cast .)
    RBRACE          reduce using rule 108 (local_value_value -> local_type_cast .)
    SHIFT           reduce using rule 108 (local_value_value -> local_type_cast .)
    OTHERWISE       reduce using rule 108 (local_value_value -> local_type_cast .)


state 214

    (109) local_value_value -> expression .

    COMMA           reduce using rule 109 (local_value_value -> expression .)
    NEWLINE         reduce using rule 109 (local_value_value -> expression .)
    SWAP            reduce using rule 109 (local_value_value -> expression .)
    FUNCTION_NAME   reduce using rule 109 (local_value_value -> expression .)
    IDENT           reduce using rule 109 (local_value_value -> expression .)
    DISPLAY         reduce using rule 109 (local_value_value -> expression .)
    CHECK           reduce using rule 109 (local_value_value -> expression .)
    FOR             reduce using rule 109 (local_value_value -> expression .)
    UNTIL           reduce using rule 109 (local_value_value -> expression .)
    REPEAT          reduce using rule 109 (local_value_value -> expression .)
    INPUT           reduce using rule 109 (local_value_value -> expression .)
    INT             reduce using rule 109 (local_value_value -> expression .)
    FLT             reduce using rule 109 (local_value_value -> expression .)
    BLN             reduce using rule 109 (local_value_value -> expression .)
    CHR             reduce using rule 109 (local_value_value -> expression .)
    STR             reduce using rule 109 (local_value_value -> expression .)
    REVIVE          reduce using rule 109 (local_value_value -> expression .)
    RBRACE          reduce using rule 109 (local_value_value -> expression .)
    SHIFT           reduce using rule 109 (local_value_value -> expression .)
    OTHERWISE       reduce using rule 109 (local_value_value -> expression .)


state 215

    (110) local_value_value -> function_call .

    COMMA           reduce using rule 110 (local_value_value -> function_call .)
    NEWLINE         reduce using rule 110 (local_value_value -> function_call .)
    SWAP            reduce using rule 110 (local_value_value -> function_call .)
    FUNCTION_NAME   reduce using rule 110 (local_value_value -> function_call .)
    IDENT           reduce using rule 110 (local_value_value -> function_call .)
    DISPLAY         reduce using rule 110 (local_value_value -> function_call .)
    CHECK           reduce using rule 110 (local_value_value -> function_call .)
    FOR             reduce using rule 110 (local_value_value -> function_call .)
    UNTIL           reduce using rule 110 (local_value_value -> function_call .)
    REPEAT          reduce using rule 110 (local_value_value -> function_call .)
    INPUT           reduce using rule 110 (local_value_value -> function_call .)
    INT             reduce using rule 110 (local_value_value -> function_call .)
    FLT             reduce using rule 110 (local_value_value -> function_call .)
    BLN             reduce using rule 110 (local_value_value -> function_call .)
    CHR             reduce using rule 110 (local_value_value -> function_call .)
    STR             reduce using rule 110 (local_value_value -> function_call .)
    REVIVE          reduce using rule 110 (local_value_value -> function_call .)
    RBRACE          reduce using rule 110 (local_value_value -> function_call .)
    SHIFT           reduce using rule 110 (local_value_value -> function_call .)
    OTHERWISE       reduce using rule 110 (local_value_value -> function_call .)


state 216

    (111) local_type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 265


state 217

    (112) local_type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 266


state 218

    (113) local_type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 267


state 219

    (114) local_type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 268


state 220

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)


state 221

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline . RBRACE function_statements_tail

    RBRACE          shift and go to state 269


state 222

    (81) revive -> REVIVE revive_value .

    NEWLINE         reduce using rule 81 (revive -> REVIVE revive_value .)


state 223

    (83) revive_value -> revive_type_cast .

    NEWLINE         reduce using rule 83 (revive_value -> revive_type_cast .)


state 224

    (84) revive_value -> expression .

    NEWLINE         reduce using rule 84 (revive_value -> expression .)


state 225

    (85) revive_value -> function_call .

    NEWLINE         reduce using rule 85 (revive_value -> function_call .)


state 226

    (86) revive_type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 270


state 227

    (87) revive_type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 271


state 228

    (88) revive_type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 272


state 229

    (89) revive_type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 273


state 230

    (92) statements_tail -> switch_statement unli_newline . statements
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 274
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 231

    (93) statements_tail -> loop_statement unli_newline . statements
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 275
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 232

    (94) statements_tail -> function_call unli_newline . statements
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 276
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 233

    (95) statements_tail -> assignment_statement unli_newline . statements
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 277
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 234

    (96) statements_tail -> output_statement unli_newline . statements
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 278
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 235

    (97) statements_tail -> conditional_statement unli_newline . statements
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 279
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 236

    (147) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    IDENT           shift and go to state 280


state 237

    (183) assignment_statement -> IDENT assign_tail .

    NEWLINE         reduce using rule 183 (assignment_statement -> IDENT assign_tail .)


state 238

    (184) assign_tail -> DOT . SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
    (185) assign_tail -> DOT . PUSH LPAREN list_element RPAREN

    SPLICE          shift and go to state 281
    PUSH            shift and go to state 282


state 239

    (186) assign_tail -> assign_op . value
    (208) value -> . type_cast
    (209) value -> . expression
    (210) value -> . function_call
    (211) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (212) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (213) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (214) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (172) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (173) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (218) input_statement -> . INPUT LPAREN RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 252
    CONVERT_TO_FLT  shift and go to state 253
    CONVERT_TO_BLN  shift and go to state 254
    CONVERT_TO_STR  shift and go to state 255
    FUNCTION_NAME   shift and go to state 201
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 208
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 283
    type_cast                      shift and go to state 249
    expression                     shift and go to state 250
    function_call                  shift and go to state 251
    factor                         shift and go to state 47
    input_statement                shift and go to state 202
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 240

    (187) assign_op -> compound_op .

    CONVERT_TO_INT  reduce using rule 187 (assign_op -> compound_op .)
    CONVERT_TO_FLT  reduce using rule 187 (assign_op -> compound_op .)
    CONVERT_TO_BLN  reduce using rule 187 (assign_op -> compound_op .)
    CONVERT_TO_STR  reduce using rule 187 (assign_op -> compound_op .)
    FUNCTION_NAME   reduce using rule 187 (assign_op -> compound_op .)
    TILDE           reduce using rule 187 (assign_op -> compound_op .)
    LPAREN          reduce using rule 187 (assign_op -> compound_op .)
    INPUT           reduce using rule 187 (assign_op -> compound_op .)
    IDENT           reduce using rule 187 (assign_op -> compound_op .)
    INT_LIT         reduce using rule 187 (assign_op -> compound_op .)
    FLT_LIT         reduce using rule 187 (assign_op -> compound_op .)
    DAY             reduce using rule 187 (assign_op -> compound_op .)
    NIGHT           reduce using rule 187 (assign_op -> compound_op .)
    STR_LIT         reduce using rule 187 (assign_op -> compound_op .)


state 241

    (188) assign_op -> EQ .

    CONVERT_TO_INT  reduce using rule 188 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 188 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 188 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 188 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 188 (assign_op -> EQ .)
    TILDE           reduce using rule 188 (assign_op -> EQ .)
    LPAREN          reduce using rule 188 (assign_op -> EQ .)
    INPUT           reduce using rule 188 (assign_op -> EQ .)
    IDENT           reduce using rule 188 (assign_op -> EQ .)
    INT_LIT         reduce using rule 188 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 188 (assign_op -> EQ .)
    DAY             reduce using rule 188 (assign_op -> EQ .)
    NIGHT           reduce using rule 188 (assign_op -> EQ .)
    STR_LIT         reduce using rule 188 (assign_op -> EQ .)


state 242

    (189) compound_op -> PLUS_EQ .

    CONVERT_TO_INT  reduce using rule 189 (compound_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 189 (compound_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 189 (compound_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 189 (compound_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 189 (compound_op -> PLUS_EQ .)
    TILDE           reduce using rule 189 (compound_op -> PLUS_EQ .)
    LPAREN          reduce using rule 189 (compound_op -> PLUS_EQ .)
    INPUT           reduce using rule 189 (compound_op -> PLUS_EQ .)
    IDENT           reduce using rule 189 (compound_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 189 (compound_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 189 (compound_op -> PLUS_EQ .)
    DAY             reduce using rule 189 (compound_op -> PLUS_EQ .)
    NIGHT           reduce using rule 189 (compound_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 189 (compound_op -> PLUS_EQ .)


state 243

    (190) compound_op -> MINUS_EQ .

    CONVERT_TO_INT  reduce using rule 190 (compound_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 190 (compound_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 190 (compound_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 190 (compound_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 190 (compound_op -> MINUS_EQ .)
    TILDE           reduce using rule 190 (compound_op -> MINUS_EQ .)
    LPAREN          reduce using rule 190 (compound_op -> MINUS_EQ .)
    INPUT           reduce using rule 190 (compound_op -> MINUS_EQ .)
    IDENT           reduce using rule 190 (compound_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 190 (compound_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 190 (compound_op -> MINUS_EQ .)
    DAY             reduce using rule 190 (compound_op -> MINUS_EQ .)
    NIGHT           reduce using rule 190 (compound_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 190 (compound_op -> MINUS_EQ .)


state 244

    (191) compound_op -> MUL_EQ .

    CONVERT_TO_INT  reduce using rule 191 (compound_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 191 (compound_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 191 (compound_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 191 (compound_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 191 (compound_op -> MUL_EQ .)
    TILDE           reduce using rule 191 (compound_op -> MUL_EQ .)
    LPAREN          reduce using rule 191 (compound_op -> MUL_EQ .)
    INPUT           reduce using rule 191 (compound_op -> MUL_EQ .)
    IDENT           reduce using rule 191 (compound_op -> MUL_EQ .)
    INT_LIT         reduce using rule 191 (compound_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 191 (compound_op -> MUL_EQ .)
    DAY             reduce using rule 191 (compound_op -> MUL_EQ .)
    NIGHT           reduce using rule 191 (compound_op -> MUL_EQ .)
    STR_LIT         reduce using rule 191 (compound_op -> MUL_EQ .)


state 245

    (192) compound_op -> DIV_EQ .

    CONVERT_TO_INT  reduce using rule 192 (compound_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 192 (compound_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 192 (compound_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 192 (compound_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 192 (compound_op -> DIV_EQ .)
    TILDE           reduce using rule 192 (compound_op -> DIV_EQ .)
    LPAREN          reduce using rule 192 (compound_op -> DIV_EQ .)
    INPUT           reduce using rule 192 (compound_op -> DIV_EQ .)
    IDENT           reduce using rule 192 (compound_op -> DIV_EQ .)
    INT_LIT         reduce using rule 192 (compound_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 192 (compound_op -> DIV_EQ .)
    DAY             reduce using rule 192 (compound_op -> DIV_EQ .)
    NIGHT           reduce using rule 192 (compound_op -> DIV_EQ .)
    STR_LIT         reduce using rule 192 (compound_op -> DIV_EQ .)


state 246

    (193) compound_op -> MOD_EQ .

    CONVERT_TO_INT  reduce using rule 193 (compound_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 193 (compound_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 193 (compound_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 193 (compound_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 193 (compound_op -> MOD_EQ .)
    TILDE           reduce using rule 193 (compound_op -> MOD_EQ .)
    LPAREN          reduce using rule 193 (compound_op -> MOD_EQ .)
    INPUT           reduce using rule 193 (compound_op -> MOD_EQ .)
    IDENT           reduce using rule 193 (compound_op -> MOD_EQ .)
    INT_LIT         reduce using rule 193 (compound_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 193 (compound_op -> MOD_EQ .)
    DAY             reduce using rule 193 (compound_op -> MOD_EQ .)
    NIGHT           reduce using rule 193 (compound_op -> MOD_EQ .)
    STR_LIT         reduce using rule 193 (compound_op -> MOD_EQ .)


state 247

    (172) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (174) arguments -> . empty
    (175) arguments -> . arg_value arg_tail
    (219) empty -> .
    (178) arg_value -> . literal
    (179) arg_value -> . var_call
    (53) literal -> . literal1
    (54) literal -> . literal2
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    RPAREN          reduce using rule 219 (empty -> .)
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    arguments                      shift and go to state 284
    empty                          shift and go to state 285
    arg_value                      shift and go to state 286
    literal                        shift and go to state 287
    var_call                       shift and go to state 288
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 248

    (180) output_statement -> DISPLAY value . next_val
    (181) next_val -> . COMMA value next_val
    (182) next_val -> . empty
    (219) empty -> .

    COMMA           shift and go to state 290
    NEWLINE         reduce using rule 219 (empty -> .)

    next_val                       shift and go to state 289
    empty                          shift and go to state 291

state 249

    (208) value -> type_cast .

    COMMA           reduce using rule 208 (value -> type_cast .)
    NEWLINE         reduce using rule 208 (value -> type_cast .)
    RPAREN          reduce using rule 208 (value -> type_cast .)


state 250

    (209) value -> expression .

    COMMA           reduce using rule 209 (value -> expression .)
    NEWLINE         reduce using rule 209 (value -> expression .)
    RPAREN          reduce using rule 209 (value -> expression .)


state 251

    (210) value -> function_call .

    COMMA           reduce using rule 210 (value -> function_call .)
    NEWLINE         reduce using rule 210 (value -> function_call .)
    RPAREN          reduce using rule 210 (value -> function_call .)


state 252

    (211) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 292


state 253

    (212) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 293


state 254

    (213) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 294


state 255

    (214) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 295


state 256

    (115) conditional_statement -> CHECK LPAREN . condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (116) condition -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    condition                      shift and go to state 296
    factor                         shift and go to state 297
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 257

    (161) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE
    (164) control_variable -> . INT IDENT EQ control_var_tail

    INT             shift and go to state 299

    control_variable               shift and go to state 298

state 258

    (162) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE statements RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 300
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 259

    (163) repeat_until -> REPEAT LBRACE . statements RBRACE UNTIL LPAREN expression RPAREN
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 301
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 260

    (218) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 302


state 261

    (102) local_dec_tail -> COMMA IDENT local_dec_tail .

    NEWLINE         reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    SWAP            reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FUNCTION_NAME   reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    IDENT           reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    DISPLAY         reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    CHECK           reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FOR             reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    UNTIL           reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    REPEAT          reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    INPUT           reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    INT             reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FLT             reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    BLN             reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    CHR             reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    STR             reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    REVIVE          reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    RBRACE          reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    SHIFT           reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    OTHERWISE       reduce using rule 102 (local_dec_tail -> COMMA IDENT local_dec_tail .)


state 262

    (103) local_dec_tail -> EQ local_value local_dec_tail2 .

    NEWLINE         reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    SWAP            reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FUNCTION_NAME   reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    IDENT           reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    DISPLAY         reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    CHECK           reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FOR             reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    UNTIL           reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    REPEAT          reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    INPUT           reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    INT             reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FLT             reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    BLN             reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    CHR             reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    STR             reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    REVIVE          reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    RBRACE          reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    SHIFT           reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    OTHERWISE       reduce using rule 103 (local_dec_tail -> EQ local_value local_dec_tail2 .)


state 263

    (104) local_dec_tail2 -> COMMA . IDENT local_dec_tail

    IDENT           shift and go to state 303


state 264

    (105) local_dec_tail2 -> empty .

    NEWLINE         reduce using rule 105 (local_dec_tail2 -> empty .)
    SWAP            reduce using rule 105 (local_dec_tail2 -> empty .)
    FUNCTION_NAME   reduce using rule 105 (local_dec_tail2 -> empty .)
    IDENT           reduce using rule 105 (local_dec_tail2 -> empty .)
    DISPLAY         reduce using rule 105 (local_dec_tail2 -> empty .)
    CHECK           reduce using rule 105 (local_dec_tail2 -> empty .)
    FOR             reduce using rule 105 (local_dec_tail2 -> empty .)
    UNTIL           reduce using rule 105 (local_dec_tail2 -> empty .)
    REPEAT          reduce using rule 105 (local_dec_tail2 -> empty .)
    INPUT           reduce using rule 105 (local_dec_tail2 -> empty .)
    INT             reduce using rule 105 (local_dec_tail2 -> empty .)
    FLT             reduce using rule 105 (local_dec_tail2 -> empty .)
    BLN             reduce using rule 105 (local_dec_tail2 -> empty .)
    CHR             reduce using rule 105 (local_dec_tail2 -> empty .)
    STR             reduce using rule 105 (local_dec_tail2 -> empty .)
    REVIVE          reduce using rule 105 (local_dec_tail2 -> empty .)
    RBRACE          reduce using rule 105 (local_dec_tail2 -> empty .)
    SHIFT           reduce using rule 105 (local_dec_tail2 -> empty .)
    OTHERWISE       reduce using rule 105 (local_dec_tail2 -> empty .)


state 265

    (111) local_type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 304
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 266

    (112) local_type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 308
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 267

    (113) local_type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 309
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 268

    (114) local_type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 310
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 269

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE . function_statements_tail
    (63) function_statements_tail -> . function_statements
    (64) function_statements_tail -> . empty
    (61) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail
    (62) function_statements -> . empty
    (219) empty -> .
    (65) ret_type -> . FUNCTION
    (66) ret_type -> . function_dtype
    (67) function_dtype -> . FUNCTION_INT
    (68) function_dtype -> . FUNCTION_FLT
    (69) function_dtype -> . FUNCTION_CHR
    (70) function_dtype -> . FUNCTION_BLN
    (71) function_dtype -> . FUNCTION_STR
    (72) function_dtype -> . FUNCTION_LIST_INT
    (73) function_dtype -> . FUNCTION_LIST_FLT
    (74) function_dtype -> . FUNCTION_LIST_CHR
    (75) function_dtype -> . FUNCTION_LIST_STR
    (76) function_dtype -> . FUNCTION_LIST_BLN

    NEWLINE         reduce using rule 219 (empty -> .)
    MAIN_CASPER     reduce using rule 219 (empty -> .)
    FUNCTION        shift and go to state 28
    FUNCTION_INT    shift and go to state 30
    FUNCTION_FLT    shift and go to state 31
    FUNCTION_CHR    shift and go to state 32
    FUNCTION_BLN    shift and go to state 33
    FUNCTION_STR    shift and go to state 34
    FUNCTION_LIST_INT shift and go to state 35
    FUNCTION_LIST_FLT shift and go to state 36
    FUNCTION_LIST_CHR shift and go to state 37
    FUNCTION_LIST_STR shift and go to state 38
    FUNCTION_LIST_BLN shift and go to state 39

    ret_type                       shift and go to state 26
    function_statements_tail       shift and go to state 311
    function_statements            shift and go to state 312
    empty                          shift and go to state 313
    function_dtype                 shift and go to state 29

state 270

    (86) revive_type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 314
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 271

    (87) revive_type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 315
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 272

    (88) revive_type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 316
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 273

    (89) revive_type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 317
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 274

    (92) statements_tail -> switch_statement unli_newline statements .

    NEWLINE         reduce using rule 92 (statements_tail -> switch_statement unli_newline statements .)
    REVIVE          reduce using rule 92 (statements_tail -> switch_statement unli_newline statements .)
    RBRACE          reduce using rule 92 (statements_tail -> switch_statement unli_newline statements .)
    SHIFT           reduce using rule 92 (statements_tail -> switch_statement unli_newline statements .)
    OTHERWISE       reduce using rule 92 (statements_tail -> switch_statement unli_newline statements .)


state 275

    (93) statements_tail -> loop_statement unli_newline statements .

    NEWLINE         reduce using rule 93 (statements_tail -> loop_statement unli_newline statements .)
    REVIVE          reduce using rule 93 (statements_tail -> loop_statement unli_newline statements .)
    RBRACE          reduce using rule 93 (statements_tail -> loop_statement unli_newline statements .)
    SHIFT           reduce using rule 93 (statements_tail -> loop_statement unli_newline statements .)
    OTHERWISE       reduce using rule 93 (statements_tail -> loop_statement unli_newline statements .)


state 276

    (94) statements_tail -> function_call unli_newline statements .

    NEWLINE         reduce using rule 94 (statements_tail -> function_call unli_newline statements .)
    REVIVE          reduce using rule 94 (statements_tail -> function_call unli_newline statements .)
    RBRACE          reduce using rule 94 (statements_tail -> function_call unli_newline statements .)
    SHIFT           reduce using rule 94 (statements_tail -> function_call unli_newline statements .)
    OTHERWISE       reduce using rule 94 (statements_tail -> function_call unli_newline statements .)


state 277

    (95) statements_tail -> assignment_statement unli_newline statements .

    NEWLINE         reduce using rule 95 (statements_tail -> assignment_statement unli_newline statements .)
    REVIVE          reduce using rule 95 (statements_tail -> assignment_statement unli_newline statements .)
    RBRACE          reduce using rule 95 (statements_tail -> assignment_statement unli_newline statements .)
    SHIFT           reduce using rule 95 (statements_tail -> assignment_statement unli_newline statements .)
    OTHERWISE       reduce using rule 95 (statements_tail -> assignment_statement unli_newline statements .)


state 278

    (96) statements_tail -> output_statement unli_newline statements .

    NEWLINE         reduce using rule 96 (statements_tail -> output_statement unli_newline statements .)
    REVIVE          reduce using rule 96 (statements_tail -> output_statement unli_newline statements .)
    RBRACE          reduce using rule 96 (statements_tail -> output_statement unli_newline statements .)
    SHIFT           reduce using rule 96 (statements_tail -> output_statement unli_newline statements .)
    OTHERWISE       reduce using rule 96 (statements_tail -> output_statement unli_newline statements .)


state 279

    (97) statements_tail -> conditional_statement unli_newline statements .

    NEWLINE         reduce using rule 97 (statements_tail -> conditional_statement unli_newline statements .)
    REVIVE          reduce using rule 97 (statements_tail -> conditional_statement unli_newline statements .)
    RBRACE          reduce using rule 97 (statements_tail -> conditional_statement unli_newline statements .)
    SHIFT           reduce using rule 97 (statements_tail -> conditional_statement unli_newline statements .)
    OTHERWISE       reduce using rule 97 (statements_tail -> conditional_statement unli_newline statements .)


state 280

    (147) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    RPAREN          shift and go to state 318


state 281

    (184) assign_tail -> DOT SPLICE . LPAREN start COMMA deleteCount COMMA splice_items RPAREN

    LPAREN          shift and go to state 319


state 282

    (185) assign_tail -> DOT PUSH . LPAREN list_element RPAREN

    LPAREN          shift and go to state 320


state 283

    (186) assign_tail -> assign_op value .

    NEWLINE         reduce using rule 186 (assign_tail -> assign_op value .)


state 284

    (172) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 321


state 285

    (174) arguments -> empty .

    RPAREN          reduce using rule 174 (arguments -> empty .)


state 286

    (175) arguments -> arg_value . arg_tail
    (176) arg_tail -> . COMMA arg_value arg_tail
    (177) arg_tail -> . empty
    (219) empty -> .

    COMMA           shift and go to state 323
    RPAREN          reduce using rule 219 (empty -> .)

    arg_tail                       shift and go to state 322
    empty                          shift and go to state 324

state 287

    (178) arg_value -> literal .

    COMMA           reduce using rule 178 (arg_value -> literal .)
    RPAREN          reduce using rule 178 (arg_value -> literal .)


state 288

    (179) arg_value -> var_call .

    COMMA           reduce using rule 179 (arg_value -> var_call .)
    RPAREN          reduce using rule 179 (arg_value -> var_call .)


state 289

    (180) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 180 (output_statement -> DISPLAY value next_val .)


state 290

    (181) next_val -> COMMA . value next_val
    (208) value -> . type_cast
    (209) value -> . expression
    (210) value -> . function_call
    (211) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (212) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (213) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (214) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (172) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (173) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (218) input_statement -> . INPUT LPAREN RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 252
    CONVERT_TO_FLT  shift and go to state 253
    CONVERT_TO_BLN  shift and go to state 254
    CONVERT_TO_STR  shift and go to state 255
    FUNCTION_NAME   shift and go to state 201
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 208
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 325
    type_cast                      shift and go to state 249
    expression                     shift and go to state 250
    function_call                  shift and go to state 251
    factor                         shift and go to state 47
    input_statement                shift and go to state 202
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 291

    (182) next_val -> empty .

    NEWLINE         reduce using rule 182 (next_val -> empty .)


state 292

    (211) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 326
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 293

    (212) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 327
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 294

    (213) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 328
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 295

    (214) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 329
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 296

    (115) conditional_statement -> CHECK LPAREN condition . RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 330


state 297

    (116) condition -> factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (219) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    RPAREN          reduce using rule 219 (empty -> .)

    factor_tail                    shift and go to state 331
    empty                          shift and go to state 83

state 298

    (161) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE

    SEMICOLON       shift and go to state 332


state 299

    (164) control_variable -> INT . IDENT EQ control_var_tail

    IDENT           shift and go to state 333


state 300

    (162) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 334


state 301

    (163) repeat_until -> REPEAT LBRACE statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 335


state 302

    (218) input_statement -> INPUT LPAREN RPAREN .

    NEWLINE         reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    SWAP            reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION_NAME   reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    IDENT           reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    DISPLAY         reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    CHECK           reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    UNTIL           reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    REPEAT          reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    FLT             reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    BLN             reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    CHR             reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    STR             reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    REVIVE          reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    SHIFT           reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    OTHERWISE       reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 218 (input_statement -> INPUT LPAREN RPAREN .)


state 303

    (104) local_dec_tail2 -> COMMA IDENT . local_dec_tail
    (101) local_dec_tail -> . empty
    (102) local_dec_tail -> . COMMA IDENT local_dec_tail
    (103) local_dec_tail -> . EQ local_value local_dec_tail2
    (219) empty -> .

    COMMA           shift and go to state 181
    EQ              shift and go to state 182
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    REVIVE          reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

    local_dec_tail                 shift and go to state 336
    empty                          shift and go to state 180

state 304

    (111) local_type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 337


state 305

    (215) typecast_value -> expression .

    RPAREN          reduce using rule 215 (typecast_value -> expression .)


state 306

    (216) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 338


state 307

    (217) typecast_value -> input_statement .

    RPAREN          reduce using rule 217 (typecast_value -> input_statement .)


state 308

    (112) local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 339


state 309

    (113) local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 340


state 310

    (114) local_type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 341


state 311

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail .

    NEWLINE         reduce using rule 61 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail .)
    MAIN_CASPER     reduce using rule 61 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements maybe_newline revive unli_newline RBRACE function_statements_tail .)


state 312

    (63) function_statements_tail -> function_statements .

    NEWLINE         reduce using rule 63 (function_statements_tail -> function_statements .)
    MAIN_CASPER     reduce using rule 63 (function_statements_tail -> function_statements .)


state 313

    (64) function_statements_tail -> empty .
    (62) function_statements -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 62 (function_statements -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 62 (function_statements -> empty .)
    NEWLINE         reduce using rule 62 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 62 (function_statements -> empty .)

  ! NEWLINE         [ reduce using rule 64 (function_statements_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 64 (function_statements_tail -> empty .) ]


state 314

    (86) revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 342


state 315

    (87) revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 343


state 316

    (88) revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 344


state 317

    (89) revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 345


state 318

    (147) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    LBRACE          shift and go to state 346


state 319

    (184) assign_tail -> DOT SPLICE LPAREN . start COMMA deleteCount COMMA splice_items RPAREN
    (194) start -> . INT_LIT

    INT_LIT         shift and go to state 348

    start                          shift and go to state 347

state 320

    (185) assign_tail -> DOT PUSH LPAREN . list_element RPAREN
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 349
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 321

    (172) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SWAP            reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FUNCTION_NAME   reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    IDENT           reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    DISPLAY         reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHECK           reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FOR             reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    UNTIL           reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REPEAT          reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INPUT           reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INT             reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FLT             reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    BLN             reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHR             reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    STR             reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REVIVE          reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SHIFT           reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    OTHERWISE       reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 172 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 322

    (175) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 175 (arguments -> arg_value arg_tail .)


state 323

    (176) arg_tail -> COMMA . arg_value arg_tail
    (178) arg_value -> . literal
    (179) arg_value -> . var_call
    (53) literal -> . literal1
    (54) literal -> . literal2
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    arg_value                      shift and go to state 350
    literal                        shift and go to state 287
    var_call                       shift and go to state 288
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 324

    (177) arg_tail -> empty .

    RPAREN          reduce using rule 177 (arg_tail -> empty .)


state 325

    (181) next_val -> COMMA value . next_val
    (181) next_val -> . COMMA value next_val
    (182) next_val -> . empty
    (219) empty -> .

    COMMA           shift and go to state 290
    NEWLINE         reduce using rule 219 (empty -> .)

    next_val                       shift and go to state 351
    empty                          shift and go to state 291

state 326

    (211) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 352


state 327

    (212) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 353


state 328

    (213) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 354


state 329

    (214) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 355


state 330

    (115) conditional_statement -> CHECK LPAREN condition RPAREN . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 356


state 331

    (116) condition -> factor factor_tail .

    RPAREN          reduce using rule 116 (condition -> factor factor_tail .)


state 332

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 357
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 333

    (164) control_variable -> INT IDENT . EQ control_var_tail

    EQ              shift and go to state 358


state 334

    (162) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 359


state 335

    (163) repeat_until -> REPEAT LBRACE statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 360


state 336

    (104) local_dec_tail2 -> COMMA IDENT local_dec_tail .

    NEWLINE         reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    SWAP            reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FUNCTION_NAME   reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    IDENT           reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    DISPLAY         reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    CHECK           reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FOR             reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    UNTIL           reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    REPEAT          reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    INPUT           reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    INT             reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FLT             reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    BLN             reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    CHR             reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    STR             reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    REVIVE          reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    RBRACE          reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    SHIFT           reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    OTHERWISE       reduce using rule 104 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)


state 337

    (111) local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 111 (local_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 338

    (216) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 361


state 339

    (112) local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 112 (local_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 340

    (113) local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INT             reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    STR             reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 113 (local_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 341

    (114) local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INT             reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    STR             reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 114 (local_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 342

    (86) revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 86 (revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 343

    (87) revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 87 (revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 344

    (88) revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 88 (revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 345

    (89) revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 89 (revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 346

    (147) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
    (148) switch_condition -> . SHIFT switch_value COLON statements switchcond_tail

    SHIFT           shift and go to state 363

    switch_condition               shift and go to state 362

state 347

    (184) assign_tail -> DOT SPLICE LPAREN start . COMMA deleteCount COMMA splice_items RPAREN

    COMMA           shift and go to state 364


state 348

    (194) start -> INT_LIT .

    COMMA           reduce using rule 194 (start -> INT_LIT .)


state 349

    (185) assign_tail -> DOT PUSH LPAREN list_element . RPAREN

    RPAREN          shift and go to state 365


state 350

    (176) arg_tail -> COMMA arg_value . arg_tail
    (176) arg_tail -> . COMMA arg_value arg_tail
    (177) arg_tail -> . empty
    (219) empty -> .

    COMMA           shift and go to state 323
    RPAREN          reduce using rule 219 (empty -> .)

    arg_tail                       shift and go to state 366
    empty                          shift and go to state 324

state 351

    (181) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 181 (next_val -> COMMA value next_val .)


state 352

    (211) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 211 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 211 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 211 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 353

    (212) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 212 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 212 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 212 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 354

    (213) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 213 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 213 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 213 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 355

    (214) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 214 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 214 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 214 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 356

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 367
    empty                          shift and go to state 17

state 357

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE

    SEMICOLON       shift and go to state 368


state 358

    (164) control_variable -> INT IDENT EQ . control_var_tail
    (165) control_var_tail -> . INT_LIT
    (166) control_var_tail -> . var_call
    (199) var_call -> . IDENT list_index

    INT_LIT         shift and go to state 370
    IDENT           shift and go to state 55

    control_var_tail               shift and go to state 369
    var_call                       shift and go to state 371

state 359

    (162) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . statements RBRACE
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 372
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 360

    (163) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 373


state 361

    (216) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 216 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 362

    (147) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition . OTHERWISE LBRACE statements RBRACE RBRACE

    OTHERWISE       shift and go to state 374


state 363

    (148) switch_condition -> SHIFT . switch_value COLON statements switchcond_tail
    (149) switch_value -> . switch_type_cast
    (150) switch_value -> . expression
    (151) switch_value -> . function_call
    (152) switch_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (153) switch_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (154) switch_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (155) switch_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (172) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (173) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (218) input_statement -> . INPUT LPAREN RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 379
    CONVERT_TO_FLT  shift and go to state 380
    CONVERT_TO_BLN  shift and go to state 381
    CONVERT_TO_STR  shift and go to state 382
    FUNCTION_NAME   shift and go to state 201
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 208
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    switch_value                   shift and go to state 375
    switch_type_cast               shift and go to state 376
    expression                     shift and go to state 377
    function_call                  shift and go to state 378
    factor                         shift and go to state 47
    input_statement                shift and go to state 202
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 364

    (184) assign_tail -> DOT SPLICE LPAREN start COMMA . deleteCount COMMA splice_items RPAREN
    (195) deleteCount -> . empty
    (196) deleteCount -> . INT_LIT
    (219) empty -> .

    INT_LIT         shift and go to state 385
    COMMA           reduce using rule 219 (empty -> .)

    deleteCount                    shift and go to state 383
    empty                          shift and go to state 384

state 365

    (185) assign_tail -> DOT PUSH LPAREN list_element RPAREN .

    NEWLINE         reduce using rule 185 (assign_tail -> DOT PUSH LPAREN list_element RPAREN .)


state 366

    (176) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 176 (arg_tail -> COMMA arg_value arg_tail .)


state 367

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 386
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 368

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN LBRACE unli_newline statements unli_newline RBRACE
    (167) update -> . var_call update_tail
    (199) var_call -> . IDENT list_index

    IDENT           shift and go to state 55

    update                         shift and go to state 387
    var_call                       shift and go to state 388

state 369

    (164) control_variable -> INT IDENT EQ control_var_tail .

    SEMICOLON       reduce using rule 164 (control_variable -> INT IDENT EQ control_var_tail .)


state 370

    (165) control_var_tail -> INT_LIT .

    SEMICOLON       reduce using rule 165 (control_var_tail -> INT_LIT .)


state 371

    (166) control_var_tail -> var_call .

    SEMICOLON       reduce using rule 166 (control_var_tail -> var_call .)


state 372

    (162) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 389


state 373

    (163) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN . expression RPAREN
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 390
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 374

    (147) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE . LBRACE statements RBRACE RBRACE

    LBRACE          shift and go to state 391


state 375

    (148) switch_condition -> SHIFT switch_value . COLON statements switchcond_tail

    COLON           shift and go to state 392


state 376

    (149) switch_value -> switch_type_cast .

    COLON           reduce using rule 149 (switch_value -> switch_type_cast .)


state 377

    (150) switch_value -> expression .

    COLON           reduce using rule 150 (switch_value -> expression .)


state 378

    (151) switch_value -> function_call .

    COLON           reduce using rule 151 (switch_value -> function_call .)


state 379

    (152) switch_type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 393


state 380

    (153) switch_type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 394


state 381

    (154) switch_type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 395


state 382

    (155) switch_type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 396


state 383

    (184) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount . COMMA splice_items RPAREN

    COMMA           shift and go to state 397


state 384

    (195) deleteCount -> empty .

    COMMA           reduce using rule 195 (deleteCount -> empty .)


state 385

    (196) deleteCount -> INT_LIT .

    COMMA           reduce using rule 196 (deleteCount -> INT_LIT .)


state 386

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 219 (empty -> .)

    maybe_newline                  shift and go to state 398
    empty                          shift and go to state 17

state 387

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN LBRACE unli_newline statements unli_newline RBRACE

    RPAREN          shift and go to state 399


state 388

    (167) update -> var_call . update_tail
    (168) update_tail -> . postfix_op
    (169) update_tail -> . compound_op value
    (170) postfix_op -> . PLUS_PLUS
    (171) postfix_op -> . MINUS_MINUS
    (189) compound_op -> . PLUS_EQ
    (190) compound_op -> . MINUS_EQ
    (191) compound_op -> . MUL_EQ
    (192) compound_op -> . DIV_EQ
    (193) compound_op -> . MOD_EQ

    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93
    PLUS_EQ         shift and go to state 242
    MINUS_EQ        shift and go to state 243
    MUL_EQ          shift and go to state 244
    DIV_EQ          shift and go to state 245
    MOD_EQ          shift and go to state 246

    update_tail                    shift and go to state 400
    postfix_op                     shift and go to state 401
    compound_op                    shift and go to state 402

state 389

    (162) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 162 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .)


state 390

    (163) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 403


state 391

    (147) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE . statements RBRACE RBRACE
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 404
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 392

    (148) switch_condition -> SHIFT switch_value COLON . statements switchcond_tail
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SHIFT           reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 405
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 393

    (152) switch_type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 406
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 394

    (153) switch_type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 407
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 395

    (154) switch_type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 408
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 396

    (155) switch_type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (215) typecast_value -> . expression
    (216) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (217) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (218) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 306
    INPUT           shift and go to state 208
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 409
    expression                     shift and go to state 305
    input_statement                shift and go to state 307
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 397

    (184) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA . splice_items RPAREN
    (197) splice_items -> . empty
    (198) splice_items -> . list_element
    (219) empty -> .
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    RPAREN          reduce using rule 219 (empty -> .)
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    splice_items                   shift and go to state 410
    empty                          shift and go to state 411
    list_element                   shift and go to state 412
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 398

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RBRACE          shift and go to state 413


state 399

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . LBRACE unli_newline statements unli_newline RBRACE

    LBRACE          shift and go to state 414


state 400

    (167) update -> var_call update_tail .

    RPAREN          reduce using rule 167 (update -> var_call update_tail .)


state 401

    (168) update_tail -> postfix_op .

    RPAREN          reduce using rule 168 (update_tail -> postfix_op .)


state 402

    (169) update_tail -> compound_op . value
    (208) value -> . type_cast
    (209) value -> . expression
    (210) value -> . function_call
    (211) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (212) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (213) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (214) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (172) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (173) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (218) input_statement -> . INPUT LPAREN RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 252
    CONVERT_TO_FLT  shift and go to state 253
    CONVERT_TO_BLN  shift and go to state 254
    CONVERT_TO_STR  shift and go to state 255
    FUNCTION_NAME   shift and go to state 201
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 208
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 415
    type_cast                      shift and go to state 249
    expression                     shift and go to state 250
    function_call                  shift and go to state 251
    factor                         shift and go to state 47
    input_statement                shift and go to state 202
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 403

    (163) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 163 (repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .)


state 404

    (147) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements . RBRACE RBRACE

    RBRACE          shift and go to state 416


state 405

    (148) switch_condition -> SHIFT switch_value COLON statements . switchcond_tail
    (156) switchcond_tail -> . switch_condition
    (157) switchcond_tail -> . empty
    (148) switch_condition -> . SHIFT switch_value COLON statements switchcond_tail
    (219) empty -> .

    SHIFT           shift and go to state 363
    OTHERWISE       reduce using rule 219 (empty -> .)

    switchcond_tail                shift and go to state 417
    switch_condition               shift and go to state 418
    empty                          shift and go to state 419

state 406

    (152) switch_type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 420


state 407

    (153) switch_type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 421


state 408

    (154) switch_type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 422


state 409

    (155) switch_type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 423


state 410

    (184) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items . RPAREN

    RPAREN          shift and go to state 424


state 411

    (197) splice_items -> empty .

    RPAREN          reduce using rule 197 (splice_items -> empty .)


state 412

    (198) splice_items -> list_element .

    RPAREN          reduce using rule 198 (splice_items -> list_element .)


state 413

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    OTHERWISE_CHECK reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 425
    empty                          shift and go to state 17

state 414

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE . unli_newline statements unli_newline RBRACE
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 426

state 415

    (169) update_tail -> compound_op value .

    RPAREN          reduce using rule 169 (update_tail -> compound_op value .)


state 416

    (147) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE . RBRACE

    RBRACE          shift and go to state 427


state 417

    (148) switch_condition -> SHIFT switch_value COLON statements switchcond_tail .

    OTHERWISE       reduce using rule 148 (switch_condition -> SHIFT switch_value COLON statements switchcond_tail .)


state 418

    (156) switchcond_tail -> switch_condition .

    OTHERWISE       reduce using rule 156 (switchcond_tail -> switch_condition .)


state 419

    (157) switchcond_tail -> empty .

    OTHERWISE       reduce using rule 157 (switchcond_tail -> empty .)


state 420

    (152) switch_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COLON           reduce using rule 152 (switch_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 421

    (153) switch_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COLON           reduce using rule 153 (switch_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 422

    (154) switch_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COLON           reduce using rule 154 (switch_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 423

    (155) switch_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COLON           reduce using rule 155 (switch_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 424

    (184) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN .

    NEWLINE         reduce using rule 184 (assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN .)


state 425

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (145) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (146) conditional_tail -> . empty
    (219) empty -> .

    OTHERWISE_CHECK shift and go to state 429
    NEWLINE         reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

    conditional_tail               shift and go to state 428
    empty                          shift and go to state 430

state 426

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline . statements unli_newline RBRACE
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 431
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 427

    (147) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE .

    NEWLINE         reduce using rule 147 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE .)


state 428

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

    NEWLINE         shift and go to state 18
    OTHERWISE       reduce using rule 219 (empty -> .)

    maybe_newline                  shift and go to state 432
    empty                          shift and go to state 17

state 429

    (145) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail

    LPAREN          shift and go to state 433


state 430

    (146) conditional_tail -> empty .

    NEWLINE         reduce using rule 146 (conditional_tail -> empty .)
    OTHERWISE       reduce using rule 146 (conditional_tail -> empty .)


state 431

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements . unli_newline RBRACE
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 434

state 432

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    OTHERWISE       shift and go to state 435


state 433

    (145) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN LBRACE statements RBRACE conditional_tail
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (199) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 436
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 434

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline . RBRACE

    RBRACE          shift and go to state 437


state 435

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

    NEWLINE         shift and go to state 18
    LBRACE          reduce using rule 219 (empty -> .)

    maybe_newline                  shift and go to state 438
    empty                          shift and go to state 17

state 436

    (145) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN LBRACE statements RBRACE conditional_tail

    RPAREN          shift and go to state 439


state 437

    (161) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE .

    NEWLINE         reduce using rule 161 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE unli_newline statements unli_newline RBRACE .)


state 438

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 440


state 439

    (145) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . LBRACE statements RBRACE conditional_tail

    LBRACE          shift and go to state 441


state 440

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 219 (empty -> .)
    FLT             reduce using rule 219 (empty -> .)
    BLN             reduce using rule 219 (empty -> .)
    CHR             reduce using rule 219 (empty -> .)
    STR             reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)

  ! NEWLINE         [ reduce using rule 219 (empty -> .) ]

    maybe_newline                  shift and go to state 442
    empty                          shift and go to state 17

state 441

    (145) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE . statements RBRACE conditional_tail
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 219 (empty -> .)
    NEWLINE         reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 443
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 442

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (90) statements -> . empty
    (91) statements -> . local_dec maybe_newline statements_tail
    (219) empty -> .
    (99) local_dec -> . var_statement local_dec_tail
    (100) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 219 (empty -> .)
    RBRACE          reduce using rule 219 (empty -> .)
    SWAP            reduce using rule 219 (empty -> .)
    FUNCTION_NAME   reduce using rule 219 (empty -> .)
    IDENT           reduce using rule 219 (empty -> .)
    DISPLAY         reduce using rule 219 (empty -> .)
    CHECK           reduce using rule 219 (empty -> .)
    FOR             reduce using rule 219 (empty -> .)
    UNTIL           reduce using rule 219 (empty -> .)
    REPEAT          reduce using rule 219 (empty -> .)
    INPUT           reduce using rule 219 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 219 (empty -> .) ]
  ! FLT             [ reduce using rule 219 (empty -> .) ]
  ! BLN             [ reduce using rule 219 (empty -> .) ]
  ! CHR             [ reduce using rule 219 (empty -> .) ]
  ! STR             [ reduce using rule 219 (empty -> .) ]

    statements                     shift and go to state 444
    empty                          shift and go to state 172
    local_dec                      shift and go to state 173
    var_statement                  shift and go to state 174
    data_type                      shift and go to state 9

state 443

    (145) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements . RBRACE conditional_tail

    RBRACE          shift and go to state 445


state 444

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (219) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 219 (empty -> .)

    maybe_newline                  shift and go to state 446
    empty                          shift and go to state 17

state 445

    (145) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE . conditional_tail
    (145) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (146) conditional_tail -> . empty
    (219) empty -> .

    OTHERWISE_CHECK shift and go to state 429
    NEWLINE         reduce using rule 219 (empty -> .)
    OTHERWISE       reduce using rule 219 (empty -> .)

    conditional_tail               shift and go to state 447
    empty                          shift and go to state 430

state 446

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 448


state 447

    (145) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .

    NEWLINE         reduce using rule 145 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .)
    OTHERWISE       reduce using rule 145 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .)


state 448

    (115) conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 115 (conditional_statement -> CHECK LPAREN condition RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 18 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 161 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 166 resolved as shift
WARNING: shift/reduce conflict for INT in state 167 resolved as shift
WARNING: shift/reduce conflict for FLT in state 167 resolved as shift
WARNING: shift/reduce conflict for BLN in state 167 resolved as shift
WARNING: shift/reduce conflict for CHR in state 167 resolved as shift
WARNING: shift/reduce conflict for STR in state 167 resolved as shift
WARNING: shift/reduce conflict for INT in state 170 resolved as shift
WARNING: shift/reduce conflict for FLT in state 170 resolved as shift
WARNING: shift/reduce conflict for BLN in state 170 resolved as shift
WARNING: shift/reduce conflict for CHR in state 170 resolved as shift
WARNING: shift/reduce conflict for STR in state 170 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 171 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 173 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 178 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 178 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 178 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 178 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 178 resolved as shift
WARNING: shift/reduce conflict for FOR in state 178 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 178 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 178 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 178 resolved as shift
WARNING: shift/reduce conflict for INT in state 178 resolved as shift
WARNING: shift/reduce conflict for FLT in state 178 resolved as shift
WARNING: shift/reduce conflict for BLN in state 178 resolved as shift
WARNING: shift/reduce conflict for CHR in state 178 resolved as shift
WARNING: shift/reduce conflict for STR in state 178 resolved as shift
WARNING: shift/reduce conflict for INT in state 230 resolved as shift
WARNING: shift/reduce conflict for FLT in state 230 resolved as shift
WARNING: shift/reduce conflict for BLN in state 230 resolved as shift
WARNING: shift/reduce conflict for CHR in state 230 resolved as shift
WARNING: shift/reduce conflict for STR in state 230 resolved as shift
WARNING: shift/reduce conflict for INT in state 231 resolved as shift
WARNING: shift/reduce conflict for FLT in state 231 resolved as shift
WARNING: shift/reduce conflict for BLN in state 231 resolved as shift
WARNING: shift/reduce conflict for CHR in state 231 resolved as shift
WARNING: shift/reduce conflict for STR in state 231 resolved as shift
WARNING: shift/reduce conflict for INT in state 232 resolved as shift
WARNING: shift/reduce conflict for FLT in state 232 resolved as shift
WARNING: shift/reduce conflict for BLN in state 232 resolved as shift
WARNING: shift/reduce conflict for CHR in state 232 resolved as shift
WARNING: shift/reduce conflict for STR in state 232 resolved as shift
WARNING: shift/reduce conflict for INT in state 233 resolved as shift
WARNING: shift/reduce conflict for FLT in state 233 resolved as shift
WARNING: shift/reduce conflict for BLN in state 233 resolved as shift
WARNING: shift/reduce conflict for CHR in state 233 resolved as shift
WARNING: shift/reduce conflict for STR in state 233 resolved as shift
WARNING: shift/reduce conflict for INT in state 234 resolved as shift
WARNING: shift/reduce conflict for FLT in state 234 resolved as shift
WARNING: shift/reduce conflict for BLN in state 234 resolved as shift
WARNING: shift/reduce conflict for CHR in state 234 resolved as shift
WARNING: shift/reduce conflict for STR in state 234 resolved as shift
WARNING: shift/reduce conflict for INT in state 235 resolved as shift
WARNING: shift/reduce conflict for FLT in state 235 resolved as shift
WARNING: shift/reduce conflict for BLN in state 235 resolved as shift
WARNING: shift/reduce conflict for CHR in state 235 resolved as shift
WARNING: shift/reduce conflict for STR in state 235 resolved as shift
WARNING: shift/reduce conflict for INT in state 259 resolved as shift
WARNING: shift/reduce conflict for FLT in state 259 resolved as shift
WARNING: shift/reduce conflict for BLN in state 259 resolved as shift
WARNING: shift/reduce conflict for CHR in state 259 resolved as shift
WARNING: shift/reduce conflict for STR in state 259 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 356 resolved as shift
WARNING: shift/reduce conflict for INT in state 359 resolved as shift
WARNING: shift/reduce conflict for FLT in state 359 resolved as shift
WARNING: shift/reduce conflict for BLN in state 359 resolved as shift
WARNING: shift/reduce conflict for CHR in state 359 resolved as shift
WARNING: shift/reduce conflict for STR in state 359 resolved as shift
WARNING: shift/reduce conflict for INT in state 367 resolved as shift
WARNING: shift/reduce conflict for FLT in state 367 resolved as shift
WARNING: shift/reduce conflict for BLN in state 367 resolved as shift
WARNING: shift/reduce conflict for CHR in state 367 resolved as shift
WARNING: shift/reduce conflict for STR in state 367 resolved as shift
WARNING: shift/reduce conflict for INT in state 391 resolved as shift
WARNING: shift/reduce conflict for FLT in state 391 resolved as shift
WARNING: shift/reduce conflict for BLN in state 391 resolved as shift
WARNING: shift/reduce conflict for CHR in state 391 resolved as shift
WARNING: shift/reduce conflict for STR in state 391 resolved as shift
WARNING: shift/reduce conflict for INT in state 392 resolved as shift
WARNING: shift/reduce conflict for FLT in state 392 resolved as shift
WARNING: shift/reduce conflict for BLN in state 392 resolved as shift
WARNING: shift/reduce conflict for CHR in state 392 resolved as shift
WARNING: shift/reduce conflict for STR in state 392 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 413 resolved as shift
WARNING: shift/reduce conflict for INT in state 426 resolved as shift
WARNING: shift/reduce conflict for FLT in state 426 resolved as shift
WARNING: shift/reduce conflict for BLN in state 426 resolved as shift
WARNING: shift/reduce conflict for CHR in state 426 resolved as shift
WARNING: shift/reduce conflict for STR in state 426 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 440 resolved as shift
WARNING: shift/reduce conflict for INT in state 441 resolved as shift
WARNING: shift/reduce conflict for FLT in state 441 resolved as shift
WARNING: shift/reduce conflict for BLN in state 441 resolved as shift
WARNING: shift/reduce conflict for CHR in state 441 resolved as shift
WARNING: shift/reduce conflict for STR in state 441 resolved as shift
WARNING: shift/reduce conflict for INT in state 442 resolved as shift
WARNING: shift/reduce conflict for FLT in state 442 resolved as shift
WARNING: shift/reduce conflict for BLN in state 442 resolved as shift
WARNING: shift/reduce conflict for CHR in state 442 resolved as shift
WARNING: shift/reduce conflict for STR in state 442 resolved as shift
WARNING: reduce/reduce conflict in state 172 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 172
WARNING: reduce/reduce conflict in state 313 resolved using rule (function_statements -> empty)
WARNING: rejected rule (function_statements_tail -> empty) in state 313
WARNING: Rule (function_statements_tail -> empty) is never reduced
