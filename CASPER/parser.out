Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH NEWLINE global_dec maybe_newline function_statements maybe_newline main_function maybe_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline
Rule 5     global_dec -> global_statement global_tail
Rule 6     global_dec -> empty
Rule 7     global_tail -> global_dec
Rule 8     global_tail -> empty
Rule 9     global_statement -> data_type IDENT global_statement_tail
Rule 10    global_statement_tail -> empty
Rule 11    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 12    global_statement_tail -> EQ global_dec_value global_tail2
Rule 13    global_tail2 -> empty
Rule 14    global_tail2 -> COMMA IDENT global_statement_tail
Rule 15    global_dec_value -> global_value
Rule 16    global_dec_value -> LBRACKET list_element RBRACKET
Rule 17    global_value -> factor
Rule 18    global_value -> expression
Rule 19    var_statement -> data_type IDENT var_tail
Rule 20    var_tail -> empty
Rule 21    var_tail -> EQ tail_value var_tail2
Rule 22    var_tail -> COMMA IDENT var_tail
Rule 23    var_tail2 -> empty
Rule 24    var_tail2 -> COMMA IDENT var_tail
Rule 25    tail_value -> value
Rule 26    tail_value -> LBRACKET list_element RBRACKET
Rule 27    list_element -> literal element_tail
Rule 28    element_tail -> empty
Rule 29    element_tail -> COMMA list_element
Rule 30    index -> INT_LIT
Rule 31    index -> IDENT
Rule 32    data_type -> INT
Rule 33    data_type -> FLT
Rule 34    data_type -> BLN
Rule 35    data_type -> CHR
Rule 36    data_type -> STR
Rule 37    value -> factor
Rule 38    value -> type_cast
Rule 39    value -> expression
Rule 40    value -> function_call
Rule 41    type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 42    type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 43    type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 44    type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 45    typecast_value -> IDENT
Rule 46    typecast_value -> literal
Rule 47    typecast_value -> expression
Rule 48    typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 49    typecast_value -> input_statement
Rule 50    literal -> INT_LIT
Rule 51    literal -> FLT_LIT
Rule 52    literal -> DAY
Rule 53    literal -> NIGHT
Rule 54    literal -> CHR_LIT
Rule 55    literal -> STR_LIT
Rule 56    expression -> expr_head expr_tail
Rule 57    expr_head -> term term_tail
Rule 58    term -> factor factor_tail
Rule 59    factor -> var_call
Rule 60    factor -> literal
Rule 61    factor -> TILDE literal
Rule 62    factor -> LPAREN expression RPAREN
Rule 63    factor_tail -> empty
Rule 64    factor_tail -> PLUS expression
Rule 65    factor_tail -> MINUS expression
Rule 66    factor_tail -> MULTIPLY expression
Rule 67    factor_tail -> DIVISION expression
Rule 68    factor_tail -> MODULO expression
Rule 69    factor_tail -> EXPONENT expression
Rule 70    term_tail -> empty
Rule 71    term_tail -> GT expression
Rule 72    term_tail -> LT expression
Rule 73    term_tail -> EQ_EQ expression
Rule 74    term_tail -> GT_EQ expression
Rule 75    term_tail -> LT_EQ expression
Rule 76    term_tail -> NOT_EQ expression
Rule 77    expr_tail -> empty
Rule 78    expr_tail -> AND expression
Rule 79    expr_tail -> OR expression
Rule 80    var_call -> IDENT var_call_tail
Rule 81    var_call_tail -> empty
Rule 82    var_call_tail -> LBRACKET index RBRACKET
Rule 83    function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE
Rule 84    function_statements -> empty
Rule 85    ret_type -> FUNCTION
Rule 86    ret_type -> function_dtype
Rule 87    function_dtype -> FUNCTION_INT
Rule 88    function_dtype -> FUNCTION_FLT
Rule 89    function_dtype -> FUNCTION_CHR
Rule 90    function_dtype -> FUNCTION_BLN
Rule 91    function_dtype -> FUNCTION_STR
Rule 92    function_dtype -> FUNCTION_LIST_INT
Rule 93    function_dtype -> FUNCTION_LIST_FLT
Rule 94    function_dtype -> FUNCTION_LIST_CHR
Rule 95    function_dtype -> FUNCTION_LIST_STR
Rule 96    function_dtype -> FUNCTION_LIST_BLN
Rule 97    parameters -> data_type IDENT parameters_tail
Rule 98    parameters -> empty
Rule 99    parameters_tail -> empty
Rule 100   parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 101   revive -> REVIVE value
Rule 102   revive -> empty
Rule 103   statements -> empty
Rule 104   statements -> local_dec NEWLINE statements_tail
Rule 105   statements_tail -> empty
Rule 106   statements_tail -> statements
Rule 107   statements_tail -> conditional_statement NEWLINE statements_tail
Rule 108   statements_tail -> switch_statement NEWLINE statements_tail
Rule 109   statements_tail -> loop_statement NEWLINE statements_tail
Rule 110   statements_tail -> function_call NEWLINE statements_tail
Rule 111   statements_tail -> string_operation_statement NEWLINE statements_tail
Rule 112   statements_tail -> output_statement NEWLINE statements_tail
Rule 113   local_dec -> var_statement
Rule 114   local_dec -> empty
Rule 115   conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
Rule 116   conditional_tail -> empty
Rule 117   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE
Rule 118   conditional_tail -> OTHERWISE LBRACE statements RBRACE
Rule 119   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
Rule 120   switch_condition -> SHIFT value COLON statements switchcond_tail
Rule 121   switchcond_tail -> empty
Rule 122   switchcond_tail -> switch_condition
Rule 123   loop_statement -> for_loop
Rule 124   loop_statement -> until_loop
Rule 125   loop_statement -> repeat_until
Rule 126   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
Rule 127   until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
Rule 128   repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
Rule 129   control_variable -> INT IDENT EQ INT_LIT
Rule 130   update -> var_call update_tail
Rule 131   update_tail -> postfix
Rule 132   update_tail -> assign_op value
Rule 133   postfix -> PLUS_PLUS
Rule 134   postfix -> MINUS_MINUS
Rule 135   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 136   function_call -> input_statement
Rule 137   arguments -> empty
Rule 138   arguments -> arg_value arg_tail
Rule 139   arg_tail -> empty
Rule 140   arg_tail -> COMMA arg_value arg_tail
Rule 141   arg_value -> literal
Rule 142   arg_value -> var_call
Rule 143   output_statement -> DISPLAY value next_val
Rule 144   output_statement -> DISPLAY LPAREN value next_val RPAREN
Rule 145   next_val -> empty
Rule 146   next_val -> COMMA value next_val
Rule 147   input_statement -> INPUT LPAREN RPAREN
Rule 148   string_operation_statement -> var_call string_operation_tail
Rule 149   string_operation_tail -> assign_op value
Rule 150   string_operation_tail -> PLUS string_val stringcon_tail
Rule 151   assign_op -> PLUS_EQ
Rule 152   assign_op -> MINUS_EQ
Rule 153   assign_op -> MUL_EQ
Rule 154   assign_op -> DIV_EQ
Rule 155   assign_op -> MOD_EQ
Rule 156   assign_op -> EQ
Rule 157   stringcon_tail -> empty
Rule 158   stringcon_tail -> PLUS string_val stringcon_tail
Rule 159   string_val -> var_call
Rule 160   string_val -> STR_LIT
Rule 161   empty -> <empty>

Terminals, with rules where they appear

AND                  : 78
BIRTH                : 1
BLN                  : 34
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 115
CHR                  : 35
CHR_LIT              : 54
COLON                : 120
COMMA                : 11 14 22 24 29 100 140 146
COMMENT              : 
CONVERT_TO_BLN       : 43
CONVERT_TO_FLT       : 42
CONVERT_TO_INT       : 41
CONVERT_TO_STR       : 44
DAY                  : 52
DISPLAY              : 143 144
DIVISION             : 67
DIV_EQ               : 154
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 12 21 129 156
EQ_EQ                : 73
EXPONENT             : 69
FLT                  : 33
FLT_LIT              : 51
FOR                  : 126
FUNCTION             : 85
FUNCTION_BLN         : 90
FUNCTION_CHR         : 89
FUNCTION_FLT         : 88
FUNCTION_INT         : 87
FUNCTION_LIST_BLN    : 96
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 94
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 93
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 92
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 95
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 48 83 135
FUNCTION_STR         : 91
GHOST                : 1
GT                   : 71
GT_EQ                : 74
IDENT                : 9 11 14 19 22 24 31 45 80 97 100 119 129
ILLEGAL              : 
IN                   : 
INPUT                : 147
INT                  : 32 129
INT_LIT              : 30 50 129
LBRACE               : 4 83 115 117 118 119 126 127 128
LBRACKET             : 16 26 82
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 4 41 42 43 44 48 62 83 115 117 119 126 127 128 135 144 147
LT                   : 72
LT_EQ                : 75
MAIN_CASPER          : 4
MEASURE              : 
MINUS                : 65
MINUS_EQ             : 152
MINUS_MINUS          : 134
MODULO               : 68
MOD_EQ               : 155
MULTIPLY             : 66
MUL_EQ               : 153
NEWLINE              : 1 3 104 107 108 109 110 111 112
NIGHT                : 53
NOT                  : 
NOT_EQ               : 76
OR                   : 79
OTHERWISE            : 118 119
OTHERWISE_CHECK      : 117
PLUS                 : 64 150 158
PLUS_EQ              : 151
PLUS_PLUS            : 133
POW                  : 
RBRACE               : 4 83 115 117 118 119 126 127 128
RBRACKET             : 16 26 82
REPEAT               : 128
REVIVE               : 101
RPAREN               : 4 41 42 43 44 48 62 83 115 117 119 126 127 128 135 144 147
SEMICOLON            : 126 126
SHIFT                : 120
SKIP                 : 
STOP                 : 
STR                  : 36
STR_LIT              : 55 160
SWAP                 : 119
TILDE                : 61
TYPE                 : 
UNTIL                : 127 128
error                : 

Nonterminals, with rules where they appear

arg_tail             : 138 140
arg_value            : 138 140
arguments            : 135
assign_op            : 132 149
conditional_statement : 107
conditional_tail     : 115
control_variable     : 126
data_type            : 9 19 97 100
element_tail         : 27
empty                : 2 6 8 10 13 20 23 28 63 70 77 81 84 98 99 102 103 105 114 116 121 137 139 145 157
expr_head            : 56
expr_tail            : 56
expression           : 18 39 47 62 64 65 66 67 68 69 71 72 73 74 75 76 78 79 115 117 126 127 128
factor               : 17 37 58
factor_tail          : 58
for_loop             : 123
function_call        : 40 110
function_dtype       : 86
function_statements  : 1
global_dec           : 1 7
global_dec_value     : 12
global_statement     : 5
global_statement_tail : 9 11 14
global_tail          : 5
global_tail2         : 12
global_value         : 15
index                : 82
input_statement      : 49 136
list_element         : 16 26 29
literal              : 27 46 60 61 141
local_dec            : 104
loop_statement       : 109
main_function        : 1
maybe_newline        : 1 1 1 3 4 4 4 83 83
next_val             : 143 144 146
output_statement     : 112
parameters           : 83
parameters_tail      : 97 100
postfix              : 131
program              : 0
repeat_until         : 125
ret_type             : 83
revive               : 83
statements           : 4 83 106 115 117 118 119 120 126 127 128
statements_tail      : 104 107 108 109 110 111 112
string_operation_statement : 111
string_operation_tail : 148
string_val           : 150 158
stringcon_tail       : 150 158
switch_condition     : 119 122
switch_statement     : 108
switchcond_tail      : 120
tail_value           : 21
term                 : 57
term_tail            : 57
type_cast            : 38
typecast_value       : 41 42 43 44
until_loop           : 124
update               : 126
update_tail          : 130
value                : 25 101 120 132 143 144 146 149
var_call             : 59 130 142 148 159
var_call_tail        : 80
var_statement        : 113
var_tail             : 19 22 24
var_tail2            : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH NEWLINE global_dec maybe_newline function_statements maybe_newline main_function maybe_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . NEWLINE global_dec maybe_newline function_statements maybe_newline main_function maybe_newline GHOST

    NEWLINE         shift and go to state 3


state 3

    (1) program -> BIRTH NEWLINE . global_dec maybe_newline function_statements maybe_newline main_function maybe_newline GHOST
    (5) global_dec -> . global_statement global_tail
    (6) global_dec -> . empty
    (9) global_statement -> . data_type IDENT global_statement_tail
    (161) empty -> .
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    global_dec                     shift and go to state 4
    global_statement               shift and go to state 5
    empty                          shift and go to state 6
    data_type                      shift and go to state 7

state 4

    (1) program -> BIRTH NEWLINE global_dec . maybe_newline function_statements maybe_newline main_function maybe_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 13
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)

  ! NEWLINE         [ reduce using rule 161 (empty -> .) ]

    maybe_newline                  shift and go to state 14
    empty                          shift and go to state 15

state 5

    (5) global_dec -> global_statement . global_tail
    (7) global_tail -> . global_dec
    (8) global_tail -> . empty
    (5) global_dec -> . global_statement global_tail
    (6) global_dec -> . empty
    (161) empty -> .
    (9) global_statement -> . data_type IDENT global_statement_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    global_statement               shift and go to state 5
    global_tail                    shift and go to state 16
    global_dec                     shift and go to state 17
    empty                          shift and go to state 18
    data_type                      shift and go to state 7

state 6

    (6) global_dec -> empty .

    NEWLINE         reduce using rule 6 (global_dec -> empty .)
    FUNCTION        reduce using rule 6 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 6 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 6 (global_dec -> empty .)


state 7

    (9) global_statement -> data_type . IDENT global_statement_tail

    IDENT           shift and go to state 19


state 8

    (32) data_type -> INT .

    IDENT           reduce using rule 32 (data_type -> INT .)


state 9

    (33) data_type -> FLT .

    IDENT           reduce using rule 33 (data_type -> FLT .)


state 10

    (34) data_type -> BLN .

    IDENT           reduce using rule 34 (data_type -> BLN .)


state 11

    (35) data_type -> CHR .

    IDENT           reduce using rule 35 (data_type -> CHR .)


state 12

    (36) data_type -> STR .

    IDENT           reduce using rule 36 (data_type -> STR .)


state 13

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 13
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)
    GHOST           reduce using rule 161 (empty -> .)
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)

  ! NEWLINE         [ reduce using rule 161 (empty -> .) ]

    maybe_newline                  shift and go to state 20
    empty                          shift and go to state 15

state 14

    (1) program -> BIRTH NEWLINE global_dec maybe_newline . function_statements maybe_newline main_function maybe_newline GHOST
    (83) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE
    (84) function_statements -> . empty
    (85) ret_type -> . FUNCTION
    (86) ret_type -> . function_dtype
    (161) empty -> .
    (87) function_dtype -> . FUNCTION_INT
    (88) function_dtype -> . FUNCTION_FLT
    (89) function_dtype -> . FUNCTION_CHR
    (90) function_dtype -> . FUNCTION_BLN
    (91) function_dtype -> . FUNCTION_STR
    (92) function_dtype -> . FUNCTION_LIST_INT
    (93) function_dtype -> . FUNCTION_LIST_FLT
    (94) function_dtype -> . FUNCTION_LIST_CHR
    (95) function_dtype -> . FUNCTION_LIST_STR
    (96) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 24
    NEWLINE         reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)
    FUNCTION_INT    shift and go to state 26
    FUNCTION_FLT    shift and go to state 27
    FUNCTION_CHR    shift and go to state 28
    FUNCTION_BLN    shift and go to state 29
    FUNCTION_STR    shift and go to state 30
    FUNCTION_LIST_INT shift and go to state 31
    FUNCTION_LIST_FLT shift and go to state 32
    FUNCTION_LIST_CHR shift and go to state 33
    FUNCTION_LIST_STR shift and go to state 34
    FUNCTION_LIST_BLN shift and go to state 35

    function_statements            shift and go to state 21
    ret_type                       shift and go to state 22
    empty                          shift and go to state 23
    function_dtype                 shift and go to state 25

state 15

    (2) maybe_newline -> empty .

    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    GHOST           reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)


state 16

    (5) global_dec -> global_statement global_tail .

    NEWLINE         reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION        reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_INT    reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_FLT    reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_CHR    reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_BLN    reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_STR    reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_INT reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_FLT reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_CHR reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_STR reduce using rule 5 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_BLN reduce using rule 5 (global_dec -> global_statement global_tail .)
    MAIN_CASPER     reduce using rule 5 (global_dec -> global_statement global_tail .)


state 17

    (7) global_tail -> global_dec .

    NEWLINE         reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 7 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 7 (global_tail -> global_dec .)


state 18

    (8) global_tail -> empty .
    (6) global_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_INT resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_FLT resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_CHR resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_BLN resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_STR resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_INT resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_FLT resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_CHR resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_STR resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_BLN resolved using rule 6 (global_dec -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 6 (global_dec -> empty .)
    NEWLINE         reduce using rule 6 (global_dec -> empty .)
    FUNCTION        reduce using rule 6 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 6 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 6 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 6 (global_dec -> empty .)

  ! NEWLINE         [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION        [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_INT    [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_FLT    [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_CHR    [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_BLN    [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_STR    [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_LIST_INT [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_LIST_FLT [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_LIST_CHR [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_LIST_STR [ reduce using rule 8 (global_tail -> empty .) ]
  ! FUNCTION_LIST_BLN [ reduce using rule 8 (global_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 8 (global_tail -> empty .) ]


state 19

    (9) global_statement -> data_type IDENT . global_statement_tail
    (10) global_statement_tail -> . empty
    (11) global_statement_tail -> . COMMA IDENT global_statement_tail
    (12) global_statement_tail -> . EQ global_dec_value global_tail2
    (161) empty -> .

    COMMA           shift and go to state 38
    EQ              shift and go to state 39
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)

    global_statement_tail          shift and go to state 36
    empty                          shift and go to state 37

state 20

    (3) maybe_newline -> NEWLINE maybe_newline .

    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    GHOST           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 21

    (1) program -> BIRTH NEWLINE global_dec maybe_newline function_statements . maybe_newline main_function maybe_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

    NEWLINE         shift and go to state 13
    MAIN_CASPER     reduce using rule 161 (empty -> .)

    maybe_newline                  shift and go to state 40
    empty                          shift and go to state 15

state 22

    (83) function_statements -> ret_type . FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE

    FUNCTION_NAME   shift and go to state 41


state 23

    (84) function_statements -> empty .

    NEWLINE         reduce using rule 84 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 84 (function_statements -> empty .)


state 24

    (85) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 85 (ret_type -> FUNCTION .)


state 25

    (86) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 86 (ret_type -> function_dtype .)


state 26

    (87) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 87 (function_dtype -> FUNCTION_INT .)


state 27

    (88) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 88 (function_dtype -> FUNCTION_FLT .)


state 28

    (89) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 89 (function_dtype -> FUNCTION_CHR .)


state 29

    (90) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 90 (function_dtype -> FUNCTION_BLN .)


state 30

    (91) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 91 (function_dtype -> FUNCTION_STR .)


state 31

    (92) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 92 (function_dtype -> FUNCTION_LIST_INT .)


state 32

    (93) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 93 (function_dtype -> FUNCTION_LIST_FLT .)


state 33

    (94) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 94 (function_dtype -> FUNCTION_LIST_CHR .)


state 34

    (95) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 95 (function_dtype -> FUNCTION_LIST_STR .)


state 35

    (96) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 96 (function_dtype -> FUNCTION_LIST_BLN .)


state 36

    (9) global_statement -> data_type IDENT global_statement_tail .

    INT             reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FLT             reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    BLN             reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    CHR             reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    STR             reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    NEWLINE         reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION        reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_INT    reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_FLT    reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_CHR    reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_BLN    reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_STR    reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_LIST_INT reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_LIST_STR reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)
    MAIN_CASPER     reduce using rule 9 (global_statement -> data_type IDENT global_statement_tail .)


state 37

    (10) global_statement_tail -> empty .

    INT             reduce using rule 10 (global_statement_tail -> empty .)
    FLT             reduce using rule 10 (global_statement_tail -> empty .)
    BLN             reduce using rule 10 (global_statement_tail -> empty .)
    CHR             reduce using rule 10 (global_statement_tail -> empty .)
    STR             reduce using rule 10 (global_statement_tail -> empty .)
    NEWLINE         reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION        reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_INT    reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_FLT    reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_CHR    reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_BLN    reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_STR    reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_LIST_INT reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_LIST_FLT reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_LIST_CHR reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_LIST_STR reduce using rule 10 (global_statement_tail -> empty .)
    FUNCTION_LIST_BLN reduce using rule 10 (global_statement_tail -> empty .)
    MAIN_CASPER     reduce using rule 10 (global_statement_tail -> empty .)


state 38

    (11) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 42


state 39

    (12) global_statement_tail -> EQ . global_dec_value global_tail2
    (15) global_dec_value -> . global_value
    (16) global_dec_value -> . LBRACKET list_element RBRACKET
    (17) global_value -> . factor
    (18) global_value -> . expression
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (56) expression -> . expr_head expr_tail
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail

    LBRACKET        shift and go to state 45
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    global_dec_value               shift and go to state 43
    global_value                   shift and go to state 44
    factor                         shift and go to state 46
    expression                     shift and go to state 47
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    expr_head                      shift and go to state 52
    term                           shift and go to state 60

state 40

    (1) program -> BIRTH NEWLINE global_dec maybe_newline function_statements maybe_newline . main_function maybe_newline GHOST
    (4) main_function -> . MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline

    MAIN_CASPER     shift and go to state 62

    main_function                  shift and go to state 61

state 41

    (83) function_statements -> ret_type FUNCTION_NAME . LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE

    LPAREN          shift and go to state 63


state 42

    (11) global_statement_tail -> COMMA IDENT . global_statement_tail
    (10) global_statement_tail -> . empty
    (11) global_statement_tail -> . COMMA IDENT global_statement_tail
    (12) global_statement_tail -> . EQ global_dec_value global_tail2
    (161) empty -> .

    COMMA           shift and go to state 38
    EQ              shift and go to state 39
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)

    global_statement_tail          shift and go to state 64
    empty                          shift and go to state 37

state 43

    (12) global_statement_tail -> EQ global_dec_value . global_tail2
    (13) global_tail2 -> . empty
    (14) global_tail2 -> . COMMA IDENT global_statement_tail
    (161) empty -> .

    COMMA           shift and go to state 67
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)

    global_tail2                   shift and go to state 65
    empty                          shift and go to state 66

state 44

    (15) global_dec_value -> global_value .

    COMMA           reduce using rule 15 (global_dec_value -> global_value .)
    INT             reduce using rule 15 (global_dec_value -> global_value .)
    FLT             reduce using rule 15 (global_dec_value -> global_value .)
    BLN             reduce using rule 15 (global_dec_value -> global_value .)
    CHR             reduce using rule 15 (global_dec_value -> global_value .)
    STR             reduce using rule 15 (global_dec_value -> global_value .)
    NEWLINE         reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION        reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_INT    reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_FLT    reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_CHR    reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_BLN    reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_STR    reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_LIST_INT reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_LIST_FLT reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_LIST_CHR reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_LIST_STR reduce using rule 15 (global_dec_value -> global_value .)
    FUNCTION_LIST_BLN reduce using rule 15 (global_dec_value -> global_value .)
    MAIN_CASPER     reduce using rule 15 (global_dec_value -> global_value .)


state 45

    (16) global_dec_value -> LBRACKET . list_element RBRACKET
    (27) list_element -> . literal element_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    list_element                   shift and go to state 68
    literal                        shift and go to state 69

state 46

    (17) global_value -> factor .
    (58) term -> factor . factor_tail
    (63) factor_tail -> . empty
    (64) factor_tail -> . PLUS expression
    (65) factor_tail -> . MINUS expression
    (66) factor_tail -> . MULTIPLY expression
    (67) factor_tail -> . DIVISION expression
    (68) factor_tail -> . MODULO expression
    (69) factor_tail -> . EXPONENT expression
    (161) empty -> .

  ! reduce/reduce conflict for COMMA resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for INT resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FLT resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for BLN resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for CHR resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for STR resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_INT resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_FLT resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_CHR resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_BLN resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_STR resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_LIST_INT resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_LIST_FLT resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_LIST_CHR resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_LIST_STR resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for FUNCTION_LIST_BLN resolved using rule 17 (global_value -> factor .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 17 (global_value -> factor .)
    COMMA           reduce using rule 17 (global_value -> factor .)
    INT             reduce using rule 17 (global_value -> factor .)
    FLT             reduce using rule 17 (global_value -> factor .)
    BLN             reduce using rule 17 (global_value -> factor .)
    CHR             reduce using rule 17 (global_value -> factor .)
    STR             reduce using rule 17 (global_value -> factor .)
    NEWLINE         reduce using rule 17 (global_value -> factor .)
    FUNCTION        reduce using rule 17 (global_value -> factor .)
    FUNCTION_INT    reduce using rule 17 (global_value -> factor .)
    FUNCTION_FLT    reduce using rule 17 (global_value -> factor .)
    FUNCTION_CHR    reduce using rule 17 (global_value -> factor .)
    FUNCTION_BLN    reduce using rule 17 (global_value -> factor .)
    FUNCTION_STR    reduce using rule 17 (global_value -> factor .)
    FUNCTION_LIST_INT reduce using rule 17 (global_value -> factor .)
    FUNCTION_LIST_FLT reduce using rule 17 (global_value -> factor .)
    FUNCTION_LIST_CHR reduce using rule 17 (global_value -> factor .)
    FUNCTION_LIST_STR reduce using rule 17 (global_value -> factor .)
    FUNCTION_LIST_BLN reduce using rule 17 (global_value -> factor .)
    MAIN_CASPER     reduce using rule 17 (global_value -> factor .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    MULTIPLY        shift and go to state 74
    DIVISION        shift and go to state 75
    MODULO          shift and go to state 76
    EXPONENT        shift and go to state 77
    GT              reduce using rule 161 (empty -> .)
    LT              reduce using rule 161 (empty -> .)
    EQ_EQ           reduce using rule 161 (empty -> .)
    GT_EQ           reduce using rule 161 (empty -> .)
    LT_EQ           reduce using rule 161 (empty -> .)
    NOT_EQ          reduce using rule 161 (empty -> .)
    AND             reduce using rule 161 (empty -> .)
    OR              reduce using rule 161 (empty -> .)

  ! COMMA           [ reduce using rule 161 (empty -> .) ]
  ! INT             [ reduce using rule 161 (empty -> .) ]
  ! FLT             [ reduce using rule 161 (empty -> .) ]
  ! BLN             [ reduce using rule 161 (empty -> .) ]
  ! CHR             [ reduce using rule 161 (empty -> .) ]
  ! STR             [ reduce using rule 161 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_INT    [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_FLT    [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_CHR    [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_BLN    [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_STR    [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_LIST_INT [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_LIST_FLT [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_LIST_CHR [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_LIST_STR [ reduce using rule 161 (empty -> .) ]
  ! FUNCTION_LIST_BLN [ reduce using rule 161 (empty -> .) ]
  ! MAIN_CASPER     [ reduce using rule 161 (empty -> .) ]

    factor_tail                    shift and go to state 70
    empty                          shift and go to state 71

state 47

    (18) global_value -> expression .

    COMMA           reduce using rule 18 (global_value -> expression .)
    INT             reduce using rule 18 (global_value -> expression .)
    FLT             reduce using rule 18 (global_value -> expression .)
    BLN             reduce using rule 18 (global_value -> expression .)
    CHR             reduce using rule 18 (global_value -> expression .)
    STR             reduce using rule 18 (global_value -> expression .)
    NEWLINE         reduce using rule 18 (global_value -> expression .)
    FUNCTION        reduce using rule 18 (global_value -> expression .)
    FUNCTION_INT    reduce using rule 18 (global_value -> expression .)
    FUNCTION_FLT    reduce using rule 18 (global_value -> expression .)
    FUNCTION_CHR    reduce using rule 18 (global_value -> expression .)
    FUNCTION_BLN    reduce using rule 18 (global_value -> expression .)
    FUNCTION_STR    reduce using rule 18 (global_value -> expression .)
    FUNCTION_LIST_INT reduce using rule 18 (global_value -> expression .)
    FUNCTION_LIST_FLT reduce using rule 18 (global_value -> expression .)
    FUNCTION_LIST_CHR reduce using rule 18 (global_value -> expression .)
    FUNCTION_LIST_STR reduce using rule 18 (global_value -> expression .)
    FUNCTION_LIST_BLN reduce using rule 18 (global_value -> expression .)
    MAIN_CASPER     reduce using rule 18 (global_value -> expression .)


state 48

    (59) factor -> var_call .

    PLUS            reduce using rule 59 (factor -> var_call .)
    MINUS           reduce using rule 59 (factor -> var_call .)
    MULTIPLY        reduce using rule 59 (factor -> var_call .)
    DIVISION        reduce using rule 59 (factor -> var_call .)
    MODULO          reduce using rule 59 (factor -> var_call .)
    EXPONENT        reduce using rule 59 (factor -> var_call .)
    COMMA           reduce using rule 59 (factor -> var_call .)
    INT             reduce using rule 59 (factor -> var_call .)
    FLT             reduce using rule 59 (factor -> var_call .)
    BLN             reduce using rule 59 (factor -> var_call .)
    CHR             reduce using rule 59 (factor -> var_call .)
    STR             reduce using rule 59 (factor -> var_call .)
    NEWLINE         reduce using rule 59 (factor -> var_call .)
    FUNCTION        reduce using rule 59 (factor -> var_call .)
    FUNCTION_INT    reduce using rule 59 (factor -> var_call .)
    FUNCTION_FLT    reduce using rule 59 (factor -> var_call .)
    FUNCTION_CHR    reduce using rule 59 (factor -> var_call .)
    FUNCTION_BLN    reduce using rule 59 (factor -> var_call .)
    FUNCTION_STR    reduce using rule 59 (factor -> var_call .)
    FUNCTION_LIST_INT reduce using rule 59 (factor -> var_call .)
    FUNCTION_LIST_FLT reduce using rule 59 (factor -> var_call .)
    FUNCTION_LIST_CHR reduce using rule 59 (factor -> var_call .)
    FUNCTION_LIST_STR reduce using rule 59 (factor -> var_call .)
    FUNCTION_LIST_BLN reduce using rule 59 (factor -> var_call .)
    MAIN_CASPER     reduce using rule 59 (factor -> var_call .)
    GT              reduce using rule 59 (factor -> var_call .)
    LT              reduce using rule 59 (factor -> var_call .)
    EQ_EQ           reduce using rule 59 (factor -> var_call .)
    GT_EQ           reduce using rule 59 (factor -> var_call .)
    LT_EQ           reduce using rule 59 (factor -> var_call .)
    NOT_EQ          reduce using rule 59 (factor -> var_call .)
    AND             reduce using rule 59 (factor -> var_call .)
    OR              reduce using rule 59 (factor -> var_call .)
    RPAREN          reduce using rule 59 (factor -> var_call .)
    RBRACE          reduce using rule 59 (factor -> var_call .)
    COLON           reduce using rule 59 (factor -> var_call .)
    SEMICOLON       reduce using rule 59 (factor -> var_call .)


state 49

    (60) factor -> literal .

    PLUS            reduce using rule 60 (factor -> literal .)
    MINUS           reduce using rule 60 (factor -> literal .)
    MULTIPLY        reduce using rule 60 (factor -> literal .)
    DIVISION        reduce using rule 60 (factor -> literal .)
    MODULO          reduce using rule 60 (factor -> literal .)
    EXPONENT        reduce using rule 60 (factor -> literal .)
    COMMA           reduce using rule 60 (factor -> literal .)
    INT             reduce using rule 60 (factor -> literal .)
    FLT             reduce using rule 60 (factor -> literal .)
    BLN             reduce using rule 60 (factor -> literal .)
    CHR             reduce using rule 60 (factor -> literal .)
    STR             reduce using rule 60 (factor -> literal .)
    NEWLINE         reduce using rule 60 (factor -> literal .)
    FUNCTION        reduce using rule 60 (factor -> literal .)
    FUNCTION_INT    reduce using rule 60 (factor -> literal .)
    FUNCTION_FLT    reduce using rule 60 (factor -> literal .)
    FUNCTION_CHR    reduce using rule 60 (factor -> literal .)
    FUNCTION_BLN    reduce using rule 60 (factor -> literal .)
    FUNCTION_STR    reduce using rule 60 (factor -> literal .)
    FUNCTION_LIST_INT reduce using rule 60 (factor -> literal .)
    FUNCTION_LIST_FLT reduce using rule 60 (factor -> literal .)
    FUNCTION_LIST_CHR reduce using rule 60 (factor -> literal .)
    FUNCTION_LIST_STR reduce using rule 60 (factor -> literal .)
    FUNCTION_LIST_BLN reduce using rule 60 (factor -> literal .)
    MAIN_CASPER     reduce using rule 60 (factor -> literal .)
    GT              reduce using rule 60 (factor -> literal .)
    LT              reduce using rule 60 (factor -> literal .)
    EQ_EQ           reduce using rule 60 (factor -> literal .)
    GT_EQ           reduce using rule 60 (factor -> literal .)
    LT_EQ           reduce using rule 60 (factor -> literal .)
    NOT_EQ          reduce using rule 60 (factor -> literal .)
    AND             reduce using rule 60 (factor -> literal .)
    OR              reduce using rule 60 (factor -> literal .)
    RPAREN          reduce using rule 60 (factor -> literal .)
    RBRACE          reduce using rule 60 (factor -> literal .)
    COLON           reduce using rule 60 (factor -> literal .)
    SEMICOLON       reduce using rule 60 (factor -> literal .)


state 50

    (61) factor -> TILDE . literal
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    literal                        shift and go to state 78

state 51

    (62) factor -> LPAREN . expression RPAREN
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 79
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 52

    (56) expression -> expr_head . expr_tail
    (77) expr_tail -> . empty
    (78) expr_tail -> . AND expression
    (79) expr_tail -> . OR expression
    (161) empty -> .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    AND             shift and go to state 83
    OR              shift and go to state 84
    GT              reduce using rule 161 (empty -> .)
    LT              reduce using rule 161 (empty -> .)
    EQ_EQ           reduce using rule 161 (empty -> .)
    GT_EQ           reduce using rule 161 (empty -> .)
    LT_EQ           reduce using rule 161 (empty -> .)
    NOT_EQ          reduce using rule 161 (empty -> .)
    COMMA           reduce using rule 161 (empty -> .)
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)
    RPAREN          reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    COLON           reduce using rule 161 (empty -> .)
    SEMICOLON       reduce using rule 161 (empty -> .)

  ! AND             [ reduce using rule 161 (empty -> .) ]
  ! OR              [ reduce using rule 161 (empty -> .) ]

    expr_tail                      shift and go to state 81
    empty                          shift and go to state 82

state 53

    (80) var_call -> IDENT . var_call_tail
    (81) var_call_tail -> . empty
    (82) var_call_tail -> . LBRACKET index RBRACKET
    (161) empty -> .

    LBRACKET        shift and go to state 87
    PLUS            reduce using rule 161 (empty -> .)
    MINUS           reduce using rule 161 (empty -> .)
    MULTIPLY        reduce using rule 161 (empty -> .)
    DIVISION        reduce using rule 161 (empty -> .)
    MODULO          reduce using rule 161 (empty -> .)
    EXPONENT        reduce using rule 161 (empty -> .)
    COMMA           reduce using rule 161 (empty -> .)
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)
    GT              reduce using rule 161 (empty -> .)
    LT              reduce using rule 161 (empty -> .)
    EQ_EQ           reduce using rule 161 (empty -> .)
    GT_EQ           reduce using rule 161 (empty -> .)
    LT_EQ           reduce using rule 161 (empty -> .)
    NOT_EQ          reduce using rule 161 (empty -> .)
    AND             reduce using rule 161 (empty -> .)
    OR              reduce using rule 161 (empty -> .)
    RPAREN          reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    COLON           reduce using rule 161 (empty -> .)
    SEMICOLON       reduce using rule 161 (empty -> .)
    PLUS_EQ         reduce using rule 161 (empty -> .)
    MINUS_EQ        reduce using rule 161 (empty -> .)
    MUL_EQ          reduce using rule 161 (empty -> .)
    DIV_EQ          reduce using rule 161 (empty -> .)
    MOD_EQ          reduce using rule 161 (empty -> .)
    EQ              reduce using rule 161 (empty -> .)
    PLUS_PLUS       reduce using rule 161 (empty -> .)
    MINUS_MINUS     reduce using rule 161 (empty -> .)

    var_call_tail                  shift and go to state 85
    empty                          shift and go to state 86

state 54

    (50) literal -> INT_LIT .

    PLUS            reduce using rule 50 (literal -> INT_LIT .)
    MINUS           reduce using rule 50 (literal -> INT_LIT .)
    MULTIPLY        reduce using rule 50 (literal -> INT_LIT .)
    DIVISION        reduce using rule 50 (literal -> INT_LIT .)
    MODULO          reduce using rule 50 (literal -> INT_LIT .)
    EXPONENT        reduce using rule 50 (literal -> INT_LIT .)
    COMMA           reduce using rule 50 (literal -> INT_LIT .)
    INT             reduce using rule 50 (literal -> INT_LIT .)
    FLT             reduce using rule 50 (literal -> INT_LIT .)
    BLN             reduce using rule 50 (literal -> INT_LIT .)
    CHR             reduce using rule 50 (literal -> INT_LIT .)
    STR             reduce using rule 50 (literal -> INT_LIT .)
    NEWLINE         reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION        reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_INT    reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_FLT    reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_CHR    reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_BLN    reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_STR    reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_LIST_INT reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_LIST_FLT reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_LIST_CHR reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_LIST_STR reduce using rule 50 (literal -> INT_LIT .)
    FUNCTION_LIST_BLN reduce using rule 50 (literal -> INT_LIT .)
    MAIN_CASPER     reduce using rule 50 (literal -> INT_LIT .)
    GT              reduce using rule 50 (literal -> INT_LIT .)
    LT              reduce using rule 50 (literal -> INT_LIT .)
    EQ_EQ           reduce using rule 50 (literal -> INT_LIT .)
    GT_EQ           reduce using rule 50 (literal -> INT_LIT .)
    LT_EQ           reduce using rule 50 (literal -> INT_LIT .)
    NOT_EQ          reduce using rule 50 (literal -> INT_LIT .)
    AND             reduce using rule 50 (literal -> INT_LIT .)
    OR              reduce using rule 50 (literal -> INT_LIT .)
    RBRACKET        reduce using rule 50 (literal -> INT_LIT .)
    RPAREN          reduce using rule 50 (literal -> INT_LIT .)
    RBRACE          reduce using rule 50 (literal -> INT_LIT .)
    COLON           reduce using rule 50 (literal -> INT_LIT .)
    SEMICOLON       reduce using rule 50 (literal -> INT_LIT .)


state 55

    (51) literal -> FLT_LIT .

    PLUS            reduce using rule 51 (literal -> FLT_LIT .)
    MINUS           reduce using rule 51 (literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 51 (literal -> FLT_LIT .)
    DIVISION        reduce using rule 51 (literal -> FLT_LIT .)
    MODULO          reduce using rule 51 (literal -> FLT_LIT .)
    EXPONENT        reduce using rule 51 (literal -> FLT_LIT .)
    COMMA           reduce using rule 51 (literal -> FLT_LIT .)
    INT             reduce using rule 51 (literal -> FLT_LIT .)
    FLT             reduce using rule 51 (literal -> FLT_LIT .)
    BLN             reduce using rule 51 (literal -> FLT_LIT .)
    CHR             reduce using rule 51 (literal -> FLT_LIT .)
    STR             reduce using rule 51 (literal -> FLT_LIT .)
    NEWLINE         reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION        reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_INT    reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_FLT    reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_CHR    reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_BLN    reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_STR    reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_LIST_INT reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_LIST_FLT reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_LIST_CHR reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_LIST_STR reduce using rule 51 (literal -> FLT_LIT .)
    FUNCTION_LIST_BLN reduce using rule 51 (literal -> FLT_LIT .)
    MAIN_CASPER     reduce using rule 51 (literal -> FLT_LIT .)
    GT              reduce using rule 51 (literal -> FLT_LIT .)
    LT              reduce using rule 51 (literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 51 (literal -> FLT_LIT .)
    GT_EQ           reduce using rule 51 (literal -> FLT_LIT .)
    LT_EQ           reduce using rule 51 (literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 51 (literal -> FLT_LIT .)
    AND             reduce using rule 51 (literal -> FLT_LIT .)
    OR              reduce using rule 51 (literal -> FLT_LIT .)
    RBRACKET        reduce using rule 51 (literal -> FLT_LIT .)
    RPAREN          reduce using rule 51 (literal -> FLT_LIT .)
    RBRACE          reduce using rule 51 (literal -> FLT_LIT .)
    COLON           reduce using rule 51 (literal -> FLT_LIT .)
    SEMICOLON       reduce using rule 51 (literal -> FLT_LIT .)


state 56

    (52) literal -> DAY .

    PLUS            reduce using rule 52 (literal -> DAY .)
    MINUS           reduce using rule 52 (literal -> DAY .)
    MULTIPLY        reduce using rule 52 (literal -> DAY .)
    DIVISION        reduce using rule 52 (literal -> DAY .)
    MODULO          reduce using rule 52 (literal -> DAY .)
    EXPONENT        reduce using rule 52 (literal -> DAY .)
    COMMA           reduce using rule 52 (literal -> DAY .)
    INT             reduce using rule 52 (literal -> DAY .)
    FLT             reduce using rule 52 (literal -> DAY .)
    BLN             reduce using rule 52 (literal -> DAY .)
    CHR             reduce using rule 52 (literal -> DAY .)
    STR             reduce using rule 52 (literal -> DAY .)
    NEWLINE         reduce using rule 52 (literal -> DAY .)
    FUNCTION        reduce using rule 52 (literal -> DAY .)
    FUNCTION_INT    reduce using rule 52 (literal -> DAY .)
    FUNCTION_FLT    reduce using rule 52 (literal -> DAY .)
    FUNCTION_CHR    reduce using rule 52 (literal -> DAY .)
    FUNCTION_BLN    reduce using rule 52 (literal -> DAY .)
    FUNCTION_STR    reduce using rule 52 (literal -> DAY .)
    FUNCTION_LIST_INT reduce using rule 52 (literal -> DAY .)
    FUNCTION_LIST_FLT reduce using rule 52 (literal -> DAY .)
    FUNCTION_LIST_CHR reduce using rule 52 (literal -> DAY .)
    FUNCTION_LIST_STR reduce using rule 52 (literal -> DAY .)
    FUNCTION_LIST_BLN reduce using rule 52 (literal -> DAY .)
    MAIN_CASPER     reduce using rule 52 (literal -> DAY .)
    GT              reduce using rule 52 (literal -> DAY .)
    LT              reduce using rule 52 (literal -> DAY .)
    EQ_EQ           reduce using rule 52 (literal -> DAY .)
    GT_EQ           reduce using rule 52 (literal -> DAY .)
    LT_EQ           reduce using rule 52 (literal -> DAY .)
    NOT_EQ          reduce using rule 52 (literal -> DAY .)
    AND             reduce using rule 52 (literal -> DAY .)
    OR              reduce using rule 52 (literal -> DAY .)
    RBRACKET        reduce using rule 52 (literal -> DAY .)
    RPAREN          reduce using rule 52 (literal -> DAY .)
    RBRACE          reduce using rule 52 (literal -> DAY .)
    COLON           reduce using rule 52 (literal -> DAY .)
    SEMICOLON       reduce using rule 52 (literal -> DAY .)


state 57

    (53) literal -> NIGHT .

    PLUS            reduce using rule 53 (literal -> NIGHT .)
    MINUS           reduce using rule 53 (literal -> NIGHT .)
    MULTIPLY        reduce using rule 53 (literal -> NIGHT .)
    DIVISION        reduce using rule 53 (literal -> NIGHT .)
    MODULO          reduce using rule 53 (literal -> NIGHT .)
    EXPONENT        reduce using rule 53 (literal -> NIGHT .)
    COMMA           reduce using rule 53 (literal -> NIGHT .)
    INT             reduce using rule 53 (literal -> NIGHT .)
    FLT             reduce using rule 53 (literal -> NIGHT .)
    BLN             reduce using rule 53 (literal -> NIGHT .)
    CHR             reduce using rule 53 (literal -> NIGHT .)
    STR             reduce using rule 53 (literal -> NIGHT .)
    NEWLINE         reduce using rule 53 (literal -> NIGHT .)
    FUNCTION        reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_INT    reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_FLT    reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_CHR    reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_BLN    reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_STR    reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_LIST_INT reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_LIST_FLT reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_LIST_CHR reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_LIST_STR reduce using rule 53 (literal -> NIGHT .)
    FUNCTION_LIST_BLN reduce using rule 53 (literal -> NIGHT .)
    MAIN_CASPER     reduce using rule 53 (literal -> NIGHT .)
    GT              reduce using rule 53 (literal -> NIGHT .)
    LT              reduce using rule 53 (literal -> NIGHT .)
    EQ_EQ           reduce using rule 53 (literal -> NIGHT .)
    GT_EQ           reduce using rule 53 (literal -> NIGHT .)
    LT_EQ           reduce using rule 53 (literal -> NIGHT .)
    NOT_EQ          reduce using rule 53 (literal -> NIGHT .)
    AND             reduce using rule 53 (literal -> NIGHT .)
    OR              reduce using rule 53 (literal -> NIGHT .)
    RBRACKET        reduce using rule 53 (literal -> NIGHT .)
    RPAREN          reduce using rule 53 (literal -> NIGHT .)
    RBRACE          reduce using rule 53 (literal -> NIGHT .)
    COLON           reduce using rule 53 (literal -> NIGHT .)
    SEMICOLON       reduce using rule 53 (literal -> NIGHT .)


state 58

    (54) literal -> CHR_LIT .

    PLUS            reduce using rule 54 (literal -> CHR_LIT .)
    MINUS           reduce using rule 54 (literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 54 (literal -> CHR_LIT .)
    DIVISION        reduce using rule 54 (literal -> CHR_LIT .)
    MODULO          reduce using rule 54 (literal -> CHR_LIT .)
    EXPONENT        reduce using rule 54 (literal -> CHR_LIT .)
    COMMA           reduce using rule 54 (literal -> CHR_LIT .)
    INT             reduce using rule 54 (literal -> CHR_LIT .)
    FLT             reduce using rule 54 (literal -> CHR_LIT .)
    BLN             reduce using rule 54 (literal -> CHR_LIT .)
    CHR             reduce using rule 54 (literal -> CHR_LIT .)
    STR             reduce using rule 54 (literal -> CHR_LIT .)
    NEWLINE         reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION        reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_INT    reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_FLT    reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_CHR    reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_BLN    reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_STR    reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_LIST_INT reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_LIST_FLT reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_LIST_CHR reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_LIST_STR reduce using rule 54 (literal -> CHR_LIT .)
    FUNCTION_LIST_BLN reduce using rule 54 (literal -> CHR_LIT .)
    MAIN_CASPER     reduce using rule 54 (literal -> CHR_LIT .)
    GT              reduce using rule 54 (literal -> CHR_LIT .)
    LT              reduce using rule 54 (literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 54 (literal -> CHR_LIT .)
    GT_EQ           reduce using rule 54 (literal -> CHR_LIT .)
    LT_EQ           reduce using rule 54 (literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 54 (literal -> CHR_LIT .)
    AND             reduce using rule 54 (literal -> CHR_LIT .)
    OR              reduce using rule 54 (literal -> CHR_LIT .)
    RBRACKET        reduce using rule 54 (literal -> CHR_LIT .)
    RPAREN          reduce using rule 54 (literal -> CHR_LIT .)
    RBRACE          reduce using rule 54 (literal -> CHR_LIT .)
    COLON           reduce using rule 54 (literal -> CHR_LIT .)
    SEMICOLON       reduce using rule 54 (literal -> CHR_LIT .)


state 59

    (55) literal -> STR_LIT .

    PLUS            reduce using rule 55 (literal -> STR_LIT .)
    MINUS           reduce using rule 55 (literal -> STR_LIT .)
    MULTIPLY        reduce using rule 55 (literal -> STR_LIT .)
    DIVISION        reduce using rule 55 (literal -> STR_LIT .)
    MODULO          reduce using rule 55 (literal -> STR_LIT .)
    EXPONENT        reduce using rule 55 (literal -> STR_LIT .)
    COMMA           reduce using rule 55 (literal -> STR_LIT .)
    INT             reduce using rule 55 (literal -> STR_LIT .)
    FLT             reduce using rule 55 (literal -> STR_LIT .)
    BLN             reduce using rule 55 (literal -> STR_LIT .)
    CHR             reduce using rule 55 (literal -> STR_LIT .)
    STR             reduce using rule 55 (literal -> STR_LIT .)
    NEWLINE         reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION        reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_INT    reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_FLT    reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_CHR    reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_BLN    reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_STR    reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_LIST_INT reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_LIST_FLT reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_LIST_CHR reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_LIST_STR reduce using rule 55 (literal -> STR_LIT .)
    FUNCTION_LIST_BLN reduce using rule 55 (literal -> STR_LIT .)
    MAIN_CASPER     reduce using rule 55 (literal -> STR_LIT .)
    GT              reduce using rule 55 (literal -> STR_LIT .)
    LT              reduce using rule 55 (literal -> STR_LIT .)
    EQ_EQ           reduce using rule 55 (literal -> STR_LIT .)
    GT_EQ           reduce using rule 55 (literal -> STR_LIT .)
    LT_EQ           reduce using rule 55 (literal -> STR_LIT .)
    NOT_EQ          reduce using rule 55 (literal -> STR_LIT .)
    AND             reduce using rule 55 (literal -> STR_LIT .)
    OR              reduce using rule 55 (literal -> STR_LIT .)
    RBRACKET        reduce using rule 55 (literal -> STR_LIT .)
    RPAREN          reduce using rule 55 (literal -> STR_LIT .)
    RBRACE          reduce using rule 55 (literal -> STR_LIT .)
    COLON           reduce using rule 55 (literal -> STR_LIT .)
    SEMICOLON       reduce using rule 55 (literal -> STR_LIT .)


state 60

    (57) expr_head -> term . term_tail
    (70) term_tail -> . empty
    (71) term_tail -> . GT expression
    (72) term_tail -> . LT expression
    (73) term_tail -> . EQ_EQ expression
    (74) term_tail -> . GT_EQ expression
    (75) term_tail -> . LT_EQ expression
    (76) term_tail -> . NOT_EQ expression
    (161) empty -> .

  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ_EQ resolved as shift
  ! shift/reduce conflict for GT_EQ resolved as shift
  ! shift/reduce conflict for LT_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
    GT              shift and go to state 90
    LT              shift and go to state 91
    EQ_EQ           shift and go to state 92
    GT_EQ           shift and go to state 93
    LT_EQ           shift and go to state 94
    NOT_EQ          shift and go to state 95
    AND             reduce using rule 161 (empty -> .)
    OR              reduce using rule 161 (empty -> .)
    COMMA           reduce using rule 161 (empty -> .)
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)
    RPAREN          reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    COLON           reduce using rule 161 (empty -> .)
    SEMICOLON       reduce using rule 161 (empty -> .)

  ! GT              [ reduce using rule 161 (empty -> .) ]
  ! LT              [ reduce using rule 161 (empty -> .) ]
  ! EQ_EQ           [ reduce using rule 161 (empty -> .) ]
  ! GT_EQ           [ reduce using rule 161 (empty -> .) ]
  ! LT_EQ           [ reduce using rule 161 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 161 (empty -> .) ]

    term_tail                      shift and go to state 88
    empty                          shift and go to state 89

state 61

    (1) program -> BIRTH NEWLINE global_dec maybe_newline function_statements maybe_newline main_function . maybe_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

    NEWLINE         shift and go to state 13
    GHOST           reduce using rule 161 (empty -> .)

    maybe_newline                  shift and go to state 96
    empty                          shift and go to state 15

state 62

    (4) main_function -> MAIN_CASPER . LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline

    LPAREN          shift and go to state 97


state 63

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN . parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE
    (97) parameters -> . data_type IDENT parameters_tail
    (98) parameters -> . empty
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR
    (161) empty -> .

    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12
    RPAREN          reduce using rule 161 (empty -> .)

    parameters                     shift and go to state 98
    data_type                      shift and go to state 99
    empty                          shift and go to state 100

state 64

    (11) global_statement_tail -> COMMA IDENT global_statement_tail .

    INT             reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FLT             reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    BLN             reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    CHR             reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    STR             reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    NEWLINE         reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION        reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_INT    reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_FLT    reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_CHR    reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_BLN    reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_STR    reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_INT reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_FLT reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_CHR reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_STR reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_BLN reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    MAIN_CASPER     reduce using rule 11 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 65

    (12) global_statement_tail -> EQ global_dec_value global_tail2 .

    INT             reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FLT             reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    BLN             reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    CHR             reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    STR             reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    NEWLINE         reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION        reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_INT    reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_FLT    reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_CHR    reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_BLN    reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_STR    reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_LIST_INT reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_LIST_FLT reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_LIST_CHR reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_LIST_STR reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    FUNCTION_LIST_BLN reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)
    MAIN_CASPER     reduce using rule 12 (global_statement_tail -> EQ global_dec_value global_tail2 .)


state 66

    (13) global_tail2 -> empty .

    INT             reduce using rule 13 (global_tail2 -> empty .)
    FLT             reduce using rule 13 (global_tail2 -> empty .)
    BLN             reduce using rule 13 (global_tail2 -> empty .)
    CHR             reduce using rule 13 (global_tail2 -> empty .)
    STR             reduce using rule 13 (global_tail2 -> empty .)
    NEWLINE         reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION        reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_INT    reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_FLT    reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_CHR    reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_BLN    reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_STR    reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_LIST_INT reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_LIST_FLT reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_LIST_CHR reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_LIST_STR reduce using rule 13 (global_tail2 -> empty .)
    FUNCTION_LIST_BLN reduce using rule 13 (global_tail2 -> empty .)
    MAIN_CASPER     reduce using rule 13 (global_tail2 -> empty .)


state 67

    (14) global_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 101


state 68

    (16) global_dec_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 102


state 69

    (27) list_element -> literal . element_tail
    (28) element_tail -> . empty
    (29) element_tail -> . COMMA list_element
    (161) empty -> .

    COMMA           shift and go to state 105
    RBRACKET        reduce using rule 161 (empty -> .)

    element_tail                   shift and go to state 103
    empty                          shift and go to state 104

state 70

    (58) term -> factor factor_tail .

    GT              reduce using rule 58 (term -> factor factor_tail .)
    LT              reduce using rule 58 (term -> factor factor_tail .)
    EQ_EQ           reduce using rule 58 (term -> factor factor_tail .)
    GT_EQ           reduce using rule 58 (term -> factor factor_tail .)
    LT_EQ           reduce using rule 58 (term -> factor factor_tail .)
    NOT_EQ          reduce using rule 58 (term -> factor factor_tail .)
    AND             reduce using rule 58 (term -> factor factor_tail .)
    OR              reduce using rule 58 (term -> factor factor_tail .)
    COMMA           reduce using rule 58 (term -> factor factor_tail .)
    INT             reduce using rule 58 (term -> factor factor_tail .)
    FLT             reduce using rule 58 (term -> factor factor_tail .)
    BLN             reduce using rule 58 (term -> factor factor_tail .)
    CHR             reduce using rule 58 (term -> factor factor_tail .)
    STR             reduce using rule 58 (term -> factor factor_tail .)
    NEWLINE         reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION        reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_INT    reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_FLT    reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_CHR    reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_BLN    reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_STR    reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 58 (term -> factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 58 (term -> factor factor_tail .)
    MAIN_CASPER     reduce using rule 58 (term -> factor factor_tail .)
    RPAREN          reduce using rule 58 (term -> factor factor_tail .)
    RBRACE          reduce using rule 58 (term -> factor factor_tail .)
    COLON           reduce using rule 58 (term -> factor factor_tail .)
    SEMICOLON       reduce using rule 58 (term -> factor factor_tail .)


state 71

    (63) factor_tail -> empty .

    GT              reduce using rule 63 (factor_tail -> empty .)
    LT              reduce using rule 63 (factor_tail -> empty .)
    EQ_EQ           reduce using rule 63 (factor_tail -> empty .)
    GT_EQ           reduce using rule 63 (factor_tail -> empty .)
    LT_EQ           reduce using rule 63 (factor_tail -> empty .)
    NOT_EQ          reduce using rule 63 (factor_tail -> empty .)
    AND             reduce using rule 63 (factor_tail -> empty .)
    OR              reduce using rule 63 (factor_tail -> empty .)
    COMMA           reduce using rule 63 (factor_tail -> empty .)
    INT             reduce using rule 63 (factor_tail -> empty .)
    FLT             reduce using rule 63 (factor_tail -> empty .)
    BLN             reduce using rule 63 (factor_tail -> empty .)
    CHR             reduce using rule 63 (factor_tail -> empty .)
    STR             reduce using rule 63 (factor_tail -> empty .)
    NEWLINE         reduce using rule 63 (factor_tail -> empty .)
    FUNCTION        reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_INT    reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_FLT    reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_CHR    reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_BLN    reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_STR    reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_LIST_INT reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_LIST_FLT reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_LIST_CHR reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_LIST_STR reduce using rule 63 (factor_tail -> empty .)
    FUNCTION_LIST_BLN reduce using rule 63 (factor_tail -> empty .)
    MAIN_CASPER     reduce using rule 63 (factor_tail -> empty .)
    RPAREN          reduce using rule 63 (factor_tail -> empty .)
    RBRACE          reduce using rule 63 (factor_tail -> empty .)
    COLON           reduce using rule 63 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 63 (factor_tail -> empty .)


state 72

    (64) factor_tail -> PLUS . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 106
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 73

    (65) factor_tail -> MINUS . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 107
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 74

    (66) factor_tail -> MULTIPLY . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 108
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 75

    (67) factor_tail -> DIVISION . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 109
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 76

    (68) factor_tail -> MODULO . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 110
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 77

    (69) factor_tail -> EXPONENT . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 111
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 78

    (61) factor -> TILDE literal .

    PLUS            reduce using rule 61 (factor -> TILDE literal .)
    MINUS           reduce using rule 61 (factor -> TILDE literal .)
    MULTIPLY        reduce using rule 61 (factor -> TILDE literal .)
    DIVISION        reduce using rule 61 (factor -> TILDE literal .)
    MODULO          reduce using rule 61 (factor -> TILDE literal .)
    EXPONENT        reduce using rule 61 (factor -> TILDE literal .)
    COMMA           reduce using rule 61 (factor -> TILDE literal .)
    INT             reduce using rule 61 (factor -> TILDE literal .)
    FLT             reduce using rule 61 (factor -> TILDE literal .)
    BLN             reduce using rule 61 (factor -> TILDE literal .)
    CHR             reduce using rule 61 (factor -> TILDE literal .)
    STR             reduce using rule 61 (factor -> TILDE literal .)
    NEWLINE         reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION        reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_INT    reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_FLT    reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_CHR    reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_BLN    reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_STR    reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_LIST_INT reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_LIST_FLT reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_LIST_CHR reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_LIST_STR reduce using rule 61 (factor -> TILDE literal .)
    FUNCTION_LIST_BLN reduce using rule 61 (factor -> TILDE literal .)
    MAIN_CASPER     reduce using rule 61 (factor -> TILDE literal .)
    GT              reduce using rule 61 (factor -> TILDE literal .)
    LT              reduce using rule 61 (factor -> TILDE literal .)
    EQ_EQ           reduce using rule 61 (factor -> TILDE literal .)
    GT_EQ           reduce using rule 61 (factor -> TILDE literal .)
    LT_EQ           reduce using rule 61 (factor -> TILDE literal .)
    NOT_EQ          reduce using rule 61 (factor -> TILDE literal .)
    AND             reduce using rule 61 (factor -> TILDE literal .)
    OR              reduce using rule 61 (factor -> TILDE literal .)
    RPAREN          reduce using rule 61 (factor -> TILDE literal .)
    RBRACE          reduce using rule 61 (factor -> TILDE literal .)
    COLON           reduce using rule 61 (factor -> TILDE literal .)
    SEMICOLON       reduce using rule 61 (factor -> TILDE literal .)


state 79

    (62) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 112


state 80

    (58) term -> factor . factor_tail
    (63) factor_tail -> . empty
    (64) factor_tail -> . PLUS expression
    (65) factor_tail -> . MINUS expression
    (66) factor_tail -> . MULTIPLY expression
    (67) factor_tail -> . DIVISION expression
    (68) factor_tail -> . MODULO expression
    (69) factor_tail -> . EXPONENT expression
    (161) empty -> .

    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    MULTIPLY        shift and go to state 74
    DIVISION        shift and go to state 75
    MODULO          shift and go to state 76
    EXPONENT        shift and go to state 77
    GT              reduce using rule 161 (empty -> .)
    LT              reduce using rule 161 (empty -> .)
    EQ_EQ           reduce using rule 161 (empty -> .)
    GT_EQ           reduce using rule 161 (empty -> .)
    LT_EQ           reduce using rule 161 (empty -> .)
    NOT_EQ          reduce using rule 161 (empty -> .)
    AND             reduce using rule 161 (empty -> .)
    OR              reduce using rule 161 (empty -> .)
    COMMA           reduce using rule 161 (empty -> .)
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)
    RPAREN          reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    COLON           reduce using rule 161 (empty -> .)
    SEMICOLON       reduce using rule 161 (empty -> .)

    factor_tail                    shift and go to state 70
    empty                          shift and go to state 71

state 81

    (56) expression -> expr_head expr_tail .

    COMMA           reduce using rule 56 (expression -> expr_head expr_tail .)
    INT             reduce using rule 56 (expression -> expr_head expr_tail .)
    FLT             reduce using rule 56 (expression -> expr_head expr_tail .)
    BLN             reduce using rule 56 (expression -> expr_head expr_tail .)
    CHR             reduce using rule 56 (expression -> expr_head expr_tail .)
    STR             reduce using rule 56 (expression -> expr_head expr_tail .)
    NEWLINE         reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION        reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_INT    reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_FLT    reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_CHR    reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_BLN    reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_STR    reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_LIST_INT reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_LIST_FLT reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_LIST_CHR reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_LIST_STR reduce using rule 56 (expression -> expr_head expr_tail .)
    FUNCTION_LIST_BLN reduce using rule 56 (expression -> expr_head expr_tail .)
    MAIN_CASPER     reduce using rule 56 (expression -> expr_head expr_tail .)
    RPAREN          reduce using rule 56 (expression -> expr_head expr_tail .)
    GT              reduce using rule 56 (expression -> expr_head expr_tail .)
    LT              reduce using rule 56 (expression -> expr_head expr_tail .)
    EQ_EQ           reduce using rule 56 (expression -> expr_head expr_tail .)
    GT_EQ           reduce using rule 56 (expression -> expr_head expr_tail .)
    LT_EQ           reduce using rule 56 (expression -> expr_head expr_tail .)
    NOT_EQ          reduce using rule 56 (expression -> expr_head expr_tail .)
    AND             reduce using rule 56 (expression -> expr_head expr_tail .)
    OR              reduce using rule 56 (expression -> expr_head expr_tail .)
    RBRACE          reduce using rule 56 (expression -> expr_head expr_tail .)
    COLON           reduce using rule 56 (expression -> expr_head expr_tail .)
    SEMICOLON       reduce using rule 56 (expression -> expr_head expr_tail .)


state 82

    (77) expr_tail -> empty .

    GT              reduce using rule 77 (expr_tail -> empty .)
    LT              reduce using rule 77 (expr_tail -> empty .)
    EQ_EQ           reduce using rule 77 (expr_tail -> empty .)
    GT_EQ           reduce using rule 77 (expr_tail -> empty .)
    LT_EQ           reduce using rule 77 (expr_tail -> empty .)
    NOT_EQ          reduce using rule 77 (expr_tail -> empty .)
    AND             reduce using rule 77 (expr_tail -> empty .)
    OR              reduce using rule 77 (expr_tail -> empty .)
    COMMA           reduce using rule 77 (expr_tail -> empty .)
    INT             reduce using rule 77 (expr_tail -> empty .)
    FLT             reduce using rule 77 (expr_tail -> empty .)
    BLN             reduce using rule 77 (expr_tail -> empty .)
    CHR             reduce using rule 77 (expr_tail -> empty .)
    STR             reduce using rule 77 (expr_tail -> empty .)
    NEWLINE         reduce using rule 77 (expr_tail -> empty .)
    FUNCTION        reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_INT    reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_FLT    reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_CHR    reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_BLN    reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_STR    reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_LIST_INT reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_LIST_FLT reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_LIST_CHR reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_LIST_STR reduce using rule 77 (expr_tail -> empty .)
    FUNCTION_LIST_BLN reduce using rule 77 (expr_tail -> empty .)
    MAIN_CASPER     reduce using rule 77 (expr_tail -> empty .)
    RPAREN          reduce using rule 77 (expr_tail -> empty .)
    RBRACE          reduce using rule 77 (expr_tail -> empty .)
    COLON           reduce using rule 77 (expr_tail -> empty .)
    SEMICOLON       reduce using rule 77 (expr_tail -> empty .)


state 83

    (78) expr_tail -> AND . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 113
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 84

    (79) expr_tail -> OR . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 114
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 85

    (80) var_call -> IDENT var_call_tail .

    PLUS            reduce using rule 80 (var_call -> IDENT var_call_tail .)
    MINUS           reduce using rule 80 (var_call -> IDENT var_call_tail .)
    MULTIPLY        reduce using rule 80 (var_call -> IDENT var_call_tail .)
    DIVISION        reduce using rule 80 (var_call -> IDENT var_call_tail .)
    MODULO          reduce using rule 80 (var_call -> IDENT var_call_tail .)
    EXPONENT        reduce using rule 80 (var_call -> IDENT var_call_tail .)
    COMMA           reduce using rule 80 (var_call -> IDENT var_call_tail .)
    INT             reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FLT             reduce using rule 80 (var_call -> IDENT var_call_tail .)
    BLN             reduce using rule 80 (var_call -> IDENT var_call_tail .)
    CHR             reduce using rule 80 (var_call -> IDENT var_call_tail .)
    STR             reduce using rule 80 (var_call -> IDENT var_call_tail .)
    NEWLINE         reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION        reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_INT    reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_FLT    reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_CHR    reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_BLN    reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_STR    reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_LIST_INT reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_LIST_FLT reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_LIST_CHR reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_LIST_STR reduce using rule 80 (var_call -> IDENT var_call_tail .)
    FUNCTION_LIST_BLN reduce using rule 80 (var_call -> IDENT var_call_tail .)
    MAIN_CASPER     reduce using rule 80 (var_call -> IDENT var_call_tail .)
    GT              reduce using rule 80 (var_call -> IDENT var_call_tail .)
    LT              reduce using rule 80 (var_call -> IDENT var_call_tail .)
    EQ_EQ           reduce using rule 80 (var_call -> IDENT var_call_tail .)
    GT_EQ           reduce using rule 80 (var_call -> IDENT var_call_tail .)
    LT_EQ           reduce using rule 80 (var_call -> IDENT var_call_tail .)
    NOT_EQ          reduce using rule 80 (var_call -> IDENT var_call_tail .)
    AND             reduce using rule 80 (var_call -> IDENT var_call_tail .)
    OR              reduce using rule 80 (var_call -> IDENT var_call_tail .)
    RPAREN          reduce using rule 80 (var_call -> IDENT var_call_tail .)
    RBRACE          reduce using rule 80 (var_call -> IDENT var_call_tail .)
    COLON           reduce using rule 80 (var_call -> IDENT var_call_tail .)
    SEMICOLON       reduce using rule 80 (var_call -> IDENT var_call_tail .)
    PLUS_EQ         reduce using rule 80 (var_call -> IDENT var_call_tail .)
    MINUS_EQ        reduce using rule 80 (var_call -> IDENT var_call_tail .)
    MUL_EQ          reduce using rule 80 (var_call -> IDENT var_call_tail .)
    DIV_EQ          reduce using rule 80 (var_call -> IDENT var_call_tail .)
    MOD_EQ          reduce using rule 80 (var_call -> IDENT var_call_tail .)
    EQ              reduce using rule 80 (var_call -> IDENT var_call_tail .)
    PLUS_PLUS       reduce using rule 80 (var_call -> IDENT var_call_tail .)
    MINUS_MINUS     reduce using rule 80 (var_call -> IDENT var_call_tail .)


state 86

    (81) var_call_tail -> empty .

    PLUS            reduce using rule 81 (var_call_tail -> empty .)
    MINUS           reduce using rule 81 (var_call_tail -> empty .)
    MULTIPLY        reduce using rule 81 (var_call_tail -> empty .)
    DIVISION        reduce using rule 81 (var_call_tail -> empty .)
    MODULO          reduce using rule 81 (var_call_tail -> empty .)
    EXPONENT        reduce using rule 81 (var_call_tail -> empty .)
    COMMA           reduce using rule 81 (var_call_tail -> empty .)
    INT             reduce using rule 81 (var_call_tail -> empty .)
    FLT             reduce using rule 81 (var_call_tail -> empty .)
    BLN             reduce using rule 81 (var_call_tail -> empty .)
    CHR             reduce using rule 81 (var_call_tail -> empty .)
    STR             reduce using rule 81 (var_call_tail -> empty .)
    NEWLINE         reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION        reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_INT    reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_FLT    reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_CHR    reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_BLN    reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_STR    reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_LIST_INT reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_LIST_FLT reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_LIST_CHR reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_LIST_STR reduce using rule 81 (var_call_tail -> empty .)
    FUNCTION_LIST_BLN reduce using rule 81 (var_call_tail -> empty .)
    MAIN_CASPER     reduce using rule 81 (var_call_tail -> empty .)
    GT              reduce using rule 81 (var_call_tail -> empty .)
    LT              reduce using rule 81 (var_call_tail -> empty .)
    EQ_EQ           reduce using rule 81 (var_call_tail -> empty .)
    GT_EQ           reduce using rule 81 (var_call_tail -> empty .)
    LT_EQ           reduce using rule 81 (var_call_tail -> empty .)
    NOT_EQ          reduce using rule 81 (var_call_tail -> empty .)
    AND             reduce using rule 81 (var_call_tail -> empty .)
    OR              reduce using rule 81 (var_call_tail -> empty .)
    RPAREN          reduce using rule 81 (var_call_tail -> empty .)
    RBRACE          reduce using rule 81 (var_call_tail -> empty .)
    COLON           reduce using rule 81 (var_call_tail -> empty .)
    SEMICOLON       reduce using rule 81 (var_call_tail -> empty .)
    PLUS_EQ         reduce using rule 81 (var_call_tail -> empty .)
    MINUS_EQ        reduce using rule 81 (var_call_tail -> empty .)
    MUL_EQ          reduce using rule 81 (var_call_tail -> empty .)
    DIV_EQ          reduce using rule 81 (var_call_tail -> empty .)
    MOD_EQ          reduce using rule 81 (var_call_tail -> empty .)
    EQ              reduce using rule 81 (var_call_tail -> empty .)
    PLUS_PLUS       reduce using rule 81 (var_call_tail -> empty .)
    MINUS_MINUS     reduce using rule 81 (var_call_tail -> empty .)


state 87

    (82) var_call_tail -> LBRACKET . index RBRACKET
    (30) index -> . INT_LIT
    (31) index -> . IDENT

    INT_LIT         shift and go to state 116
    IDENT           shift and go to state 117

    index                          shift and go to state 115

state 88

    (57) expr_head -> term term_tail .

    AND             reduce using rule 57 (expr_head -> term term_tail .)
    OR              reduce using rule 57 (expr_head -> term term_tail .)
    COMMA           reduce using rule 57 (expr_head -> term term_tail .)
    INT             reduce using rule 57 (expr_head -> term term_tail .)
    FLT             reduce using rule 57 (expr_head -> term term_tail .)
    BLN             reduce using rule 57 (expr_head -> term term_tail .)
    CHR             reduce using rule 57 (expr_head -> term term_tail .)
    STR             reduce using rule 57 (expr_head -> term term_tail .)
    NEWLINE         reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION        reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_INT    reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_FLT    reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_CHR    reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_BLN    reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_STR    reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_LIST_INT reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_LIST_FLT reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_LIST_CHR reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_LIST_STR reduce using rule 57 (expr_head -> term term_tail .)
    FUNCTION_LIST_BLN reduce using rule 57 (expr_head -> term term_tail .)
    MAIN_CASPER     reduce using rule 57 (expr_head -> term term_tail .)
    RPAREN          reduce using rule 57 (expr_head -> term term_tail .)
    GT              reduce using rule 57 (expr_head -> term term_tail .)
    LT              reduce using rule 57 (expr_head -> term term_tail .)
    EQ_EQ           reduce using rule 57 (expr_head -> term term_tail .)
    GT_EQ           reduce using rule 57 (expr_head -> term term_tail .)
    LT_EQ           reduce using rule 57 (expr_head -> term term_tail .)
    NOT_EQ          reduce using rule 57 (expr_head -> term term_tail .)
    RBRACE          reduce using rule 57 (expr_head -> term term_tail .)
    COLON           reduce using rule 57 (expr_head -> term term_tail .)
    SEMICOLON       reduce using rule 57 (expr_head -> term term_tail .)


state 89

    (70) term_tail -> empty .

    GT              reduce using rule 70 (term_tail -> empty .)
    LT              reduce using rule 70 (term_tail -> empty .)
    EQ_EQ           reduce using rule 70 (term_tail -> empty .)
    GT_EQ           reduce using rule 70 (term_tail -> empty .)
    LT_EQ           reduce using rule 70 (term_tail -> empty .)
    NOT_EQ          reduce using rule 70 (term_tail -> empty .)
    AND             reduce using rule 70 (term_tail -> empty .)
    OR              reduce using rule 70 (term_tail -> empty .)
    COMMA           reduce using rule 70 (term_tail -> empty .)
    INT             reduce using rule 70 (term_tail -> empty .)
    FLT             reduce using rule 70 (term_tail -> empty .)
    BLN             reduce using rule 70 (term_tail -> empty .)
    CHR             reduce using rule 70 (term_tail -> empty .)
    STR             reduce using rule 70 (term_tail -> empty .)
    NEWLINE         reduce using rule 70 (term_tail -> empty .)
    FUNCTION        reduce using rule 70 (term_tail -> empty .)
    FUNCTION_INT    reduce using rule 70 (term_tail -> empty .)
    FUNCTION_FLT    reduce using rule 70 (term_tail -> empty .)
    FUNCTION_CHR    reduce using rule 70 (term_tail -> empty .)
    FUNCTION_BLN    reduce using rule 70 (term_tail -> empty .)
    FUNCTION_STR    reduce using rule 70 (term_tail -> empty .)
    FUNCTION_LIST_INT reduce using rule 70 (term_tail -> empty .)
    FUNCTION_LIST_FLT reduce using rule 70 (term_tail -> empty .)
    FUNCTION_LIST_CHR reduce using rule 70 (term_tail -> empty .)
    FUNCTION_LIST_STR reduce using rule 70 (term_tail -> empty .)
    FUNCTION_LIST_BLN reduce using rule 70 (term_tail -> empty .)
    MAIN_CASPER     reduce using rule 70 (term_tail -> empty .)
    RPAREN          reduce using rule 70 (term_tail -> empty .)
    RBRACE          reduce using rule 70 (term_tail -> empty .)
    COLON           reduce using rule 70 (term_tail -> empty .)
    SEMICOLON       reduce using rule 70 (term_tail -> empty .)


state 90

    (71) term_tail -> GT . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 118
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 91

    (72) term_tail -> LT . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 119
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 92

    (73) term_tail -> EQ_EQ . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 120
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 93

    (74) term_tail -> GT_EQ . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 121
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 94

    (75) term_tail -> LT_EQ . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 122
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 95

    (76) term_tail -> NOT_EQ . expression
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 123
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 96

    (1) program -> BIRTH NEWLINE global_dec maybe_newline function_statements maybe_newline main_function maybe_newline . GHOST

    GHOST           shift and go to state 124


state 97

    (4) main_function -> MAIN_CASPER LPAREN . RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline

    RPAREN          shift and go to state 125


state 98

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN parameters . RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE

    RPAREN          shift and go to state 126


state 99

    (97) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 127


state 100

    (98) parameters -> empty .

    RPAREN          reduce using rule 98 (parameters -> empty .)


state 101

    (14) global_tail2 -> COMMA IDENT . global_statement_tail
    (10) global_statement_tail -> . empty
    (11) global_statement_tail -> . COMMA IDENT global_statement_tail
    (12) global_statement_tail -> . EQ global_dec_value global_tail2
    (161) empty -> .

    COMMA           shift and go to state 38
    EQ              shift and go to state 39
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    FUNCTION        reduce using rule 161 (empty -> .)
    FUNCTION_INT    reduce using rule 161 (empty -> .)
    FUNCTION_FLT    reduce using rule 161 (empty -> .)
    FUNCTION_CHR    reduce using rule 161 (empty -> .)
    FUNCTION_BLN    reduce using rule 161 (empty -> .)
    FUNCTION_STR    reduce using rule 161 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 161 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 161 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 161 (empty -> .)
    MAIN_CASPER     reduce using rule 161 (empty -> .)

    global_statement_tail          shift and go to state 128
    empty                          shift and go to state 37

state 102

    (16) global_dec_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    INT             reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FLT             reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    BLN             reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    CHR             reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    STR             reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION        reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_INT    reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_FLT    reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_CHR    reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_BLN    reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_STR    reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_INT reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_FLT reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_CHR reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_STR reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_BLN reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)
    MAIN_CASPER     reduce using rule 16 (global_dec_value -> LBRACKET list_element RBRACKET .)


state 103

    (27) list_element -> literal element_tail .

    RBRACKET        reduce using rule 27 (list_element -> literal element_tail .)


state 104

    (28) element_tail -> empty .

    RBRACKET        reduce using rule 28 (element_tail -> empty .)


state 105

    (29) element_tail -> COMMA . list_element
    (27) list_element -> . literal element_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    list_element                   shift and go to state 129
    literal                        shift and go to state 69

state 106

    (64) factor_tail -> PLUS expression .

    GT              reduce using rule 64 (factor_tail -> PLUS expression .)
    LT              reduce using rule 64 (factor_tail -> PLUS expression .)
    EQ_EQ           reduce using rule 64 (factor_tail -> PLUS expression .)
    GT_EQ           reduce using rule 64 (factor_tail -> PLUS expression .)
    LT_EQ           reduce using rule 64 (factor_tail -> PLUS expression .)
    NOT_EQ          reduce using rule 64 (factor_tail -> PLUS expression .)
    AND             reduce using rule 64 (factor_tail -> PLUS expression .)
    OR              reduce using rule 64 (factor_tail -> PLUS expression .)
    COMMA           reduce using rule 64 (factor_tail -> PLUS expression .)
    INT             reduce using rule 64 (factor_tail -> PLUS expression .)
    FLT             reduce using rule 64 (factor_tail -> PLUS expression .)
    BLN             reduce using rule 64 (factor_tail -> PLUS expression .)
    CHR             reduce using rule 64 (factor_tail -> PLUS expression .)
    STR             reduce using rule 64 (factor_tail -> PLUS expression .)
    NEWLINE         reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION        reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_INT    reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_FLT    reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_CHR    reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_BLN    reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_STR    reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_LIST_INT reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_LIST_FLT reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_LIST_CHR reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_LIST_STR reduce using rule 64 (factor_tail -> PLUS expression .)
    FUNCTION_LIST_BLN reduce using rule 64 (factor_tail -> PLUS expression .)
    MAIN_CASPER     reduce using rule 64 (factor_tail -> PLUS expression .)
    RPAREN          reduce using rule 64 (factor_tail -> PLUS expression .)
    RBRACE          reduce using rule 64 (factor_tail -> PLUS expression .)
    COLON           reduce using rule 64 (factor_tail -> PLUS expression .)
    SEMICOLON       reduce using rule 64 (factor_tail -> PLUS expression .)


state 107

    (65) factor_tail -> MINUS expression .

    GT              reduce using rule 65 (factor_tail -> MINUS expression .)
    LT              reduce using rule 65 (factor_tail -> MINUS expression .)
    EQ_EQ           reduce using rule 65 (factor_tail -> MINUS expression .)
    GT_EQ           reduce using rule 65 (factor_tail -> MINUS expression .)
    LT_EQ           reduce using rule 65 (factor_tail -> MINUS expression .)
    NOT_EQ          reduce using rule 65 (factor_tail -> MINUS expression .)
    AND             reduce using rule 65 (factor_tail -> MINUS expression .)
    OR              reduce using rule 65 (factor_tail -> MINUS expression .)
    COMMA           reduce using rule 65 (factor_tail -> MINUS expression .)
    INT             reduce using rule 65 (factor_tail -> MINUS expression .)
    FLT             reduce using rule 65 (factor_tail -> MINUS expression .)
    BLN             reduce using rule 65 (factor_tail -> MINUS expression .)
    CHR             reduce using rule 65 (factor_tail -> MINUS expression .)
    STR             reduce using rule 65 (factor_tail -> MINUS expression .)
    NEWLINE         reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION        reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_INT    reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_FLT    reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_CHR    reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_BLN    reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_STR    reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_LIST_INT reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_LIST_FLT reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_LIST_CHR reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_LIST_STR reduce using rule 65 (factor_tail -> MINUS expression .)
    FUNCTION_LIST_BLN reduce using rule 65 (factor_tail -> MINUS expression .)
    MAIN_CASPER     reduce using rule 65 (factor_tail -> MINUS expression .)
    RPAREN          reduce using rule 65 (factor_tail -> MINUS expression .)
    RBRACE          reduce using rule 65 (factor_tail -> MINUS expression .)
    COLON           reduce using rule 65 (factor_tail -> MINUS expression .)
    SEMICOLON       reduce using rule 65 (factor_tail -> MINUS expression .)


state 108

    (66) factor_tail -> MULTIPLY expression .

    GT              reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    LT              reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    EQ_EQ           reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    GT_EQ           reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    LT_EQ           reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    NOT_EQ          reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    AND             reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    OR              reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    COMMA           reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    INT             reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FLT             reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    BLN             reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    CHR             reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    STR             reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    NEWLINE         reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION        reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_INT    reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_FLT    reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_CHR    reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_BLN    reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_STR    reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_LIST_INT reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_LIST_FLT reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_LIST_CHR reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_LIST_STR reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    FUNCTION_LIST_BLN reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    MAIN_CASPER     reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    RPAREN          reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    RBRACE          reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    COLON           reduce using rule 66 (factor_tail -> MULTIPLY expression .)
    SEMICOLON       reduce using rule 66 (factor_tail -> MULTIPLY expression .)


state 109

    (67) factor_tail -> DIVISION expression .

    GT              reduce using rule 67 (factor_tail -> DIVISION expression .)
    LT              reduce using rule 67 (factor_tail -> DIVISION expression .)
    EQ_EQ           reduce using rule 67 (factor_tail -> DIVISION expression .)
    GT_EQ           reduce using rule 67 (factor_tail -> DIVISION expression .)
    LT_EQ           reduce using rule 67 (factor_tail -> DIVISION expression .)
    NOT_EQ          reduce using rule 67 (factor_tail -> DIVISION expression .)
    AND             reduce using rule 67 (factor_tail -> DIVISION expression .)
    OR              reduce using rule 67 (factor_tail -> DIVISION expression .)
    COMMA           reduce using rule 67 (factor_tail -> DIVISION expression .)
    INT             reduce using rule 67 (factor_tail -> DIVISION expression .)
    FLT             reduce using rule 67 (factor_tail -> DIVISION expression .)
    BLN             reduce using rule 67 (factor_tail -> DIVISION expression .)
    CHR             reduce using rule 67 (factor_tail -> DIVISION expression .)
    STR             reduce using rule 67 (factor_tail -> DIVISION expression .)
    NEWLINE         reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION        reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_INT    reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_FLT    reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_CHR    reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_BLN    reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_STR    reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_LIST_INT reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_LIST_FLT reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_LIST_CHR reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_LIST_STR reduce using rule 67 (factor_tail -> DIVISION expression .)
    FUNCTION_LIST_BLN reduce using rule 67 (factor_tail -> DIVISION expression .)
    MAIN_CASPER     reduce using rule 67 (factor_tail -> DIVISION expression .)
    RPAREN          reduce using rule 67 (factor_tail -> DIVISION expression .)
    RBRACE          reduce using rule 67 (factor_tail -> DIVISION expression .)
    COLON           reduce using rule 67 (factor_tail -> DIVISION expression .)
    SEMICOLON       reduce using rule 67 (factor_tail -> DIVISION expression .)


state 110

    (68) factor_tail -> MODULO expression .

    GT              reduce using rule 68 (factor_tail -> MODULO expression .)
    LT              reduce using rule 68 (factor_tail -> MODULO expression .)
    EQ_EQ           reduce using rule 68 (factor_tail -> MODULO expression .)
    GT_EQ           reduce using rule 68 (factor_tail -> MODULO expression .)
    LT_EQ           reduce using rule 68 (factor_tail -> MODULO expression .)
    NOT_EQ          reduce using rule 68 (factor_tail -> MODULO expression .)
    AND             reduce using rule 68 (factor_tail -> MODULO expression .)
    OR              reduce using rule 68 (factor_tail -> MODULO expression .)
    COMMA           reduce using rule 68 (factor_tail -> MODULO expression .)
    INT             reduce using rule 68 (factor_tail -> MODULO expression .)
    FLT             reduce using rule 68 (factor_tail -> MODULO expression .)
    BLN             reduce using rule 68 (factor_tail -> MODULO expression .)
    CHR             reduce using rule 68 (factor_tail -> MODULO expression .)
    STR             reduce using rule 68 (factor_tail -> MODULO expression .)
    NEWLINE         reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION        reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_INT    reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_FLT    reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_CHR    reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_BLN    reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_STR    reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_LIST_INT reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_LIST_FLT reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_LIST_CHR reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_LIST_STR reduce using rule 68 (factor_tail -> MODULO expression .)
    FUNCTION_LIST_BLN reduce using rule 68 (factor_tail -> MODULO expression .)
    MAIN_CASPER     reduce using rule 68 (factor_tail -> MODULO expression .)
    RPAREN          reduce using rule 68 (factor_tail -> MODULO expression .)
    RBRACE          reduce using rule 68 (factor_tail -> MODULO expression .)
    COLON           reduce using rule 68 (factor_tail -> MODULO expression .)
    SEMICOLON       reduce using rule 68 (factor_tail -> MODULO expression .)


state 111

    (69) factor_tail -> EXPONENT expression .

    GT              reduce using rule 69 (factor_tail -> EXPONENT expression .)
    LT              reduce using rule 69 (factor_tail -> EXPONENT expression .)
    EQ_EQ           reduce using rule 69 (factor_tail -> EXPONENT expression .)
    GT_EQ           reduce using rule 69 (factor_tail -> EXPONENT expression .)
    LT_EQ           reduce using rule 69 (factor_tail -> EXPONENT expression .)
    NOT_EQ          reduce using rule 69 (factor_tail -> EXPONENT expression .)
    AND             reduce using rule 69 (factor_tail -> EXPONENT expression .)
    OR              reduce using rule 69 (factor_tail -> EXPONENT expression .)
    COMMA           reduce using rule 69 (factor_tail -> EXPONENT expression .)
    INT             reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FLT             reduce using rule 69 (factor_tail -> EXPONENT expression .)
    BLN             reduce using rule 69 (factor_tail -> EXPONENT expression .)
    CHR             reduce using rule 69 (factor_tail -> EXPONENT expression .)
    STR             reduce using rule 69 (factor_tail -> EXPONENT expression .)
    NEWLINE         reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION        reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_INT    reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_FLT    reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_CHR    reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_BLN    reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_STR    reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_LIST_INT reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_LIST_FLT reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_LIST_CHR reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_LIST_STR reduce using rule 69 (factor_tail -> EXPONENT expression .)
    FUNCTION_LIST_BLN reduce using rule 69 (factor_tail -> EXPONENT expression .)
    MAIN_CASPER     reduce using rule 69 (factor_tail -> EXPONENT expression .)
    RPAREN          reduce using rule 69 (factor_tail -> EXPONENT expression .)
    RBRACE          reduce using rule 69 (factor_tail -> EXPONENT expression .)
    COLON           reduce using rule 69 (factor_tail -> EXPONENT expression .)
    SEMICOLON       reduce using rule 69 (factor_tail -> EXPONENT expression .)


state 112

    (62) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    INT             reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FLT             reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    BLN             reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    CHR             reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    STR             reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION        reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_INT    reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_FLT    reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_CHR    reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_BLN    reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_STR    reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_INT reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_FLT reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_CHR reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_STR reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_BLN reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    MAIN_CASPER     reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 62 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 62 (factor -> LPAREN expression RPAREN .)


state 113

    (78) expr_tail -> AND expression .

    GT              reduce using rule 78 (expr_tail -> AND expression .)
    LT              reduce using rule 78 (expr_tail -> AND expression .)
    EQ_EQ           reduce using rule 78 (expr_tail -> AND expression .)
    GT_EQ           reduce using rule 78 (expr_tail -> AND expression .)
    LT_EQ           reduce using rule 78 (expr_tail -> AND expression .)
    NOT_EQ          reduce using rule 78 (expr_tail -> AND expression .)
    AND             reduce using rule 78 (expr_tail -> AND expression .)
    OR              reduce using rule 78 (expr_tail -> AND expression .)
    COMMA           reduce using rule 78 (expr_tail -> AND expression .)
    INT             reduce using rule 78 (expr_tail -> AND expression .)
    FLT             reduce using rule 78 (expr_tail -> AND expression .)
    BLN             reduce using rule 78 (expr_tail -> AND expression .)
    CHR             reduce using rule 78 (expr_tail -> AND expression .)
    STR             reduce using rule 78 (expr_tail -> AND expression .)
    NEWLINE         reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION        reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_INT    reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_FLT    reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_CHR    reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_BLN    reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_STR    reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_LIST_INT reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_LIST_FLT reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_LIST_CHR reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_LIST_STR reduce using rule 78 (expr_tail -> AND expression .)
    FUNCTION_LIST_BLN reduce using rule 78 (expr_tail -> AND expression .)
    MAIN_CASPER     reduce using rule 78 (expr_tail -> AND expression .)
    RPAREN          reduce using rule 78 (expr_tail -> AND expression .)
    RBRACE          reduce using rule 78 (expr_tail -> AND expression .)
    COLON           reduce using rule 78 (expr_tail -> AND expression .)
    SEMICOLON       reduce using rule 78 (expr_tail -> AND expression .)


state 114

    (79) expr_tail -> OR expression .

    GT              reduce using rule 79 (expr_tail -> OR expression .)
    LT              reduce using rule 79 (expr_tail -> OR expression .)
    EQ_EQ           reduce using rule 79 (expr_tail -> OR expression .)
    GT_EQ           reduce using rule 79 (expr_tail -> OR expression .)
    LT_EQ           reduce using rule 79 (expr_tail -> OR expression .)
    NOT_EQ          reduce using rule 79 (expr_tail -> OR expression .)
    AND             reduce using rule 79 (expr_tail -> OR expression .)
    OR              reduce using rule 79 (expr_tail -> OR expression .)
    COMMA           reduce using rule 79 (expr_tail -> OR expression .)
    INT             reduce using rule 79 (expr_tail -> OR expression .)
    FLT             reduce using rule 79 (expr_tail -> OR expression .)
    BLN             reduce using rule 79 (expr_tail -> OR expression .)
    CHR             reduce using rule 79 (expr_tail -> OR expression .)
    STR             reduce using rule 79 (expr_tail -> OR expression .)
    NEWLINE         reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION        reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_INT    reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_FLT    reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_CHR    reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_BLN    reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_STR    reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_LIST_INT reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_LIST_FLT reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_LIST_CHR reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_LIST_STR reduce using rule 79 (expr_tail -> OR expression .)
    FUNCTION_LIST_BLN reduce using rule 79 (expr_tail -> OR expression .)
    MAIN_CASPER     reduce using rule 79 (expr_tail -> OR expression .)
    RPAREN          reduce using rule 79 (expr_tail -> OR expression .)
    RBRACE          reduce using rule 79 (expr_tail -> OR expression .)
    COLON           reduce using rule 79 (expr_tail -> OR expression .)
    SEMICOLON       reduce using rule 79 (expr_tail -> OR expression .)


state 115

    (82) var_call_tail -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 130


state 116

    (30) index -> INT_LIT .

    RBRACKET        reduce using rule 30 (index -> INT_LIT .)


state 117

    (31) index -> IDENT .

    RBRACKET        reduce using rule 31 (index -> IDENT .)


state 118

    (71) term_tail -> GT expression .

    GT              reduce using rule 71 (term_tail -> GT expression .)
    LT              reduce using rule 71 (term_tail -> GT expression .)
    EQ_EQ           reduce using rule 71 (term_tail -> GT expression .)
    GT_EQ           reduce using rule 71 (term_tail -> GT expression .)
    LT_EQ           reduce using rule 71 (term_tail -> GT expression .)
    NOT_EQ          reduce using rule 71 (term_tail -> GT expression .)
    AND             reduce using rule 71 (term_tail -> GT expression .)
    OR              reduce using rule 71 (term_tail -> GT expression .)
    COMMA           reduce using rule 71 (term_tail -> GT expression .)
    INT             reduce using rule 71 (term_tail -> GT expression .)
    FLT             reduce using rule 71 (term_tail -> GT expression .)
    BLN             reduce using rule 71 (term_tail -> GT expression .)
    CHR             reduce using rule 71 (term_tail -> GT expression .)
    STR             reduce using rule 71 (term_tail -> GT expression .)
    NEWLINE         reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION        reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_INT    reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_FLT    reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_CHR    reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_BLN    reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_STR    reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_LIST_INT reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_LIST_FLT reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_LIST_CHR reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_LIST_STR reduce using rule 71 (term_tail -> GT expression .)
    FUNCTION_LIST_BLN reduce using rule 71 (term_tail -> GT expression .)
    MAIN_CASPER     reduce using rule 71 (term_tail -> GT expression .)
    RPAREN          reduce using rule 71 (term_tail -> GT expression .)
    RBRACE          reduce using rule 71 (term_tail -> GT expression .)
    COLON           reduce using rule 71 (term_tail -> GT expression .)
    SEMICOLON       reduce using rule 71 (term_tail -> GT expression .)


state 119

    (72) term_tail -> LT expression .

    GT              reduce using rule 72 (term_tail -> LT expression .)
    LT              reduce using rule 72 (term_tail -> LT expression .)
    EQ_EQ           reduce using rule 72 (term_tail -> LT expression .)
    GT_EQ           reduce using rule 72 (term_tail -> LT expression .)
    LT_EQ           reduce using rule 72 (term_tail -> LT expression .)
    NOT_EQ          reduce using rule 72 (term_tail -> LT expression .)
    AND             reduce using rule 72 (term_tail -> LT expression .)
    OR              reduce using rule 72 (term_tail -> LT expression .)
    COMMA           reduce using rule 72 (term_tail -> LT expression .)
    INT             reduce using rule 72 (term_tail -> LT expression .)
    FLT             reduce using rule 72 (term_tail -> LT expression .)
    BLN             reduce using rule 72 (term_tail -> LT expression .)
    CHR             reduce using rule 72 (term_tail -> LT expression .)
    STR             reduce using rule 72 (term_tail -> LT expression .)
    NEWLINE         reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION        reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_INT    reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_FLT    reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_CHR    reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_BLN    reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_STR    reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_LIST_INT reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_LIST_FLT reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_LIST_CHR reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_LIST_STR reduce using rule 72 (term_tail -> LT expression .)
    FUNCTION_LIST_BLN reduce using rule 72 (term_tail -> LT expression .)
    MAIN_CASPER     reduce using rule 72 (term_tail -> LT expression .)
    RPAREN          reduce using rule 72 (term_tail -> LT expression .)
    RBRACE          reduce using rule 72 (term_tail -> LT expression .)
    COLON           reduce using rule 72 (term_tail -> LT expression .)
    SEMICOLON       reduce using rule 72 (term_tail -> LT expression .)


state 120

    (73) term_tail -> EQ_EQ expression .

    GT              reduce using rule 73 (term_tail -> EQ_EQ expression .)
    LT              reduce using rule 73 (term_tail -> EQ_EQ expression .)
    EQ_EQ           reduce using rule 73 (term_tail -> EQ_EQ expression .)
    GT_EQ           reduce using rule 73 (term_tail -> EQ_EQ expression .)
    LT_EQ           reduce using rule 73 (term_tail -> EQ_EQ expression .)
    NOT_EQ          reduce using rule 73 (term_tail -> EQ_EQ expression .)
    AND             reduce using rule 73 (term_tail -> EQ_EQ expression .)
    OR              reduce using rule 73 (term_tail -> EQ_EQ expression .)
    COMMA           reduce using rule 73 (term_tail -> EQ_EQ expression .)
    INT             reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FLT             reduce using rule 73 (term_tail -> EQ_EQ expression .)
    BLN             reduce using rule 73 (term_tail -> EQ_EQ expression .)
    CHR             reduce using rule 73 (term_tail -> EQ_EQ expression .)
    STR             reduce using rule 73 (term_tail -> EQ_EQ expression .)
    NEWLINE         reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION        reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_INT    reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_FLT    reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_CHR    reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_BLN    reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_STR    reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_LIST_INT reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_LIST_FLT reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_LIST_CHR reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_LIST_STR reduce using rule 73 (term_tail -> EQ_EQ expression .)
    FUNCTION_LIST_BLN reduce using rule 73 (term_tail -> EQ_EQ expression .)
    MAIN_CASPER     reduce using rule 73 (term_tail -> EQ_EQ expression .)
    RPAREN          reduce using rule 73 (term_tail -> EQ_EQ expression .)
    RBRACE          reduce using rule 73 (term_tail -> EQ_EQ expression .)
    COLON           reduce using rule 73 (term_tail -> EQ_EQ expression .)
    SEMICOLON       reduce using rule 73 (term_tail -> EQ_EQ expression .)


state 121

    (74) term_tail -> GT_EQ expression .

    GT              reduce using rule 74 (term_tail -> GT_EQ expression .)
    LT              reduce using rule 74 (term_tail -> GT_EQ expression .)
    EQ_EQ           reduce using rule 74 (term_tail -> GT_EQ expression .)
    GT_EQ           reduce using rule 74 (term_tail -> GT_EQ expression .)
    LT_EQ           reduce using rule 74 (term_tail -> GT_EQ expression .)
    NOT_EQ          reduce using rule 74 (term_tail -> GT_EQ expression .)
    AND             reduce using rule 74 (term_tail -> GT_EQ expression .)
    OR              reduce using rule 74 (term_tail -> GT_EQ expression .)
    COMMA           reduce using rule 74 (term_tail -> GT_EQ expression .)
    INT             reduce using rule 74 (term_tail -> GT_EQ expression .)
    FLT             reduce using rule 74 (term_tail -> GT_EQ expression .)
    BLN             reduce using rule 74 (term_tail -> GT_EQ expression .)
    CHR             reduce using rule 74 (term_tail -> GT_EQ expression .)
    STR             reduce using rule 74 (term_tail -> GT_EQ expression .)
    NEWLINE         reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION        reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_INT    reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_FLT    reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_CHR    reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_BLN    reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_STR    reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_LIST_INT reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_LIST_FLT reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_LIST_CHR reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_LIST_STR reduce using rule 74 (term_tail -> GT_EQ expression .)
    FUNCTION_LIST_BLN reduce using rule 74 (term_tail -> GT_EQ expression .)
    MAIN_CASPER     reduce using rule 74 (term_tail -> GT_EQ expression .)
    RPAREN          reduce using rule 74 (term_tail -> GT_EQ expression .)
    RBRACE          reduce using rule 74 (term_tail -> GT_EQ expression .)
    COLON           reduce using rule 74 (term_tail -> GT_EQ expression .)
    SEMICOLON       reduce using rule 74 (term_tail -> GT_EQ expression .)


state 122

    (75) term_tail -> LT_EQ expression .

    GT              reduce using rule 75 (term_tail -> LT_EQ expression .)
    LT              reduce using rule 75 (term_tail -> LT_EQ expression .)
    EQ_EQ           reduce using rule 75 (term_tail -> LT_EQ expression .)
    GT_EQ           reduce using rule 75 (term_tail -> LT_EQ expression .)
    LT_EQ           reduce using rule 75 (term_tail -> LT_EQ expression .)
    NOT_EQ          reduce using rule 75 (term_tail -> LT_EQ expression .)
    AND             reduce using rule 75 (term_tail -> LT_EQ expression .)
    OR              reduce using rule 75 (term_tail -> LT_EQ expression .)
    COMMA           reduce using rule 75 (term_tail -> LT_EQ expression .)
    INT             reduce using rule 75 (term_tail -> LT_EQ expression .)
    FLT             reduce using rule 75 (term_tail -> LT_EQ expression .)
    BLN             reduce using rule 75 (term_tail -> LT_EQ expression .)
    CHR             reduce using rule 75 (term_tail -> LT_EQ expression .)
    STR             reduce using rule 75 (term_tail -> LT_EQ expression .)
    NEWLINE         reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION        reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_INT    reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_FLT    reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_CHR    reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_BLN    reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_STR    reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_LIST_INT reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_LIST_FLT reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_LIST_CHR reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_LIST_STR reduce using rule 75 (term_tail -> LT_EQ expression .)
    FUNCTION_LIST_BLN reduce using rule 75 (term_tail -> LT_EQ expression .)
    MAIN_CASPER     reduce using rule 75 (term_tail -> LT_EQ expression .)
    RPAREN          reduce using rule 75 (term_tail -> LT_EQ expression .)
    RBRACE          reduce using rule 75 (term_tail -> LT_EQ expression .)
    COLON           reduce using rule 75 (term_tail -> LT_EQ expression .)
    SEMICOLON       reduce using rule 75 (term_tail -> LT_EQ expression .)


state 123

    (76) term_tail -> NOT_EQ expression .

    GT              reduce using rule 76 (term_tail -> NOT_EQ expression .)
    LT              reduce using rule 76 (term_tail -> NOT_EQ expression .)
    EQ_EQ           reduce using rule 76 (term_tail -> NOT_EQ expression .)
    GT_EQ           reduce using rule 76 (term_tail -> NOT_EQ expression .)
    LT_EQ           reduce using rule 76 (term_tail -> NOT_EQ expression .)
    NOT_EQ          reduce using rule 76 (term_tail -> NOT_EQ expression .)
    AND             reduce using rule 76 (term_tail -> NOT_EQ expression .)
    OR              reduce using rule 76 (term_tail -> NOT_EQ expression .)
    COMMA           reduce using rule 76 (term_tail -> NOT_EQ expression .)
    INT             reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FLT             reduce using rule 76 (term_tail -> NOT_EQ expression .)
    BLN             reduce using rule 76 (term_tail -> NOT_EQ expression .)
    CHR             reduce using rule 76 (term_tail -> NOT_EQ expression .)
    STR             reduce using rule 76 (term_tail -> NOT_EQ expression .)
    NEWLINE         reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION        reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_INT    reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_FLT    reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_CHR    reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_BLN    reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_STR    reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_LIST_INT reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_LIST_FLT reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_LIST_CHR reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_LIST_STR reduce using rule 76 (term_tail -> NOT_EQ expression .)
    FUNCTION_LIST_BLN reduce using rule 76 (term_tail -> NOT_EQ expression .)
    MAIN_CASPER     reduce using rule 76 (term_tail -> NOT_EQ expression .)
    RPAREN          reduce using rule 76 (term_tail -> NOT_EQ expression .)
    RBRACE          reduce using rule 76 (term_tail -> NOT_EQ expression .)
    COLON           reduce using rule 76 (term_tail -> NOT_EQ expression .)
    SEMICOLON       reduce using rule 76 (term_tail -> NOT_EQ expression .)


state 124

    (1) program -> BIRTH NEWLINE global_dec maybe_newline function_statements maybe_newline main_function maybe_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH NEWLINE global_dec maybe_newline function_statements maybe_newline main_function maybe_newline GHOST .)


state 125

    (4) main_function -> MAIN_CASPER LPAREN RPAREN . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline

    LBRACE          shift and go to state 131


state 126

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN . LBRACE maybe_newline statements revive maybe_newline RBRACE

    LBRACE          shift and go to state 132


state 127

    (97) parameters -> data_type IDENT . parameters_tail
    (99) parameters_tail -> . empty
    (100) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (161) empty -> .

    COMMA           shift and go to state 135
    RPAREN          reduce using rule 161 (empty -> .)

    parameters_tail                shift and go to state 133
    empty                          shift and go to state 134

state 128

    (14) global_tail2 -> COMMA IDENT global_statement_tail .

    INT             reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FLT             reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    BLN             reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    CHR             reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    STR             reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    NEWLINE         reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION        reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_INT    reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_FLT    reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_CHR    reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_BLN    reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_STR    reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_INT reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_FLT reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_CHR reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_STR reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_BLN reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)
    MAIN_CASPER     reduce using rule 14 (global_tail2 -> COMMA IDENT global_statement_tail .)


state 129

    (29) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 29 (element_tail -> COMMA list_element .)


state 130

    (82) var_call_tail -> LBRACKET index RBRACKET .

    PLUS            reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    INT             reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FLT             reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    BLN             reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    CHR             reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    STR             reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION        reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_INT    reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_FLT    reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_CHR    reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_BLN    reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_STR    reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_INT reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_FLT reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_CHR reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_STR reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_BLN reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    MAIN_CASPER     reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    GT              reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    LT              reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    AND             reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    OR              reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ              reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_PLUS       reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 82 (var_call_tail -> LBRACKET index RBRACKET .)


state 131

    (4) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 13
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)

  ! NEWLINE         [ reduce using rule 161 (empty -> .) ]

    maybe_newline                  shift and go to state 136
    empty                          shift and go to state 15

state 132

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE . maybe_newline statements revive maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 13
    INT             reduce using rule 161 (empty -> .)
    FLT             reduce using rule 161 (empty -> .)
    BLN             reduce using rule 161 (empty -> .)
    CHR             reduce using rule 161 (empty -> .)
    STR             reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)

  ! NEWLINE         [ reduce using rule 161 (empty -> .) ]

    maybe_newline                  shift and go to state 137
    empty                          shift and go to state 15

state 133

    (97) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 97 (parameters -> data_type IDENT parameters_tail .)


state 134

    (99) parameters_tail -> empty .

    RPAREN          reduce using rule 99 (parameters_tail -> empty .)


state 135

    (100) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    data_type                      shift and go to state 138

state 136

    (4) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 139
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 137

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline . statements revive maybe_newline RBRACE
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    REVIVE          reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 144
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 138

    (100) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 145


state 139

    (4) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

    NEWLINE         shift and go to state 13
    RBRACE          reduce using rule 161 (empty -> .)

    maybe_newline                  shift and go to state 146
    empty                          shift and go to state 15

state 140

    (103) statements -> empty .
    (114) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 103 (statements -> empty .)
    NEWLINE         reduce using rule 103 (statements -> empty .)
    RBRACE          reduce using rule 103 (statements -> empty .)
    REVIVE          reduce using rule 103 (statements -> empty .)
    SHIFT           reduce using rule 103 (statements -> empty .)
    OTHERWISE       reduce using rule 103 (statements -> empty .)

  ! NEWLINE         [ reduce using rule 114 (local_dec -> empty .) ]


state 141

    (104) statements -> local_dec . NEWLINE statements_tail

    NEWLINE         shift and go to state 147


state 142

    (113) local_dec -> var_statement .

    NEWLINE         reduce using rule 113 (local_dec -> var_statement .)


state 143

    (19) var_statement -> data_type . IDENT var_tail

    IDENT           shift and go to state 148


state 144

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements . revive maybe_newline RBRACE
    (101) revive -> . REVIVE value
    (102) revive -> . empty
    (161) empty -> .

    REVIVE          shift and go to state 150
    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)

    revive                         shift and go to state 149
    empty                          shift and go to state 151

state 145

    (100) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (99) parameters_tail -> . empty
    (100) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (161) empty -> .

    COMMA           shift and go to state 135
    RPAREN          reduce using rule 161 (empty -> .)

    parameters_tail                shift and go to state 152
    empty                          shift and go to state 134

state 146

    (4) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline

    RBRACE          shift and go to state 153


state 147

    (104) statements -> local_dec NEWLINE . statements_tail
    (105) statements_tail -> . empty
    (106) statements_tail -> . statements
    (107) statements_tail -> . conditional_statement NEWLINE statements_tail
    (108) statements_tail -> . switch_statement NEWLINE statements_tail
    (109) statements_tail -> . loop_statement NEWLINE statements_tail
    (110) statements_tail -> . function_call NEWLINE statements_tail
    (111) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (112) statements_tail -> . output_statement NEWLINE statements_tail
    (161) empty -> .
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (115) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (119) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (123) loop_statement -> . for_loop
    (124) loop_statement -> . until_loop
    (125) loop_statement -> . repeat_until
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (148) string_operation_statement -> . var_call string_operation_tail
    (143) output_statement -> . DISPLAY value next_val
    (144) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (126) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (127) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (128) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (147) input_statement -> . INPUT LPAREN RPAREN
    (80) var_call -> . IDENT var_call_tail
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)
    SHIFT           reduce using rule 161 (empty -> .)
    OTHERWISE       reduce using rule 161 (empty -> .)
    CHECK           shift and go to state 163
    SWAP            shift and go to state 164
    FUNCTION_NAME   shift and go to state 168
    DISPLAY         shift and go to state 171
    FOR             shift and go to state 172
    UNTIL           shift and go to state 173
    REPEAT          shift and go to state 174
    INPUT           shift and go to state 175
    IDENT           shift and go to state 53
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    local_dec                      shift and go to state 141
    statements_tail                shift and go to state 154
    empty                          shift and go to state 155
    statements                     shift and go to state 156
    conditional_statement          shift and go to state 157
    switch_statement               shift and go to state 158
    loop_statement                 shift and go to state 159
    function_call                  shift and go to state 160
    string_operation_statement     shift and go to state 161
    output_statement               shift and go to state 162
    for_loop                       shift and go to state 165
    until_loop                     shift and go to state 166
    repeat_until                   shift and go to state 167
    input_statement                shift and go to state 169
    var_call                       shift and go to state 170
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 148

    (19) var_statement -> data_type IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (161) empty -> .

    EQ              shift and go to state 178
    COMMA           shift and go to state 179
    NEWLINE         reduce using rule 161 (empty -> .)

    var_tail                       shift and go to state 176
    empty                          shift and go to state 177

state 149

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

    NEWLINE         shift and go to state 13
    RBRACE          reduce using rule 161 (empty -> .)

    maybe_newline                  shift and go to state 180
    empty                          shift and go to state 15

state 150

    (101) revive -> REVIVE . value
    (37) value -> . factor
    (38) value -> . type_cast
    (39) value -> . expression
    (40) value -> . function_call
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (41) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (56) expression -> . expr_head expr_tail
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (57) expr_head -> . term term_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (58) term -> . factor factor_tail

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    CONVERT_TO_INT  shift and go to state 186
    CONVERT_TO_FLT  shift and go to state 187
    CONVERT_TO_BLN  shift and go to state 188
    CONVERT_TO_STR  shift and go to state 189
    FUNCTION_NAME   shift and go to state 168
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175

    value                          shift and go to state 181
    factor                         shift and go to state 182
    type_cast                      shift and go to state 183
    expression                     shift and go to state 184
    function_call                  shift and go to state 185
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    expr_head                      shift and go to state 52
    input_statement                shift and go to state 169
    term                           shift and go to state 60

state 151

    (102) revive -> empty .

    NEWLINE         reduce using rule 102 (revive -> empty .)
    RBRACE          reduce using rule 102 (revive -> empty .)


state 152

    (100) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 100 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 153

    (4) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (161) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 13
    GHOST           reduce using rule 161 (empty -> .)

  ! NEWLINE         [ reduce using rule 161 (empty -> .) ]

    maybe_newline                  shift and go to state 190
    empty                          shift and go to state 15

state 154

    (104) statements -> local_dec NEWLINE statements_tail .

    NEWLINE         reduce using rule 104 (statements -> local_dec NEWLINE statements_tail .)
    RBRACE          reduce using rule 104 (statements -> local_dec NEWLINE statements_tail .)
    REVIVE          reduce using rule 104 (statements -> local_dec NEWLINE statements_tail .)
    SHIFT           reduce using rule 104 (statements -> local_dec NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 104 (statements -> local_dec NEWLINE statements_tail .)


state 155

    (105) statements_tail -> empty .
    (103) statements -> empty .
    (114) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 103 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 103 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 103 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 103 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 103 (statements -> empty .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 103 (statements -> empty .)
    NEWLINE         reduce using rule 103 (statements -> empty .)
    RBRACE          reduce using rule 103 (statements -> empty .)
    REVIVE          reduce using rule 103 (statements -> empty .)
    SHIFT           reduce using rule 103 (statements -> empty .)
    OTHERWISE       reduce using rule 103 (statements -> empty .)

  ! NEWLINE         [ reduce using rule 105 (statements_tail -> empty .) ]
  ! RBRACE          [ reduce using rule 105 (statements_tail -> empty .) ]
  ! REVIVE          [ reduce using rule 105 (statements_tail -> empty .) ]
  ! SHIFT           [ reduce using rule 105 (statements_tail -> empty .) ]
  ! OTHERWISE       [ reduce using rule 105 (statements_tail -> empty .) ]
  ! NEWLINE         [ reduce using rule 114 (local_dec -> empty .) ]


state 156

    (106) statements_tail -> statements .

    NEWLINE         reduce using rule 106 (statements_tail -> statements .)
    RBRACE          reduce using rule 106 (statements_tail -> statements .)
    REVIVE          reduce using rule 106 (statements_tail -> statements .)
    SHIFT           reduce using rule 106 (statements_tail -> statements .)
    OTHERWISE       reduce using rule 106 (statements_tail -> statements .)


state 157

    (107) statements_tail -> conditional_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 191


state 158

    (108) statements_tail -> switch_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 192


state 159

    (109) statements_tail -> loop_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 193


state 160

    (110) statements_tail -> function_call . NEWLINE statements_tail

    NEWLINE         shift and go to state 194


state 161

    (111) statements_tail -> string_operation_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 195


state 162

    (112) statements_tail -> output_statement . NEWLINE statements_tail

    NEWLINE         shift and go to state 196


state 163

    (115) conditional_statement -> CHECK . LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail

    LPAREN          shift and go to state 197


state 164

    (119) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE

    LPAREN          shift and go to state 198


state 165

    (123) loop_statement -> for_loop .

    NEWLINE         reduce using rule 123 (loop_statement -> for_loop .)


state 166

    (124) loop_statement -> until_loop .

    NEWLINE         reduce using rule 124 (loop_statement -> until_loop .)


state 167

    (125) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 125 (loop_statement -> repeat_until .)


state 168

    (135) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 199


state 169

    (136) function_call -> input_statement .

    NEWLINE         reduce using rule 136 (function_call -> input_statement .)
    RBRACE          reduce using rule 136 (function_call -> input_statement .)
    COMMA           reduce using rule 136 (function_call -> input_statement .)
    RPAREN          reduce using rule 136 (function_call -> input_statement .)
    COLON           reduce using rule 136 (function_call -> input_statement .)


state 170

    (148) string_operation_statement -> var_call . string_operation_tail
    (149) string_operation_tail -> . assign_op value
    (150) string_operation_tail -> . PLUS string_val stringcon_tail
    (151) assign_op -> . PLUS_EQ
    (152) assign_op -> . MINUS_EQ
    (153) assign_op -> . MUL_EQ
    (154) assign_op -> . DIV_EQ
    (155) assign_op -> . MOD_EQ
    (156) assign_op -> . EQ

    PLUS            shift and go to state 202
    PLUS_EQ         shift and go to state 203
    MINUS_EQ        shift and go to state 204
    MUL_EQ          shift and go to state 205
    DIV_EQ          shift and go to state 206
    MOD_EQ          shift and go to state 207
    EQ              shift and go to state 208

    string_operation_tail          shift and go to state 200
    assign_op                      shift and go to state 201

state 171

    (143) output_statement -> DISPLAY . value next_val
    (144) output_statement -> DISPLAY . LPAREN value next_val RPAREN
    (37) value -> . factor
    (38) value -> . type_cast
    (39) value -> . expression
    (40) value -> . function_call
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (41) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (56) expression -> . expr_head expr_tail
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (57) expr_head -> . term term_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (58) term -> . factor factor_tail

    LPAREN          shift and go to state 210
    TILDE           shift and go to state 50
    CONVERT_TO_INT  shift and go to state 186
    CONVERT_TO_FLT  shift and go to state 187
    CONVERT_TO_BLN  shift and go to state 188
    CONVERT_TO_STR  shift and go to state 189
    FUNCTION_NAME   shift and go to state 168
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175

    value                          shift and go to state 209
    factor                         shift and go to state 182
    type_cast                      shift and go to state 183
    expression                     shift and go to state 184
    function_call                  shift and go to state 185
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    expr_head                      shift and go to state 52
    input_statement                shift and go to state 169
    term                           shift and go to state 60

state 172

    (126) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 211


state 173

    (127) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 212


state 174

    (128) repeat_until -> REPEAT . LBRACE statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 213


state 175

    (147) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 214


state 176

    (19) var_statement -> data_type IDENT var_tail .

    NEWLINE         reduce using rule 19 (var_statement -> data_type IDENT var_tail .)


state 177

    (20) var_tail -> empty .

    NEWLINE         reduce using rule 20 (var_tail -> empty .)


state 178

    (21) var_tail -> EQ . tail_value var_tail2
    (25) tail_value -> . value
    (26) tail_value -> . LBRACKET list_element RBRACKET
    (37) value -> . factor
    (38) value -> . type_cast
    (39) value -> . expression
    (40) value -> . function_call
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (41) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (56) expression -> . expr_head expr_tail
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (57) expr_head -> . term term_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (58) term -> . factor factor_tail

    LBRACKET        shift and go to state 217
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    CONVERT_TO_INT  shift and go to state 186
    CONVERT_TO_FLT  shift and go to state 187
    CONVERT_TO_BLN  shift and go to state 188
    CONVERT_TO_STR  shift and go to state 189
    FUNCTION_NAME   shift and go to state 168
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175

    tail_value                     shift and go to state 215
    value                          shift and go to state 216
    factor                         shift and go to state 182
    type_cast                      shift and go to state 183
    expression                     shift and go to state 184
    function_call                  shift and go to state 185
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    expr_head                      shift and go to state 52
    input_statement                shift and go to state 169
    term                           shift and go to state 60

state 179

    (22) var_tail -> COMMA . IDENT var_tail

    IDENT           shift and go to state 218


state 180

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline . RBRACE

    RBRACE          shift and go to state 219


state 181

    (101) revive -> REVIVE value .

    NEWLINE         reduce using rule 101 (revive -> REVIVE value .)
    RBRACE          reduce using rule 101 (revive -> REVIVE value .)


state 182

    (37) value -> factor .
    (58) term -> factor . factor_tail
    (63) factor_tail -> . empty
    (64) factor_tail -> . PLUS expression
    (65) factor_tail -> . MINUS expression
    (66) factor_tail -> . MULTIPLY expression
    (67) factor_tail -> . DIVISION expression
    (68) factor_tail -> . MODULO expression
    (69) factor_tail -> . EXPONENT expression
    (161) empty -> .

  ! reduce/reduce conflict for NEWLINE resolved using rule 37 (value -> factor .)
  ! reduce/reduce conflict for RBRACE resolved using rule 37 (value -> factor .)
  ! reduce/reduce conflict for COMMA resolved using rule 37 (value -> factor .)
  ! reduce/reduce conflict for RPAREN resolved using rule 37 (value -> factor .)
  ! reduce/reduce conflict for COLON resolved using rule 37 (value -> factor .)
    NEWLINE         reduce using rule 37 (value -> factor .)
    RBRACE          reduce using rule 37 (value -> factor .)
    COMMA           reduce using rule 37 (value -> factor .)
    RPAREN          reduce using rule 37 (value -> factor .)
    COLON           reduce using rule 37 (value -> factor .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    MULTIPLY        shift and go to state 74
    DIVISION        shift and go to state 75
    MODULO          shift and go to state 76
    EXPONENT        shift and go to state 77
    GT              reduce using rule 161 (empty -> .)
    LT              reduce using rule 161 (empty -> .)
    EQ_EQ           reduce using rule 161 (empty -> .)
    GT_EQ           reduce using rule 161 (empty -> .)
    LT_EQ           reduce using rule 161 (empty -> .)
    NOT_EQ          reduce using rule 161 (empty -> .)
    AND             reduce using rule 161 (empty -> .)
    OR              reduce using rule 161 (empty -> .)

  ! NEWLINE         [ reduce using rule 161 (empty -> .) ]
  ! RBRACE          [ reduce using rule 161 (empty -> .) ]
  ! COMMA           [ reduce using rule 161 (empty -> .) ]
  ! RPAREN          [ reduce using rule 161 (empty -> .) ]
  ! COLON           [ reduce using rule 161 (empty -> .) ]

    factor_tail                    shift and go to state 70
    empty                          shift and go to state 71

state 183

    (38) value -> type_cast .

    NEWLINE         reduce using rule 38 (value -> type_cast .)
    RBRACE          reduce using rule 38 (value -> type_cast .)
    COMMA           reduce using rule 38 (value -> type_cast .)
    RPAREN          reduce using rule 38 (value -> type_cast .)
    COLON           reduce using rule 38 (value -> type_cast .)


state 184

    (39) value -> expression .

    NEWLINE         reduce using rule 39 (value -> expression .)
    RBRACE          reduce using rule 39 (value -> expression .)
    COMMA           reduce using rule 39 (value -> expression .)
    RPAREN          reduce using rule 39 (value -> expression .)
    COLON           reduce using rule 39 (value -> expression .)


state 185

    (40) value -> function_call .

    NEWLINE         reduce using rule 40 (value -> function_call .)
    RBRACE          reduce using rule 40 (value -> function_call .)
    COMMA           reduce using rule 40 (value -> function_call .)
    RPAREN          reduce using rule 40 (value -> function_call .)
    COLON           reduce using rule 40 (value -> function_call .)


state 186

    (41) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 220


state 187

    (42) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 221


state 188

    (43) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 222


state 189

    (44) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 223


state 190

    (4) main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline .

    NEWLINE         reduce using rule 4 (main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline .)
    GHOST           reduce using rule 4 (main_function -> MAIN_CASPER LPAREN RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline .)


state 191

    (107) statements_tail -> conditional_statement NEWLINE . statements_tail
    (105) statements_tail -> . empty
    (106) statements_tail -> . statements
    (107) statements_tail -> . conditional_statement NEWLINE statements_tail
    (108) statements_tail -> . switch_statement NEWLINE statements_tail
    (109) statements_tail -> . loop_statement NEWLINE statements_tail
    (110) statements_tail -> . function_call NEWLINE statements_tail
    (111) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (112) statements_tail -> . output_statement NEWLINE statements_tail
    (161) empty -> .
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (115) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (119) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (123) loop_statement -> . for_loop
    (124) loop_statement -> . until_loop
    (125) loop_statement -> . repeat_until
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (148) string_operation_statement -> . var_call string_operation_tail
    (143) output_statement -> . DISPLAY value next_val
    (144) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (126) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (127) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (128) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (147) input_statement -> . INPUT LPAREN RPAREN
    (80) var_call -> . IDENT var_call_tail
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)
    SHIFT           reduce using rule 161 (empty -> .)
    OTHERWISE       reduce using rule 161 (empty -> .)
    CHECK           shift and go to state 163
    SWAP            shift and go to state 164
    FUNCTION_NAME   shift and go to state 168
    DISPLAY         shift and go to state 171
    FOR             shift and go to state 172
    UNTIL           shift and go to state 173
    REPEAT          shift and go to state 174
    INPUT           shift and go to state 175
    IDENT           shift and go to state 53
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    conditional_statement          shift and go to state 157
    statements_tail                shift and go to state 224
    empty                          shift and go to state 155
    statements                     shift and go to state 156
    switch_statement               shift and go to state 158
    loop_statement                 shift and go to state 159
    function_call                  shift and go to state 160
    string_operation_statement     shift and go to state 161
    output_statement               shift and go to state 162
    local_dec                      shift and go to state 141
    for_loop                       shift and go to state 165
    until_loop                     shift and go to state 166
    repeat_until                   shift and go to state 167
    input_statement                shift and go to state 169
    var_call                       shift and go to state 170
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 192

    (108) statements_tail -> switch_statement NEWLINE . statements_tail
    (105) statements_tail -> . empty
    (106) statements_tail -> . statements
    (107) statements_tail -> . conditional_statement NEWLINE statements_tail
    (108) statements_tail -> . switch_statement NEWLINE statements_tail
    (109) statements_tail -> . loop_statement NEWLINE statements_tail
    (110) statements_tail -> . function_call NEWLINE statements_tail
    (111) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (112) statements_tail -> . output_statement NEWLINE statements_tail
    (161) empty -> .
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (115) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (119) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (123) loop_statement -> . for_loop
    (124) loop_statement -> . until_loop
    (125) loop_statement -> . repeat_until
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (148) string_operation_statement -> . var_call string_operation_tail
    (143) output_statement -> . DISPLAY value next_val
    (144) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (126) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (127) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (128) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (147) input_statement -> . INPUT LPAREN RPAREN
    (80) var_call -> . IDENT var_call_tail
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)
    SHIFT           reduce using rule 161 (empty -> .)
    OTHERWISE       reduce using rule 161 (empty -> .)
    CHECK           shift and go to state 163
    SWAP            shift and go to state 164
    FUNCTION_NAME   shift and go to state 168
    DISPLAY         shift and go to state 171
    FOR             shift and go to state 172
    UNTIL           shift and go to state 173
    REPEAT          shift and go to state 174
    INPUT           shift and go to state 175
    IDENT           shift and go to state 53
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    switch_statement               shift and go to state 158
    statements_tail                shift and go to state 225
    empty                          shift and go to state 155
    statements                     shift and go to state 156
    conditional_statement          shift and go to state 157
    loop_statement                 shift and go to state 159
    function_call                  shift and go to state 160
    string_operation_statement     shift and go to state 161
    output_statement               shift and go to state 162
    local_dec                      shift and go to state 141
    for_loop                       shift and go to state 165
    until_loop                     shift and go to state 166
    repeat_until                   shift and go to state 167
    input_statement                shift and go to state 169
    var_call                       shift and go to state 170
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 193

    (109) statements_tail -> loop_statement NEWLINE . statements_tail
    (105) statements_tail -> . empty
    (106) statements_tail -> . statements
    (107) statements_tail -> . conditional_statement NEWLINE statements_tail
    (108) statements_tail -> . switch_statement NEWLINE statements_tail
    (109) statements_tail -> . loop_statement NEWLINE statements_tail
    (110) statements_tail -> . function_call NEWLINE statements_tail
    (111) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (112) statements_tail -> . output_statement NEWLINE statements_tail
    (161) empty -> .
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (115) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (119) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (123) loop_statement -> . for_loop
    (124) loop_statement -> . until_loop
    (125) loop_statement -> . repeat_until
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (148) string_operation_statement -> . var_call string_operation_tail
    (143) output_statement -> . DISPLAY value next_val
    (144) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (126) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (127) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (128) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (147) input_statement -> . INPUT LPAREN RPAREN
    (80) var_call -> . IDENT var_call_tail
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)
    SHIFT           reduce using rule 161 (empty -> .)
    OTHERWISE       reduce using rule 161 (empty -> .)
    CHECK           shift and go to state 163
    SWAP            shift and go to state 164
    FUNCTION_NAME   shift and go to state 168
    DISPLAY         shift and go to state 171
    FOR             shift and go to state 172
    UNTIL           shift and go to state 173
    REPEAT          shift and go to state 174
    INPUT           shift and go to state 175
    IDENT           shift and go to state 53
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    loop_statement                 shift and go to state 159
    statements_tail                shift and go to state 226
    empty                          shift and go to state 155
    statements                     shift and go to state 156
    conditional_statement          shift and go to state 157
    switch_statement               shift and go to state 158
    function_call                  shift and go to state 160
    string_operation_statement     shift and go to state 161
    output_statement               shift and go to state 162
    local_dec                      shift and go to state 141
    for_loop                       shift and go to state 165
    until_loop                     shift and go to state 166
    repeat_until                   shift and go to state 167
    input_statement                shift and go to state 169
    var_call                       shift and go to state 170
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 194

    (110) statements_tail -> function_call NEWLINE . statements_tail
    (105) statements_tail -> . empty
    (106) statements_tail -> . statements
    (107) statements_tail -> . conditional_statement NEWLINE statements_tail
    (108) statements_tail -> . switch_statement NEWLINE statements_tail
    (109) statements_tail -> . loop_statement NEWLINE statements_tail
    (110) statements_tail -> . function_call NEWLINE statements_tail
    (111) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (112) statements_tail -> . output_statement NEWLINE statements_tail
    (161) empty -> .
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (115) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (119) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (123) loop_statement -> . for_loop
    (124) loop_statement -> . until_loop
    (125) loop_statement -> . repeat_until
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (148) string_operation_statement -> . var_call string_operation_tail
    (143) output_statement -> . DISPLAY value next_val
    (144) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (126) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (127) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (128) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (147) input_statement -> . INPUT LPAREN RPAREN
    (80) var_call -> . IDENT var_call_tail
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)
    SHIFT           reduce using rule 161 (empty -> .)
    OTHERWISE       reduce using rule 161 (empty -> .)
    CHECK           shift and go to state 163
    SWAP            shift and go to state 164
    FUNCTION_NAME   shift and go to state 168
    DISPLAY         shift and go to state 171
    FOR             shift and go to state 172
    UNTIL           shift and go to state 173
    REPEAT          shift and go to state 174
    INPUT           shift and go to state 175
    IDENT           shift and go to state 53
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    function_call                  shift and go to state 160
    statements_tail                shift and go to state 227
    empty                          shift and go to state 155
    statements                     shift and go to state 156
    conditional_statement          shift and go to state 157
    switch_statement               shift and go to state 158
    loop_statement                 shift and go to state 159
    string_operation_statement     shift and go to state 161
    output_statement               shift and go to state 162
    local_dec                      shift and go to state 141
    for_loop                       shift and go to state 165
    until_loop                     shift and go to state 166
    repeat_until                   shift and go to state 167
    input_statement                shift and go to state 169
    var_call                       shift and go to state 170
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 195

    (111) statements_tail -> string_operation_statement NEWLINE . statements_tail
    (105) statements_tail -> . empty
    (106) statements_tail -> . statements
    (107) statements_tail -> . conditional_statement NEWLINE statements_tail
    (108) statements_tail -> . switch_statement NEWLINE statements_tail
    (109) statements_tail -> . loop_statement NEWLINE statements_tail
    (110) statements_tail -> . function_call NEWLINE statements_tail
    (111) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (112) statements_tail -> . output_statement NEWLINE statements_tail
    (161) empty -> .
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (115) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (119) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (123) loop_statement -> . for_loop
    (124) loop_statement -> . until_loop
    (125) loop_statement -> . repeat_until
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (148) string_operation_statement -> . var_call string_operation_tail
    (143) output_statement -> . DISPLAY value next_val
    (144) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (126) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (127) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (128) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (147) input_statement -> . INPUT LPAREN RPAREN
    (80) var_call -> . IDENT var_call_tail
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)
    SHIFT           reduce using rule 161 (empty -> .)
    OTHERWISE       reduce using rule 161 (empty -> .)
    CHECK           shift and go to state 163
    SWAP            shift and go to state 164
    FUNCTION_NAME   shift and go to state 168
    DISPLAY         shift and go to state 171
    FOR             shift and go to state 172
    UNTIL           shift and go to state 173
    REPEAT          shift and go to state 174
    INPUT           shift and go to state 175
    IDENT           shift and go to state 53
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    string_operation_statement     shift and go to state 161
    statements_tail                shift and go to state 228
    empty                          shift and go to state 155
    statements                     shift and go to state 156
    conditional_statement          shift and go to state 157
    switch_statement               shift and go to state 158
    loop_statement                 shift and go to state 159
    function_call                  shift and go to state 160
    output_statement               shift and go to state 162
    local_dec                      shift and go to state 141
    for_loop                       shift and go to state 165
    until_loop                     shift and go to state 166
    repeat_until                   shift and go to state 167
    input_statement                shift and go to state 169
    var_call                       shift and go to state 170
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 196

    (112) statements_tail -> output_statement NEWLINE . statements_tail
    (105) statements_tail -> . empty
    (106) statements_tail -> . statements
    (107) statements_tail -> . conditional_statement NEWLINE statements_tail
    (108) statements_tail -> . switch_statement NEWLINE statements_tail
    (109) statements_tail -> . loop_statement NEWLINE statements_tail
    (110) statements_tail -> . function_call NEWLINE statements_tail
    (111) statements_tail -> . string_operation_statement NEWLINE statements_tail
    (112) statements_tail -> . output_statement NEWLINE statements_tail
    (161) empty -> .
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (115) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (119) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE
    (123) loop_statement -> . for_loop
    (124) loop_statement -> . until_loop
    (125) loop_statement -> . repeat_until
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (148) string_operation_statement -> . var_call string_operation_tail
    (143) output_statement -> . DISPLAY value next_val
    (144) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (126) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (127) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (128) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (147) input_statement -> . INPUT LPAREN RPAREN
    (80) var_call -> . IDENT var_call_tail
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 161 (empty -> .)
    RBRACE          reduce using rule 161 (empty -> .)
    REVIVE          reduce using rule 161 (empty -> .)
    SHIFT           reduce using rule 161 (empty -> .)
    OTHERWISE       reduce using rule 161 (empty -> .)
    CHECK           shift and go to state 163
    SWAP            shift and go to state 164
    FUNCTION_NAME   shift and go to state 168
    DISPLAY         shift and go to state 171
    FOR             shift and go to state 172
    UNTIL           shift and go to state 173
    REPEAT          shift and go to state 174
    INPUT           shift and go to state 175
    IDENT           shift and go to state 53
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    output_statement               shift and go to state 162
    statements_tail                shift and go to state 229
    empty                          shift and go to state 155
    statements                     shift and go to state 156
    conditional_statement          shift and go to state 157
    switch_statement               shift and go to state 158
    loop_statement                 shift and go to state 159
    function_call                  shift and go to state 160
    string_operation_statement     shift and go to state 161
    local_dec                      shift and go to state 141
    for_loop                       shift and go to state 165
    until_loop                     shift and go to state 166
    repeat_until                   shift and go to state 167
    input_statement                shift and go to state 169
    var_call                       shift and go to state 170
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 197

    (115) conditional_statement -> CHECK LPAREN . expression RPAREN LBRACE statements RBRACE conditional_tail
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 230
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 198

    (119) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE

    IDENT           shift and go to state 231


state 199

    (135) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (137) arguments -> . empty
    (138) arguments -> . arg_value arg_tail
    (161) empty -> .
    (141) arg_value -> . literal
    (142) arg_value -> . var_call
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (80) var_call -> . IDENT var_call_tail

    RPAREN          reduce using rule 161 (empty -> .)
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    IDENT           shift and go to state 53

    arguments                      shift and go to state 232
    empty                          shift and go to state 233
    arg_value                      shift and go to state 234
    literal                        shift and go to state 235
    var_call                       shift and go to state 236

state 200

    (148) string_operation_statement -> var_call string_operation_tail .

    NEWLINE         reduce using rule 148 (string_operation_statement -> var_call string_operation_tail .)


state 201

    (149) string_operation_tail -> assign_op . value
    (37) value -> . factor
    (38) value -> . type_cast
    (39) value -> . expression
    (40) value -> . function_call
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (41) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (56) expression -> . expr_head expr_tail
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (57) expr_head -> . term term_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (58) term -> . factor factor_tail

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    CONVERT_TO_INT  shift and go to state 186
    CONVERT_TO_FLT  shift and go to state 187
    CONVERT_TO_BLN  shift and go to state 188
    CONVERT_TO_STR  shift and go to state 189
    FUNCTION_NAME   shift and go to state 168
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175

    value                          shift and go to state 237
    factor                         shift and go to state 182
    type_cast                      shift and go to state 183
    expression                     shift and go to state 184
    function_call                  shift and go to state 185
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    expr_head                      shift and go to state 52
    input_statement                shift and go to state 169
    term                           shift and go to state 60

state 202

    (150) string_operation_tail -> PLUS . string_val stringcon_tail
    (159) string_val -> . var_call
    (160) string_val -> . STR_LIT
    (80) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 240
    IDENT           shift and go to state 53

    string_val                     shift and go to state 238
    var_call                       shift and go to state 239

state 203

    (151) assign_op -> PLUS_EQ .

    TILDE           reduce using rule 151 (assign_op -> PLUS_EQ .)
    LPAREN          reduce using rule 151 (assign_op -> PLUS_EQ .)
    CONVERT_TO_INT  reduce using rule 151 (assign_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 151 (assign_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 151 (assign_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 151 (assign_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 151 (assign_op -> PLUS_EQ .)
    IDENT           reduce using rule 151 (assign_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 151 (assign_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 151 (assign_op -> PLUS_EQ .)
    DAY             reduce using rule 151 (assign_op -> PLUS_EQ .)
    NIGHT           reduce using rule 151 (assign_op -> PLUS_EQ .)
    CHR_LIT         reduce using rule 151 (assign_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 151 (assign_op -> PLUS_EQ .)
    INPUT           reduce using rule 151 (assign_op -> PLUS_EQ .)


state 204

    (152) assign_op -> MINUS_EQ .

    TILDE           reduce using rule 152 (assign_op -> MINUS_EQ .)
    LPAREN          reduce using rule 152 (assign_op -> MINUS_EQ .)
    CONVERT_TO_INT  reduce using rule 152 (assign_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 152 (assign_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 152 (assign_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 152 (assign_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 152 (assign_op -> MINUS_EQ .)
    IDENT           reduce using rule 152 (assign_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 152 (assign_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 152 (assign_op -> MINUS_EQ .)
    DAY             reduce using rule 152 (assign_op -> MINUS_EQ .)
    NIGHT           reduce using rule 152 (assign_op -> MINUS_EQ .)
    CHR_LIT         reduce using rule 152 (assign_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 152 (assign_op -> MINUS_EQ .)
    INPUT           reduce using rule 152 (assign_op -> MINUS_EQ .)


state 205

    (153) assign_op -> MUL_EQ .

    TILDE           reduce using rule 153 (assign_op -> MUL_EQ .)
    LPAREN          reduce using rule 153 (assign_op -> MUL_EQ .)
    CONVERT_TO_INT  reduce using rule 153 (assign_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 153 (assign_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 153 (assign_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 153 (assign_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 153 (assign_op -> MUL_EQ .)
    IDENT           reduce using rule 153 (assign_op -> MUL_EQ .)
    INT_LIT         reduce using rule 153 (assign_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 153 (assign_op -> MUL_EQ .)
    DAY             reduce using rule 153 (assign_op -> MUL_EQ .)
    NIGHT           reduce using rule 153 (assign_op -> MUL_EQ .)
    CHR_LIT         reduce using rule 153 (assign_op -> MUL_EQ .)
    STR_LIT         reduce using rule 153 (assign_op -> MUL_EQ .)
    INPUT           reduce using rule 153 (assign_op -> MUL_EQ .)


state 206

    (154) assign_op -> DIV_EQ .

    TILDE           reduce using rule 154 (assign_op -> DIV_EQ .)
    LPAREN          reduce using rule 154 (assign_op -> DIV_EQ .)
    CONVERT_TO_INT  reduce using rule 154 (assign_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 154 (assign_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 154 (assign_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 154 (assign_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 154 (assign_op -> DIV_EQ .)
    IDENT           reduce using rule 154 (assign_op -> DIV_EQ .)
    INT_LIT         reduce using rule 154 (assign_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 154 (assign_op -> DIV_EQ .)
    DAY             reduce using rule 154 (assign_op -> DIV_EQ .)
    NIGHT           reduce using rule 154 (assign_op -> DIV_EQ .)
    CHR_LIT         reduce using rule 154 (assign_op -> DIV_EQ .)
    STR_LIT         reduce using rule 154 (assign_op -> DIV_EQ .)
    INPUT           reduce using rule 154 (assign_op -> DIV_EQ .)


state 207

    (155) assign_op -> MOD_EQ .

    TILDE           reduce using rule 155 (assign_op -> MOD_EQ .)
    LPAREN          reduce using rule 155 (assign_op -> MOD_EQ .)
    CONVERT_TO_INT  reduce using rule 155 (assign_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 155 (assign_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 155 (assign_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 155 (assign_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 155 (assign_op -> MOD_EQ .)
    IDENT           reduce using rule 155 (assign_op -> MOD_EQ .)
    INT_LIT         reduce using rule 155 (assign_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 155 (assign_op -> MOD_EQ .)
    DAY             reduce using rule 155 (assign_op -> MOD_EQ .)
    NIGHT           reduce using rule 155 (assign_op -> MOD_EQ .)
    CHR_LIT         reduce using rule 155 (assign_op -> MOD_EQ .)
    STR_LIT         reduce using rule 155 (assign_op -> MOD_EQ .)
    INPUT           reduce using rule 155 (assign_op -> MOD_EQ .)


state 208

    (156) assign_op -> EQ .

    TILDE           reduce using rule 156 (assign_op -> EQ .)
    LPAREN          reduce using rule 156 (assign_op -> EQ .)
    CONVERT_TO_INT  reduce using rule 156 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 156 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 156 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 156 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 156 (assign_op -> EQ .)
    IDENT           reduce using rule 156 (assign_op -> EQ .)
    INT_LIT         reduce using rule 156 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 156 (assign_op -> EQ .)
    DAY             reduce using rule 156 (assign_op -> EQ .)
    NIGHT           reduce using rule 156 (assign_op -> EQ .)
    CHR_LIT         reduce using rule 156 (assign_op -> EQ .)
    STR_LIT         reduce using rule 156 (assign_op -> EQ .)
    INPUT           reduce using rule 156 (assign_op -> EQ .)


state 209

    (143) output_statement -> DISPLAY value . next_val
    (145) next_val -> . empty
    (146) next_val -> . COMMA value next_val
    (161) empty -> .

    COMMA           shift and go to state 243
    NEWLINE         reduce using rule 161 (empty -> .)

    next_val                       shift and go to state 241
    empty                          shift and go to state 242

state 210

    (144) output_statement -> DISPLAY LPAREN . value next_val RPAREN
    (62) factor -> LPAREN . expression RPAREN
    (37) value -> . factor
    (38) value -> . type_cast
    (39) value -> . expression
    (40) value -> . function_call
    (56) expression -> . expr_head expr_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (41) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (57) expr_head -> . term term_tail
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (147) input_statement -> . INPUT LPAREN RPAREN
    (58) term -> . factor factor_tail

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    CONVERT_TO_INT  shift and go to state 186
    CONVERT_TO_FLT  shift and go to state 187
    CONVERT_TO_BLN  shift and go to state 188
    CONVERT_TO_STR  shift and go to state 189
    FUNCTION_NAME   shift and go to state 168
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175

    value                          shift and go to state 244
    expression                     shift and go to state 245
    factor                         shift and go to state 182
    type_cast                      shift and go to state 183
    function_call                  shift and go to state 185
    expr_head                      shift and go to state 52
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    input_statement                shift and go to state 169
    term                           shift and go to state 60

state 211

    (126) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (129) control_variable -> . INT IDENT EQ INT_LIT

    INT             shift and go to state 247

    control_variable               shift and go to state 246

state 212

    (127) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE statements RBRACE
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 248
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 213

    (128) repeat_until -> REPEAT LBRACE . statements RBRACE UNTIL LPAREN expression RPAREN
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 249
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 214

    (147) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 250


state 215

    (21) var_tail -> EQ tail_value . var_tail2
    (23) var_tail2 -> . empty
    (24) var_tail2 -> . COMMA IDENT var_tail
    (161) empty -> .

    COMMA           shift and go to state 253
    NEWLINE         reduce using rule 161 (empty -> .)

    var_tail2                      shift and go to state 251
    empty                          shift and go to state 252

state 216

    (25) tail_value -> value .

    COMMA           reduce using rule 25 (tail_value -> value .)
    NEWLINE         reduce using rule 25 (tail_value -> value .)


state 217

    (26) tail_value -> LBRACKET . list_element RBRACKET
    (27) list_element -> . literal element_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    list_element                   shift and go to state 254
    literal                        shift and go to state 69

state 218

    (22) var_tail -> COMMA IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (161) empty -> .

    EQ              shift and go to state 178
    COMMA           shift and go to state 179
    NEWLINE         reduce using rule 161 (empty -> .)

    var_tail                       shift and go to state 255
    empty                          shift and go to state 177

state 219

    (83) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE .

    NEWLINE         reduce using rule 83 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE .)
    MAIN_CASPER     reduce using rule 83 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE .)


state 220

    (41) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (45) typecast_value -> . IDENT
    (46) typecast_value -> . literal
    (47) typecast_value -> . expression
    (48) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (49) typecast_value -> . input_statement
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (56) expression -> . expr_head expr_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 257
    FUNCTION_NAME   shift and go to state 260
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51

    typecast_value                 shift and go to state 256
    literal                        shift and go to state 258
    expression                     shift and go to state 259
    input_statement                shift and go to state 261
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48

state 221

    (42) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (45) typecast_value -> . IDENT
    (46) typecast_value -> . literal
    (47) typecast_value -> . expression
    (48) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (49) typecast_value -> . input_statement
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (56) expression -> . expr_head expr_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 257
    FUNCTION_NAME   shift and go to state 260
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51

    typecast_value                 shift and go to state 262
    literal                        shift and go to state 258
    expression                     shift and go to state 259
    input_statement                shift and go to state 261
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48

state 222

    (43) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (45) typecast_value -> . IDENT
    (46) typecast_value -> . literal
    (47) typecast_value -> . expression
    (48) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (49) typecast_value -> . input_statement
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (56) expression -> . expr_head expr_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 257
    FUNCTION_NAME   shift and go to state 260
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51

    typecast_value                 shift and go to state 263
    literal                        shift and go to state 258
    expression                     shift and go to state 259
    input_statement                shift and go to state 261
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48

state 223

    (44) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (45) typecast_value -> . IDENT
    (46) typecast_value -> . literal
    (47) typecast_value -> . expression
    (48) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (49) typecast_value -> . input_statement
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (56) expression -> . expr_head expr_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 257
    FUNCTION_NAME   shift and go to state 260
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51

    typecast_value                 shift and go to state 264
    literal                        shift and go to state 258
    expression                     shift and go to state 259
    input_statement                shift and go to state 261
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48

state 224

    (107) statements_tail -> conditional_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 107 (statements_tail -> conditional_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 107 (statements_tail -> conditional_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 107 (statements_tail -> conditional_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 107 (statements_tail -> conditional_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 107 (statements_tail -> conditional_statement NEWLINE statements_tail .)


state 225

    (108) statements_tail -> switch_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 108 (statements_tail -> switch_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 108 (statements_tail -> switch_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 108 (statements_tail -> switch_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 108 (statements_tail -> switch_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 108 (statements_tail -> switch_statement NEWLINE statements_tail .)


state 226

    (109) statements_tail -> loop_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 109 (statements_tail -> loop_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 109 (statements_tail -> loop_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 109 (statements_tail -> loop_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 109 (statements_tail -> loop_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 109 (statements_tail -> loop_statement NEWLINE statements_tail .)


state 227

    (110) statements_tail -> function_call NEWLINE statements_tail .

    NEWLINE         reduce using rule 110 (statements_tail -> function_call NEWLINE statements_tail .)
    RBRACE          reduce using rule 110 (statements_tail -> function_call NEWLINE statements_tail .)
    REVIVE          reduce using rule 110 (statements_tail -> function_call NEWLINE statements_tail .)
    SHIFT           reduce using rule 110 (statements_tail -> function_call NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 110 (statements_tail -> function_call NEWLINE statements_tail .)


state 228

    (111) statements_tail -> string_operation_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 111 (statements_tail -> string_operation_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 111 (statements_tail -> string_operation_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 111 (statements_tail -> string_operation_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 111 (statements_tail -> string_operation_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 111 (statements_tail -> string_operation_statement NEWLINE statements_tail .)


state 229

    (112) statements_tail -> output_statement NEWLINE statements_tail .

    NEWLINE         reduce using rule 112 (statements_tail -> output_statement NEWLINE statements_tail .)
    RBRACE          reduce using rule 112 (statements_tail -> output_statement NEWLINE statements_tail .)
    REVIVE          reduce using rule 112 (statements_tail -> output_statement NEWLINE statements_tail .)
    SHIFT           reduce using rule 112 (statements_tail -> output_statement NEWLINE statements_tail .)
    OTHERWISE       reduce using rule 112 (statements_tail -> output_statement NEWLINE statements_tail .)


state 230

    (115) conditional_statement -> CHECK LPAREN expression . RPAREN LBRACE statements RBRACE conditional_tail

    RPAREN          shift and go to state 265


state 231

    (119) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE switch_condition OTHERWISE statements RBRACE

    RPAREN          shift and go to state 266


state 232

    (135) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 267


state 233

    (137) arguments -> empty .

    RPAREN          reduce using rule 137 (arguments -> empty .)


state 234

    (138) arguments -> arg_value . arg_tail
    (139) arg_tail -> . empty
    (140) arg_tail -> . COMMA arg_value arg_tail
    (161) empty -> .

    COMMA           shift and go to state 270
    RPAREN          reduce using rule 161 (empty -> .)

    arg_tail                       shift and go to state 268
    empty                          shift and go to state 269

state 235

    (141) arg_value -> literal .

    COMMA           reduce using rule 141 (arg_value -> literal .)
    RPAREN          reduce using rule 141 (arg_value -> literal .)


state 236

    (142) arg_value -> var_call .

    COMMA           reduce using rule 142 (arg_value -> var_call .)
    RPAREN          reduce using rule 142 (arg_value -> var_call .)


state 237

    (149) string_operation_tail -> assign_op value .

    NEWLINE         reduce using rule 149 (string_operation_tail -> assign_op value .)


state 238

    (150) string_operation_tail -> PLUS string_val . stringcon_tail
    (157) stringcon_tail -> . empty
    (158) stringcon_tail -> . PLUS string_val stringcon_tail
    (161) empty -> .

    PLUS            shift and go to state 271
    NEWLINE         reduce using rule 161 (empty -> .)

    stringcon_tail                 shift and go to state 272
    empty                          shift and go to state 273

state 239

    (159) string_val -> var_call .

    PLUS            reduce using rule 159 (string_val -> var_call .)
    NEWLINE         reduce using rule 159 (string_val -> var_call .)


state 240

    (160) string_val -> STR_LIT .

    PLUS            reduce using rule 160 (string_val -> STR_LIT .)
    NEWLINE         reduce using rule 160 (string_val -> STR_LIT .)


state 241

    (143) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 143 (output_statement -> DISPLAY value next_val .)


state 242

    (145) next_val -> empty .

    NEWLINE         reduce using rule 145 (next_val -> empty .)
    RPAREN          reduce using rule 145 (next_val -> empty .)


state 243

    (146) next_val -> COMMA . value next_val
    (37) value -> . factor
    (38) value -> . type_cast
    (39) value -> . expression
    (40) value -> . function_call
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (41) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (56) expression -> . expr_head expr_tail
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (57) expr_head -> . term term_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (58) term -> . factor factor_tail

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    CONVERT_TO_INT  shift and go to state 186
    CONVERT_TO_FLT  shift and go to state 187
    CONVERT_TO_BLN  shift and go to state 188
    CONVERT_TO_STR  shift and go to state 189
    FUNCTION_NAME   shift and go to state 168
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175

    value                          shift and go to state 274
    factor                         shift and go to state 182
    type_cast                      shift and go to state 183
    expression                     shift and go to state 184
    function_call                  shift and go to state 185
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    expr_head                      shift and go to state 52
    input_statement                shift and go to state 169
    term                           shift and go to state 60

state 244

    (144) output_statement -> DISPLAY LPAREN value . next_val RPAREN
    (145) next_val -> . empty
    (146) next_val -> . COMMA value next_val
    (161) empty -> .

    COMMA           shift and go to state 243
    RPAREN          reduce using rule 161 (empty -> .)

    next_val                       shift and go to state 275
    empty                          shift and go to state 242

state 245

    (62) factor -> LPAREN expression . RPAREN
    (39) value -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 112
    COMMA           reduce using rule 39 (value -> expression .)

  ! RPAREN          [ reduce using rule 39 (value -> expression .) ]


state 246

    (126) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 276


state 247

    (129) control_variable -> INT . IDENT EQ INT_LIT

    IDENT           shift and go to state 277


state 248

    (127) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 278


state 249

    (128) repeat_until -> REPEAT LBRACE statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 279


state 250

    (147) input_statement -> INPUT LPAREN RPAREN .

    NEWLINE         reduce using rule 147 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 147 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 147 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 147 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 147 (input_statement -> INPUT LPAREN RPAREN .)


state 251

    (21) var_tail -> EQ tail_value var_tail2 .

    NEWLINE         reduce using rule 21 (var_tail -> EQ tail_value var_tail2 .)


state 252

    (23) var_tail2 -> empty .

    NEWLINE         reduce using rule 23 (var_tail2 -> empty .)


state 253

    (24) var_tail2 -> COMMA . IDENT var_tail

    IDENT           shift and go to state 280


state 254

    (26) tail_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 281


state 255

    (22) var_tail -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 22 (var_tail -> COMMA IDENT var_tail .)


state 256

    (41) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 282


state 257

    (45) typecast_value -> IDENT .
    (80) var_call -> IDENT . var_call_tail
    (81) var_call_tail -> . empty
    (82) var_call_tail -> . LBRACKET index RBRACKET
    (161) empty -> .

  ! reduce/reduce conflict for RPAREN resolved using rule 45 (typecast_value -> IDENT .)
    RPAREN          reduce using rule 45 (typecast_value -> IDENT .)
    LBRACKET        shift and go to state 87
    PLUS            reduce using rule 161 (empty -> .)
    MINUS           reduce using rule 161 (empty -> .)
    MULTIPLY        reduce using rule 161 (empty -> .)
    DIVISION        reduce using rule 161 (empty -> .)
    MODULO          reduce using rule 161 (empty -> .)
    EXPONENT        reduce using rule 161 (empty -> .)
    GT              reduce using rule 161 (empty -> .)
    LT              reduce using rule 161 (empty -> .)
    EQ_EQ           reduce using rule 161 (empty -> .)
    GT_EQ           reduce using rule 161 (empty -> .)
    LT_EQ           reduce using rule 161 (empty -> .)
    NOT_EQ          reduce using rule 161 (empty -> .)
    AND             reduce using rule 161 (empty -> .)
    OR              reduce using rule 161 (empty -> .)

  ! RPAREN          [ reduce using rule 161 (empty -> .) ]

    var_call_tail                  shift and go to state 85
    empty                          shift and go to state 86

state 258

    (46) typecast_value -> literal .
    (60) factor -> literal .

  ! reduce/reduce conflict for RPAREN resolved using rule 46 (typecast_value -> literal .)
    RPAREN          reduce using rule 46 (typecast_value -> literal .)
    PLUS            reduce using rule 60 (factor -> literal .)
    MINUS           reduce using rule 60 (factor -> literal .)
    MULTIPLY        reduce using rule 60 (factor -> literal .)
    DIVISION        reduce using rule 60 (factor -> literal .)
    MODULO          reduce using rule 60 (factor -> literal .)
    EXPONENT        reduce using rule 60 (factor -> literal .)
    GT              reduce using rule 60 (factor -> literal .)
    LT              reduce using rule 60 (factor -> literal .)
    EQ_EQ           reduce using rule 60 (factor -> literal .)
    GT_EQ           reduce using rule 60 (factor -> literal .)
    LT_EQ           reduce using rule 60 (factor -> literal .)
    NOT_EQ          reduce using rule 60 (factor -> literal .)
    AND             reduce using rule 60 (factor -> literal .)
    OR              reduce using rule 60 (factor -> literal .)

  ! RPAREN          [ reduce using rule 60 (factor -> literal .) ]


state 259

    (47) typecast_value -> expression .

    RPAREN          reduce using rule 47 (typecast_value -> expression .)


state 260

    (48) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 283


state 261

    (49) typecast_value -> input_statement .

    RPAREN          reduce using rule 49 (typecast_value -> input_statement .)


state 262

    (42) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 284


state 263

    (43) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 285


state 264

    (44) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 286


state 265

    (115) conditional_statement -> CHECK LPAREN expression RPAREN . LBRACE statements RBRACE conditional_tail

    LBRACE          shift and go to state 287


state 266

    (119) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE switch_condition OTHERWISE statements RBRACE

    LBRACE          shift and go to state 288


state 267

    (135) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 135 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 135 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 135 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 135 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 135 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 268

    (138) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 138 (arguments -> arg_value arg_tail .)


state 269

    (139) arg_tail -> empty .

    RPAREN          reduce using rule 139 (arg_tail -> empty .)


state 270

    (140) arg_tail -> COMMA . arg_value arg_tail
    (141) arg_value -> . literal
    (142) arg_value -> . var_call
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (80) var_call -> . IDENT var_call_tail

    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    IDENT           shift and go to state 53

    arg_value                      shift and go to state 289
    literal                        shift and go to state 235
    var_call                       shift and go to state 236

state 271

    (158) stringcon_tail -> PLUS . string_val stringcon_tail
    (159) string_val -> . var_call
    (160) string_val -> . STR_LIT
    (80) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 240
    IDENT           shift and go to state 53

    string_val                     shift and go to state 290
    var_call                       shift and go to state 239

state 272

    (150) string_operation_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 150 (string_operation_tail -> PLUS string_val stringcon_tail .)


state 273

    (157) stringcon_tail -> empty .

    NEWLINE         reduce using rule 157 (stringcon_tail -> empty .)


state 274

    (146) next_val -> COMMA value . next_val
    (145) next_val -> . empty
    (146) next_val -> . COMMA value next_val
    (161) empty -> .

    COMMA           shift and go to state 243
    NEWLINE         reduce using rule 161 (empty -> .)
    RPAREN          reduce using rule 161 (empty -> .)

    next_val                       shift and go to state 291
    empty                          shift and go to state 242

state 275

    (144) output_statement -> DISPLAY LPAREN value next_val . RPAREN

    RPAREN          shift and go to state 292


state 276

    (126) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 293
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 277

    (129) control_variable -> INT IDENT . EQ INT_LIT

    EQ              shift and go to state 294


state 278

    (127) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 295


state 279

    (128) repeat_until -> REPEAT LBRACE statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 296


state 280

    (24) var_tail2 -> COMMA IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (161) empty -> .

    EQ              shift and go to state 178
    COMMA           shift and go to state 179
    NEWLINE         reduce using rule 161 (empty -> .)

    var_tail                       shift and go to state 297
    empty                          shift and go to state 177

state 281

    (26) tail_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 26 (tail_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 26 (tail_value -> LBRACKET list_element RBRACKET .)


state 282

    (41) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 41 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 41 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 41 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 41 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 41 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 283

    (48) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 298


state 284

    (42) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 42 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 42 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 42 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 42 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 42 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 285

    (43) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 43 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 43 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 43 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 43 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 43 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 286

    (44) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 44 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 44 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 44 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 44 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 44 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 287

    (115) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE . statements RBRACE conditional_tail
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 299
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 288

    (119) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . switch_condition OTHERWISE statements RBRACE
    (120) switch_condition -> . SHIFT value COLON statements switchcond_tail

    SHIFT           shift and go to state 301

    switch_condition               shift and go to state 300

state 289

    (140) arg_tail -> COMMA arg_value . arg_tail
    (139) arg_tail -> . empty
    (140) arg_tail -> . COMMA arg_value arg_tail
    (161) empty -> .

    COMMA           shift and go to state 270
    RPAREN          reduce using rule 161 (empty -> .)

    arg_tail                       shift and go to state 302
    empty                          shift and go to state 269

state 290

    (158) stringcon_tail -> PLUS string_val . stringcon_tail
    (157) stringcon_tail -> . empty
    (158) stringcon_tail -> . PLUS string_val stringcon_tail
    (161) empty -> .

    PLUS            shift and go to state 271
    NEWLINE         reduce using rule 161 (empty -> .)

    stringcon_tail                 shift and go to state 303
    empty                          shift and go to state 273

state 291

    (146) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 146 (next_val -> COMMA value next_val .)
    RPAREN          reduce using rule 146 (next_val -> COMMA value next_val .)


state 292

    (144) output_statement -> DISPLAY LPAREN value next_val RPAREN .

    NEWLINE         reduce using rule 144 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)


state 293

    (126) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 304


state 294

    (129) control_variable -> INT IDENT EQ . INT_LIT

    INT_LIT         shift and go to state 305


state 295

    (127) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . statements RBRACE
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 306
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 296

    (128) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 307


state 297

    (24) var_tail2 -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 24 (var_tail2 -> COMMA IDENT var_tail .)


state 298

    (48) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 48 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 299

    (115) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements . RBRACE conditional_tail

    RBRACE          shift and go to state 308


state 300

    (119) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition . OTHERWISE statements RBRACE

    OTHERWISE       shift and go to state 309


state 301

    (120) switch_condition -> SHIFT . value COLON statements switchcond_tail
    (37) value -> . factor
    (38) value -> . type_cast
    (39) value -> . expression
    (40) value -> . function_call
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (41) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (56) expression -> . expr_head expr_tail
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (57) expr_head -> . term term_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (58) term -> . factor factor_tail

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    CONVERT_TO_INT  shift and go to state 186
    CONVERT_TO_FLT  shift and go to state 187
    CONVERT_TO_BLN  shift and go to state 188
    CONVERT_TO_STR  shift and go to state 189
    FUNCTION_NAME   shift and go to state 168
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175

    value                          shift and go to state 310
    factor                         shift and go to state 182
    type_cast                      shift and go to state 183
    expression                     shift and go to state 184
    function_call                  shift and go to state 185
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    expr_head                      shift and go to state 52
    input_statement                shift and go to state 169
    term                           shift and go to state 60

state 302

    (140) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 140 (arg_tail -> COMMA arg_value arg_tail .)


state 303

    (158) stringcon_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 158 (stringcon_tail -> PLUS string_val stringcon_tail .)


state 304

    (126) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN LBRACE statements RBRACE
    (130) update -> . var_call update_tail
    (80) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 53

    update                         shift and go to state 311
    var_call                       shift and go to state 312

state 305

    (129) control_variable -> INT IDENT EQ INT_LIT .

    SEMICOLON       reduce using rule 129 (control_variable -> INT IDENT EQ INT_LIT .)


state 306

    (127) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 313


state 307

    (128) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN . expression RPAREN
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 314
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 308

    (115) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements RBRACE . conditional_tail
    (116) conditional_tail -> . empty
    (117) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE
    (118) conditional_tail -> . OTHERWISE LBRACE statements RBRACE
    (161) empty -> .

    OTHERWISE_CHECK shift and go to state 317
    OTHERWISE       shift and go to state 318
    NEWLINE         reduce using rule 161 (empty -> .)

    conditional_tail               shift and go to state 315
    empty                          shift and go to state 316

state 309

    (119) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE . statements RBRACE
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 319
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 310

    (120) switch_condition -> SHIFT value . COLON statements switchcond_tail

    COLON           shift and go to state 320


state 311

    (126) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 321


state 312

    (130) update -> var_call . update_tail
    (131) update_tail -> . postfix
    (132) update_tail -> . assign_op value
    (133) postfix -> . PLUS_PLUS
    (134) postfix -> . MINUS_MINUS
    (151) assign_op -> . PLUS_EQ
    (152) assign_op -> . MINUS_EQ
    (153) assign_op -> . MUL_EQ
    (154) assign_op -> . DIV_EQ
    (155) assign_op -> . MOD_EQ
    (156) assign_op -> . EQ

    PLUS_PLUS       shift and go to state 325
    MINUS_MINUS     shift and go to state 326
    PLUS_EQ         shift and go to state 203
    MINUS_EQ        shift and go to state 204
    MUL_EQ          shift and go to state 205
    DIV_EQ          shift and go to state 206
    MOD_EQ          shift and go to state 207
    EQ              shift and go to state 208

    update_tail                    shift and go to state 322
    postfix                        shift and go to state 323
    assign_op                      shift and go to state 324

state 313

    (127) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 127 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .)


state 314

    (128) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 327


state 315

    (115) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .

    NEWLINE         reduce using rule 115 (conditional_statement -> CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .)


state 316

    (116) conditional_tail -> empty .

    NEWLINE         reduce using rule 116 (conditional_tail -> empty .)


state 317

    (117) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 328


state 318

    (118) conditional_tail -> OTHERWISE . LBRACE statements RBRACE

    LBRACE          shift and go to state 329


state 319

    (119) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements . RBRACE

    RBRACE          shift and go to state 330


state 320

    (120) switch_condition -> SHIFT value COLON . statements switchcond_tail
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    SHIFT           reduce using rule 161 (empty -> .)
    OTHERWISE       reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 331
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 321

    (126) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 332


state 322

    (130) update -> var_call update_tail .

    RPAREN          reduce using rule 130 (update -> var_call update_tail .)


state 323

    (131) update_tail -> postfix .

    RPAREN          reduce using rule 131 (update_tail -> postfix .)


state 324

    (132) update_tail -> assign_op . value
    (37) value -> . factor
    (38) value -> . type_cast
    (39) value -> . expression
    (40) value -> . function_call
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (41) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (56) expression -> . expr_head expr_tail
    (135) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (136) function_call -> . input_statement
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT
    (57) expr_head -> . term term_tail
    (147) input_statement -> . INPUT LPAREN RPAREN
    (58) term -> . factor factor_tail

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    CONVERT_TO_INT  shift and go to state 186
    CONVERT_TO_FLT  shift and go to state 187
    CONVERT_TO_BLN  shift and go to state 188
    CONVERT_TO_STR  shift and go to state 189
    FUNCTION_NAME   shift and go to state 168
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59
    INPUT           shift and go to state 175

    value                          shift and go to state 333
    factor                         shift and go to state 182
    type_cast                      shift and go to state 183
    expression                     shift and go to state 184
    function_call                  shift and go to state 185
    var_call                       shift and go to state 48
    literal                        shift and go to state 49
    expr_head                      shift and go to state 52
    input_statement                shift and go to state 169
    term                           shift and go to state 60

state 325

    (133) postfix -> PLUS_PLUS .

    RPAREN          reduce using rule 133 (postfix -> PLUS_PLUS .)


state 326

    (134) postfix -> MINUS_MINUS .

    RPAREN          reduce using rule 134 (postfix -> MINUS_MINUS .)


state 327

    (128) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 128 (repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .)


state 328

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN LBRACE statements RBRACE
    (56) expression -> . expr_head expr_tail
    (57) expr_head -> . term term_tail
    (58) term -> . factor factor_tail
    (59) factor -> . var_call
    (60) factor -> . literal
    (61) factor -> . TILDE literal
    (62) factor -> . LPAREN expression RPAREN
    (80) var_call -> . IDENT var_call_tail
    (50) literal -> . INT_LIT
    (51) literal -> . FLT_LIT
    (52) literal -> . DAY
    (53) literal -> . NIGHT
    (54) literal -> . CHR_LIT
    (55) literal -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 51
    IDENT           shift and go to state 53
    INT_LIT         shift and go to state 54
    FLT_LIT         shift and go to state 55
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    CHR_LIT         shift and go to state 58
    STR_LIT         shift and go to state 59

    expression                     shift and go to state 334
    expr_head                      shift and go to state 52
    term                           shift and go to state 60
    factor                         shift and go to state 80
    var_call                       shift and go to state 48
    literal                        shift and go to state 49

state 329

    (118) conditional_tail -> OTHERWISE LBRACE . statements RBRACE
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 335
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 330

    (119) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE .

    NEWLINE         reduce using rule 119 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE statements RBRACE .)


state 331

    (120) switch_condition -> SHIFT value COLON statements . switchcond_tail
    (121) switchcond_tail -> . empty
    (122) switchcond_tail -> . switch_condition
    (161) empty -> .
    (120) switch_condition -> . SHIFT value COLON statements switchcond_tail

    OTHERWISE       reduce using rule 161 (empty -> .)
    SHIFT           shift and go to state 301

    switchcond_tail                shift and go to state 336
    empty                          shift and go to state 337
    switch_condition               shift and go to state 338

state 332

    (126) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE . statements RBRACE
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 339
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 333

    (132) update_tail -> assign_op value .

    RPAREN          reduce using rule 132 (update_tail -> assign_op value .)


state 334

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 340


state 335

    (118) conditional_tail -> OTHERWISE LBRACE statements . RBRACE

    RBRACE          shift and go to state 341


state 336

    (120) switch_condition -> SHIFT value COLON statements switchcond_tail .

    OTHERWISE       reduce using rule 120 (switch_condition -> SHIFT value COLON statements switchcond_tail .)


state 337

    (121) switchcond_tail -> empty .

    OTHERWISE       reduce using rule 121 (switchcond_tail -> empty .)


state 338

    (122) switchcond_tail -> switch_condition .

    OTHERWISE       reduce using rule 122 (switchcond_tail -> switch_condition .)


state 339

    (126) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 342


state 340

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 343


state 341

    (118) conditional_tail -> OTHERWISE LBRACE statements RBRACE .

    NEWLINE         reduce using rule 118 (conditional_tail -> OTHERWISE LBRACE statements RBRACE .)


state 342

    (126) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 126 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE .)


state 343

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE . statements RBRACE
    (103) statements -> . empty
    (104) statements -> . local_dec NEWLINE statements_tail
    (161) empty -> .
    (113) local_dec -> . var_statement
    (114) local_dec -> . empty
    (19) var_statement -> . data_type IDENT var_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 161 (empty -> .)
    NEWLINE         reduce using rule 161 (empty -> .)
    INT             shift and go to state 8
    FLT             shift and go to state 9
    BLN             shift and go to state 10
    CHR             shift and go to state 11
    STR             shift and go to state 12

    statements                     shift and go to state 344
    empty                          shift and go to state 140
    local_dec                      shift and go to state 141
    var_statement                  shift and go to state 142
    data_type                      shift and go to state 143

state 344

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 345


state 345

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 117 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 13 resolved as shift
WARNING: shift/reduce conflict for AND in state 52 resolved as shift
WARNING: shift/reduce conflict for OR in state 52 resolved as shift
WARNING: shift/reduce conflict for GT in state 60 resolved as shift
WARNING: shift/reduce conflict for LT in state 60 resolved as shift
WARNING: shift/reduce conflict for EQ_EQ in state 60 resolved as shift
WARNING: shift/reduce conflict for GT_EQ in state 60 resolved as shift
WARNING: shift/reduce conflict for LT_EQ in state 60 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 60 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 131 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 132 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 153 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 245 resolved as shift
WARNING: reduce/reduce conflict in state 18 resolved using rule (global_dec -> empty)
WARNING: rejected rule (global_tail -> empty) in state 18
WARNING: reduce/reduce conflict in state 46 resolved using rule (global_value -> factor)
WARNING: rejected rule (empty -> <empty>) in state 46
WARNING: reduce/reduce conflict in state 140 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 140
WARNING: reduce/reduce conflict in state 155 resolved using rule (statements -> empty)
WARNING: rejected rule (statements_tail -> empty) in state 155
WARNING: reduce/reduce conflict in state 155 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 155
WARNING: reduce/reduce conflict in state 182 resolved using rule (value -> factor)
WARNING: rejected rule (empty -> <empty>) in state 182
WARNING: reduce/reduce conflict in state 257 resolved using rule (typecast_value -> IDENT)
WARNING: rejected rule (empty -> <empty>) in state 257
WARNING: reduce/reduce conflict in state 258 resolved using rule (typecast_value -> literal)
WARNING: rejected rule (factor -> literal) in state 258
WARNING: Rule (global_tail -> empty) is never reduced
WARNING: Rule (local_dec -> empty) is never reduced
WARNING: Rule (statements_tail -> empty) is never reduced
