Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_statement -> data_type IDENT global_statement_tail
Rule 11    global_statement_tail -> empty
Rule 12    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 13    global_statement_tail -> EQ global_dec_value global_tail2
Rule 14    global_tail2 -> empty
Rule 15    global_tail2 -> COMMA IDENT global_statement_tail
Rule 16    global_dec_value -> global_value
Rule 17    global_dec_value -> LBRACKET list_element RBRACKET
Rule 18    global_value -> expression
Rule 19    var_statement -> data_type IDENT var_tail unli_newline
Rule 20    var_tail -> empty
Rule 21    var_tail -> EQ tail_value var_tail2
Rule 22    var_tail -> COMMA IDENT var_tail
Rule 23    var_tail2 -> empty
Rule 24    var_tail2 -> COMMA IDENT var_tail
Rule 25    tail_value -> value
Rule 26    tail_value -> LBRACKET list_element RBRACKET
Rule 27    list_element -> literal element_tail
Rule 28    element_tail -> empty
Rule 29    element_tail -> COMMA list_element
Rule 30    index -> INT_LIT
Rule 31    index -> IDENT
Rule 32    data_type -> INT
Rule 33    data_type -> FLT
Rule 34    data_type -> BLN
Rule 35    data_type -> CHR
Rule 36    data_type -> STR
Rule 37    value -> type_cast
Rule 38    value -> expression
Rule 39    value -> function_call
Rule 40    type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 41    type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 42    type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 43    type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 44    typecast_value -> expression
Rule 45    typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 46    typecast_value -> input_statement
Rule 47    literal -> INT_LIT
Rule 48    literal -> FLT_LIT
Rule 49    literal -> DAY
Rule 50    literal -> NIGHT
Rule 51    literal -> CHR_LIT
Rule 52    literal -> STR_LIT
Rule 53    expression -> factor factor_tail
Rule 54    factor -> var_call
Rule 55    factor -> literal
Rule 56    factor -> TILDE literal
Rule 57    factor -> LPAREN expression RPAREN
Rule 58    factor_tail -> empty
Rule 59    factor_tail -> PLUS expression
Rule 60    factor_tail -> MINUS expression
Rule 61    factor_tail -> MULTIPLY expression
Rule 62    factor_tail -> DIVISION expression
Rule 63    factor_tail -> MODULO expression
Rule 64    factor_tail -> EXPONENT expression
Rule 65    factor_tail -> GT expression
Rule 66    factor_tail -> LT expression
Rule 67    factor_tail -> EQ_EQ expression
Rule 68    factor_tail -> GT_EQ expression
Rule 69    factor_tail -> LT_EQ expression
Rule 70    factor_tail -> NOT_EQ expression
Rule 71    factor_tail -> AND expression
Rule 72    factor_tail -> OR expression
Rule 73    var_call -> IDENT var_call_tail
Rule 74    var_call_tail -> empty
Rule 75    var_call_tail -> LBRACKET index RBRACKET
Rule 76    function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
Rule 77    function_statements -> empty
Rule 78    function_statements_tail -> function_statements
Rule 79    function_statements_tail -> empty
Rule 80    ret_type -> FUNCTION
Rule 81    ret_type -> function_dtype
Rule 82    function_dtype -> FUNCTION_INT
Rule 83    function_dtype -> FUNCTION_FLT
Rule 84    function_dtype -> FUNCTION_CHR
Rule 85    function_dtype -> FUNCTION_BLN
Rule 86    function_dtype -> FUNCTION_STR
Rule 87    function_dtype -> FUNCTION_LIST_INT
Rule 88    function_dtype -> FUNCTION_LIST_FLT
Rule 89    function_dtype -> FUNCTION_LIST_CHR
Rule 90    function_dtype -> FUNCTION_LIST_STR
Rule 91    function_dtype -> FUNCTION_LIST_BLN
Rule 92    parameters -> data_type IDENT parameters_tail
Rule 93    parameters -> empty
Rule 94    parameters_tail -> empty
Rule 95    parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 96    revive -> REVIVE revive_value
Rule 97    revive -> empty
Rule 98    revive_value -> revive_type_cast
Rule 99    revive_value -> expression
Rule 100   revive_value -> function_call
Rule 101   revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 102   revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 103   revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 104   revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 105   statements -> empty
Rule 106   statements -> local_dec maybe_newline statements_tail
Rule 107   statements_tail -> string_operation_statement unli_newline statements
Rule 108   statements_tail -> conditional_statement unli_newline statements
Rule 109   statements_tail -> switch_statement unli_newline statements
Rule 110   statements_tail -> loop_statement unli_newline statements
Rule 111   statements_tail -> function_call unli_newline statements
Rule 112   statements_tail -> output_statement unli_newline statements
Rule 113   statements_tail -> statements
Rule 114   local_dec -> empty
Rule 115   local_dec -> var_statement
Rule 116   conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
Rule 117   conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
Rule 118   conditional_tail -> empty
Rule 119   condition -> condition_factor condition_factor_tail
Rule 120   condition_factor -> var_call
Rule 121   condition_factor -> condition_literal
Rule 122   condition_factor -> TILDE condition_literal
Rule 123   condition_factor -> LPAREN condition RPAREN
Rule 124   condition_factor_tail -> empty
Rule 125   condition_factor_tail -> PLUS condition
Rule 126   condition_factor_tail -> MINUS condition
Rule 127   condition_factor_tail -> MULTIPLY condition
Rule 128   condition_factor_tail -> DIVISION condition
Rule 129   condition_factor_tail -> MODULO condition
Rule 130   condition_factor_tail -> EXPONENT condition
Rule 131   condition_factor_tail -> GT condition
Rule 132   condition_factor_tail -> LT condition
Rule 133   condition_factor_tail -> EQ_EQ condition
Rule 134   condition_factor_tail -> GT_EQ condition
Rule 135   condition_factor_tail -> LT_EQ condition
Rule 136   condition_factor_tail -> NOT_EQ condition
Rule 137   condition_factor_tail -> AND condition
Rule 138   condition_factor_tail -> OR condition
Rule 139   condition_literal -> INT_LIT
Rule 140   condition_literal -> FLT_LIT
Rule 141   condition_literal -> DAY
Rule 142   condition_literal -> NIGHT
Rule 143   condition_literal -> CHR_LIT
Rule 144   condition_literal -> STR_LIT
Rule 145   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
Rule 146   switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail
Rule 147   switchcond_tail -> empty
Rule 148   switchcond_tail -> switch_condition
Rule 149   loop_statement -> for_loop
Rule 150   loop_statement -> until_loop
Rule 151   loop_statement -> repeat_until
Rule 152   for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
Rule 153   for_loop_condition -> for_loop_condition_factor for_loop_condition_factor_tail
Rule 154   for_loop_condition_factor -> var_call
Rule 155   for_loop_condition_factor -> for_loop_condition_literal
Rule 156   for_loop_condition_factor -> TILDE for_loop_condition_literal
Rule 157   for_loop_condition_factor -> LPAREN for_loop_condition RPAREN
Rule 158   for_loop_condition_factor_tail -> empty
Rule 159   for_loop_condition_factor_tail -> PLUS for_loop_condition
Rule 160   for_loop_condition_factor_tail -> MINUS for_loop_condition
Rule 161   for_loop_condition_factor_tail -> MULTIPLY for_loop_condition
Rule 162   for_loop_condition_factor_tail -> DIVISION for_loop_condition
Rule 163   for_loop_condition_factor_tail -> MODULO for_loop_condition
Rule 164   for_loop_condition_factor_tail -> EXPONENT for_loop_condition
Rule 165   for_loop_condition_factor_tail -> GT for_loop_condition
Rule 166   for_loop_condition_factor_tail -> LT for_loop_condition
Rule 167   for_loop_condition_factor_tail -> EQ_EQ for_loop_condition
Rule 168   for_loop_condition_factor_tail -> GT_EQ for_loop_condition
Rule 169   for_loop_condition_factor_tail -> LT_EQ for_loop_condition
Rule 170   for_loop_condition_factor_tail -> NOT_EQ for_loop_condition
Rule 171   for_loop_condition_factor_tail -> AND for_loop_condition
Rule 172   for_loop_condition_factor_tail -> OR for_loop_condition
Rule 173   for_loop_condition_literal -> INT_LIT
Rule 174   for_loop_condition_literal -> FLT_LIT
Rule 175   for_loop_condition_literal -> DAY
Rule 176   for_loop_condition_literal -> NIGHT
Rule 177   for_loop_condition_literal -> CHR_LIT
Rule 178   for_loop_condition_literal -> STR_LIT
Rule 179   until_loop -> UNTIL LPAREN until_loop_condition RPAREN LBRACE maybe_newline statements RBRACE
Rule 180   repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN until_loop_condition RPAREN
Rule 181   until_loop_condition -> until_loop_condition_factor until_loop_condition_factor_tail
Rule 182   until_loop_condition_factor -> var_call
Rule 183   until_loop_condition_factor -> until_loop_condition_literal
Rule 184   until_loop_condition_factor -> TILDE until_loop_condition_literal
Rule 185   until_loop_condition_factor -> LPAREN until_loop_condition RPAREN
Rule 186   until_loop_condition_factor_tail -> empty
Rule 187   until_loop_condition_factor_tail -> PLUS until_loop_condition
Rule 188   until_loop_condition_factor_tail -> MINUS until_loop_condition
Rule 189   until_loop_condition_factor_tail -> MULTIPLY until_loop_condition
Rule 190   until_loop_condition_factor_tail -> DIVISION until_loop_condition
Rule 191   until_loop_condition_factor_tail -> MODULO until_loop_condition
Rule 192   until_loop_condition_factor_tail -> EXPONENT until_loop_condition
Rule 193   until_loop_condition_factor_tail -> GT until_loop_condition
Rule 194   until_loop_condition_factor_tail -> LT until_loop_condition
Rule 195   until_loop_condition_factor_tail -> EQ_EQ until_loop_condition
Rule 196   until_loop_condition_factor_tail -> GT_EQ until_loop_condition
Rule 197   until_loop_condition_factor_tail -> LT_EQ until_loop_condition
Rule 198   until_loop_condition_factor_tail -> NOT_EQ until_loop_condition
Rule 199   until_loop_condition_factor_tail -> AND until_loop_condition
Rule 200   until_loop_condition_factor_tail -> OR until_loop_condition
Rule 201   until_loop_condition_literal -> INT_LIT
Rule 202   until_loop_condition_literal -> FLT_LIT
Rule 203   until_loop_condition_literal -> DAY
Rule 204   until_loop_condition_literal -> NIGHT
Rule 205   until_loop_condition_literal -> CHR_LIT
Rule 206   until_loop_condition_literal -> STR_LIT
Rule 207   control_variable -> INT IDENT EQ control_var_tail
Rule 208   control_var_tail -> INT_LIT
Rule 209   control_var_tail -> var_call
Rule 210   update -> var_call update_tail
Rule 211   update_tail -> postfix
Rule 212   update_tail -> assign_op value
Rule 213   postfix -> PLUS_PLUS
Rule 214   postfix -> MINUS_MINUS
Rule 215   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 216   function_call -> input_statement
Rule 217   arguments -> empty
Rule 218   arguments -> arg_value arg_tail
Rule 219   arg_tail -> empty
Rule 220   arg_tail -> COMMA arg_value arg_tail
Rule 221   arg_value -> literal
Rule 222   arg_value -> var_call
Rule 223   output_statement -> DISPLAY output_value next_val
Rule 224   output_statement -> DISPLAY LPAREN output_value next_val RPAREN
Rule 225   output_value -> output_type_cast
Rule 226   output_value -> expression
Rule 227   output_value -> function_call
Rule 228   output_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 229   output_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 230   output_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 231   output_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 232   next_val -> empty
Rule 233   next_val -> COMMA value next_val
Rule 234   input_statement -> INPUT LPAREN RPAREN
Rule 235   string_operation_statement -> var_call string_operation_tail
Rule 236   string_operation_tail -> PLUS string_val stringcon_tail
Rule 237   string_operation_tail -> update_tail
Rule 238   assign_op -> PLUS_EQ
Rule 239   assign_op -> MINUS_EQ
Rule 240   assign_op -> MUL_EQ
Rule 241   assign_op -> DIV_EQ
Rule 242   assign_op -> MOD_EQ
Rule 243   assign_op -> EQ
Rule 244   stringcon_tail -> empty
Rule 245   stringcon_tail -> PLUS string_val stringcon_tail
Rule 246   string_val -> var_call
Rule 247   string_val -> STR_LIT
Rule 248   empty -> <empty>

Terminals, with rules where they appear

AND                  : 71 137 171 199
BIRTH                : 1
BLN                  : 34
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 116
CHR                  : 35
CHR_LIT              : 51 143 177 205
COLON                : 146
COMMA                : 12 15 22 24 29 95 220 233
COMMENT              : 
CONVERT_TO_BLN       : 42 103 230
CONVERT_TO_FLT       : 41 102 229
CONVERT_TO_INT       : 40 101 228
CONVERT_TO_STR       : 43 104 231
DAY                  : 49 141 175 203
DISPLAY              : 223 224
DIVISION             : 62 128 162 190
DIV_EQ               : 241
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 13 21 207 243
EQ_EQ                : 67 133 167 195
EXPONENT             : 64 130 164 192
FLT                  : 33
FLT_LIT              : 48 140 174 202
FOR                  : 152
FUNCTION             : 80
FUNCTION_BLN         : 85
FUNCTION_CHR         : 84
FUNCTION_FLT         : 83
FUNCTION_INT         : 82
FUNCTION_LIST_BLN    : 91
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 89
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 88
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 87
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 90
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 45 76 215
FUNCTION_STR         : 86
GHOST                : 1
GT                   : 65 131 165 193
GT_EQ                : 68 134 168 196
IDENT                : 10 12 15 19 22 24 31 73 92 95 145 207
ILLEGAL              : 
IN                   : 
INPUT                : 234
INT                  : 32 207
INT_LIT              : 30 47 139 173 201 208
LBRACE               : 6 76 116 116 117 145 145 152 179 180
LBRACKET             : 17 26 75
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 40 41 42 43 45 57 76 101 102 103 104 116 117 123 145 152 157 179 180 185 215 224 228 229 230 231 234
LT                   : 66 132 166 194
LT_EQ                : 69 135 169 197
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 60 126 160 188
MINUS_EQ             : 239
MINUS_MINUS          : 214
MODULO               : 63 129 163 191
MOD_EQ               : 242
MULTIPLY             : 61 127 161 189
MUL_EQ               : 240
NEWLINE              : 3 4 5
NIGHT                : 50 142 176 204
NOT                  : 
NOT_EQ               : 70 136 170 198
OR                   : 72 138 172 200
OTHERWISE            : 116 145
OTHERWISE_CHECK      : 117
PLUS                 : 59 125 159 187 236 245
PLUS_EQ              : 238
PLUS_PLUS            : 213
POW                  : 
RBRACE               : 6 76 116 116 117 145 145 152 179 180
RBRACKET             : 17 26 75
REPEAT               : 180
REVIVE               : 96
RPAREN               : 6 40 41 42 43 45 57 76 101 102 103 104 116 117 123 145 152 157 179 180 185 215 224 228 229 230 231 234
SEMICOLON            : 152 152
SHIFT                : 146
SKIP                 : 
STOP                 : 
STR                  : 36
STR_LIT              : 52 144 178 206 247
SWAP                 : 145
TILDE                : 56 122 156 184
TYPE                 : 
UNTIL                : 179 180
error                : 

Nonterminals, with rules where they appear

arg_tail             : 218 220
arg_value            : 218 220
arguments            : 215
assign_op            : 212
condition            : 116 117 123 125 126 127 128 129 130 131 132 133 134 135 136 137 138
condition_factor     : 119
condition_factor_tail : 119
condition_literal    : 121 122
conditional_statement : 108
conditional_tail     : 116 117
control_var_tail     : 207
control_variable     : 152
data_type            : 10 19 92 95
element_tail         : 27
empty                : 2 8 11 14 20 23 28 58 74 77 79 93 94 97 105 114 118 124 147 158 186 217 219 232 244
expression           : 18 38 44 57 59 60 61 62 63 64 65 66 67 68 69 70 71 72 99 226
factor               : 53
factor_tail          : 53
for_loop             : 149
for_loop_condition   : 152 157 159 160 161 162 163 164 165 166 167 168 169 170 171 172
for_loop_condition_factor : 153
for_loop_condition_factor_tail : 153
for_loop_condition_literal : 155 156
function_call        : 39 100 111 227
function_dtype       : 81
function_statements  : 1 78
function_statements_tail : 76
global_dec           : 1 9
global_dec_value     : 13
global_statement     : 7
global_statement_tail : 10 12 15
global_tail          : 7
global_tail2         : 13
global_value         : 16
index                : 75
input_statement      : 46 216
list_element         : 17 26 29
literal              : 27 55 56 221
local_dec            : 106
loop_statement       : 110
main_function        : 1
maybe_newline        : 1 1 3 6 6 6 76 76 106 116 116 116 116 116 117 117 117 145 145 145 145 145 145 146 152 152 179 180
next_val             : 223 224 233
output_statement     : 112
output_type_cast     : 225
output_value         : 223 224
parameters           : 76
parameters_tail      : 92 95
postfix              : 211
program              : 0
repeat_until         : 151
ret_type             : 76
revive               : 76
revive_type_cast     : 98
revive_value         : 96
statements           : 6 76 107 108 109 110 111 112 113 116 116 117 145 146 152 179 180
statements_tail      : 106
string_operation_statement : 107
string_operation_tail : 235
string_val           : 236 245
stringcon_tail       : 236 245
switch_condition     : 145 148
switch_statement     : 109
switchcond_tail      : 146
tail_value           : 21
type_cast            : 37
typecast_value       : 40 41 42 43 101 102 103 104 228 229 230 231
unli_newline         : 1 1 5 7 19 76 107 108 109 110 111 112
until_loop           : 150
until_loop_condition : 179 180 185 187 188 189 190 191 192 193 194 195 196 197 198 199 200
until_loop_condition_factor : 181
until_loop_condition_factor_tail : 181
until_loop_condition_literal : 183 184
update               : 152
update_tail          : 210 237
value                : 25 146 212 233
var_call             : 54 120 154 182 209 210 222 235 246
var_call_tail        : 73
var_statement        : 115
var_tail             : 19 22 24
var_tail2            : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . data_type IDENT global_statement_tail
    (248) empty -> .
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 248 (empty -> .)
    FUNCTION        reduce using rule 248 (empty -> .)
    FUNCTION_INT    reduce using rule 248 (empty -> .)
    FUNCTION_FLT    reduce using rule 248 (empty -> .)
    FUNCTION_CHR    reduce using rule 248 (empty -> .)
    FUNCTION_BLN    reduce using rule 248 (empty -> .)
    FUNCTION_STR    reduce using rule 248 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 248 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 248 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 248 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 248 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 248 (empty -> .)
    MAIN_CASPER     reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    INPUT           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 14

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    FUNCTION        reduce using rule 248 (empty -> .)
    FUNCTION_INT    reduce using rule 248 (empty -> .)
    FUNCTION_FLT    reduce using rule 248 (empty -> .)
    FUNCTION_CHR    reduce using rule 248 (empty -> .)
    FUNCTION_BLN    reduce using rule 248 (empty -> .)
    FUNCTION_STR    reduce using rule 248 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 248 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 248 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 248 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 248 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 248 (empty -> .)
    MAIN_CASPER     reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 15
    empty                          shift and go to state 16

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 18

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)


state 8

    (10) global_statement -> data_type . IDENT global_statement_tail

    IDENT           shift and go to state 19


state 9

    (32) data_type -> INT .

    IDENT           reduce using rule 32 (data_type -> INT .)


state 10

    (33) data_type -> FLT .

    IDENT           reduce using rule 33 (data_type -> FLT .)


state 11

    (34) data_type -> BLN .

    IDENT           reduce using rule 34 (data_type -> BLN .)


state 12

    (35) data_type -> CHR .

    IDENT           reduce using rule 35 (data_type -> CHR .)


state 13

    (36) data_type -> STR .

    IDENT           reduce using rule 36 (data_type -> STR .)


state 14

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    INPUT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 15

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (76) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (77) function_statements -> . empty
    (80) ret_type -> . FUNCTION
    (81) ret_type -> . function_dtype
    (248) empty -> .
    (82) function_dtype -> . FUNCTION_INT
    (83) function_dtype -> . FUNCTION_FLT
    (84) function_dtype -> . FUNCTION_CHR
    (85) function_dtype -> . FUNCTION_BLN
    (86) function_dtype -> . FUNCTION_STR
    (87) function_dtype -> . FUNCTION_LIST_INT
    (88) function_dtype -> . FUNCTION_LIST_FLT
    (89) function_dtype -> . FUNCTION_LIST_CHR
    (90) function_dtype -> . FUNCTION_LIST_STR
    (91) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 23
    NEWLINE         reduce using rule 248 (empty -> .)
    MAIN_CASPER     reduce using rule 248 (empty -> .)
    FUNCTION_INT    shift and go to state 25
    FUNCTION_FLT    shift and go to state 26
    FUNCTION_CHR    shift and go to state 27
    FUNCTION_BLN    shift and go to state 28
    FUNCTION_STR    shift and go to state 29
    FUNCTION_LIST_INT shift and go to state 30
    FUNCTION_LIST_FLT shift and go to state 31
    FUNCTION_LIST_CHR shift and go to state 32
    FUNCTION_LIST_STR shift and go to state 33
    FUNCTION_LIST_BLN shift and go to state 34

    function_statements            shift and go to state 20
    ret_type                       shift and go to state 21
    empty                          shift and go to state 22
    function_dtype                 shift and go to state 24

state 16

    (2) maybe_newline -> empty .

    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    INPUT           reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE_CHECK reduce using rule 2 (maybe_newline -> empty .)


state 17

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    FUNCTION        reduce using rule 248 (empty -> .)
    FUNCTION_INT    reduce using rule 248 (empty -> .)
    FUNCTION_FLT    reduce using rule 248 (empty -> .)
    FUNCTION_CHR    reduce using rule 248 (empty -> .)
    FUNCTION_BLN    reduce using rule 248 (empty -> .)
    FUNCTION_STR    reduce using rule 248 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 248 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 248 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 248 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 248 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 248 (empty -> .)
    MAIN_CASPER     reduce using rule 248 (empty -> .)
    LBRACE          reduce using rule 248 (empty -> .)
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    REVIVE          reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    OTHERWISE_CHECK reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 35
    empty                          shift and go to state 16

state 18

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . data_type IDENT global_statement_tail
    (248) empty -> .
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 248 (empty -> .)
    FUNCTION        reduce using rule 248 (empty -> .)
    FUNCTION_INT    reduce using rule 248 (empty -> .)
    FUNCTION_FLT    reduce using rule 248 (empty -> .)
    FUNCTION_CHR    reduce using rule 248 (empty -> .)
    FUNCTION_BLN    reduce using rule 248 (empty -> .)
    FUNCTION_STR    reduce using rule 248 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 248 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 248 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 248 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 248 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 248 (empty -> .)
    MAIN_CASPER     reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 36
    global_dec                     shift and go to state 37
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 19

    (10) global_statement -> data_type IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (248) empty -> .

    COMMA           shift and go to state 40
    EQ              shift and go to state 41
    NEWLINE         reduce using rule 248 (empty -> .)

    global_statement_tail          shift and go to state 38
    empty                          shift and go to state 39

state 20

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 42
    empty                          shift and go to state 16

state 21

    (76) function_statements -> ret_type . FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail

    FUNCTION_NAME   shift and go to state 43


state 22

    (77) function_statements -> empty .

    NEWLINE         reduce using rule 77 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 77 (function_statements -> empty .)


state 23

    (80) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 80 (ret_type -> FUNCTION .)


state 24

    (81) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 81 (ret_type -> function_dtype .)


state 25

    (82) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 82 (function_dtype -> FUNCTION_INT .)


state 26

    (83) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 83 (function_dtype -> FUNCTION_FLT .)


state 27

    (84) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 84 (function_dtype -> FUNCTION_CHR .)


state 28

    (85) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 85 (function_dtype -> FUNCTION_BLN .)


state 29

    (86) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 86 (function_dtype -> FUNCTION_STR .)


state 30

    (87) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 87 (function_dtype -> FUNCTION_LIST_INT .)


state 31

    (88) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 88 (function_dtype -> FUNCTION_LIST_FLT .)


state 32

    (89) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 89 (function_dtype -> FUNCTION_LIST_CHR .)


state 33

    (90) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 90 (function_dtype -> FUNCTION_LIST_STR .)


state 34

    (91) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 91 (function_dtype -> FUNCTION_LIST_BLN .)


state 35

    (3) maybe_newline -> NEWLINE maybe_newline .

    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INPUT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE_CHECK reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 36

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 37

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)


state 38

    (10) global_statement -> data_type IDENT global_statement_tail .

    NEWLINE         reduce using rule 10 (global_statement -> data_type IDENT global_statement_tail .)


state 39

    (11) global_statement_tail -> empty .

    NEWLINE         reduce using rule 11 (global_statement_tail -> empty .)


state 40

    (12) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 44


state 41

    (13) global_statement_tail -> EQ . global_dec_value global_tail2
    (16) global_dec_value -> . global_value
    (17) global_dec_value -> . LBRACKET list_element RBRACKET
    (18) global_value -> . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LBRACKET        shift and go to state 47
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    global_dec_value               shift and go to state 45
    global_value                   shift and go to state 46
    expression                     shift and go to state 48
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 42

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 62

    main_function                  shift and go to state 61

state 43

    (76) function_statements -> ret_type FUNCTION_NAME . LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail

    LPAREN          shift and go to state 63


state 44

    (12) global_statement_tail -> COMMA IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (248) empty -> .

    COMMA           shift and go to state 40
    EQ              shift and go to state 41
    NEWLINE         reduce using rule 248 (empty -> .)

    global_statement_tail          shift and go to state 64
    empty                          shift and go to state 39

state 45

    (13) global_statement_tail -> EQ global_dec_value . global_tail2
    (14) global_tail2 -> . empty
    (15) global_tail2 -> . COMMA IDENT global_statement_tail
    (248) empty -> .

    COMMA           shift and go to state 67
    NEWLINE         reduce using rule 248 (empty -> .)

    global_tail2                   shift and go to state 65
    empty                          shift and go to state 66

state 46

    (16) global_dec_value -> global_value .

    COMMA           reduce using rule 16 (global_dec_value -> global_value .)
    NEWLINE         reduce using rule 16 (global_dec_value -> global_value .)


state 47

    (17) global_dec_value -> LBRACKET . list_element RBRACKET
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    list_element                   shift and go to state 68
    literal                        shift and go to state 69

state 48

    (18) global_value -> expression .

    COMMA           reduce using rule 18 (global_value -> expression .)
    NEWLINE         reduce using rule 18 (global_value -> expression .)


state 49

    (53) expression -> factor . factor_tail
    (58) factor_tail -> . empty
    (59) factor_tail -> . PLUS expression
    (60) factor_tail -> . MINUS expression
    (61) factor_tail -> . MULTIPLY expression
    (62) factor_tail -> . DIVISION expression
    (63) factor_tail -> . MODULO expression
    (64) factor_tail -> . EXPONENT expression
    (65) factor_tail -> . GT expression
    (66) factor_tail -> . LT expression
    (67) factor_tail -> . EQ_EQ expression
    (68) factor_tail -> . GT_EQ expression
    (69) factor_tail -> . LT_EQ expression
    (70) factor_tail -> . NOT_EQ expression
    (71) factor_tail -> . AND expression
    (72) factor_tail -> . OR expression
    (248) empty -> .

    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    MULTIPLY        shift and go to state 74
    DIVISION        shift and go to state 75
    MODULO          shift and go to state 76
    EXPONENT        shift and go to state 77
    GT              shift and go to state 78
    LT              shift and go to state 79
    EQ_EQ           shift and go to state 80
    GT_EQ           shift and go to state 81
    LT_EQ           shift and go to state 82
    NOT_EQ          shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85
    COMMA           reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RPAREN          reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    COLON           reduce using rule 248 (empty -> .)

    factor_tail                    shift and go to state 70
    empty                          shift and go to state 71

state 50

    (54) factor -> var_call .

    PLUS            reduce using rule 54 (factor -> var_call .)
    MINUS           reduce using rule 54 (factor -> var_call .)
    MULTIPLY        reduce using rule 54 (factor -> var_call .)
    DIVISION        reduce using rule 54 (factor -> var_call .)
    MODULO          reduce using rule 54 (factor -> var_call .)
    EXPONENT        reduce using rule 54 (factor -> var_call .)
    GT              reduce using rule 54 (factor -> var_call .)
    LT              reduce using rule 54 (factor -> var_call .)
    EQ_EQ           reduce using rule 54 (factor -> var_call .)
    GT_EQ           reduce using rule 54 (factor -> var_call .)
    LT_EQ           reduce using rule 54 (factor -> var_call .)
    NOT_EQ          reduce using rule 54 (factor -> var_call .)
    AND             reduce using rule 54 (factor -> var_call .)
    OR              reduce using rule 54 (factor -> var_call .)
    COMMA           reduce using rule 54 (factor -> var_call .)
    NEWLINE         reduce using rule 54 (factor -> var_call .)
    RPAREN          reduce using rule 54 (factor -> var_call .)
    RBRACE          reduce using rule 54 (factor -> var_call .)
    COLON           reduce using rule 54 (factor -> var_call .)


state 51

    (55) factor -> literal .

    PLUS            reduce using rule 55 (factor -> literal .)
    MINUS           reduce using rule 55 (factor -> literal .)
    MULTIPLY        reduce using rule 55 (factor -> literal .)
    DIVISION        reduce using rule 55 (factor -> literal .)
    MODULO          reduce using rule 55 (factor -> literal .)
    EXPONENT        reduce using rule 55 (factor -> literal .)
    GT              reduce using rule 55 (factor -> literal .)
    LT              reduce using rule 55 (factor -> literal .)
    EQ_EQ           reduce using rule 55 (factor -> literal .)
    GT_EQ           reduce using rule 55 (factor -> literal .)
    LT_EQ           reduce using rule 55 (factor -> literal .)
    NOT_EQ          reduce using rule 55 (factor -> literal .)
    AND             reduce using rule 55 (factor -> literal .)
    OR              reduce using rule 55 (factor -> literal .)
    COMMA           reduce using rule 55 (factor -> literal .)
    NEWLINE         reduce using rule 55 (factor -> literal .)
    RPAREN          reduce using rule 55 (factor -> literal .)
    RBRACE          reduce using rule 55 (factor -> literal .)
    COLON           reduce using rule 55 (factor -> literal .)


state 52

    (56) factor -> TILDE . literal
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    literal                        shift and go to state 86

state 53

    (57) factor -> LPAREN . expression RPAREN
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 87
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 54

    (73) var_call -> IDENT . var_call_tail
    (74) var_call_tail -> . empty
    (75) var_call_tail -> . LBRACKET index RBRACKET
    (248) empty -> .

    LBRACKET        shift and go to state 90
    PLUS            reduce using rule 248 (empty -> .)
    MINUS           reduce using rule 248 (empty -> .)
    MULTIPLY        reduce using rule 248 (empty -> .)
    DIVISION        reduce using rule 248 (empty -> .)
    MODULO          reduce using rule 248 (empty -> .)
    EXPONENT        reduce using rule 248 (empty -> .)
    GT              reduce using rule 248 (empty -> .)
    LT              reduce using rule 248 (empty -> .)
    EQ_EQ           reduce using rule 248 (empty -> .)
    GT_EQ           reduce using rule 248 (empty -> .)
    LT_EQ           reduce using rule 248 (empty -> .)
    NOT_EQ          reduce using rule 248 (empty -> .)
    AND             reduce using rule 248 (empty -> .)
    OR              reduce using rule 248 (empty -> .)
    COMMA           reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RPAREN          reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    COLON           reduce using rule 248 (empty -> .)
    PLUS_PLUS       reduce using rule 248 (empty -> .)
    MINUS_MINUS     reduce using rule 248 (empty -> .)
    PLUS_EQ         reduce using rule 248 (empty -> .)
    MINUS_EQ        reduce using rule 248 (empty -> .)
    MUL_EQ          reduce using rule 248 (empty -> .)
    DIV_EQ          reduce using rule 248 (empty -> .)
    MOD_EQ          reduce using rule 248 (empty -> .)
    EQ              reduce using rule 248 (empty -> .)
    SEMICOLON       reduce using rule 248 (empty -> .)

    var_call_tail                  shift and go to state 88
    empty                          shift and go to state 89

state 55

    (47) literal -> INT_LIT .

    PLUS            reduce using rule 47 (literal -> INT_LIT .)
    MINUS           reduce using rule 47 (literal -> INT_LIT .)
    MULTIPLY        reduce using rule 47 (literal -> INT_LIT .)
    DIVISION        reduce using rule 47 (literal -> INT_LIT .)
    MODULO          reduce using rule 47 (literal -> INT_LIT .)
    EXPONENT        reduce using rule 47 (literal -> INT_LIT .)
    GT              reduce using rule 47 (literal -> INT_LIT .)
    LT              reduce using rule 47 (literal -> INT_LIT .)
    EQ_EQ           reduce using rule 47 (literal -> INT_LIT .)
    GT_EQ           reduce using rule 47 (literal -> INT_LIT .)
    LT_EQ           reduce using rule 47 (literal -> INT_LIT .)
    NOT_EQ          reduce using rule 47 (literal -> INT_LIT .)
    AND             reduce using rule 47 (literal -> INT_LIT .)
    OR              reduce using rule 47 (literal -> INT_LIT .)
    COMMA           reduce using rule 47 (literal -> INT_LIT .)
    NEWLINE         reduce using rule 47 (literal -> INT_LIT .)
    RBRACKET        reduce using rule 47 (literal -> INT_LIT .)
    RPAREN          reduce using rule 47 (literal -> INT_LIT .)
    RBRACE          reduce using rule 47 (literal -> INT_LIT .)
    COLON           reduce using rule 47 (literal -> INT_LIT .)


state 56

    (48) literal -> FLT_LIT .

    PLUS            reduce using rule 48 (literal -> FLT_LIT .)
    MINUS           reduce using rule 48 (literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 48 (literal -> FLT_LIT .)
    DIVISION        reduce using rule 48 (literal -> FLT_LIT .)
    MODULO          reduce using rule 48 (literal -> FLT_LIT .)
    EXPONENT        reduce using rule 48 (literal -> FLT_LIT .)
    GT              reduce using rule 48 (literal -> FLT_LIT .)
    LT              reduce using rule 48 (literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    GT_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    LT_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 48 (literal -> FLT_LIT .)
    AND             reduce using rule 48 (literal -> FLT_LIT .)
    OR              reduce using rule 48 (literal -> FLT_LIT .)
    COMMA           reduce using rule 48 (literal -> FLT_LIT .)
    NEWLINE         reduce using rule 48 (literal -> FLT_LIT .)
    RBRACKET        reduce using rule 48 (literal -> FLT_LIT .)
    RPAREN          reduce using rule 48 (literal -> FLT_LIT .)
    RBRACE          reduce using rule 48 (literal -> FLT_LIT .)
    COLON           reduce using rule 48 (literal -> FLT_LIT .)


state 57

    (49) literal -> DAY .

    PLUS            reduce using rule 49 (literal -> DAY .)
    MINUS           reduce using rule 49 (literal -> DAY .)
    MULTIPLY        reduce using rule 49 (literal -> DAY .)
    DIVISION        reduce using rule 49 (literal -> DAY .)
    MODULO          reduce using rule 49 (literal -> DAY .)
    EXPONENT        reduce using rule 49 (literal -> DAY .)
    GT              reduce using rule 49 (literal -> DAY .)
    LT              reduce using rule 49 (literal -> DAY .)
    EQ_EQ           reduce using rule 49 (literal -> DAY .)
    GT_EQ           reduce using rule 49 (literal -> DAY .)
    LT_EQ           reduce using rule 49 (literal -> DAY .)
    NOT_EQ          reduce using rule 49 (literal -> DAY .)
    AND             reduce using rule 49 (literal -> DAY .)
    OR              reduce using rule 49 (literal -> DAY .)
    COMMA           reduce using rule 49 (literal -> DAY .)
    NEWLINE         reduce using rule 49 (literal -> DAY .)
    RBRACKET        reduce using rule 49 (literal -> DAY .)
    RPAREN          reduce using rule 49 (literal -> DAY .)
    RBRACE          reduce using rule 49 (literal -> DAY .)
    COLON           reduce using rule 49 (literal -> DAY .)


state 58

    (50) literal -> NIGHT .

    PLUS            reduce using rule 50 (literal -> NIGHT .)
    MINUS           reduce using rule 50 (literal -> NIGHT .)
    MULTIPLY        reduce using rule 50 (literal -> NIGHT .)
    DIVISION        reduce using rule 50 (literal -> NIGHT .)
    MODULO          reduce using rule 50 (literal -> NIGHT .)
    EXPONENT        reduce using rule 50 (literal -> NIGHT .)
    GT              reduce using rule 50 (literal -> NIGHT .)
    LT              reduce using rule 50 (literal -> NIGHT .)
    EQ_EQ           reduce using rule 50 (literal -> NIGHT .)
    GT_EQ           reduce using rule 50 (literal -> NIGHT .)
    LT_EQ           reduce using rule 50 (literal -> NIGHT .)
    NOT_EQ          reduce using rule 50 (literal -> NIGHT .)
    AND             reduce using rule 50 (literal -> NIGHT .)
    OR              reduce using rule 50 (literal -> NIGHT .)
    COMMA           reduce using rule 50 (literal -> NIGHT .)
    NEWLINE         reduce using rule 50 (literal -> NIGHT .)
    RBRACKET        reduce using rule 50 (literal -> NIGHT .)
    RPAREN          reduce using rule 50 (literal -> NIGHT .)
    RBRACE          reduce using rule 50 (literal -> NIGHT .)
    COLON           reduce using rule 50 (literal -> NIGHT .)


state 59

    (51) literal -> CHR_LIT .

    PLUS            reduce using rule 51 (literal -> CHR_LIT .)
    MINUS           reduce using rule 51 (literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 51 (literal -> CHR_LIT .)
    DIVISION        reduce using rule 51 (literal -> CHR_LIT .)
    MODULO          reduce using rule 51 (literal -> CHR_LIT .)
    EXPONENT        reduce using rule 51 (literal -> CHR_LIT .)
    GT              reduce using rule 51 (literal -> CHR_LIT .)
    LT              reduce using rule 51 (literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    GT_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    LT_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 51 (literal -> CHR_LIT .)
    AND             reduce using rule 51 (literal -> CHR_LIT .)
    OR              reduce using rule 51 (literal -> CHR_LIT .)
    COMMA           reduce using rule 51 (literal -> CHR_LIT .)
    NEWLINE         reduce using rule 51 (literal -> CHR_LIT .)
    RBRACKET        reduce using rule 51 (literal -> CHR_LIT .)
    RPAREN          reduce using rule 51 (literal -> CHR_LIT .)
    RBRACE          reduce using rule 51 (literal -> CHR_LIT .)
    COLON           reduce using rule 51 (literal -> CHR_LIT .)


state 60

    (52) literal -> STR_LIT .

    PLUS            reduce using rule 52 (literal -> STR_LIT .)
    MINUS           reduce using rule 52 (literal -> STR_LIT .)
    MULTIPLY        reduce using rule 52 (literal -> STR_LIT .)
    DIVISION        reduce using rule 52 (literal -> STR_LIT .)
    MODULO          reduce using rule 52 (literal -> STR_LIT .)
    EXPONENT        reduce using rule 52 (literal -> STR_LIT .)
    GT              reduce using rule 52 (literal -> STR_LIT .)
    LT              reduce using rule 52 (literal -> STR_LIT .)
    EQ_EQ           reduce using rule 52 (literal -> STR_LIT .)
    GT_EQ           reduce using rule 52 (literal -> STR_LIT .)
    LT_EQ           reduce using rule 52 (literal -> STR_LIT .)
    NOT_EQ          reduce using rule 52 (literal -> STR_LIT .)
    AND             reduce using rule 52 (literal -> STR_LIT .)
    OR              reduce using rule 52 (literal -> STR_LIT .)
    COMMA           reduce using rule 52 (literal -> STR_LIT .)
    NEWLINE         reduce using rule 52 (literal -> STR_LIT .)
    RBRACKET        reduce using rule 52 (literal -> STR_LIT .)
    RPAREN          reduce using rule 52 (literal -> STR_LIT .)
    RBRACE          reduce using rule 52 (literal -> STR_LIT .)
    COLON           reduce using rule 52 (literal -> STR_LIT .)


state 61

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 91

state 62

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 92


state 63

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN . parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (92) parameters -> . data_type IDENT parameters_tail
    (93) parameters -> . empty
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR
    (248) empty -> .

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13
    RPAREN          reduce using rule 248 (empty -> .)

    parameters                     shift and go to state 93
    data_type                      shift and go to state 94
    empty                          shift and go to state 95

state 64

    (12) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 12 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 65

    (13) global_statement_tail -> EQ global_dec_value global_tail2 .

    NEWLINE         reduce using rule 13 (global_statement_tail -> EQ global_dec_value global_tail2 .)


state 66

    (14) global_tail2 -> empty .

    NEWLINE         reduce using rule 14 (global_tail2 -> empty .)


state 67

    (15) global_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 96


state 68

    (17) global_dec_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 97


state 69

    (27) list_element -> literal . element_tail
    (28) element_tail -> . empty
    (29) element_tail -> . COMMA list_element
    (248) empty -> .

    COMMA           shift and go to state 100
    RBRACKET        reduce using rule 248 (empty -> .)

    element_tail                   shift and go to state 98
    empty                          shift and go to state 99

state 70

    (53) expression -> factor factor_tail .

    COMMA           reduce using rule 53 (expression -> factor factor_tail .)
    NEWLINE         reduce using rule 53 (expression -> factor factor_tail .)
    RPAREN          reduce using rule 53 (expression -> factor factor_tail .)
    RBRACE          reduce using rule 53 (expression -> factor factor_tail .)
    COLON           reduce using rule 53 (expression -> factor factor_tail .)


state 71

    (58) factor_tail -> empty .

    COMMA           reduce using rule 58 (factor_tail -> empty .)
    NEWLINE         reduce using rule 58 (factor_tail -> empty .)
    RPAREN          reduce using rule 58 (factor_tail -> empty .)
    RBRACE          reduce using rule 58 (factor_tail -> empty .)
    COLON           reduce using rule 58 (factor_tail -> empty .)


state 72

    (59) factor_tail -> PLUS . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 101
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 73

    (60) factor_tail -> MINUS . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 102
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 74

    (61) factor_tail -> MULTIPLY . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 103
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 75

    (62) factor_tail -> DIVISION . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 104
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 76

    (63) factor_tail -> MODULO . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 105
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 77

    (64) factor_tail -> EXPONENT . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 106
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 78

    (65) factor_tail -> GT . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 107
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 79

    (66) factor_tail -> LT . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 108
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 80

    (67) factor_tail -> EQ_EQ . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 109
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 81

    (68) factor_tail -> GT_EQ . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 110
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 82

    (69) factor_tail -> LT_EQ . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 111
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 83

    (70) factor_tail -> NOT_EQ . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 112
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 84

    (71) factor_tail -> AND . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 113
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 85

    (72) factor_tail -> OR . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 114
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 86

    (56) factor -> TILDE literal .

    PLUS            reduce using rule 56 (factor -> TILDE literal .)
    MINUS           reduce using rule 56 (factor -> TILDE literal .)
    MULTIPLY        reduce using rule 56 (factor -> TILDE literal .)
    DIVISION        reduce using rule 56 (factor -> TILDE literal .)
    MODULO          reduce using rule 56 (factor -> TILDE literal .)
    EXPONENT        reduce using rule 56 (factor -> TILDE literal .)
    GT              reduce using rule 56 (factor -> TILDE literal .)
    LT              reduce using rule 56 (factor -> TILDE literal .)
    EQ_EQ           reduce using rule 56 (factor -> TILDE literal .)
    GT_EQ           reduce using rule 56 (factor -> TILDE literal .)
    LT_EQ           reduce using rule 56 (factor -> TILDE literal .)
    NOT_EQ          reduce using rule 56 (factor -> TILDE literal .)
    AND             reduce using rule 56 (factor -> TILDE literal .)
    OR              reduce using rule 56 (factor -> TILDE literal .)
    COMMA           reduce using rule 56 (factor -> TILDE literal .)
    NEWLINE         reduce using rule 56 (factor -> TILDE literal .)
    RPAREN          reduce using rule 56 (factor -> TILDE literal .)
    RBRACE          reduce using rule 56 (factor -> TILDE literal .)
    COLON           reduce using rule 56 (factor -> TILDE literal .)


state 87

    (57) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 115


state 88

    (73) var_call -> IDENT var_call_tail .

    PLUS            reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MINUS           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MULTIPLY        reduce using rule 73 (var_call -> IDENT var_call_tail .)
    DIVISION        reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MODULO          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    EXPONENT        reduce using rule 73 (var_call -> IDENT var_call_tail .)
    GT              reduce using rule 73 (var_call -> IDENT var_call_tail .)
    LT              reduce using rule 73 (var_call -> IDENT var_call_tail .)
    EQ_EQ           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    GT_EQ           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    LT_EQ           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    NOT_EQ          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    AND             reduce using rule 73 (var_call -> IDENT var_call_tail .)
    OR              reduce using rule 73 (var_call -> IDENT var_call_tail .)
    COMMA           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    NEWLINE         reduce using rule 73 (var_call -> IDENT var_call_tail .)
    RPAREN          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    RBRACE          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    COLON           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    PLUS_PLUS       reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MINUS_MINUS     reduce using rule 73 (var_call -> IDENT var_call_tail .)
    PLUS_EQ         reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MINUS_EQ        reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MUL_EQ          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    DIV_EQ          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MOD_EQ          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    EQ              reduce using rule 73 (var_call -> IDENT var_call_tail .)
    SEMICOLON       reduce using rule 73 (var_call -> IDENT var_call_tail .)


state 89

    (74) var_call_tail -> empty .

    PLUS            reduce using rule 74 (var_call_tail -> empty .)
    MINUS           reduce using rule 74 (var_call_tail -> empty .)
    MULTIPLY        reduce using rule 74 (var_call_tail -> empty .)
    DIVISION        reduce using rule 74 (var_call_tail -> empty .)
    MODULO          reduce using rule 74 (var_call_tail -> empty .)
    EXPONENT        reduce using rule 74 (var_call_tail -> empty .)
    GT              reduce using rule 74 (var_call_tail -> empty .)
    LT              reduce using rule 74 (var_call_tail -> empty .)
    EQ_EQ           reduce using rule 74 (var_call_tail -> empty .)
    GT_EQ           reduce using rule 74 (var_call_tail -> empty .)
    LT_EQ           reduce using rule 74 (var_call_tail -> empty .)
    NOT_EQ          reduce using rule 74 (var_call_tail -> empty .)
    AND             reduce using rule 74 (var_call_tail -> empty .)
    OR              reduce using rule 74 (var_call_tail -> empty .)
    COMMA           reduce using rule 74 (var_call_tail -> empty .)
    NEWLINE         reduce using rule 74 (var_call_tail -> empty .)
    RPAREN          reduce using rule 74 (var_call_tail -> empty .)
    RBRACE          reduce using rule 74 (var_call_tail -> empty .)
    COLON           reduce using rule 74 (var_call_tail -> empty .)
    PLUS_PLUS       reduce using rule 74 (var_call_tail -> empty .)
    MINUS_MINUS     reduce using rule 74 (var_call_tail -> empty .)
    PLUS_EQ         reduce using rule 74 (var_call_tail -> empty .)
    MINUS_EQ        reduce using rule 74 (var_call_tail -> empty .)
    MUL_EQ          reduce using rule 74 (var_call_tail -> empty .)
    DIV_EQ          reduce using rule 74 (var_call_tail -> empty .)
    MOD_EQ          reduce using rule 74 (var_call_tail -> empty .)
    EQ              reduce using rule 74 (var_call_tail -> empty .)
    SEMICOLON       reduce using rule 74 (var_call_tail -> empty .)


state 90

    (75) var_call_tail -> LBRACKET . index RBRACKET
    (30) index -> . INT_LIT
    (31) index -> . IDENT

    INT_LIT         shift and go to state 117
    IDENT           shift and go to state 118

    index                          shift and go to state 116

state 91

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 119


state 92

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 120


state 93

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters . RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail

    RPAREN          shift and go to state 121


state 94

    (92) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 122


state 95

    (93) parameters -> empty .

    RPAREN          reduce using rule 93 (parameters -> empty .)


state 96

    (15) global_tail2 -> COMMA IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (248) empty -> .

    COMMA           shift and go to state 40
    EQ              shift and go to state 41
    NEWLINE         reduce using rule 248 (empty -> .)

    global_statement_tail          shift and go to state 123
    empty                          shift and go to state 39

state 97

    (17) global_dec_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 17 (global_dec_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 17 (global_dec_value -> LBRACKET list_element RBRACKET .)


state 98

    (27) list_element -> literal element_tail .

    RBRACKET        reduce using rule 27 (list_element -> literal element_tail .)


state 99

    (28) element_tail -> empty .

    RBRACKET        reduce using rule 28 (element_tail -> empty .)


state 100

    (29) element_tail -> COMMA . list_element
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    list_element                   shift and go to state 124
    literal                        shift and go to state 69

state 101

    (59) factor_tail -> PLUS expression .

    COMMA           reduce using rule 59 (factor_tail -> PLUS expression .)
    NEWLINE         reduce using rule 59 (factor_tail -> PLUS expression .)
    RPAREN          reduce using rule 59 (factor_tail -> PLUS expression .)
    RBRACE          reduce using rule 59 (factor_tail -> PLUS expression .)
    COLON           reduce using rule 59 (factor_tail -> PLUS expression .)


state 102

    (60) factor_tail -> MINUS expression .

    COMMA           reduce using rule 60 (factor_tail -> MINUS expression .)
    NEWLINE         reduce using rule 60 (factor_tail -> MINUS expression .)
    RPAREN          reduce using rule 60 (factor_tail -> MINUS expression .)
    RBRACE          reduce using rule 60 (factor_tail -> MINUS expression .)
    COLON           reduce using rule 60 (factor_tail -> MINUS expression .)


state 103

    (61) factor_tail -> MULTIPLY expression .

    COMMA           reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    NEWLINE         reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    RPAREN          reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    RBRACE          reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    COLON           reduce using rule 61 (factor_tail -> MULTIPLY expression .)


state 104

    (62) factor_tail -> DIVISION expression .

    COMMA           reduce using rule 62 (factor_tail -> DIVISION expression .)
    NEWLINE         reduce using rule 62 (factor_tail -> DIVISION expression .)
    RPAREN          reduce using rule 62 (factor_tail -> DIVISION expression .)
    RBRACE          reduce using rule 62 (factor_tail -> DIVISION expression .)
    COLON           reduce using rule 62 (factor_tail -> DIVISION expression .)


state 105

    (63) factor_tail -> MODULO expression .

    COMMA           reduce using rule 63 (factor_tail -> MODULO expression .)
    NEWLINE         reduce using rule 63 (factor_tail -> MODULO expression .)
    RPAREN          reduce using rule 63 (factor_tail -> MODULO expression .)
    RBRACE          reduce using rule 63 (factor_tail -> MODULO expression .)
    COLON           reduce using rule 63 (factor_tail -> MODULO expression .)


state 106

    (64) factor_tail -> EXPONENT expression .

    COMMA           reduce using rule 64 (factor_tail -> EXPONENT expression .)
    NEWLINE         reduce using rule 64 (factor_tail -> EXPONENT expression .)
    RPAREN          reduce using rule 64 (factor_tail -> EXPONENT expression .)
    RBRACE          reduce using rule 64 (factor_tail -> EXPONENT expression .)
    COLON           reduce using rule 64 (factor_tail -> EXPONENT expression .)


state 107

    (65) factor_tail -> GT expression .

    COMMA           reduce using rule 65 (factor_tail -> GT expression .)
    NEWLINE         reduce using rule 65 (factor_tail -> GT expression .)
    RPAREN          reduce using rule 65 (factor_tail -> GT expression .)
    RBRACE          reduce using rule 65 (factor_tail -> GT expression .)
    COLON           reduce using rule 65 (factor_tail -> GT expression .)


state 108

    (66) factor_tail -> LT expression .

    COMMA           reduce using rule 66 (factor_tail -> LT expression .)
    NEWLINE         reduce using rule 66 (factor_tail -> LT expression .)
    RPAREN          reduce using rule 66 (factor_tail -> LT expression .)
    RBRACE          reduce using rule 66 (factor_tail -> LT expression .)
    COLON           reduce using rule 66 (factor_tail -> LT expression .)


state 109

    (67) factor_tail -> EQ_EQ expression .

    COMMA           reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    NEWLINE         reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    RPAREN          reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    RBRACE          reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    COLON           reduce using rule 67 (factor_tail -> EQ_EQ expression .)


state 110

    (68) factor_tail -> GT_EQ expression .

    COMMA           reduce using rule 68 (factor_tail -> GT_EQ expression .)
    NEWLINE         reduce using rule 68 (factor_tail -> GT_EQ expression .)
    RPAREN          reduce using rule 68 (factor_tail -> GT_EQ expression .)
    RBRACE          reduce using rule 68 (factor_tail -> GT_EQ expression .)
    COLON           reduce using rule 68 (factor_tail -> GT_EQ expression .)


state 111

    (69) factor_tail -> LT_EQ expression .

    COMMA           reduce using rule 69 (factor_tail -> LT_EQ expression .)
    NEWLINE         reduce using rule 69 (factor_tail -> LT_EQ expression .)
    RPAREN          reduce using rule 69 (factor_tail -> LT_EQ expression .)
    RBRACE          reduce using rule 69 (factor_tail -> LT_EQ expression .)
    COLON           reduce using rule 69 (factor_tail -> LT_EQ expression .)


state 112

    (70) factor_tail -> NOT_EQ expression .

    COMMA           reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    NEWLINE         reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    RPAREN          reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    RBRACE          reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    COLON           reduce using rule 70 (factor_tail -> NOT_EQ expression .)


state 113

    (71) factor_tail -> AND expression .

    COMMA           reduce using rule 71 (factor_tail -> AND expression .)
    NEWLINE         reduce using rule 71 (factor_tail -> AND expression .)
    RPAREN          reduce using rule 71 (factor_tail -> AND expression .)
    RBRACE          reduce using rule 71 (factor_tail -> AND expression .)
    COLON           reduce using rule 71 (factor_tail -> AND expression .)


state 114

    (72) factor_tail -> OR expression .

    COMMA           reduce using rule 72 (factor_tail -> OR expression .)
    NEWLINE         reduce using rule 72 (factor_tail -> OR expression .)
    RPAREN          reduce using rule 72 (factor_tail -> OR expression .)
    RBRACE          reduce using rule 72 (factor_tail -> OR expression .)
    COLON           reduce using rule 72 (factor_tail -> OR expression .)


state 115

    (57) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 57 (factor -> LPAREN expression RPAREN .)


state 116

    (75) var_call_tail -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 125


state 117

    (30) index -> INT_LIT .

    RBRACKET        reduce using rule 30 (index -> INT_LIT .)


state 118

    (31) index -> IDENT .

    RBRACKET        reduce using rule 31 (index -> IDENT .)


state 119

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 120

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 126
    empty                          shift and go to state 16

state 121

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN . LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail

    LBRACE          shift and go to state 127


state 122

    (92) parameters -> data_type IDENT . parameters_tail
    (94) parameters_tail -> . empty
    (95) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (248) empty -> .

    COMMA           shift and go to state 130
    RPAREN          reduce using rule 248 (empty -> .)

    parameters_tail                shift and go to state 128
    empty                          shift and go to state 129

state 123

    (15) global_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 15 (global_tail2 -> COMMA IDENT global_statement_tail .)


state 124

    (29) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 29 (element_tail -> COMMA list_element .)


state 125

    (75) var_call_tail -> LBRACKET index RBRACKET .

    PLUS            reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    GT              reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    LT              reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    AND             reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    OR              reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_PLUS       reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ              reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)


state 126

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 131


state 127

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE . maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    REVIVE          reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 132
    empty                          shift and go to state 16

state 128

    (92) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 92 (parameters -> data_type IDENT parameters_tail .)


state 129

    (94) parameters_tail -> empty .

    RPAREN          reduce using rule 94 (parameters_tail -> empty .)


state 130

    (95) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    data_type                      shift and go to state 133

state 131

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 134
    empty                          shift and go to state 16

state 132

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline . statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 135
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 133

    (95) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 140


state 134

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 141
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 135

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements . revive maybe_newline RBRACE unli_newline function_statements_tail
    (96) revive -> . REVIVE revive_value
    (97) revive -> . empty
    (248) empty -> .

    REVIVE          shift and go to state 143
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)

    revive                         shift and go to state 142
    empty                          shift and go to state 144

state 136

    (105) statements -> empty .
    (114) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 105 (statements -> empty .)
    REVIVE          reduce using rule 105 (statements -> empty .)
    NEWLINE         reduce using rule 105 (statements -> empty .)
    RBRACE          reduce using rule 105 (statements -> empty .)
    SHIFT           reduce using rule 105 (statements -> empty .)
    OTHERWISE       reduce using rule 105 (statements -> empty .)
    CHECK           reduce using rule 114 (local_dec -> empty .)
    SWAP            reduce using rule 114 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 114 (local_dec -> empty .)
    DISPLAY         reduce using rule 114 (local_dec -> empty .)
    IDENT           reduce using rule 114 (local_dec -> empty .)
    FOR             reduce using rule 114 (local_dec -> empty .)
    UNTIL           reduce using rule 114 (local_dec -> empty .)
    REPEAT          reduce using rule 114 (local_dec -> empty .)
    INPUT           reduce using rule 114 (local_dec -> empty .)
    INT             reduce using rule 114 (local_dec -> empty .)
    FLT             reduce using rule 114 (local_dec -> empty .)
    BLN             reduce using rule 114 (local_dec -> empty .)
    CHR             reduce using rule 114 (local_dec -> empty .)
    STR             reduce using rule 114 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 114 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 114 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 114 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 114 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 114 (local_dec -> empty .) ]


state 137

    (106) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    REVIVE          reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 145
    empty                          shift and go to state 16

state 138

    (115) local_dec -> var_statement .

    NEWLINE         reduce using rule 115 (local_dec -> var_statement .)
    CHECK           reduce using rule 115 (local_dec -> var_statement .)
    SWAP            reduce using rule 115 (local_dec -> var_statement .)
    FUNCTION_NAME   reduce using rule 115 (local_dec -> var_statement .)
    DISPLAY         reduce using rule 115 (local_dec -> var_statement .)
    IDENT           reduce using rule 115 (local_dec -> var_statement .)
    FOR             reduce using rule 115 (local_dec -> var_statement .)
    UNTIL           reduce using rule 115 (local_dec -> var_statement .)
    REPEAT          reduce using rule 115 (local_dec -> var_statement .)
    INPUT           reduce using rule 115 (local_dec -> var_statement .)
    INT             reduce using rule 115 (local_dec -> var_statement .)
    FLT             reduce using rule 115 (local_dec -> var_statement .)
    BLN             reduce using rule 115 (local_dec -> var_statement .)
    CHR             reduce using rule 115 (local_dec -> var_statement .)
    STR             reduce using rule 115 (local_dec -> var_statement .)
    REVIVE          reduce using rule 115 (local_dec -> var_statement .)
    RBRACE          reduce using rule 115 (local_dec -> var_statement .)
    SHIFT           reduce using rule 115 (local_dec -> var_statement .)
    OTHERWISE       reduce using rule 115 (local_dec -> var_statement .)


state 139

    (19) var_statement -> data_type . IDENT var_tail unli_newline

    IDENT           shift and go to state 146


state 140

    (95) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (94) parameters_tail -> . empty
    (95) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (248) empty -> .

    COMMA           shift and go to state 130
    RPAREN          reduce using rule 248 (empty -> .)

    parameters_tail                shift and go to state 147
    empty                          shift and go to state 129

state 141

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 148
    empty                          shift and go to state 16

state 142

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive . maybe_newline RBRACE unli_newline function_statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 149
    empty                          shift and go to state 16

state 143

    (96) revive -> REVIVE . revive_value
    (98) revive_value -> . revive_type_cast
    (99) revive_value -> . expression
    (100) revive_value -> . function_call
    (101) revive_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (102) revive_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (103) revive_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (104) revive_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (215) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (216) function_call -> . input_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (234) input_statement -> . INPUT LPAREN RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 154
    CONVERT_TO_FLT  shift and go to state 155
    CONVERT_TO_BLN  shift and go to state 156
    CONVERT_TO_STR  shift and go to state 157
    FUNCTION_NAME   shift and go to state 158
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 160
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    revive_value                   shift and go to state 150
    revive_type_cast               shift and go to state 151
    expression                     shift and go to state 152
    function_call                  shift and go to state 153
    factor                         shift and go to state 49
    input_statement                shift and go to state 159
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 144

    (97) revive -> empty .

    NEWLINE         reduce using rule 97 (revive -> empty .)
    RBRACE          reduce using rule 97 (revive -> empty .)


state 145

    (106) statements -> local_dec maybe_newline . statements_tail
    (107) statements_tail -> . string_operation_statement unli_newline statements
    (108) statements_tail -> . conditional_statement unli_newline statements
    (109) statements_tail -> . switch_statement unli_newline statements
    (110) statements_tail -> . loop_statement unli_newline statements
    (111) statements_tail -> . function_call unli_newline statements
    (112) statements_tail -> . output_statement unli_newline statements
    (113) statements_tail -> . statements
    (235) string_operation_statement -> . var_call string_operation_tail
    (116) conditional_statement -> . CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (145) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (149) loop_statement -> . for_loop
    (150) loop_statement -> . until_loop
    (151) loop_statement -> . repeat_until
    (215) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (216) function_call -> . input_statement
    (223) output_statement -> . DISPLAY output_value next_val
    (224) output_statement -> . DISPLAY LPAREN output_value next_val RPAREN
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (73) var_call -> . IDENT var_call_tail
    (152) for_loop -> . FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (179) until_loop -> . UNTIL LPAREN until_loop_condition RPAREN LBRACE maybe_newline statements RBRACE
    (180) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN until_loop_condition RPAREN
    (234) input_statement -> . INPUT LPAREN RPAREN
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 158
    DISPLAY         shift and go to state 175
    IDENT           shift and go to state 54
    FOR             shift and go to state 176
    UNTIL           shift and go to state 177
    REPEAT          shift and go to state 178
    INPUT           shift and go to state 160
    REVIVE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 248 (empty -> .) ]
  ! SWAP            [ reduce using rule 248 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 248 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 248 (empty -> .) ]
  ! IDENT           [ reduce using rule 248 (empty -> .) ]
  ! FOR             [ reduce using rule 248 (empty -> .) ]
  ! UNTIL           [ reduce using rule 248 (empty -> .) ]
  ! REPEAT          [ reduce using rule 248 (empty -> .) ]
  ! INPUT           [ reduce using rule 248 (empty -> .) ]
  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    local_dec                      shift and go to state 137
    statements_tail                shift and go to state 161
    string_operation_statement     shift and go to state 162
    statements                     shift and go to state 163
    conditional_statement          shift and go to state 164
    switch_statement               shift and go to state 165
    loop_statement                 shift and go to state 166
    function_call                  shift and go to state 167
    output_statement               shift and go to state 168
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 159
    empty                          shift and go to state 136
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 146

    (19) var_statement -> data_type IDENT . var_tail unli_newline
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (248) empty -> .

    EQ              shift and go to state 181
    COMMA           shift and go to state 182
    NEWLINE         reduce using rule 248 (empty -> .)

    var_tail                       shift and go to state 179
    empty                          shift and go to state 180

state 147

    (95) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 95 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 148

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 183


state 149

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline . RBRACE unli_newline function_statements_tail

    RBRACE          shift and go to state 184


state 150

    (96) revive -> REVIVE revive_value .

    NEWLINE         reduce using rule 96 (revive -> REVIVE revive_value .)
    RBRACE          reduce using rule 96 (revive -> REVIVE revive_value .)


state 151

    (98) revive_value -> revive_type_cast .

    NEWLINE         reduce using rule 98 (revive_value -> revive_type_cast .)
    RBRACE          reduce using rule 98 (revive_value -> revive_type_cast .)


state 152

    (99) revive_value -> expression .

    NEWLINE         reduce using rule 99 (revive_value -> expression .)
    RBRACE          reduce using rule 99 (revive_value -> expression .)


state 153

    (100) revive_value -> function_call .

    NEWLINE         reduce using rule 100 (revive_value -> function_call .)
    RBRACE          reduce using rule 100 (revive_value -> function_call .)


state 154

    (101) revive_type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 185


state 155

    (102) revive_type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 186


state 156

    (103) revive_type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 187


state 157

    (104) revive_type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 188


state 158

    (215) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 189


state 159

    (216) function_call -> input_statement .

    NEWLINE         reduce using rule 216 (function_call -> input_statement .)
    RBRACE          reduce using rule 216 (function_call -> input_statement .)
    COMMA           reduce using rule 216 (function_call -> input_statement .)
    RPAREN          reduce using rule 216 (function_call -> input_statement .)
    COLON           reduce using rule 216 (function_call -> input_statement .)


state 160

    (234) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 190


state 161

    (106) statements -> local_dec maybe_newline statements_tail .

    REVIVE          reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    NEWLINE         reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)


state 162

    (107) statements_tail -> string_operation_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 191

state 163

    (113) statements_tail -> statements .

    REVIVE          reduce using rule 113 (statements_tail -> statements .)
    NEWLINE         reduce using rule 113 (statements_tail -> statements .)
    RBRACE          reduce using rule 113 (statements_tail -> statements .)
    SHIFT           reduce using rule 113 (statements_tail -> statements .)
    OTHERWISE       reduce using rule 113 (statements_tail -> statements .)


state 164

    (108) statements_tail -> conditional_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 192

state 165

    (109) statements_tail -> switch_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 193

state 166

    (110) statements_tail -> loop_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 194

state 167

    (111) statements_tail -> function_call . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 195

state 168

    (112) statements_tail -> output_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 196

state 169

    (235) string_operation_statement -> var_call . string_operation_tail
    (236) string_operation_tail -> . PLUS string_val stringcon_tail
    (237) string_operation_tail -> . update_tail
    (211) update_tail -> . postfix
    (212) update_tail -> . assign_op value
    (213) postfix -> . PLUS_PLUS
    (214) postfix -> . MINUS_MINUS
    (238) assign_op -> . PLUS_EQ
    (239) assign_op -> . MINUS_EQ
    (240) assign_op -> . MUL_EQ
    (241) assign_op -> . DIV_EQ
    (242) assign_op -> . MOD_EQ
    (243) assign_op -> . EQ

    PLUS            shift and go to state 198
    PLUS_PLUS       shift and go to state 202
    MINUS_MINUS     shift and go to state 203
    PLUS_EQ         shift and go to state 204
    MINUS_EQ        shift and go to state 205
    MUL_EQ          shift and go to state 206
    DIV_EQ          shift and go to state 207
    MOD_EQ          shift and go to state 208
    EQ              shift and go to state 209

    string_operation_tail          shift and go to state 197
    update_tail                    shift and go to state 199
    postfix                        shift and go to state 200
    assign_op                      shift and go to state 201

state 170

    (116) conditional_statement -> CHECK . LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 210


state 171

    (145) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LPAREN          shift and go to state 211


state 172

    (149) loop_statement -> for_loop .

    NEWLINE         reduce using rule 149 (loop_statement -> for_loop .)


state 173

    (150) loop_statement -> until_loop .

    NEWLINE         reduce using rule 150 (loop_statement -> until_loop .)


state 174

    (151) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 151 (loop_statement -> repeat_until .)


state 175

    (223) output_statement -> DISPLAY . output_value next_val
    (224) output_statement -> DISPLAY . LPAREN output_value next_val RPAREN
    (225) output_value -> . output_type_cast
    (226) output_value -> . expression
    (227) output_value -> . function_call
    (228) output_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (229) output_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (230) output_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (231) output_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (215) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (216) function_call -> . input_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (234) input_statement -> . INPUT LPAREN RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LPAREN          shift and go to state 213
    CONVERT_TO_INT  shift and go to state 217
    CONVERT_TO_FLT  shift and go to state 218
    CONVERT_TO_BLN  shift and go to state 219
    CONVERT_TO_STR  shift and go to state 220
    FUNCTION_NAME   shift and go to state 158
    TILDE           shift and go to state 52
    INPUT           shift and go to state 160
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    output_value                   shift and go to state 212
    output_type_cast               shift and go to state 214
    expression                     shift and go to state 215
    function_call                  shift and go to state 216
    factor                         shift and go to state 49
    input_statement                shift and go to state 159
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 176

    (152) for_loop -> FOR . LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 221


state 177

    (179) until_loop -> UNTIL . LPAREN until_loop_condition RPAREN LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 222


state 178

    (180) repeat_until -> REPEAT . LBRACE maybe_newline statements RBRACE UNTIL LPAREN until_loop_condition RPAREN

    LBRACE          shift and go to state 223


state 179

    (19) var_statement -> data_type IDENT var_tail . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 224

state 180

    (20) var_tail -> empty .

    NEWLINE         reduce using rule 20 (var_tail -> empty .)


state 181

    (21) var_tail -> EQ . tail_value var_tail2
    (25) tail_value -> . value
    (26) tail_value -> . LBRACKET list_element RBRACKET
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (215) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (216) function_call -> . input_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (234) input_statement -> . INPUT LPAREN RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LBRACKET        shift and go to state 227
    CONVERT_TO_INT  shift and go to state 231
    CONVERT_TO_FLT  shift and go to state 232
    CONVERT_TO_BLN  shift and go to state 233
    CONVERT_TO_STR  shift and go to state 234
    FUNCTION_NAME   shift and go to state 158
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 160
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    tail_value                     shift and go to state 225
    value                          shift and go to state 226
    type_cast                      shift and go to state 228
    expression                     shift and go to state 229
    function_call                  shift and go to state 230
    factor                         shift and go to state 49
    input_statement                shift and go to state 159
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 182

    (22) var_tail -> COMMA . IDENT var_tail

    IDENT           shift and go to state 235


state 183

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)


state 184

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE . unli_newline function_statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 236

state 185

    (101) revive_type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 237
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 186

    (102) revive_type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 241
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 187

    (103) revive_type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 242
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 188

    (104) revive_type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 243
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 189

    (215) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (217) arguments -> . empty
    (218) arguments -> . arg_value arg_tail
    (248) empty -> .
    (221) arg_value -> . literal
    (222) arg_value -> . var_call
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT
    (73) var_call -> . IDENT var_call_tail

    RPAREN          reduce using rule 248 (empty -> .)
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60
    IDENT           shift and go to state 54

    arguments                      shift and go to state 244
    empty                          shift and go to state 245
    arg_value                      shift and go to state 246
    literal                        shift and go to state 247
    var_call                       shift and go to state 248

state 190

    (234) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 249


state 191

    (107) statements_tail -> string_operation_statement unli_newline . statements
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 250
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 192

    (108) statements_tail -> conditional_statement unli_newline . statements
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 251
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 193

    (109) statements_tail -> switch_statement unli_newline . statements
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 252
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 194

    (110) statements_tail -> loop_statement unli_newline . statements
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 253
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 195

    (111) statements_tail -> function_call unli_newline . statements
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 254
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 196

    (112) statements_tail -> output_statement unli_newline . statements
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 255
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 197

    (235) string_operation_statement -> var_call string_operation_tail .

    NEWLINE         reduce using rule 235 (string_operation_statement -> var_call string_operation_tail .)


state 198

    (236) string_operation_tail -> PLUS . string_val stringcon_tail
    (246) string_val -> . var_call
    (247) string_val -> . STR_LIT
    (73) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 258
    IDENT           shift and go to state 54

    string_val                     shift and go to state 256
    var_call                       shift and go to state 257

state 199

    (237) string_operation_tail -> update_tail .

    NEWLINE         reduce using rule 237 (string_operation_tail -> update_tail .)


state 200

    (211) update_tail -> postfix .

    NEWLINE         reduce using rule 211 (update_tail -> postfix .)
    RPAREN          reduce using rule 211 (update_tail -> postfix .)


state 201

    (212) update_tail -> assign_op . value
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (215) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (216) function_call -> . input_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (234) input_statement -> . INPUT LPAREN RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 231
    CONVERT_TO_FLT  shift and go to state 232
    CONVERT_TO_BLN  shift and go to state 233
    CONVERT_TO_STR  shift and go to state 234
    FUNCTION_NAME   shift and go to state 158
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 160
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 259
    type_cast                      shift and go to state 228
    expression                     shift and go to state 229
    function_call                  shift and go to state 230
    factor                         shift and go to state 49
    input_statement                shift and go to state 159
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 202

    (213) postfix -> PLUS_PLUS .

    NEWLINE         reduce using rule 213 (postfix -> PLUS_PLUS .)
    RPAREN          reduce using rule 213 (postfix -> PLUS_PLUS .)


state 203

    (214) postfix -> MINUS_MINUS .

    NEWLINE         reduce using rule 214 (postfix -> MINUS_MINUS .)
    RPAREN          reduce using rule 214 (postfix -> MINUS_MINUS .)


state 204

    (238) assign_op -> PLUS_EQ .

    CONVERT_TO_INT  reduce using rule 238 (assign_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 238 (assign_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 238 (assign_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 238 (assign_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 238 (assign_op -> PLUS_EQ .)
    TILDE           reduce using rule 238 (assign_op -> PLUS_EQ .)
    LPAREN          reduce using rule 238 (assign_op -> PLUS_EQ .)
    INPUT           reduce using rule 238 (assign_op -> PLUS_EQ .)
    IDENT           reduce using rule 238 (assign_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 238 (assign_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 238 (assign_op -> PLUS_EQ .)
    DAY             reduce using rule 238 (assign_op -> PLUS_EQ .)
    NIGHT           reduce using rule 238 (assign_op -> PLUS_EQ .)
    CHR_LIT         reduce using rule 238 (assign_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 238 (assign_op -> PLUS_EQ .)


state 205

    (239) assign_op -> MINUS_EQ .

    CONVERT_TO_INT  reduce using rule 239 (assign_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 239 (assign_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 239 (assign_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 239 (assign_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 239 (assign_op -> MINUS_EQ .)
    TILDE           reduce using rule 239 (assign_op -> MINUS_EQ .)
    LPAREN          reduce using rule 239 (assign_op -> MINUS_EQ .)
    INPUT           reduce using rule 239 (assign_op -> MINUS_EQ .)
    IDENT           reduce using rule 239 (assign_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 239 (assign_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 239 (assign_op -> MINUS_EQ .)
    DAY             reduce using rule 239 (assign_op -> MINUS_EQ .)
    NIGHT           reduce using rule 239 (assign_op -> MINUS_EQ .)
    CHR_LIT         reduce using rule 239 (assign_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 239 (assign_op -> MINUS_EQ .)


state 206

    (240) assign_op -> MUL_EQ .

    CONVERT_TO_INT  reduce using rule 240 (assign_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 240 (assign_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 240 (assign_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 240 (assign_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 240 (assign_op -> MUL_EQ .)
    TILDE           reduce using rule 240 (assign_op -> MUL_EQ .)
    LPAREN          reduce using rule 240 (assign_op -> MUL_EQ .)
    INPUT           reduce using rule 240 (assign_op -> MUL_EQ .)
    IDENT           reduce using rule 240 (assign_op -> MUL_EQ .)
    INT_LIT         reduce using rule 240 (assign_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 240 (assign_op -> MUL_EQ .)
    DAY             reduce using rule 240 (assign_op -> MUL_EQ .)
    NIGHT           reduce using rule 240 (assign_op -> MUL_EQ .)
    CHR_LIT         reduce using rule 240 (assign_op -> MUL_EQ .)
    STR_LIT         reduce using rule 240 (assign_op -> MUL_EQ .)


state 207

    (241) assign_op -> DIV_EQ .

    CONVERT_TO_INT  reduce using rule 241 (assign_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 241 (assign_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 241 (assign_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 241 (assign_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 241 (assign_op -> DIV_EQ .)
    TILDE           reduce using rule 241 (assign_op -> DIV_EQ .)
    LPAREN          reduce using rule 241 (assign_op -> DIV_EQ .)
    INPUT           reduce using rule 241 (assign_op -> DIV_EQ .)
    IDENT           reduce using rule 241 (assign_op -> DIV_EQ .)
    INT_LIT         reduce using rule 241 (assign_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 241 (assign_op -> DIV_EQ .)
    DAY             reduce using rule 241 (assign_op -> DIV_EQ .)
    NIGHT           reduce using rule 241 (assign_op -> DIV_EQ .)
    CHR_LIT         reduce using rule 241 (assign_op -> DIV_EQ .)
    STR_LIT         reduce using rule 241 (assign_op -> DIV_EQ .)


state 208

    (242) assign_op -> MOD_EQ .

    CONVERT_TO_INT  reduce using rule 242 (assign_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 242 (assign_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 242 (assign_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 242 (assign_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 242 (assign_op -> MOD_EQ .)
    TILDE           reduce using rule 242 (assign_op -> MOD_EQ .)
    LPAREN          reduce using rule 242 (assign_op -> MOD_EQ .)
    INPUT           reduce using rule 242 (assign_op -> MOD_EQ .)
    IDENT           reduce using rule 242 (assign_op -> MOD_EQ .)
    INT_LIT         reduce using rule 242 (assign_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 242 (assign_op -> MOD_EQ .)
    DAY             reduce using rule 242 (assign_op -> MOD_EQ .)
    NIGHT           reduce using rule 242 (assign_op -> MOD_EQ .)
    CHR_LIT         reduce using rule 242 (assign_op -> MOD_EQ .)
    STR_LIT         reduce using rule 242 (assign_op -> MOD_EQ .)


state 209

    (243) assign_op -> EQ .

    CONVERT_TO_INT  reduce using rule 243 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 243 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 243 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 243 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 243 (assign_op -> EQ .)
    TILDE           reduce using rule 243 (assign_op -> EQ .)
    LPAREN          reduce using rule 243 (assign_op -> EQ .)
    INPUT           reduce using rule 243 (assign_op -> EQ .)
    IDENT           reduce using rule 243 (assign_op -> EQ .)
    INT_LIT         reduce using rule 243 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 243 (assign_op -> EQ .)
    DAY             reduce using rule 243 (assign_op -> EQ .)
    NIGHT           reduce using rule 243 (assign_op -> EQ .)
    CHR_LIT         reduce using rule 243 (assign_op -> EQ .)
    STR_LIT         reduce using rule 243 (assign_op -> EQ .)


state 210

    (116) conditional_statement -> CHECK LPAREN . condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 261
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 211

    (145) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    IDENT           shift and go to state 272


state 212

    (223) output_statement -> DISPLAY output_value . next_val
    (232) next_val -> . empty
    (233) next_val -> . COMMA value next_val
    (248) empty -> .

    COMMA           shift and go to state 275
    NEWLINE         reduce using rule 248 (empty -> .)

    next_val                       shift and go to state 273
    empty                          shift and go to state 274

state 213

    (224) output_statement -> DISPLAY LPAREN . output_value next_val RPAREN
    (57) factor -> LPAREN . expression RPAREN
    (225) output_value -> . output_type_cast
    (226) output_value -> . expression
    (227) output_value -> . function_call
    (53) expression -> . factor factor_tail
    (228) output_type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (229) output_type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (230) output_type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (231) output_type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (215) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (216) function_call -> . input_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (234) input_statement -> . INPUT LPAREN RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 217
    CONVERT_TO_FLT  shift and go to state 218
    CONVERT_TO_BLN  shift and go to state 219
    CONVERT_TO_STR  shift and go to state 220
    FUNCTION_NAME   shift and go to state 158
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 160
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    output_value                   shift and go to state 276
    expression                     shift and go to state 277
    output_type_cast               shift and go to state 214
    function_call                  shift and go to state 216
    factor                         shift and go to state 49
    input_statement                shift and go to state 159
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 214

    (225) output_value -> output_type_cast .

    COMMA           reduce using rule 225 (output_value -> output_type_cast .)
    NEWLINE         reduce using rule 225 (output_value -> output_type_cast .)
    RPAREN          reduce using rule 225 (output_value -> output_type_cast .)


state 215

    (226) output_value -> expression .

    COMMA           reduce using rule 226 (output_value -> expression .)
    NEWLINE         reduce using rule 226 (output_value -> expression .)


state 216

    (227) output_value -> function_call .

    COMMA           reduce using rule 227 (output_value -> function_call .)
    NEWLINE         reduce using rule 227 (output_value -> function_call .)
    RPAREN          reduce using rule 227 (output_value -> function_call .)


state 217

    (228) output_type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 278


state 218

    (229) output_type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 279


state 219

    (230) output_type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 280


state 220

    (231) output_type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 281


state 221

    (152) for_loop -> FOR LPAREN . control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (207) control_variable -> . INT IDENT EQ control_var_tail

    INT             shift and go to state 283

    control_variable               shift and go to state 282

state 222

    (179) until_loop -> UNTIL LPAREN . until_loop_condition RPAREN LBRACE maybe_newline statements RBRACE
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 285
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 223

    (180) repeat_until -> REPEAT LBRACE . maybe_newline statements RBRACE UNTIL LPAREN until_loop_condition RPAREN
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 296
    empty                          shift and go to state 16

state 224

    (19) var_statement -> data_type IDENT var_tail unli_newline .

    NEWLINE         reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    CHECK           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    SWAP            reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    FUNCTION_NAME   reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    DISPLAY         reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    IDENT           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    FOR             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    UNTIL           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    REPEAT          reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    INPUT           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    INT             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    FLT             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    BLN             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    CHR             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    STR             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    REVIVE          reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    RBRACE          reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    SHIFT           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    OTHERWISE       reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)


state 225

    (21) var_tail -> EQ tail_value . var_tail2
    (23) var_tail2 -> . empty
    (24) var_tail2 -> . COMMA IDENT var_tail
    (248) empty -> .

    COMMA           shift and go to state 299
    NEWLINE         reduce using rule 248 (empty -> .)

    var_tail2                      shift and go to state 297
    empty                          shift and go to state 298

state 226

    (25) tail_value -> value .

    COMMA           reduce using rule 25 (tail_value -> value .)
    NEWLINE         reduce using rule 25 (tail_value -> value .)


state 227

    (26) tail_value -> LBRACKET . list_element RBRACKET
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    list_element                   shift and go to state 300
    literal                        shift and go to state 69

state 228

    (37) value -> type_cast .

    COMMA           reduce using rule 37 (value -> type_cast .)
    NEWLINE         reduce using rule 37 (value -> type_cast .)
    RPAREN          reduce using rule 37 (value -> type_cast .)
    COLON           reduce using rule 37 (value -> type_cast .)


state 229

    (38) value -> expression .

    COMMA           reduce using rule 38 (value -> expression .)
    NEWLINE         reduce using rule 38 (value -> expression .)
    RPAREN          reduce using rule 38 (value -> expression .)
    COLON           reduce using rule 38 (value -> expression .)


state 230

    (39) value -> function_call .

    COMMA           reduce using rule 39 (value -> function_call .)
    NEWLINE         reduce using rule 39 (value -> function_call .)
    RPAREN          reduce using rule 39 (value -> function_call .)
    COLON           reduce using rule 39 (value -> function_call .)


state 231

    (40) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 301


state 232

    (41) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 302


state 233

    (42) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 303


state 234

    (43) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 304


state 235

    (22) var_tail -> COMMA IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (248) empty -> .

    EQ              shift and go to state 181
    COMMA           shift and go to state 182
    NEWLINE         reduce using rule 248 (empty -> .)

    var_tail                       shift and go to state 305
    empty                          shift and go to state 180

state 236

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline . function_statements_tail
    (78) function_statements_tail -> . function_statements
    (79) function_statements_tail -> . empty
    (76) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (77) function_statements -> . empty
    (248) empty -> .
    (80) ret_type -> . FUNCTION
    (81) ret_type -> . function_dtype
    (82) function_dtype -> . FUNCTION_INT
    (83) function_dtype -> . FUNCTION_FLT
    (84) function_dtype -> . FUNCTION_CHR
    (85) function_dtype -> . FUNCTION_BLN
    (86) function_dtype -> . FUNCTION_STR
    (87) function_dtype -> . FUNCTION_LIST_INT
    (88) function_dtype -> . FUNCTION_LIST_FLT
    (89) function_dtype -> . FUNCTION_LIST_CHR
    (90) function_dtype -> . FUNCTION_LIST_STR
    (91) function_dtype -> . FUNCTION_LIST_BLN

    NEWLINE         reduce using rule 248 (empty -> .)
    MAIN_CASPER     reduce using rule 248 (empty -> .)
    FUNCTION        shift and go to state 23
    FUNCTION_INT    shift and go to state 25
    FUNCTION_FLT    shift and go to state 26
    FUNCTION_CHR    shift and go to state 27
    FUNCTION_BLN    shift and go to state 28
    FUNCTION_STR    shift and go to state 29
    FUNCTION_LIST_INT shift and go to state 30
    FUNCTION_LIST_FLT shift and go to state 31
    FUNCTION_LIST_CHR shift and go to state 32
    FUNCTION_LIST_STR shift and go to state 33
    FUNCTION_LIST_BLN shift and go to state 34

    ret_type                       shift and go to state 21
    function_statements_tail       shift and go to state 306
    function_statements            shift and go to state 307
    empty                          shift and go to state 308
    function_dtype                 shift and go to state 24

state 237

    (101) revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 309


state 238

    (44) typecast_value -> expression .

    RPAREN          reduce using rule 44 (typecast_value -> expression .)


state 239

    (45) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 310


state 240

    (46) typecast_value -> input_statement .

    RPAREN          reduce using rule 46 (typecast_value -> input_statement .)


state 241

    (102) revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 311


state 242

    (103) revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 312


state 243

    (104) revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 313


state 244

    (215) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 314


state 245

    (217) arguments -> empty .

    RPAREN          reduce using rule 217 (arguments -> empty .)


state 246

    (218) arguments -> arg_value . arg_tail
    (219) arg_tail -> . empty
    (220) arg_tail -> . COMMA arg_value arg_tail
    (248) empty -> .

    COMMA           shift and go to state 317
    RPAREN          reduce using rule 248 (empty -> .)

    arg_tail                       shift and go to state 315
    empty                          shift and go to state 316

state 247

    (221) arg_value -> literal .

    COMMA           reduce using rule 221 (arg_value -> literal .)
    RPAREN          reduce using rule 221 (arg_value -> literal .)


state 248

    (222) arg_value -> var_call .

    COMMA           reduce using rule 222 (arg_value -> var_call .)
    RPAREN          reduce using rule 222 (arg_value -> var_call .)


state 249

    (234) input_statement -> INPUT LPAREN RPAREN .

    NEWLINE         reduce using rule 234 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 234 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 234 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 234 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 234 (input_statement -> INPUT LPAREN RPAREN .)


state 250

    (107) statements_tail -> string_operation_statement unli_newline statements .

    REVIVE          reduce using rule 107 (statements_tail -> string_operation_statement unli_newline statements .)
    NEWLINE         reduce using rule 107 (statements_tail -> string_operation_statement unli_newline statements .)
    RBRACE          reduce using rule 107 (statements_tail -> string_operation_statement unli_newline statements .)
    SHIFT           reduce using rule 107 (statements_tail -> string_operation_statement unli_newline statements .)
    OTHERWISE       reduce using rule 107 (statements_tail -> string_operation_statement unli_newline statements .)


state 251

    (108) statements_tail -> conditional_statement unli_newline statements .

    REVIVE          reduce using rule 108 (statements_tail -> conditional_statement unli_newline statements .)
    NEWLINE         reduce using rule 108 (statements_tail -> conditional_statement unli_newline statements .)
    RBRACE          reduce using rule 108 (statements_tail -> conditional_statement unli_newline statements .)
    SHIFT           reduce using rule 108 (statements_tail -> conditional_statement unli_newline statements .)
    OTHERWISE       reduce using rule 108 (statements_tail -> conditional_statement unli_newline statements .)


state 252

    (109) statements_tail -> switch_statement unli_newline statements .

    REVIVE          reduce using rule 109 (statements_tail -> switch_statement unli_newline statements .)
    NEWLINE         reduce using rule 109 (statements_tail -> switch_statement unli_newline statements .)
    RBRACE          reduce using rule 109 (statements_tail -> switch_statement unli_newline statements .)
    SHIFT           reduce using rule 109 (statements_tail -> switch_statement unli_newline statements .)
    OTHERWISE       reduce using rule 109 (statements_tail -> switch_statement unli_newline statements .)


state 253

    (110) statements_tail -> loop_statement unli_newline statements .

    REVIVE          reduce using rule 110 (statements_tail -> loop_statement unli_newline statements .)
    NEWLINE         reduce using rule 110 (statements_tail -> loop_statement unli_newline statements .)
    RBRACE          reduce using rule 110 (statements_tail -> loop_statement unli_newline statements .)
    SHIFT           reduce using rule 110 (statements_tail -> loop_statement unli_newline statements .)
    OTHERWISE       reduce using rule 110 (statements_tail -> loop_statement unli_newline statements .)


state 254

    (111) statements_tail -> function_call unli_newline statements .

    REVIVE          reduce using rule 111 (statements_tail -> function_call unli_newline statements .)
    NEWLINE         reduce using rule 111 (statements_tail -> function_call unli_newline statements .)
    RBRACE          reduce using rule 111 (statements_tail -> function_call unli_newline statements .)
    SHIFT           reduce using rule 111 (statements_tail -> function_call unli_newline statements .)
    OTHERWISE       reduce using rule 111 (statements_tail -> function_call unli_newline statements .)


state 255

    (112) statements_tail -> output_statement unli_newline statements .

    REVIVE          reduce using rule 112 (statements_tail -> output_statement unli_newline statements .)
    NEWLINE         reduce using rule 112 (statements_tail -> output_statement unli_newline statements .)
    RBRACE          reduce using rule 112 (statements_tail -> output_statement unli_newline statements .)
    SHIFT           reduce using rule 112 (statements_tail -> output_statement unli_newline statements .)
    OTHERWISE       reduce using rule 112 (statements_tail -> output_statement unli_newline statements .)


state 256

    (236) string_operation_tail -> PLUS string_val . stringcon_tail
    (244) stringcon_tail -> . empty
    (245) stringcon_tail -> . PLUS string_val stringcon_tail
    (248) empty -> .

    PLUS            shift and go to state 318
    NEWLINE         reduce using rule 248 (empty -> .)

    stringcon_tail                 shift and go to state 319
    empty                          shift and go to state 320

state 257

    (246) string_val -> var_call .

    PLUS            reduce using rule 246 (string_val -> var_call .)
    NEWLINE         reduce using rule 246 (string_val -> var_call .)


state 258

    (247) string_val -> STR_LIT .

    PLUS            reduce using rule 247 (string_val -> STR_LIT .)
    NEWLINE         reduce using rule 247 (string_val -> STR_LIT .)


state 259

    (212) update_tail -> assign_op value .

    NEWLINE         reduce using rule 212 (update_tail -> assign_op value .)
    RPAREN          reduce using rule 212 (update_tail -> assign_op value .)


state 260

    (123) condition_factor -> LPAREN . condition RPAREN
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 321
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 261

    (116) conditional_statement -> CHECK LPAREN condition . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 322


state 262

    (119) condition -> condition_factor . condition_factor_tail
    (124) condition_factor_tail -> . empty
    (125) condition_factor_tail -> . PLUS condition
    (126) condition_factor_tail -> . MINUS condition
    (127) condition_factor_tail -> . MULTIPLY condition
    (128) condition_factor_tail -> . DIVISION condition
    (129) condition_factor_tail -> . MODULO condition
    (130) condition_factor_tail -> . EXPONENT condition
    (131) condition_factor_tail -> . GT condition
    (132) condition_factor_tail -> . LT condition
    (133) condition_factor_tail -> . EQ_EQ condition
    (134) condition_factor_tail -> . GT_EQ condition
    (135) condition_factor_tail -> . LT_EQ condition
    (136) condition_factor_tail -> . NOT_EQ condition
    (137) condition_factor_tail -> . AND condition
    (138) condition_factor_tail -> . OR condition
    (248) empty -> .

    PLUS            shift and go to state 325
    MINUS           shift and go to state 326
    MULTIPLY        shift and go to state 327
    DIVISION        shift and go to state 328
    MODULO          shift and go to state 329
    EXPONENT        shift and go to state 330
    GT              shift and go to state 331
    LT              shift and go to state 332
    EQ_EQ           shift and go to state 333
    GT_EQ           shift and go to state 334
    LT_EQ           shift and go to state 335
    NOT_EQ          shift and go to state 336
    AND             shift and go to state 337
    OR              shift and go to state 338
    RPAREN          reduce using rule 248 (empty -> .)

    condition_factor_tail          shift and go to state 323
    empty                          shift and go to state 324

state 263

    (120) condition_factor -> var_call .

    PLUS            reduce using rule 120 (condition_factor -> var_call .)
    MINUS           reduce using rule 120 (condition_factor -> var_call .)
    MULTIPLY        reduce using rule 120 (condition_factor -> var_call .)
    DIVISION        reduce using rule 120 (condition_factor -> var_call .)
    MODULO          reduce using rule 120 (condition_factor -> var_call .)
    EXPONENT        reduce using rule 120 (condition_factor -> var_call .)
    GT              reduce using rule 120 (condition_factor -> var_call .)
    LT              reduce using rule 120 (condition_factor -> var_call .)
    EQ_EQ           reduce using rule 120 (condition_factor -> var_call .)
    GT_EQ           reduce using rule 120 (condition_factor -> var_call .)
    LT_EQ           reduce using rule 120 (condition_factor -> var_call .)
    NOT_EQ          reduce using rule 120 (condition_factor -> var_call .)
    AND             reduce using rule 120 (condition_factor -> var_call .)
    OR              reduce using rule 120 (condition_factor -> var_call .)
    RPAREN          reduce using rule 120 (condition_factor -> var_call .)


state 264

    (121) condition_factor -> condition_literal .

    PLUS            reduce using rule 121 (condition_factor -> condition_literal .)
    MINUS           reduce using rule 121 (condition_factor -> condition_literal .)
    MULTIPLY        reduce using rule 121 (condition_factor -> condition_literal .)
    DIVISION        reduce using rule 121 (condition_factor -> condition_literal .)
    MODULO          reduce using rule 121 (condition_factor -> condition_literal .)
    EXPONENT        reduce using rule 121 (condition_factor -> condition_literal .)
    GT              reduce using rule 121 (condition_factor -> condition_literal .)
    LT              reduce using rule 121 (condition_factor -> condition_literal .)
    EQ_EQ           reduce using rule 121 (condition_factor -> condition_literal .)
    GT_EQ           reduce using rule 121 (condition_factor -> condition_literal .)
    LT_EQ           reduce using rule 121 (condition_factor -> condition_literal .)
    NOT_EQ          reduce using rule 121 (condition_factor -> condition_literal .)
    AND             reduce using rule 121 (condition_factor -> condition_literal .)
    OR              reduce using rule 121 (condition_factor -> condition_literal .)
    RPAREN          reduce using rule 121 (condition_factor -> condition_literal .)


state 265

    (122) condition_factor -> TILDE . condition_literal
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition_literal              shift and go to state 339

state 266

    (139) condition_literal -> INT_LIT .

    PLUS            reduce using rule 139 (condition_literal -> INT_LIT .)
    MINUS           reduce using rule 139 (condition_literal -> INT_LIT .)
    MULTIPLY        reduce using rule 139 (condition_literal -> INT_LIT .)
    DIVISION        reduce using rule 139 (condition_literal -> INT_LIT .)
    MODULO          reduce using rule 139 (condition_literal -> INT_LIT .)
    EXPONENT        reduce using rule 139 (condition_literal -> INT_LIT .)
    GT              reduce using rule 139 (condition_literal -> INT_LIT .)
    LT              reduce using rule 139 (condition_literal -> INT_LIT .)
    EQ_EQ           reduce using rule 139 (condition_literal -> INT_LIT .)
    GT_EQ           reduce using rule 139 (condition_literal -> INT_LIT .)
    LT_EQ           reduce using rule 139 (condition_literal -> INT_LIT .)
    NOT_EQ          reduce using rule 139 (condition_literal -> INT_LIT .)
    AND             reduce using rule 139 (condition_literal -> INT_LIT .)
    OR              reduce using rule 139 (condition_literal -> INT_LIT .)
    RPAREN          reduce using rule 139 (condition_literal -> INT_LIT .)


state 267

    (140) condition_literal -> FLT_LIT .

    PLUS            reduce using rule 140 (condition_literal -> FLT_LIT .)
    MINUS           reduce using rule 140 (condition_literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 140 (condition_literal -> FLT_LIT .)
    DIVISION        reduce using rule 140 (condition_literal -> FLT_LIT .)
    MODULO          reduce using rule 140 (condition_literal -> FLT_LIT .)
    EXPONENT        reduce using rule 140 (condition_literal -> FLT_LIT .)
    GT              reduce using rule 140 (condition_literal -> FLT_LIT .)
    LT              reduce using rule 140 (condition_literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 140 (condition_literal -> FLT_LIT .)
    GT_EQ           reduce using rule 140 (condition_literal -> FLT_LIT .)
    LT_EQ           reduce using rule 140 (condition_literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 140 (condition_literal -> FLT_LIT .)
    AND             reduce using rule 140 (condition_literal -> FLT_LIT .)
    OR              reduce using rule 140 (condition_literal -> FLT_LIT .)
    RPAREN          reduce using rule 140 (condition_literal -> FLT_LIT .)


state 268

    (141) condition_literal -> DAY .

    PLUS            reduce using rule 141 (condition_literal -> DAY .)
    MINUS           reduce using rule 141 (condition_literal -> DAY .)
    MULTIPLY        reduce using rule 141 (condition_literal -> DAY .)
    DIVISION        reduce using rule 141 (condition_literal -> DAY .)
    MODULO          reduce using rule 141 (condition_literal -> DAY .)
    EXPONENT        reduce using rule 141 (condition_literal -> DAY .)
    GT              reduce using rule 141 (condition_literal -> DAY .)
    LT              reduce using rule 141 (condition_literal -> DAY .)
    EQ_EQ           reduce using rule 141 (condition_literal -> DAY .)
    GT_EQ           reduce using rule 141 (condition_literal -> DAY .)
    LT_EQ           reduce using rule 141 (condition_literal -> DAY .)
    NOT_EQ          reduce using rule 141 (condition_literal -> DAY .)
    AND             reduce using rule 141 (condition_literal -> DAY .)
    OR              reduce using rule 141 (condition_literal -> DAY .)
    RPAREN          reduce using rule 141 (condition_literal -> DAY .)


state 269

    (142) condition_literal -> NIGHT .

    PLUS            reduce using rule 142 (condition_literal -> NIGHT .)
    MINUS           reduce using rule 142 (condition_literal -> NIGHT .)
    MULTIPLY        reduce using rule 142 (condition_literal -> NIGHT .)
    DIVISION        reduce using rule 142 (condition_literal -> NIGHT .)
    MODULO          reduce using rule 142 (condition_literal -> NIGHT .)
    EXPONENT        reduce using rule 142 (condition_literal -> NIGHT .)
    GT              reduce using rule 142 (condition_literal -> NIGHT .)
    LT              reduce using rule 142 (condition_literal -> NIGHT .)
    EQ_EQ           reduce using rule 142 (condition_literal -> NIGHT .)
    GT_EQ           reduce using rule 142 (condition_literal -> NIGHT .)
    LT_EQ           reduce using rule 142 (condition_literal -> NIGHT .)
    NOT_EQ          reduce using rule 142 (condition_literal -> NIGHT .)
    AND             reduce using rule 142 (condition_literal -> NIGHT .)
    OR              reduce using rule 142 (condition_literal -> NIGHT .)
    RPAREN          reduce using rule 142 (condition_literal -> NIGHT .)


state 270

    (143) condition_literal -> CHR_LIT .

    PLUS            reduce using rule 143 (condition_literal -> CHR_LIT .)
    MINUS           reduce using rule 143 (condition_literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 143 (condition_literal -> CHR_LIT .)
    DIVISION        reduce using rule 143 (condition_literal -> CHR_LIT .)
    MODULO          reduce using rule 143 (condition_literal -> CHR_LIT .)
    EXPONENT        reduce using rule 143 (condition_literal -> CHR_LIT .)
    GT              reduce using rule 143 (condition_literal -> CHR_LIT .)
    LT              reduce using rule 143 (condition_literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 143 (condition_literal -> CHR_LIT .)
    GT_EQ           reduce using rule 143 (condition_literal -> CHR_LIT .)
    LT_EQ           reduce using rule 143 (condition_literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 143 (condition_literal -> CHR_LIT .)
    AND             reduce using rule 143 (condition_literal -> CHR_LIT .)
    OR              reduce using rule 143 (condition_literal -> CHR_LIT .)
    RPAREN          reduce using rule 143 (condition_literal -> CHR_LIT .)


state 271

    (144) condition_literal -> STR_LIT .

    PLUS            reduce using rule 144 (condition_literal -> STR_LIT .)
    MINUS           reduce using rule 144 (condition_literal -> STR_LIT .)
    MULTIPLY        reduce using rule 144 (condition_literal -> STR_LIT .)
    DIVISION        reduce using rule 144 (condition_literal -> STR_LIT .)
    MODULO          reduce using rule 144 (condition_literal -> STR_LIT .)
    EXPONENT        reduce using rule 144 (condition_literal -> STR_LIT .)
    GT              reduce using rule 144 (condition_literal -> STR_LIT .)
    LT              reduce using rule 144 (condition_literal -> STR_LIT .)
    EQ_EQ           reduce using rule 144 (condition_literal -> STR_LIT .)
    GT_EQ           reduce using rule 144 (condition_literal -> STR_LIT .)
    LT_EQ           reduce using rule 144 (condition_literal -> STR_LIT .)
    NOT_EQ          reduce using rule 144 (condition_literal -> STR_LIT .)
    AND             reduce using rule 144 (condition_literal -> STR_LIT .)
    OR              reduce using rule 144 (condition_literal -> STR_LIT .)
    RPAREN          reduce using rule 144 (condition_literal -> STR_LIT .)


state 272

    (145) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    RPAREN          shift and go to state 340


state 273

    (223) output_statement -> DISPLAY output_value next_val .

    NEWLINE         reduce using rule 223 (output_statement -> DISPLAY output_value next_val .)


state 274

    (232) next_val -> empty .

    NEWLINE         reduce using rule 232 (next_val -> empty .)
    RPAREN          reduce using rule 232 (next_val -> empty .)


state 275

    (233) next_val -> COMMA . value next_val
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (215) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (216) function_call -> . input_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (234) input_statement -> . INPUT LPAREN RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 231
    CONVERT_TO_FLT  shift and go to state 232
    CONVERT_TO_BLN  shift and go to state 233
    CONVERT_TO_STR  shift and go to state 234
    FUNCTION_NAME   shift and go to state 158
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 160
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 341
    type_cast                      shift and go to state 228
    expression                     shift and go to state 229
    function_call                  shift and go to state 230
    factor                         shift and go to state 49
    input_statement                shift and go to state 159
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 276

    (224) output_statement -> DISPLAY LPAREN output_value . next_val RPAREN
    (232) next_val -> . empty
    (233) next_val -> . COMMA value next_val
    (248) empty -> .

    COMMA           shift and go to state 275
    RPAREN          reduce using rule 248 (empty -> .)

    next_val                       shift and go to state 342
    empty                          shift and go to state 274

state 277

    (57) factor -> LPAREN expression . RPAREN
    (226) output_value -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 115
    COMMA           reduce using rule 226 (output_value -> expression .)

  ! RPAREN          [ reduce using rule 226 (output_value -> expression .) ]


state 278

    (228) output_type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 343
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 279

    (229) output_type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 344
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 280

    (230) output_type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 345
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 281

    (231) output_type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 346
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 282

    (152) for_loop -> FOR LPAREN control_variable . SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 347


state 283

    (207) control_variable -> INT . IDENT EQ control_var_tail

    IDENT           shift and go to state 348


state 284

    (185) until_loop_condition_factor -> LPAREN . until_loop_condition RPAREN
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 349
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 285

    (179) until_loop -> UNTIL LPAREN until_loop_condition . RPAREN LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 350


state 286

    (181) until_loop_condition -> until_loop_condition_factor . until_loop_condition_factor_tail
    (186) until_loop_condition_factor_tail -> . empty
    (187) until_loop_condition_factor_tail -> . PLUS until_loop_condition
    (188) until_loop_condition_factor_tail -> . MINUS until_loop_condition
    (189) until_loop_condition_factor_tail -> . MULTIPLY until_loop_condition
    (190) until_loop_condition_factor_tail -> . DIVISION until_loop_condition
    (191) until_loop_condition_factor_tail -> . MODULO until_loop_condition
    (192) until_loop_condition_factor_tail -> . EXPONENT until_loop_condition
    (193) until_loop_condition_factor_tail -> . GT until_loop_condition
    (194) until_loop_condition_factor_tail -> . LT until_loop_condition
    (195) until_loop_condition_factor_tail -> . EQ_EQ until_loop_condition
    (196) until_loop_condition_factor_tail -> . GT_EQ until_loop_condition
    (197) until_loop_condition_factor_tail -> . LT_EQ until_loop_condition
    (198) until_loop_condition_factor_tail -> . NOT_EQ until_loop_condition
    (199) until_loop_condition_factor_tail -> . AND until_loop_condition
    (200) until_loop_condition_factor_tail -> . OR until_loop_condition
    (248) empty -> .

    PLUS            shift and go to state 353
    MINUS           shift and go to state 354
    MULTIPLY        shift and go to state 355
    DIVISION        shift and go to state 356
    MODULO          shift and go to state 357
    EXPONENT        shift and go to state 358
    GT              shift and go to state 359
    LT              shift and go to state 360
    EQ_EQ           shift and go to state 361
    GT_EQ           shift and go to state 362
    LT_EQ           shift and go to state 363
    NOT_EQ          shift and go to state 364
    AND             shift and go to state 365
    OR              shift and go to state 366
    RPAREN          reduce using rule 248 (empty -> .)

    until_loop_condition_factor_tail shift and go to state 351
    empty                          shift and go to state 352

state 287

    (182) until_loop_condition_factor -> var_call .

    PLUS            reduce using rule 182 (until_loop_condition_factor -> var_call .)
    MINUS           reduce using rule 182 (until_loop_condition_factor -> var_call .)
    MULTIPLY        reduce using rule 182 (until_loop_condition_factor -> var_call .)
    DIVISION        reduce using rule 182 (until_loop_condition_factor -> var_call .)
    MODULO          reduce using rule 182 (until_loop_condition_factor -> var_call .)
    EXPONENT        reduce using rule 182 (until_loop_condition_factor -> var_call .)
    GT              reduce using rule 182 (until_loop_condition_factor -> var_call .)
    LT              reduce using rule 182 (until_loop_condition_factor -> var_call .)
    EQ_EQ           reduce using rule 182 (until_loop_condition_factor -> var_call .)
    GT_EQ           reduce using rule 182 (until_loop_condition_factor -> var_call .)
    LT_EQ           reduce using rule 182 (until_loop_condition_factor -> var_call .)
    NOT_EQ          reduce using rule 182 (until_loop_condition_factor -> var_call .)
    AND             reduce using rule 182 (until_loop_condition_factor -> var_call .)
    OR              reduce using rule 182 (until_loop_condition_factor -> var_call .)
    RPAREN          reduce using rule 182 (until_loop_condition_factor -> var_call .)


state 288

    (183) until_loop_condition_factor -> until_loop_condition_literal .

    PLUS            reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    MINUS           reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    MULTIPLY        reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    DIVISION        reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    MODULO          reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    EXPONENT        reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    GT              reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    LT              reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    EQ_EQ           reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    GT_EQ           reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    LT_EQ           reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    NOT_EQ          reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    AND             reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    OR              reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)
    RPAREN          reduce using rule 183 (until_loop_condition_factor -> until_loop_condition_literal .)


state 289

    (184) until_loop_condition_factor -> TILDE . until_loop_condition_literal
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition_literal   shift and go to state 367

state 290

    (201) until_loop_condition_literal -> INT_LIT .

    PLUS            reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    MINUS           reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    MULTIPLY        reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    DIVISION        reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    MODULO          reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    EXPONENT        reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    GT              reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    LT              reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    EQ_EQ           reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    GT_EQ           reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    LT_EQ           reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    NOT_EQ          reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    AND             reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    OR              reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)
    RPAREN          reduce using rule 201 (until_loop_condition_literal -> INT_LIT .)


state 291

    (202) until_loop_condition_literal -> FLT_LIT .

    PLUS            reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    MINUS           reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    DIVISION        reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    MODULO          reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    EXPONENT        reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    GT              reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    LT              reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    GT_EQ           reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    LT_EQ           reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    AND             reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    OR              reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)
    RPAREN          reduce using rule 202 (until_loop_condition_literal -> FLT_LIT .)


state 292

    (203) until_loop_condition_literal -> DAY .

    PLUS            reduce using rule 203 (until_loop_condition_literal -> DAY .)
    MINUS           reduce using rule 203 (until_loop_condition_literal -> DAY .)
    MULTIPLY        reduce using rule 203 (until_loop_condition_literal -> DAY .)
    DIVISION        reduce using rule 203 (until_loop_condition_literal -> DAY .)
    MODULO          reduce using rule 203 (until_loop_condition_literal -> DAY .)
    EXPONENT        reduce using rule 203 (until_loop_condition_literal -> DAY .)
    GT              reduce using rule 203 (until_loop_condition_literal -> DAY .)
    LT              reduce using rule 203 (until_loop_condition_literal -> DAY .)
    EQ_EQ           reduce using rule 203 (until_loop_condition_literal -> DAY .)
    GT_EQ           reduce using rule 203 (until_loop_condition_literal -> DAY .)
    LT_EQ           reduce using rule 203 (until_loop_condition_literal -> DAY .)
    NOT_EQ          reduce using rule 203 (until_loop_condition_literal -> DAY .)
    AND             reduce using rule 203 (until_loop_condition_literal -> DAY .)
    OR              reduce using rule 203 (until_loop_condition_literal -> DAY .)
    RPAREN          reduce using rule 203 (until_loop_condition_literal -> DAY .)


state 293

    (204) until_loop_condition_literal -> NIGHT .

    PLUS            reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    MINUS           reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    MULTIPLY        reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    DIVISION        reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    MODULO          reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    EXPONENT        reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    GT              reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    LT              reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    EQ_EQ           reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    GT_EQ           reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    LT_EQ           reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    NOT_EQ          reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    AND             reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    OR              reduce using rule 204 (until_loop_condition_literal -> NIGHT .)
    RPAREN          reduce using rule 204 (until_loop_condition_literal -> NIGHT .)


state 294

    (205) until_loop_condition_literal -> CHR_LIT .

    PLUS            reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    MINUS           reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    DIVISION        reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    MODULO          reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    EXPONENT        reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    GT              reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    LT              reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    GT_EQ           reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    LT_EQ           reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    AND             reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    OR              reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)
    RPAREN          reduce using rule 205 (until_loop_condition_literal -> CHR_LIT .)


state 295

    (206) until_loop_condition_literal -> STR_LIT .

    PLUS            reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    MINUS           reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    MULTIPLY        reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    DIVISION        reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    MODULO          reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    EXPONENT        reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    GT              reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    LT              reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    EQ_EQ           reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    GT_EQ           reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    LT_EQ           reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    NOT_EQ          reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    AND             reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    OR              reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)
    RPAREN          reduce using rule 206 (until_loop_condition_literal -> STR_LIT .)


state 296

    (180) repeat_until -> REPEAT LBRACE maybe_newline . statements RBRACE UNTIL LPAREN until_loop_condition RPAREN
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 368
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 297

    (21) var_tail -> EQ tail_value var_tail2 .

    NEWLINE         reduce using rule 21 (var_tail -> EQ tail_value var_tail2 .)


state 298

    (23) var_tail2 -> empty .

    NEWLINE         reduce using rule 23 (var_tail2 -> empty .)


state 299

    (24) var_tail2 -> COMMA . IDENT var_tail

    IDENT           shift and go to state 369


state 300

    (26) tail_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 370


state 301

    (40) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 371
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 302

    (41) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 372
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 303

    (42) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 373
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 304

    (43) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (234) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 239
    INPUT           shift and go to state 160
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 374
    expression                     shift and go to state 238
    input_statement                shift and go to state 240
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 305

    (22) var_tail -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 22 (var_tail -> COMMA IDENT var_tail .)


state 306

    (76) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail .

    NEWLINE         reduce using rule 76 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail .)
    MAIN_CASPER     reduce using rule 76 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE maybe_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail .)


state 307

    (78) function_statements_tail -> function_statements .

    NEWLINE         reduce using rule 78 (function_statements_tail -> function_statements .)
    MAIN_CASPER     reduce using rule 78 (function_statements_tail -> function_statements .)


state 308

    (79) function_statements_tail -> empty .
    (77) function_statements -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 77 (function_statements -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 77 (function_statements -> empty .)
    NEWLINE         reduce using rule 77 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 77 (function_statements -> empty .)

  ! NEWLINE         [ reduce using rule 79 (function_statements_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 79 (function_statements_tail -> empty .) ]


state 309

    (101) revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 101 (revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 101 (revive_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 310

    (45) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 375


state 311

    (102) revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 102 (revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 102 (revive_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 312

    (103) revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 103 (revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 103 (revive_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 313

    (104) revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 104 (revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 104 (revive_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 314

    (215) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 215 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 215 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 215 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 215 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 215 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 315

    (218) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 218 (arguments -> arg_value arg_tail .)


state 316

    (219) arg_tail -> empty .

    RPAREN          reduce using rule 219 (arg_tail -> empty .)


state 317

    (220) arg_tail -> COMMA . arg_value arg_tail
    (221) arg_value -> . literal
    (222) arg_value -> . var_call
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT
    (73) var_call -> . IDENT var_call_tail

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60
    IDENT           shift and go to state 54

    arg_value                      shift and go to state 376
    literal                        shift and go to state 247
    var_call                       shift and go to state 248

state 318

    (245) stringcon_tail -> PLUS . string_val stringcon_tail
    (246) string_val -> . var_call
    (247) string_val -> . STR_LIT
    (73) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 258
    IDENT           shift and go to state 54

    string_val                     shift and go to state 377
    var_call                       shift and go to state 257

state 319

    (236) string_operation_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 236 (string_operation_tail -> PLUS string_val stringcon_tail .)


state 320

    (244) stringcon_tail -> empty .

    NEWLINE         reduce using rule 244 (stringcon_tail -> empty .)


state 321

    (123) condition_factor -> LPAREN condition . RPAREN

    RPAREN          shift and go to state 378


state 322

    (116) conditional_statement -> CHECK LPAREN condition RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 379
    empty                          shift and go to state 16

state 323

    (119) condition -> condition_factor condition_factor_tail .

    RPAREN          reduce using rule 119 (condition -> condition_factor condition_factor_tail .)


state 324

    (124) condition_factor_tail -> empty .

    RPAREN          reduce using rule 124 (condition_factor_tail -> empty .)


state 325

    (125) condition_factor_tail -> PLUS . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 380
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 326

    (126) condition_factor_tail -> MINUS . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 381
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 327

    (127) condition_factor_tail -> MULTIPLY . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 382
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 328

    (128) condition_factor_tail -> DIVISION . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 383
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 329

    (129) condition_factor_tail -> MODULO . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 384
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 330

    (130) condition_factor_tail -> EXPONENT . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 385
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 331

    (131) condition_factor_tail -> GT . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 386
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 332

    (132) condition_factor_tail -> LT . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 387
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 333

    (133) condition_factor_tail -> EQ_EQ . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 388
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 334

    (134) condition_factor_tail -> GT_EQ . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 389
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 335

    (135) condition_factor_tail -> LT_EQ . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 390
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 336

    (136) condition_factor_tail -> NOT_EQ . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 391
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 337

    (137) condition_factor_tail -> AND . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 392
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 338

    (138) condition_factor_tail -> OR . condition
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 393
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 339

    (122) condition_factor -> TILDE condition_literal .

    PLUS            reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    MINUS           reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    MULTIPLY        reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    DIVISION        reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    MODULO          reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    EXPONENT        reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    GT              reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    LT              reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    EQ_EQ           reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    GT_EQ           reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    LT_EQ           reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    NOT_EQ          reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    AND             reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    OR              reduce using rule 122 (condition_factor -> TILDE condition_literal .)
    RPAREN          reduce using rule 122 (condition_factor -> TILDE condition_literal .)


state 340

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 394


state 341

    (233) next_val -> COMMA value . next_val
    (232) next_val -> . empty
    (233) next_val -> . COMMA value next_val
    (248) empty -> .

    COMMA           shift and go to state 275
    NEWLINE         reduce using rule 248 (empty -> .)
    RPAREN          reduce using rule 248 (empty -> .)

    next_val                       shift and go to state 395
    empty                          shift and go to state 274

state 342

    (224) output_statement -> DISPLAY LPAREN output_value next_val . RPAREN

    RPAREN          shift and go to state 396


state 343

    (228) output_type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 397


state 344

    (229) output_type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 398


state 345

    (230) output_type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 399


state 346

    (231) output_type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 400


state 347

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON . for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 402
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 348

    (207) control_variable -> INT IDENT . EQ control_var_tail

    EQ              shift and go to state 413


state 349

    (185) until_loop_condition_factor -> LPAREN until_loop_condition . RPAREN

    RPAREN          shift and go to state 414


state 350

    (179) until_loop -> UNTIL LPAREN until_loop_condition RPAREN . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 415


state 351

    (181) until_loop_condition -> until_loop_condition_factor until_loop_condition_factor_tail .

    RPAREN          reduce using rule 181 (until_loop_condition -> until_loop_condition_factor until_loop_condition_factor_tail .)


state 352

    (186) until_loop_condition_factor_tail -> empty .

    RPAREN          reduce using rule 186 (until_loop_condition_factor_tail -> empty .)


state 353

    (187) until_loop_condition_factor_tail -> PLUS . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 416
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 354

    (188) until_loop_condition_factor_tail -> MINUS . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 417
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 355

    (189) until_loop_condition_factor_tail -> MULTIPLY . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 418
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 356

    (190) until_loop_condition_factor_tail -> DIVISION . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 419
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 357

    (191) until_loop_condition_factor_tail -> MODULO . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 420
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 358

    (192) until_loop_condition_factor_tail -> EXPONENT . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 421
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 359

    (193) until_loop_condition_factor_tail -> GT . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 422
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 360

    (194) until_loop_condition_factor_tail -> LT . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 423
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 361

    (195) until_loop_condition_factor_tail -> EQ_EQ . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 424
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 362

    (196) until_loop_condition_factor_tail -> GT_EQ . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 425
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 363

    (197) until_loop_condition_factor_tail -> LT_EQ . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 426
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 364

    (198) until_loop_condition_factor_tail -> NOT_EQ . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 427
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 365

    (199) until_loop_condition_factor_tail -> AND . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 428
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 366

    (200) until_loop_condition_factor_tail -> OR . until_loop_condition
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 429
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 367

    (184) until_loop_condition_factor -> TILDE until_loop_condition_literal .

    PLUS            reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    MINUS           reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    MULTIPLY        reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    DIVISION        reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    MODULO          reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    EXPONENT        reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    GT              reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    LT              reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    EQ_EQ           reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    GT_EQ           reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    LT_EQ           reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    NOT_EQ          reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    AND             reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    OR              reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)
    RPAREN          reduce using rule 184 (until_loop_condition_factor -> TILDE until_loop_condition_literal .)


state 368

    (180) repeat_until -> REPEAT LBRACE maybe_newline statements . RBRACE UNTIL LPAREN until_loop_condition RPAREN

    RBRACE          shift and go to state 430


state 369

    (24) var_tail2 -> COMMA IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (248) empty -> .

    EQ              shift and go to state 181
    COMMA           shift and go to state 182
    NEWLINE         reduce using rule 248 (empty -> .)

    var_tail                       shift and go to state 431
    empty                          shift and go to state 180

state 370

    (26) tail_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 26 (tail_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 26 (tail_value -> LBRACKET list_element RBRACKET .)


state 371

    (40) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 432


state 372

    (41) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 433


state 373

    (42) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 434


state 374

    (43) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 435


state 375

    (45) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 45 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 376

    (220) arg_tail -> COMMA arg_value . arg_tail
    (219) arg_tail -> . empty
    (220) arg_tail -> . COMMA arg_value arg_tail
    (248) empty -> .

    COMMA           shift and go to state 317
    RPAREN          reduce using rule 248 (empty -> .)

    arg_tail                       shift and go to state 436
    empty                          shift and go to state 316

state 377

    (245) stringcon_tail -> PLUS string_val . stringcon_tail
    (244) stringcon_tail -> . empty
    (245) stringcon_tail -> . PLUS string_val stringcon_tail
    (248) empty -> .

    PLUS            shift and go to state 318
    NEWLINE         reduce using rule 248 (empty -> .)

    stringcon_tail                 shift and go to state 437
    empty                          shift and go to state 320

state 378

    (123) condition_factor -> LPAREN condition RPAREN .

    PLUS            reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    MINUS           reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    MULTIPLY        reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    DIVISION        reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    MODULO          reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    EXPONENT        reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    GT              reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    LT              reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    EQ_EQ           reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    GT_EQ           reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    LT_EQ           reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    NOT_EQ          reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    AND             reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    OR              reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)
    RPAREN          reduce using rule 123 (condition_factor -> LPAREN condition RPAREN .)


state 379

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 438


state 380

    (125) condition_factor_tail -> PLUS condition .

    RPAREN          reduce using rule 125 (condition_factor_tail -> PLUS condition .)


state 381

    (126) condition_factor_tail -> MINUS condition .

    RPAREN          reduce using rule 126 (condition_factor_tail -> MINUS condition .)


state 382

    (127) condition_factor_tail -> MULTIPLY condition .

    RPAREN          reduce using rule 127 (condition_factor_tail -> MULTIPLY condition .)


state 383

    (128) condition_factor_tail -> DIVISION condition .

    RPAREN          reduce using rule 128 (condition_factor_tail -> DIVISION condition .)


state 384

    (129) condition_factor_tail -> MODULO condition .

    RPAREN          reduce using rule 129 (condition_factor_tail -> MODULO condition .)


state 385

    (130) condition_factor_tail -> EXPONENT condition .

    RPAREN          reduce using rule 130 (condition_factor_tail -> EXPONENT condition .)


state 386

    (131) condition_factor_tail -> GT condition .

    RPAREN          reduce using rule 131 (condition_factor_tail -> GT condition .)


state 387

    (132) condition_factor_tail -> LT condition .

    RPAREN          reduce using rule 132 (condition_factor_tail -> LT condition .)


state 388

    (133) condition_factor_tail -> EQ_EQ condition .

    RPAREN          reduce using rule 133 (condition_factor_tail -> EQ_EQ condition .)


state 389

    (134) condition_factor_tail -> GT_EQ condition .

    RPAREN          reduce using rule 134 (condition_factor_tail -> GT_EQ condition .)


state 390

    (135) condition_factor_tail -> LT_EQ condition .

    RPAREN          reduce using rule 135 (condition_factor_tail -> LT_EQ condition .)


state 391

    (136) condition_factor_tail -> NOT_EQ condition .

    RPAREN          reduce using rule 136 (condition_factor_tail -> NOT_EQ condition .)


state 392

    (137) condition_factor_tail -> AND condition .

    RPAREN          reduce using rule 137 (condition_factor_tail -> AND condition .)


state 393

    (138) condition_factor_tail -> OR condition .

    RPAREN          reduce using rule 138 (condition_factor_tail -> OR condition .)


state 394

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    SHIFT           reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 439
    empty                          shift and go to state 16

state 395

    (233) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 233 (next_val -> COMMA value next_val .)
    RPAREN          reduce using rule 233 (next_val -> COMMA value next_val .)


state 396

    (224) output_statement -> DISPLAY LPAREN output_value next_val RPAREN .

    NEWLINE         reduce using rule 224 (output_statement -> DISPLAY LPAREN output_value next_val RPAREN .)


state 397

    (228) output_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 228 (output_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 228 (output_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 228 (output_type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 398

    (229) output_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 229 (output_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 229 (output_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 229 (output_type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 399

    (230) output_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 230 (output_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 230 (output_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 230 (output_type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 400

    (231) output_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 231 (output_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 231 (output_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 231 (output_type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 401

    (157) for_loop_condition_factor -> LPAREN . for_loop_condition RPAREN
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 440
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 402

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition . SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 441


state 403

    (153) for_loop_condition -> for_loop_condition_factor . for_loop_condition_factor_tail
    (158) for_loop_condition_factor_tail -> . empty
    (159) for_loop_condition_factor_tail -> . PLUS for_loop_condition
    (160) for_loop_condition_factor_tail -> . MINUS for_loop_condition
    (161) for_loop_condition_factor_tail -> . MULTIPLY for_loop_condition
    (162) for_loop_condition_factor_tail -> . DIVISION for_loop_condition
    (163) for_loop_condition_factor_tail -> . MODULO for_loop_condition
    (164) for_loop_condition_factor_tail -> . EXPONENT for_loop_condition
    (165) for_loop_condition_factor_tail -> . GT for_loop_condition
    (166) for_loop_condition_factor_tail -> . LT for_loop_condition
    (167) for_loop_condition_factor_tail -> . EQ_EQ for_loop_condition
    (168) for_loop_condition_factor_tail -> . GT_EQ for_loop_condition
    (169) for_loop_condition_factor_tail -> . LT_EQ for_loop_condition
    (170) for_loop_condition_factor_tail -> . NOT_EQ for_loop_condition
    (171) for_loop_condition_factor_tail -> . AND for_loop_condition
    (172) for_loop_condition_factor_tail -> . OR for_loop_condition
    (248) empty -> .

    PLUS            shift and go to state 444
    MINUS           shift and go to state 445
    MULTIPLY        shift and go to state 446
    DIVISION        shift and go to state 447
    MODULO          shift and go to state 448
    EXPONENT        shift and go to state 449
    GT              shift and go to state 450
    LT              shift and go to state 451
    EQ_EQ           shift and go to state 452
    GT_EQ           shift and go to state 453
    LT_EQ           shift and go to state 454
    NOT_EQ          shift and go to state 455
    AND             shift and go to state 456
    OR              shift and go to state 457
    SEMICOLON       reduce using rule 248 (empty -> .)
    RPAREN          reduce using rule 248 (empty -> .)

    for_loop_condition_factor_tail shift and go to state 442
    empty                          shift and go to state 443

state 404

    (154) for_loop_condition_factor -> var_call .

    PLUS            reduce using rule 154 (for_loop_condition_factor -> var_call .)
    MINUS           reduce using rule 154 (for_loop_condition_factor -> var_call .)
    MULTIPLY        reduce using rule 154 (for_loop_condition_factor -> var_call .)
    DIVISION        reduce using rule 154 (for_loop_condition_factor -> var_call .)
    MODULO          reduce using rule 154 (for_loop_condition_factor -> var_call .)
    EXPONENT        reduce using rule 154 (for_loop_condition_factor -> var_call .)
    GT              reduce using rule 154 (for_loop_condition_factor -> var_call .)
    LT              reduce using rule 154 (for_loop_condition_factor -> var_call .)
    EQ_EQ           reduce using rule 154 (for_loop_condition_factor -> var_call .)
    GT_EQ           reduce using rule 154 (for_loop_condition_factor -> var_call .)
    LT_EQ           reduce using rule 154 (for_loop_condition_factor -> var_call .)
    NOT_EQ          reduce using rule 154 (for_loop_condition_factor -> var_call .)
    AND             reduce using rule 154 (for_loop_condition_factor -> var_call .)
    OR              reduce using rule 154 (for_loop_condition_factor -> var_call .)
    SEMICOLON       reduce using rule 154 (for_loop_condition_factor -> var_call .)
    RPAREN          reduce using rule 154 (for_loop_condition_factor -> var_call .)


state 405

    (155) for_loop_condition_factor -> for_loop_condition_literal .

    PLUS            reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    MINUS           reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    MULTIPLY        reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    DIVISION        reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    MODULO          reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    EXPONENT        reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    GT              reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    LT              reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    EQ_EQ           reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    GT_EQ           reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    LT_EQ           reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    NOT_EQ          reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    AND             reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    OR              reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    SEMICOLON       reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)
    RPAREN          reduce using rule 155 (for_loop_condition_factor -> for_loop_condition_literal .)


state 406

    (156) for_loop_condition_factor -> TILDE . for_loop_condition_literal
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition_literal     shift and go to state 458

state 407

    (173) for_loop_condition_literal -> INT_LIT .

    PLUS            reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    MINUS           reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    MULTIPLY        reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    DIVISION        reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    MODULO          reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    EXPONENT        reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    GT              reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    LT              reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    EQ_EQ           reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    GT_EQ           reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    LT_EQ           reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    NOT_EQ          reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    AND             reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    OR              reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    SEMICOLON       reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)
    RPAREN          reduce using rule 173 (for_loop_condition_literal -> INT_LIT .)


state 408

    (174) for_loop_condition_literal -> FLT_LIT .

    PLUS            reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    MINUS           reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    DIVISION        reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    MODULO          reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    EXPONENT        reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    GT              reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    LT              reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    GT_EQ           reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    LT_EQ           reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    AND             reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    OR              reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    SEMICOLON       reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)
    RPAREN          reduce using rule 174 (for_loop_condition_literal -> FLT_LIT .)


state 409

    (175) for_loop_condition_literal -> DAY .

    PLUS            reduce using rule 175 (for_loop_condition_literal -> DAY .)
    MINUS           reduce using rule 175 (for_loop_condition_literal -> DAY .)
    MULTIPLY        reduce using rule 175 (for_loop_condition_literal -> DAY .)
    DIVISION        reduce using rule 175 (for_loop_condition_literal -> DAY .)
    MODULO          reduce using rule 175 (for_loop_condition_literal -> DAY .)
    EXPONENT        reduce using rule 175 (for_loop_condition_literal -> DAY .)
    GT              reduce using rule 175 (for_loop_condition_literal -> DAY .)
    LT              reduce using rule 175 (for_loop_condition_literal -> DAY .)
    EQ_EQ           reduce using rule 175 (for_loop_condition_literal -> DAY .)
    GT_EQ           reduce using rule 175 (for_loop_condition_literal -> DAY .)
    LT_EQ           reduce using rule 175 (for_loop_condition_literal -> DAY .)
    NOT_EQ          reduce using rule 175 (for_loop_condition_literal -> DAY .)
    AND             reduce using rule 175 (for_loop_condition_literal -> DAY .)
    OR              reduce using rule 175 (for_loop_condition_literal -> DAY .)
    SEMICOLON       reduce using rule 175 (for_loop_condition_literal -> DAY .)
    RPAREN          reduce using rule 175 (for_loop_condition_literal -> DAY .)


state 410

    (176) for_loop_condition_literal -> NIGHT .

    PLUS            reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    MINUS           reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    MULTIPLY        reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    DIVISION        reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    MODULO          reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    EXPONENT        reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    GT              reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    LT              reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    EQ_EQ           reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    GT_EQ           reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    LT_EQ           reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    NOT_EQ          reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    AND             reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    OR              reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    SEMICOLON       reduce using rule 176 (for_loop_condition_literal -> NIGHT .)
    RPAREN          reduce using rule 176 (for_loop_condition_literal -> NIGHT .)


state 411

    (177) for_loop_condition_literal -> CHR_LIT .

    PLUS            reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    MINUS           reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    DIVISION        reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    MODULO          reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    EXPONENT        reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    GT              reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    LT              reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    GT_EQ           reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    LT_EQ           reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    AND             reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    OR              reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    SEMICOLON       reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)
    RPAREN          reduce using rule 177 (for_loop_condition_literal -> CHR_LIT .)


state 412

    (178) for_loop_condition_literal -> STR_LIT .

    PLUS            reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    MINUS           reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    MULTIPLY        reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    DIVISION        reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    MODULO          reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    EXPONENT        reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    GT              reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    LT              reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    EQ_EQ           reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    GT_EQ           reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    LT_EQ           reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    NOT_EQ          reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    AND             reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    OR              reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    SEMICOLON       reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)
    RPAREN          reduce using rule 178 (for_loop_condition_literal -> STR_LIT .)


state 413

    (207) control_variable -> INT IDENT EQ . control_var_tail
    (208) control_var_tail -> . INT_LIT
    (209) control_var_tail -> . var_call
    (73) var_call -> . IDENT var_call_tail

    INT_LIT         shift and go to state 460
    IDENT           shift and go to state 54

    control_var_tail               shift and go to state 459
    var_call                       shift and go to state 461

state 414

    (185) until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .

    PLUS            reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    MINUS           reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    MULTIPLY        reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    DIVISION        reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    MODULO          reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    EXPONENT        reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    GT              reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    LT              reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    EQ_EQ           reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    GT_EQ           reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    LT_EQ           reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    NOT_EQ          reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    AND             reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    OR              reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)
    RPAREN          reduce using rule 185 (until_loop_condition_factor -> LPAREN until_loop_condition RPAREN .)


state 415

    (179) until_loop -> UNTIL LPAREN until_loop_condition RPAREN LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 462
    empty                          shift and go to state 16

state 416

    (187) until_loop_condition_factor_tail -> PLUS until_loop_condition .

    RPAREN          reduce using rule 187 (until_loop_condition_factor_tail -> PLUS until_loop_condition .)


state 417

    (188) until_loop_condition_factor_tail -> MINUS until_loop_condition .

    RPAREN          reduce using rule 188 (until_loop_condition_factor_tail -> MINUS until_loop_condition .)


state 418

    (189) until_loop_condition_factor_tail -> MULTIPLY until_loop_condition .

    RPAREN          reduce using rule 189 (until_loop_condition_factor_tail -> MULTIPLY until_loop_condition .)


state 419

    (190) until_loop_condition_factor_tail -> DIVISION until_loop_condition .

    RPAREN          reduce using rule 190 (until_loop_condition_factor_tail -> DIVISION until_loop_condition .)


state 420

    (191) until_loop_condition_factor_tail -> MODULO until_loop_condition .

    RPAREN          reduce using rule 191 (until_loop_condition_factor_tail -> MODULO until_loop_condition .)


state 421

    (192) until_loop_condition_factor_tail -> EXPONENT until_loop_condition .

    RPAREN          reduce using rule 192 (until_loop_condition_factor_tail -> EXPONENT until_loop_condition .)


state 422

    (193) until_loop_condition_factor_tail -> GT until_loop_condition .

    RPAREN          reduce using rule 193 (until_loop_condition_factor_tail -> GT until_loop_condition .)


state 423

    (194) until_loop_condition_factor_tail -> LT until_loop_condition .

    RPAREN          reduce using rule 194 (until_loop_condition_factor_tail -> LT until_loop_condition .)


state 424

    (195) until_loop_condition_factor_tail -> EQ_EQ until_loop_condition .

    RPAREN          reduce using rule 195 (until_loop_condition_factor_tail -> EQ_EQ until_loop_condition .)


state 425

    (196) until_loop_condition_factor_tail -> GT_EQ until_loop_condition .

    RPAREN          reduce using rule 196 (until_loop_condition_factor_tail -> GT_EQ until_loop_condition .)


state 426

    (197) until_loop_condition_factor_tail -> LT_EQ until_loop_condition .

    RPAREN          reduce using rule 197 (until_loop_condition_factor_tail -> LT_EQ until_loop_condition .)


state 427

    (198) until_loop_condition_factor_tail -> NOT_EQ until_loop_condition .

    RPAREN          reduce using rule 198 (until_loop_condition_factor_tail -> NOT_EQ until_loop_condition .)


state 428

    (199) until_loop_condition_factor_tail -> AND until_loop_condition .

    RPAREN          reduce using rule 199 (until_loop_condition_factor_tail -> AND until_loop_condition .)


state 429

    (200) until_loop_condition_factor_tail -> OR until_loop_condition .

    RPAREN          reduce using rule 200 (until_loop_condition_factor_tail -> OR until_loop_condition .)


state 430

    (180) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE . UNTIL LPAREN until_loop_condition RPAREN

    UNTIL           shift and go to state 463


state 431

    (24) var_tail2 -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 24 (var_tail2 -> COMMA IDENT var_tail .)


state 432

    (40) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 433

    (41) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 434

    (42) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 435

    (43) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    COMMA           reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 436

    (220) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 220 (arg_tail -> COMMA arg_value arg_tail .)


state 437

    (245) stringcon_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 245 (stringcon_tail -> PLUS string_val stringcon_tail .)


state 438

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 464
    empty                          shift and go to state 16

state 439

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline . switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (146) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    SHIFT           shift and go to state 466

    switch_condition               shift and go to state 465

state 440

    (157) for_loop_condition_factor -> LPAREN for_loop_condition . RPAREN

    RPAREN          shift and go to state 467


state 441

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON . update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (210) update -> . var_call update_tail
    (73) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 54

    update                         shift and go to state 468
    var_call                       shift and go to state 469

state 442

    (153) for_loop_condition -> for_loop_condition_factor for_loop_condition_factor_tail .

    SEMICOLON       reduce using rule 153 (for_loop_condition -> for_loop_condition_factor for_loop_condition_factor_tail .)
    RPAREN          reduce using rule 153 (for_loop_condition -> for_loop_condition_factor for_loop_condition_factor_tail .)


state 443

    (158) for_loop_condition_factor_tail -> empty .

    SEMICOLON       reduce using rule 158 (for_loop_condition_factor_tail -> empty .)
    RPAREN          reduce using rule 158 (for_loop_condition_factor_tail -> empty .)


state 444

    (159) for_loop_condition_factor_tail -> PLUS . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 470
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 445

    (160) for_loop_condition_factor_tail -> MINUS . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 471
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 446

    (161) for_loop_condition_factor_tail -> MULTIPLY . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 472
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 447

    (162) for_loop_condition_factor_tail -> DIVISION . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 473
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 448

    (163) for_loop_condition_factor_tail -> MODULO . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 474
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 449

    (164) for_loop_condition_factor_tail -> EXPONENT . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 475
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 450

    (165) for_loop_condition_factor_tail -> GT . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 476
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 451

    (166) for_loop_condition_factor_tail -> LT . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 477
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 452

    (167) for_loop_condition_factor_tail -> EQ_EQ . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 478
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 453

    (168) for_loop_condition_factor_tail -> GT_EQ . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 479
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 454

    (169) for_loop_condition_factor_tail -> LT_EQ . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 480
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 455

    (170) for_loop_condition_factor_tail -> NOT_EQ . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 481
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 456

    (171) for_loop_condition_factor_tail -> AND . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 482
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 457

    (172) for_loop_condition_factor_tail -> OR . for_loop_condition
    (153) for_loop_condition -> . for_loop_condition_factor for_loop_condition_factor_tail
    (154) for_loop_condition_factor -> . var_call
    (155) for_loop_condition_factor -> . for_loop_condition_literal
    (156) for_loop_condition_factor -> . TILDE for_loop_condition_literal
    (157) for_loop_condition_factor -> . LPAREN for_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (173) for_loop_condition_literal -> . INT_LIT
    (174) for_loop_condition_literal -> . FLT_LIT
    (175) for_loop_condition_literal -> . DAY
    (176) for_loop_condition_literal -> . NIGHT
    (177) for_loop_condition_literal -> . CHR_LIT
    (178) for_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 406
    LPAREN          shift and go to state 401
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 407
    FLT_LIT         shift and go to state 408
    DAY             shift and go to state 409
    NIGHT           shift and go to state 410
    CHR_LIT         shift and go to state 411
    STR_LIT         shift and go to state 412

    for_loop_condition             shift and go to state 483
    for_loop_condition_factor      shift and go to state 403
    var_call                       shift and go to state 404
    for_loop_condition_literal     shift and go to state 405

state 458

    (156) for_loop_condition_factor -> TILDE for_loop_condition_literal .

    PLUS            reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    MINUS           reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    MULTIPLY        reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    DIVISION        reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    MODULO          reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    EXPONENT        reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    GT              reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    LT              reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    EQ_EQ           reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    GT_EQ           reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    LT_EQ           reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    NOT_EQ          reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    AND             reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    OR              reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    SEMICOLON       reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)
    RPAREN          reduce using rule 156 (for_loop_condition_factor -> TILDE for_loop_condition_literal .)


state 459

    (207) control_variable -> INT IDENT EQ control_var_tail .

    SEMICOLON       reduce using rule 207 (control_variable -> INT IDENT EQ control_var_tail .)


state 460

    (208) control_var_tail -> INT_LIT .

    SEMICOLON       reduce using rule 208 (control_var_tail -> INT_LIT .)


state 461

    (209) control_var_tail -> var_call .

    SEMICOLON       reduce using rule 209 (control_var_tail -> var_call .)


state 462

    (179) until_loop -> UNTIL LPAREN until_loop_condition RPAREN LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 484
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 463

    (180) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL . LPAREN until_loop_condition RPAREN

    LPAREN          shift and go to state 485


state 464

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 486
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 465

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE       reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 487
    empty                          shift and go to state 16

state 466

    (146) switch_condition -> SHIFT . value COLON maybe_newline statements switchcond_tail
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (215) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (216) function_call -> . input_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (234) input_statement -> . INPUT LPAREN RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 231
    CONVERT_TO_FLT  shift and go to state 232
    CONVERT_TO_BLN  shift and go to state 233
    CONVERT_TO_STR  shift and go to state 234
    FUNCTION_NAME   shift and go to state 158
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 160
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 488
    type_cast                      shift and go to state 228
    expression                     shift and go to state 229
    function_call                  shift and go to state 230
    factor                         shift and go to state 49
    input_statement                shift and go to state 159
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 467

    (157) for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .

    PLUS            reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    MINUS           reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    MULTIPLY        reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    DIVISION        reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    MODULO          reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    EXPONENT        reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    GT              reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    LT              reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    EQ_EQ           reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    GT_EQ           reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    LT_EQ           reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    NOT_EQ          reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    AND             reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    OR              reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    SEMICOLON       reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)
    RPAREN          reduce using rule 157 (for_loop_condition_factor -> LPAREN for_loop_condition RPAREN .)


state 468

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 489


state 469

    (210) update -> var_call . update_tail
    (211) update_tail -> . postfix
    (212) update_tail -> . assign_op value
    (213) postfix -> . PLUS_PLUS
    (214) postfix -> . MINUS_MINUS
    (238) assign_op -> . PLUS_EQ
    (239) assign_op -> . MINUS_EQ
    (240) assign_op -> . MUL_EQ
    (241) assign_op -> . DIV_EQ
    (242) assign_op -> . MOD_EQ
    (243) assign_op -> . EQ

    PLUS_PLUS       shift and go to state 202
    MINUS_MINUS     shift and go to state 203
    PLUS_EQ         shift and go to state 204
    MINUS_EQ        shift and go to state 205
    MUL_EQ          shift and go to state 206
    DIV_EQ          shift and go to state 207
    MOD_EQ          shift and go to state 208
    EQ              shift and go to state 209

    update_tail                    shift and go to state 490
    postfix                        shift and go to state 200
    assign_op                      shift and go to state 201

state 470

    (159) for_loop_condition_factor_tail -> PLUS for_loop_condition .

    SEMICOLON       reduce using rule 159 (for_loop_condition_factor_tail -> PLUS for_loop_condition .)
    RPAREN          reduce using rule 159 (for_loop_condition_factor_tail -> PLUS for_loop_condition .)


state 471

    (160) for_loop_condition_factor_tail -> MINUS for_loop_condition .

    SEMICOLON       reduce using rule 160 (for_loop_condition_factor_tail -> MINUS for_loop_condition .)
    RPAREN          reduce using rule 160 (for_loop_condition_factor_tail -> MINUS for_loop_condition .)


state 472

    (161) for_loop_condition_factor_tail -> MULTIPLY for_loop_condition .

    SEMICOLON       reduce using rule 161 (for_loop_condition_factor_tail -> MULTIPLY for_loop_condition .)
    RPAREN          reduce using rule 161 (for_loop_condition_factor_tail -> MULTIPLY for_loop_condition .)


state 473

    (162) for_loop_condition_factor_tail -> DIVISION for_loop_condition .

    SEMICOLON       reduce using rule 162 (for_loop_condition_factor_tail -> DIVISION for_loop_condition .)
    RPAREN          reduce using rule 162 (for_loop_condition_factor_tail -> DIVISION for_loop_condition .)


state 474

    (163) for_loop_condition_factor_tail -> MODULO for_loop_condition .

    SEMICOLON       reduce using rule 163 (for_loop_condition_factor_tail -> MODULO for_loop_condition .)
    RPAREN          reduce using rule 163 (for_loop_condition_factor_tail -> MODULO for_loop_condition .)


state 475

    (164) for_loop_condition_factor_tail -> EXPONENT for_loop_condition .

    SEMICOLON       reduce using rule 164 (for_loop_condition_factor_tail -> EXPONENT for_loop_condition .)
    RPAREN          reduce using rule 164 (for_loop_condition_factor_tail -> EXPONENT for_loop_condition .)


state 476

    (165) for_loop_condition_factor_tail -> GT for_loop_condition .

    SEMICOLON       reduce using rule 165 (for_loop_condition_factor_tail -> GT for_loop_condition .)
    RPAREN          reduce using rule 165 (for_loop_condition_factor_tail -> GT for_loop_condition .)


state 477

    (166) for_loop_condition_factor_tail -> LT for_loop_condition .

    SEMICOLON       reduce using rule 166 (for_loop_condition_factor_tail -> LT for_loop_condition .)
    RPAREN          reduce using rule 166 (for_loop_condition_factor_tail -> LT for_loop_condition .)


state 478

    (167) for_loop_condition_factor_tail -> EQ_EQ for_loop_condition .

    SEMICOLON       reduce using rule 167 (for_loop_condition_factor_tail -> EQ_EQ for_loop_condition .)
    RPAREN          reduce using rule 167 (for_loop_condition_factor_tail -> EQ_EQ for_loop_condition .)


state 479

    (168) for_loop_condition_factor_tail -> GT_EQ for_loop_condition .

    SEMICOLON       reduce using rule 168 (for_loop_condition_factor_tail -> GT_EQ for_loop_condition .)
    RPAREN          reduce using rule 168 (for_loop_condition_factor_tail -> GT_EQ for_loop_condition .)


state 480

    (169) for_loop_condition_factor_tail -> LT_EQ for_loop_condition .

    SEMICOLON       reduce using rule 169 (for_loop_condition_factor_tail -> LT_EQ for_loop_condition .)
    RPAREN          reduce using rule 169 (for_loop_condition_factor_tail -> LT_EQ for_loop_condition .)


state 481

    (170) for_loop_condition_factor_tail -> NOT_EQ for_loop_condition .

    SEMICOLON       reduce using rule 170 (for_loop_condition_factor_tail -> NOT_EQ for_loop_condition .)
    RPAREN          reduce using rule 170 (for_loop_condition_factor_tail -> NOT_EQ for_loop_condition .)


state 482

    (171) for_loop_condition_factor_tail -> AND for_loop_condition .

    SEMICOLON       reduce using rule 171 (for_loop_condition_factor_tail -> AND for_loop_condition .)
    RPAREN          reduce using rule 171 (for_loop_condition_factor_tail -> AND for_loop_condition .)


state 483

    (172) for_loop_condition_factor_tail -> OR for_loop_condition .

    SEMICOLON       reduce using rule 172 (for_loop_condition_factor_tail -> OR for_loop_condition .)
    RPAREN          reduce using rule 172 (for_loop_condition_factor_tail -> OR for_loop_condition .)


state 484

    (179) until_loop -> UNTIL LPAREN until_loop_condition RPAREN LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 491


state 485

    (180) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN . until_loop_condition RPAREN
    (181) until_loop_condition -> . until_loop_condition_factor until_loop_condition_factor_tail
    (182) until_loop_condition_factor -> . var_call
    (183) until_loop_condition_factor -> . until_loop_condition_literal
    (184) until_loop_condition_factor -> . TILDE until_loop_condition_literal
    (185) until_loop_condition_factor -> . LPAREN until_loop_condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (201) until_loop_condition_literal -> . INT_LIT
    (202) until_loop_condition_literal -> . FLT_LIT
    (203) until_loop_condition_literal -> . DAY
    (204) until_loop_condition_literal -> . NIGHT
    (205) until_loop_condition_literal -> . CHR_LIT
    (206) until_loop_condition_literal -> . STR_LIT

    TILDE           shift and go to state 289
    LPAREN          shift and go to state 284
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 290
    FLT_LIT         shift and go to state 291
    DAY             shift and go to state 292
    NIGHT           shift and go to state 293
    CHR_LIT         shift and go to state 294
    STR_LIT         shift and go to state 295

    until_loop_condition           shift and go to state 492
    until_loop_condition_factor    shift and go to state 286
    var_call                       shift and go to state 287
    until_loop_condition_literal   shift and go to state 288

state 486

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    RBRACE          shift and go to state 493


state 487

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    OTHERWISE       shift and go to state 494


state 488

    (146) switch_condition -> SHIFT value . COLON maybe_newline statements switchcond_tail

    COLON           shift and go to state 495


state 489

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 496
    empty                          shift and go to state 16

state 490

    (210) update -> var_call update_tail .

    RPAREN          reduce using rule 210 (update -> var_call update_tail .)


state 491

    (179) until_loop -> UNTIL LPAREN until_loop_condition RPAREN LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 179 (until_loop -> UNTIL LPAREN until_loop_condition RPAREN LBRACE maybe_newline statements RBRACE .)


state 492

    (180) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN until_loop_condition . RPAREN

    RPAREN          shift and go to state 497


state 493

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 498
    empty                          shift and go to state 16

state 494

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 499
    empty                          shift and go to state 16

state 495

    (146) switch_condition -> SHIFT value COLON . maybe_newline statements switchcond_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    SHIFT           reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 500
    empty                          shift and go to state 16

state 496

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 501


state 497

    (180) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN until_loop_condition RPAREN .

    NEWLINE         reduce using rule 180 (repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN until_loop_condition RPAREN .)


state 498

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (117) conditional_tail -> . OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (118) conditional_tail -> . empty
    (248) empty -> .

    OTHERWISE_CHECK shift and go to state 503
    OTHERWISE       reduce using rule 248 (empty -> .)

    conditional_tail               shift and go to state 502
    empty                          shift and go to state 504

state 499

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 505


state 500

    (146) switch_condition -> SHIFT value COLON maybe_newline . statements switchcond_tail
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SHIFT           reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 506
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 501

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 507
    empty                          shift and go to state 16

state 502

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail . OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    OTHERWISE       shift and go to state 508


state 503

    (117) conditional_tail -> OTHERWISE_CHECK . LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    LPAREN          shift and go to state 509


state 504

    (118) conditional_tail -> empty .

    OTHERWISE       reduce using rule 118 (conditional_tail -> empty .)


state 505

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 510
    empty                          shift and go to state 16

state 506

    (146) switch_condition -> SHIFT value COLON maybe_newline statements . switchcond_tail
    (147) switchcond_tail -> . empty
    (148) switchcond_tail -> . switch_condition
    (248) empty -> .
    (146) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    NEWLINE         reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)
    SHIFT           shift and go to state 466

    switchcond_tail                shift and go to state 511
    empty                          shift and go to state 512
    switch_condition               shift and go to state 513

state 507

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 514
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 508

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 515
    empty                          shift and go to state 16

state 509

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN . condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (119) condition -> . condition_factor condition_factor_tail
    (120) condition_factor -> . var_call
    (121) condition_factor -> . condition_literal
    (122) condition_factor -> . TILDE condition_literal
    (123) condition_factor -> . LPAREN condition RPAREN
    (73) var_call -> . IDENT var_call_tail
    (139) condition_literal -> . INT_LIT
    (140) condition_literal -> . FLT_LIT
    (141) condition_literal -> . DAY
    (142) condition_literal -> . NIGHT
    (143) condition_literal -> . CHR_LIT
    (144) condition_literal -> . STR_LIT

    TILDE           shift and go to state 265
    LPAREN          shift and go to state 260
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 266
    FLT_LIT         shift and go to state 267
    DAY             shift and go to state 268
    NIGHT           shift and go to state 269
    CHR_LIT         shift and go to state 270
    STR_LIT         shift and go to state 271

    condition                      shift and go to state 516
    condition_factor               shift and go to state 262
    var_call                       shift and go to state 263
    condition_literal              shift and go to state 264

state 510

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 517
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 511

    (146) switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .

    NEWLINE         reduce using rule 146 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)
    OTHERWISE       reduce using rule 146 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)


state 512

    (147) switchcond_tail -> empty .

    NEWLINE         reduce using rule 147 (switchcond_tail -> empty .)
    OTHERWISE       reduce using rule 147 (switchcond_tail -> empty .)


state 513

    (148) switchcond_tail -> switch_condition .

    NEWLINE         reduce using rule 148 (switchcond_tail -> switch_condition .)
    OTHERWISE       reduce using rule 148 (switchcond_tail -> switch_condition .)


state 514

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 518


state 515

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 519


state 516

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    RPAREN          shift and go to state 520


state 517

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 521
    empty                          shift and go to state 16

state 518

    (152) for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 152 (for_loop -> FOR LPAREN control_variable SEMICOLON for_loop_condition SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .)


state 519

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 522
    empty                          shift and go to state 16

state 520

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 523
    empty                          shift and go to state 16

state 521

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline RBRACE

    RBRACE          shift and go to state 524


state 522

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 525
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 523

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    LBRACE          shift and go to state 526


state 524

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 527
    empty                          shift and go to state 16

state 525

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 528


state 526

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 248 (empty -> .)
    FLT             reduce using rule 248 (empty -> .)
    BLN             reduce using rule 248 (empty -> .)
    CHR             reduce using rule 248 (empty -> .)
    STR             reduce using rule 248 (empty -> .)
    RBRACE          reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)

  ! NEWLINE         [ reduce using rule 248 (empty -> .) ]

    maybe_newline                  shift and go to state 529
    empty                          shift and go to state 16

state 527

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . RBRACE

    RBRACE          shift and go to state 530


state 528

    (116) conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 116 (conditional_statement -> CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .)


state 529

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (248) empty -> .
    (114) local_dec -> . empty
    (115) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 248 (empty -> .)
    NEWLINE         reduce using rule 248 (empty -> .)
    CHECK           reduce using rule 248 (empty -> .)
    SWAP            reduce using rule 248 (empty -> .)
    FUNCTION_NAME   reduce using rule 248 (empty -> .)
    DISPLAY         reduce using rule 248 (empty -> .)
    IDENT           reduce using rule 248 (empty -> .)
    FOR             reduce using rule 248 (empty -> .)
    UNTIL           reduce using rule 248 (empty -> .)
    REPEAT          reduce using rule 248 (empty -> .)
    INPUT           reduce using rule 248 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 248 (empty -> .) ]
  ! FLT             [ reduce using rule 248 (empty -> .) ]
  ! BLN             [ reduce using rule 248 (empty -> .) ]
  ! CHR             [ reduce using rule 248 (empty -> .) ]
  ! STR             [ reduce using rule 248 (empty -> .) ]

    statements                     shift and go to state 531
    empty                          shift and go to state 136
    local_dec                      shift and go to state 137
    var_statement                  shift and go to state 138
    data_type                      shift and go to state 139

state 530

    (145) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .

    NEWLINE         reduce using rule 145 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .)


state 531

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail

    RBRACE          shift and go to state 532


state 532

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (248) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 248 (empty -> .)
    OTHERWISE       reduce using rule 248 (empty -> .)

    maybe_newline                  shift and go to state 533
    empty                          shift and go to state 16

state 533

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail
    (117) conditional_tail -> . OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (118) conditional_tail -> . empty
    (248) empty -> .

    OTHERWISE_CHECK shift and go to state 503
    OTHERWISE       reduce using rule 248 (empty -> .)

    conditional_tail               shift and go to state 534
    empty                          shift and go to state 504

state 534

    (117) conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .

    OTHERWISE       reduce using rule 117 (conditional_tail -> OTHERWISE_CHECK LPAREN condition RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 17 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 127 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 131 resolved as shift
WARNING: shift/reduce conflict for INT in state 132 resolved as shift
WARNING: shift/reduce conflict for FLT in state 132 resolved as shift
WARNING: shift/reduce conflict for BLN in state 132 resolved as shift
WARNING: shift/reduce conflict for CHR in state 132 resolved as shift
WARNING: shift/reduce conflict for STR in state 132 resolved as shift
WARNING: shift/reduce conflict for INT in state 134 resolved as shift
WARNING: shift/reduce conflict for FLT in state 134 resolved as shift
WARNING: shift/reduce conflict for BLN in state 134 resolved as shift
WARNING: shift/reduce conflict for CHR in state 134 resolved as shift
WARNING: shift/reduce conflict for STR in state 134 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 137 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 145 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 145 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 145 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 145 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 145 resolved as shift
WARNING: shift/reduce conflict for FOR in state 145 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 145 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 145 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 145 resolved as shift
WARNING: shift/reduce conflict for INT in state 145 resolved as shift
WARNING: shift/reduce conflict for FLT in state 145 resolved as shift
WARNING: shift/reduce conflict for BLN in state 145 resolved as shift
WARNING: shift/reduce conflict for CHR in state 145 resolved as shift
WARNING: shift/reduce conflict for STR in state 145 resolved as shift
WARNING: shift/reduce conflict for INT in state 191 resolved as shift
WARNING: shift/reduce conflict for FLT in state 191 resolved as shift
WARNING: shift/reduce conflict for BLN in state 191 resolved as shift
WARNING: shift/reduce conflict for CHR in state 191 resolved as shift
WARNING: shift/reduce conflict for STR in state 191 resolved as shift
WARNING: shift/reduce conflict for INT in state 192 resolved as shift
WARNING: shift/reduce conflict for FLT in state 192 resolved as shift
WARNING: shift/reduce conflict for BLN in state 192 resolved as shift
WARNING: shift/reduce conflict for CHR in state 192 resolved as shift
WARNING: shift/reduce conflict for STR in state 192 resolved as shift
WARNING: shift/reduce conflict for INT in state 193 resolved as shift
WARNING: shift/reduce conflict for FLT in state 193 resolved as shift
WARNING: shift/reduce conflict for BLN in state 193 resolved as shift
WARNING: shift/reduce conflict for CHR in state 193 resolved as shift
WARNING: shift/reduce conflict for STR in state 193 resolved as shift
WARNING: shift/reduce conflict for INT in state 194 resolved as shift
WARNING: shift/reduce conflict for FLT in state 194 resolved as shift
WARNING: shift/reduce conflict for BLN in state 194 resolved as shift
WARNING: shift/reduce conflict for CHR in state 194 resolved as shift
WARNING: shift/reduce conflict for STR in state 194 resolved as shift
WARNING: shift/reduce conflict for INT in state 195 resolved as shift
WARNING: shift/reduce conflict for FLT in state 195 resolved as shift
WARNING: shift/reduce conflict for BLN in state 195 resolved as shift
WARNING: shift/reduce conflict for CHR in state 195 resolved as shift
WARNING: shift/reduce conflict for STR in state 195 resolved as shift
WARNING: shift/reduce conflict for INT in state 196 resolved as shift
WARNING: shift/reduce conflict for FLT in state 196 resolved as shift
WARNING: shift/reduce conflict for BLN in state 196 resolved as shift
WARNING: shift/reduce conflict for CHR in state 196 resolved as shift
WARNING: shift/reduce conflict for STR in state 196 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 223 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 277 resolved as shift
WARNING: shift/reduce conflict for INT in state 296 resolved as shift
WARNING: shift/reduce conflict for FLT in state 296 resolved as shift
WARNING: shift/reduce conflict for BLN in state 296 resolved as shift
WARNING: shift/reduce conflict for CHR in state 296 resolved as shift
WARNING: shift/reduce conflict for STR in state 296 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 415 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 438 resolved as shift
WARNING: shift/reduce conflict for INT in state 462 resolved as shift
WARNING: shift/reduce conflict for FLT in state 462 resolved as shift
WARNING: shift/reduce conflict for BLN in state 462 resolved as shift
WARNING: shift/reduce conflict for CHR in state 462 resolved as shift
WARNING: shift/reduce conflict for STR in state 462 resolved as shift
WARNING: shift/reduce conflict for INT in state 464 resolved as shift
WARNING: shift/reduce conflict for FLT in state 464 resolved as shift
WARNING: shift/reduce conflict for BLN in state 464 resolved as shift
WARNING: shift/reduce conflict for CHR in state 464 resolved as shift
WARNING: shift/reduce conflict for STR in state 464 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 495 resolved as shift
WARNING: shift/reduce conflict for INT in state 500 resolved as shift
WARNING: shift/reduce conflict for FLT in state 500 resolved as shift
WARNING: shift/reduce conflict for BLN in state 500 resolved as shift
WARNING: shift/reduce conflict for CHR in state 500 resolved as shift
WARNING: shift/reduce conflict for STR in state 500 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 501 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 505 resolved as shift
WARNING: shift/reduce conflict for INT in state 507 resolved as shift
WARNING: shift/reduce conflict for FLT in state 507 resolved as shift
WARNING: shift/reduce conflict for BLN in state 507 resolved as shift
WARNING: shift/reduce conflict for CHR in state 507 resolved as shift
WARNING: shift/reduce conflict for STR in state 507 resolved as shift
WARNING: shift/reduce conflict for INT in state 510 resolved as shift
WARNING: shift/reduce conflict for FLT in state 510 resolved as shift
WARNING: shift/reduce conflict for BLN in state 510 resolved as shift
WARNING: shift/reduce conflict for CHR in state 510 resolved as shift
WARNING: shift/reduce conflict for STR in state 510 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 519 resolved as shift
WARNING: shift/reduce conflict for INT in state 522 resolved as shift
WARNING: shift/reduce conflict for FLT in state 522 resolved as shift
WARNING: shift/reduce conflict for BLN in state 522 resolved as shift
WARNING: shift/reduce conflict for CHR in state 522 resolved as shift
WARNING: shift/reduce conflict for STR in state 522 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 526 resolved as shift
WARNING: shift/reduce conflict for INT in state 529 resolved as shift
WARNING: shift/reduce conflict for FLT in state 529 resolved as shift
WARNING: shift/reduce conflict for BLN in state 529 resolved as shift
WARNING: shift/reduce conflict for CHR in state 529 resolved as shift
WARNING: shift/reduce conflict for STR in state 529 resolved as shift
WARNING: reduce/reduce conflict in state 136 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 136
WARNING: reduce/reduce conflict in state 308 resolved using rule (function_statements -> empty)
WARNING: rejected rule (function_statements_tail -> empty) in state 308
WARNING: Rule (function_statements_tail -> empty) is never reduced
