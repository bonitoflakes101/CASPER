Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_statement -> var_statement global_statement_tail
Rule 11    var_statement -> data_type IDENT list_dec
Rule 12    list_dec -> empty
Rule 13    list_dec -> LBRACKET RBRACKET _2d_list
Rule 14    _2d_list -> empty
Rule 15    _2d_list -> LBRACKET RBRACKET
Rule 16    global_statement_tail -> empty
Rule 17    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 18    global_statement_tail -> EQ global_value global_statement_tail2
Rule 19    global_statement_tail2 -> COMMA IDENT global_statement_tail
Rule 20    global_statement_tail2 -> empty
Rule 21    global_value -> expression
Rule 22    global_value -> list_value
Rule 23    list_value -> LBRACKET list_element RBRACKET
Rule 24    list_element -> literal element_tail
Rule 25    element_tail -> COMMA list_element
Rule 26    element_tail -> empty
Rule 27    data_type -> INT
Rule 28    data_type -> FLT
Rule 29    data_type -> BLN
Rule 30    data_type -> CHR
Rule 31    data_type -> STR
Rule 32    expression -> factor factor_tail
Rule 33    factor -> var_call postfix
Rule 34    factor -> literal1
Rule 35    factor -> TILDE INT_LIT
Rule 36    factor -> TILDE FLT_LIT
Rule 37    factor -> LPAREN expression RPAREN
Rule 38    factor_tail -> PLUS factor factor_tail
Rule 39    factor_tail -> MINUS factor factor_tail
Rule 40    factor_tail -> MULTIPLY factor factor_tail
Rule 41    factor_tail -> DIVISION factor factor_tail
Rule 42    factor_tail -> MODULO factor factor_tail
Rule 43    factor_tail -> EXPONENT factor factor_tail
Rule 44    factor_tail -> GT factor factor_tail
Rule 45    factor_tail -> LT factor factor_tail
Rule 46    factor_tail -> EQ_EQ factor factor_tail
Rule 47    factor_tail -> GT_EQ factor factor_tail
Rule 48    factor_tail -> LT_EQ factor factor_tail
Rule 49    factor_tail -> NOT_EQ factor factor_tail
Rule 50    factor_tail -> AND factor factor_tail
Rule 51    factor_tail -> OR factor factor_tail
Rule 52    factor_tail -> empty
Rule 53    literal -> literal1
Rule 54    literal -> literal2
Rule 55    literal1 -> INT_LIT
Rule 56    literal1 -> FLT_LIT
Rule 57    literal1 -> DAY
Rule 58    literal1 -> NIGHT
Rule 59    literal1 -> STR_LIT
Rule 60    literal2 -> CHR_LIT
Rule 61    function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail
Rule 62    function_statements -> empty
Rule 63    function_statements_tail -> function_statements
Rule 64    function_statements_tail -> empty
Rule 65    ret_type -> FUNCTION
Rule 66    ret_type -> function_dtype
Rule 67    function_dtype -> FUNCTION_INT
Rule 68    function_dtype -> FUNCTION_FLT
Rule 69    function_dtype -> FUNCTION_CHR
Rule 70    function_dtype -> FUNCTION_BLN
Rule 71    function_dtype -> FUNCTION_STR
Rule 72    function_dtype -> FUNCTION_LIST_INT
Rule 73    function_dtype -> FUNCTION_LIST_FLT
Rule 74    function_dtype -> FUNCTION_LIST_CHR
Rule 75    function_dtype -> FUNCTION_LIST_STR
Rule 76    function_dtype -> FUNCTION_LIST_BLN
Rule 77    parameters -> data_type IDENT parameters_tail
Rule 78    parameters -> empty
Rule 79    parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 80    parameters_tail -> empty
Rule 81    revive -> REVIVE value
Rule 82    revive -> empty
Rule 83    statements -> empty
Rule 84    statements -> local_dec maybe_newline statements_tail
Rule 85    statements_tail -> switch_statement unli_newline statements
Rule 86    statements_tail -> loop_statement unli_newline statements
Rule 87    statements_tail -> function_call unli_newline statements
Rule 88    statements_tail -> assignment_statement unli_newline statements
Rule 89    statements_tail -> output_statement unli_newline statements
Rule 90    statements_tail -> conditional_statement unli_newline statements
Rule 91    statements_tail -> statements
Rule 92    local_dec -> var_statement local_dec_tail
Rule 93    local_dec -> empty
Rule 94    local_dec_tail -> empty
Rule 95    local_dec_tail -> COMMA IDENT local_dec_tail
Rule 96    local_dec_tail -> EQ local_value local_dec_tail2
Rule 97    local_dec_tail2 -> COMMA IDENT local_dec_tail
Rule 98    local_dec_tail2 -> empty
Rule 99    local_value -> value
Rule 100   local_value -> list_value
Rule 101   conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 102   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
Rule 103   conditional_tail -> empty
Rule 104   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
Rule 105   switch_condition -> SHIFT value COLON statements switchcond_tail
Rule 106   switchcond_tail -> switch_condition
Rule 107   switchcond_tail -> empty
Rule 108   loop_statement -> for_loop
Rule 109   loop_statement -> until_loop
Rule 110   loop_statement -> repeat_until
Rule 111   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
Rule 112   until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
Rule 113   repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
Rule 114   control_variable -> INT IDENT EQ control_var_tail
Rule 115   control_var_tail -> INT_LIT
Rule 116   control_var_tail -> var_call
Rule 117   update -> var_call update_tail
Rule 118   update_tail -> postfix_op
Rule 119   update_tail -> compound_op value
Rule 120   postfix_op -> PLUS_PLUS
Rule 121   postfix_op -> MINUS_MINUS
Rule 122   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 123   function_call -> input_statement
Rule 124   arguments -> empty
Rule 125   arguments -> arg_value arg_tail
Rule 126   arg_tail -> COMMA arg_value arg_tail
Rule 127   arg_tail -> empty
Rule 128   arg_value -> literal
Rule 129   arg_value -> var_call
Rule 130   output_statement -> DISPLAY value next_val
Rule 131   next_val -> COMMA value next_val
Rule 132   next_val -> empty
Rule 133   assignment_statement -> IDENT assign_tail
Rule 134   assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
Rule 135   assign_tail -> DOT PUSH LPAREN list_element RPAREN
Rule 136   assign_tail -> assign_op value
Rule 137   assign_op -> compound_op
Rule 138   assign_op -> EQ
Rule 139   compound_op -> PLUS_EQ
Rule 140   compound_op -> MINUS_EQ
Rule 141   compound_op -> MUL_EQ
Rule 142   compound_op -> DIV_EQ
Rule 143   compound_op -> MOD_EQ
Rule 144   start -> INT_LIT
Rule 145   deleteCount -> empty
Rule 146   deleteCount -> INT_LIT
Rule 147   splice_items -> empty
Rule 148   splice_items -> list_element
Rule 149   var_call -> IDENT list_index
Rule 150   list_index -> LBRACKET index RBRACKET list_index2
Rule 151   list_index -> empty
Rule 152   list_index2 -> LBRACKET index RBRACKET
Rule 153   list_index2 -> empty
Rule 154   index -> INT_LIT
Rule 155   index -> IDENT
Rule 156   postfix -> empty
Rule 157   postfix -> postfix_op
Rule 158   value -> type_cast
Rule 159   value -> expression
Rule 160   value -> function_call
Rule 161   type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 162   type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 163   type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 164   type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 165   typecast_value -> expression
Rule 166   typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 167   typecast_value -> input_statement
Rule 168   input_statement -> INPUT LPAREN RPAREN
Rule 169   empty -> <empty>

Terminals, with rules where they appear

AND                  : 50
BIRTH                : 1
BLN                  : 29
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 101
CHR                  : 30
CHR_LIT              : 60
COLON                : 105
COMMA                : 17 19 25 79 95 97 126 131 134 134
COMMENT              : 
CONVERT_TO_BLN       : 163
CONVERT_TO_FLT       : 162
CONVERT_TO_INT       : 161
CONVERT_TO_STR       : 164
DAY                  : 57
DISPLAY              : 130
DIVISION             : 41
DIV_EQ               : 142
DOT                  : 134 135
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 18 96 114 138
EQ_EQ                : 46
EXPONENT             : 43
FLT                  : 28
FLT_LIT              : 36 56
FOR                  : 111
FUNCTION             : 65
FUNCTION_BLN         : 70
FUNCTION_CHR         : 69
FUNCTION_FLT         : 68
FUNCTION_INT         : 67
FUNCTION_LIST_BLN    : 76
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 74
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 73
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 72
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 75
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 61 122 166
FUNCTION_STR         : 71
GHOST                : 1
GT                   : 44
GT_EQ                : 47
IDENT                : 11 17 19 77 79 95 97 104 114 133 149 155
ILLEGAL              : 
IN                   : 
INPUT                : 168
INT                  : 27 114
INT_LIT              : 35 55 115 144 146 154
LBRACE               : 6 61 101 101 102 104 104 111 112 113
LBRACKET             : 13 15 23 150 152
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 37 61 101 102 104 111 112 113 122 134 135 161 162 163 164 166 168
LT                   : 45
LT_EQ                : 48
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 39
MINUS_EQ             : 140
MINUS_MINUS          : 121
MODULO               : 42
MOD_EQ               : 143
MULTIPLY             : 40
MUL_EQ               : 141
NEWLINE              : 3 4 5
NIGHT                : 58
NOT                  : 
NOT_EQ               : 49
OR                   : 51
OTHERWISE            : 101 104
OTHERWISE_CHECK      : 102
PLUS                 : 38
PLUS_EQ              : 139
PLUS_PLUS            : 120
POW                  : 
PUSH                 : 135
RBRACE               : 6 61 101 101 102 104 104 111 112 113
RBRACKET             : 13 15 23 150 152
REPEAT               : 113
REVIVE               : 81
RPAREN               : 6 37 61 101 102 104 111 112 113 122 134 135 161 162 163 164 166 168
SEMICOLON            : 111 111
SHIFT                : 105
SKIP                 : 
SPLICE               : 134
STOP                 : 
STR                  : 31
STR_LIT              : 59
SWAP                 : 104
TILDE                : 35 36
TYPE                 : 
UNTIL                : 112 113
error                : 

Nonterminals, with rules where they appear

_2d_list             : 13
arg_tail             : 125 126
arg_value            : 125 126
arguments            : 122
assign_op            : 136
assign_tail          : 133
assignment_statement : 88
compound_op          : 119 137
conditional_statement : 90
conditional_tail     : 101 102
control_var_tail     : 114
control_variable     : 111
data_type            : 11 77 79
deleteCount          : 134
element_tail         : 24
empty                : 2 8 12 14 16 20 26 52 62 64 78 80 82 83 93 94 98 103 107 124 127 132 145 147 151 153 156
expression           : 21 37 101 102 111 112 113 159 165
factor               : 32 38 39 40 41 42 43 44 45 46 47 48 49 50 51
factor_tail          : 32 38 39 40 41 42 43 44 45 46 47 48 49 50 51
for_loop             : 108
function_call        : 87 160
function_dtype       : 66
function_statements  : 1 63
function_statements_tail : 61
global_dec           : 1 9
global_statement     : 7
global_statement_tail : 10 17 19
global_statement_tail2 : 18
global_tail          : 7
global_value         : 18
index                : 150 152
input_statement      : 123 167
list_dec             : 11
list_element         : 23 25 135 148
list_index           : 149
list_index2          : 150
list_value           : 22 100
literal              : 24 128
literal1             : 34 53
literal2             : 54
local_dec            : 84
local_dec_tail       : 92 95 97
local_dec_tail2      : 96
local_value          : 96
loop_statement       : 86
main_function        : 1
maybe_newline        : 1 1 3 6 6 6 84 101 101 101 101 101 101 101
next_val             : 130 131
output_statement     : 89
parameters           : 61
parameters_tail      : 77 79
postfix              : 33
postfix_op           : 118 157
program              : 0
repeat_until         : 110
ret_type             : 61
revive               : 61
splice_items         : 134
start                : 134
statements           : 6 61 85 86 87 88 89 90 91 101 101 102 104 105 111 112 113
statements_tail      : 84
switch_condition     : 104 106
switch_statement     : 85
switchcond_tail      : 105
type_cast            : 158
typecast_value       : 161 162 163 164
unli_newline         : 1 1 5 7 85 86 87 88 89 90
until_loop           : 109
update               : 111
update_tail          : 117
value                : 81 99 105 119 130 131 136
var_call             : 33 116 117 129
var_statement        : 10 92

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . var_statement global_statement_tail
    (169) empty -> .
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    var_statement                  shift and go to state 8
    data_type                      shift and go to state 9

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    INPUT           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 15

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 16
    empty                          shift and go to state 17

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 19

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)


state 8

    (10) global_statement -> var_statement . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (169) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 169 (empty -> .)

    global_statement_tail          shift and go to state 20
    empty                          shift and go to state 21

state 9

    (11) var_statement -> data_type . IDENT list_dec

    IDENT           shift and go to state 24


state 10

    (27) data_type -> INT .

    IDENT           reduce using rule 27 (data_type -> INT .)


state 11

    (28) data_type -> FLT .

    IDENT           reduce using rule 28 (data_type -> FLT .)


state 12

    (29) data_type -> BLN .

    IDENT           reduce using rule 29 (data_type -> BLN .)


state 13

    (30) data_type -> CHR .

    IDENT           reduce using rule 30 (data_type -> CHR .)


state 14

    (31) data_type -> STR .

    IDENT           reduce using rule 31 (data_type -> STR .)


state 15

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    INPUT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 16

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (61) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail
    (62) function_statements -> . empty
    (65) ret_type -> . FUNCTION
    (66) ret_type -> . function_dtype
    (169) empty -> .
    (67) function_dtype -> . FUNCTION_INT
    (68) function_dtype -> . FUNCTION_FLT
    (69) function_dtype -> . FUNCTION_CHR
    (70) function_dtype -> . FUNCTION_BLN
    (71) function_dtype -> . FUNCTION_STR
    (72) function_dtype -> . FUNCTION_LIST_INT
    (73) function_dtype -> . FUNCTION_LIST_FLT
    (74) function_dtype -> . FUNCTION_LIST_CHR
    (75) function_dtype -> . FUNCTION_LIST_STR
    (76) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 28
    NEWLINE         reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    FUNCTION_INT    shift and go to state 30
    FUNCTION_FLT    shift and go to state 31
    FUNCTION_CHR    shift and go to state 32
    FUNCTION_BLN    shift and go to state 33
    FUNCTION_STR    shift and go to state 34
    FUNCTION_LIST_INT shift and go to state 35
    FUNCTION_LIST_FLT shift and go to state 36
    FUNCTION_LIST_CHR shift and go to state 37
    FUNCTION_LIST_STR shift and go to state 38
    FUNCTION_LIST_BLN shift and go to state 39

    function_statements            shift and go to state 25
    ret_type                       shift and go to state 26
    empty                          shift and go to state 27
    function_dtype                 shift and go to state 29

state 17

    (2) maybe_newline -> empty .

    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    INPUT           reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE_CHECK reduce using rule 2 (maybe_newline -> empty .)


state 18

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    LBRACE          reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    OTHERWISE_CHECK reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 40
    empty                          shift and go to state 17

state 19

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . var_statement global_statement_tail
    (169) empty -> .
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 41
    global_dec                     shift and go to state 42
    empty                          shift and go to state 7
    var_statement                  shift and go to state 8
    data_type                      shift and go to state 9

state 20

    (10) global_statement -> var_statement global_statement_tail .

    NEWLINE         reduce using rule 10 (global_statement -> var_statement global_statement_tail .)


state 21

    (16) global_statement_tail -> empty .

    NEWLINE         reduce using rule 16 (global_statement_tail -> empty .)


state 22

    (17) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 43


state 23

    (18) global_statement_tail -> EQ . global_value global_statement_tail2
    (21) global_value -> . expression
    (22) global_value -> . list_value
    (32) expression -> . factor factor_tail
    (23) list_value -> . LBRACKET list_element RBRACKET
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    LBRACKET        shift and go to state 48
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    global_value                   shift and go to state 44
    expression                     shift and go to state 45
    list_value                     shift and go to state 46
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 24

    (11) var_statement -> data_type IDENT . list_dec
    (12) list_dec -> . empty
    (13) list_dec -> . LBRACKET RBRACKET _2d_list
    (169) empty -> .

    LBRACKET        shift and go to state 61
    COMMA           reduce using rule 169 (empty -> .)
    EQ              reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    list_dec                       shift and go to state 59
    empty                          shift and go to state 60

state 25

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    MAIN_CASPER     reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 62
    empty                          shift and go to state 17

state 26

    (61) function_statements -> ret_type . FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail

    FUNCTION_NAME   shift and go to state 63


state 27

    (62) function_statements -> empty .

    NEWLINE         reduce using rule 62 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 62 (function_statements -> empty .)


state 28

    (65) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 65 (ret_type -> FUNCTION .)


state 29

    (66) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 66 (ret_type -> function_dtype .)


state 30

    (67) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 67 (function_dtype -> FUNCTION_INT .)


state 31

    (68) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 68 (function_dtype -> FUNCTION_FLT .)


state 32

    (69) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 69 (function_dtype -> FUNCTION_CHR .)


state 33

    (70) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 70 (function_dtype -> FUNCTION_BLN .)


state 34

    (71) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 71 (function_dtype -> FUNCTION_STR .)


state 35

    (72) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 72 (function_dtype -> FUNCTION_LIST_INT .)


state 36

    (73) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 73 (function_dtype -> FUNCTION_LIST_FLT .)


state 37

    (74) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 74 (function_dtype -> FUNCTION_LIST_CHR .)


state 38

    (75) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 75 (function_dtype -> FUNCTION_LIST_STR .)


state 39

    (76) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 76 (function_dtype -> FUNCTION_LIST_BLN .)


state 40

    (3) maybe_newline -> NEWLINE maybe_newline .

    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INPUT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE_CHECK reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 41

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 42

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)


state 43

    (17) global_statement_tail -> COMMA IDENT . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (169) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 169 (empty -> .)

    global_statement_tail          shift and go to state 64
    empty                          shift and go to state 21

state 44

    (18) global_statement_tail -> EQ global_value . global_statement_tail2
    (19) global_statement_tail2 -> . COMMA IDENT global_statement_tail
    (20) global_statement_tail2 -> . empty
    (169) empty -> .

    COMMA           shift and go to state 66
    NEWLINE         reduce using rule 169 (empty -> .)

    global_statement_tail2         shift and go to state 65
    empty                          shift and go to state 67

state 45

    (21) global_value -> expression .

    COMMA           reduce using rule 21 (global_value -> expression .)
    NEWLINE         reduce using rule 21 (global_value -> expression .)


state 46

    (22) global_value -> list_value .

    COMMA           reduce using rule 22 (global_value -> list_value .)
    NEWLINE         reduce using rule 22 (global_value -> list_value .)


state 47

    (32) expression -> factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 68
    empty                          shift and go to state 83

state 48

    (23) list_value -> LBRACKET . list_element RBRACKET
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 84
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 49

    (33) factor -> var_call . postfix
    (156) postfix -> . empty
    (157) postfix -> . postfix_op
    (169) empty -> .
    (120) postfix_op -> . PLUS_PLUS
    (121) postfix_op -> . MINUS_MINUS

    PLUS            reduce using rule 169 (empty -> .)
    MINUS           reduce using rule 169 (empty -> .)
    MULTIPLY        reduce using rule 169 (empty -> .)
    DIVISION        reduce using rule 169 (empty -> .)
    MODULO          reduce using rule 169 (empty -> .)
    EXPONENT        reduce using rule 169 (empty -> .)
    GT              reduce using rule 169 (empty -> .)
    LT              reduce using rule 169 (empty -> .)
    EQ_EQ           reduce using rule 169 (empty -> .)
    GT_EQ           reduce using rule 169 (empty -> .)
    LT_EQ           reduce using rule 169 (empty -> .)
    NOT_EQ          reduce using rule 169 (empty -> .)
    AND             reduce using rule 169 (empty -> .)
    OR              reduce using rule 169 (empty -> .)
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)
    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93

    postfix                        shift and go to state 89
    empty                          shift and go to state 90
    postfix_op                     shift and go to state 91

state 50

    (34) factor -> literal1 .

    PLUS            reduce using rule 34 (factor -> literal1 .)
    MINUS           reduce using rule 34 (factor -> literal1 .)
    MULTIPLY        reduce using rule 34 (factor -> literal1 .)
    DIVISION        reduce using rule 34 (factor -> literal1 .)
    MODULO          reduce using rule 34 (factor -> literal1 .)
    EXPONENT        reduce using rule 34 (factor -> literal1 .)
    GT              reduce using rule 34 (factor -> literal1 .)
    LT              reduce using rule 34 (factor -> literal1 .)
    EQ_EQ           reduce using rule 34 (factor -> literal1 .)
    GT_EQ           reduce using rule 34 (factor -> literal1 .)
    LT_EQ           reduce using rule 34 (factor -> literal1 .)
    NOT_EQ          reduce using rule 34 (factor -> literal1 .)
    AND             reduce using rule 34 (factor -> literal1 .)
    OR              reduce using rule 34 (factor -> literal1 .)
    COMMA           reduce using rule 34 (factor -> literal1 .)
    NEWLINE         reduce using rule 34 (factor -> literal1 .)
    RPAREN          reduce using rule 34 (factor -> literal1 .)
    RBRACE          reduce using rule 34 (factor -> literal1 .)
    SWAP            reduce using rule 34 (factor -> literal1 .)
    FUNCTION_NAME   reduce using rule 34 (factor -> literal1 .)
    IDENT           reduce using rule 34 (factor -> literal1 .)
    DISPLAY         reduce using rule 34 (factor -> literal1 .)
    CHECK           reduce using rule 34 (factor -> literal1 .)
    FOR             reduce using rule 34 (factor -> literal1 .)
    UNTIL           reduce using rule 34 (factor -> literal1 .)
    REPEAT          reduce using rule 34 (factor -> literal1 .)
    INPUT           reduce using rule 34 (factor -> literal1 .)
    INT             reduce using rule 34 (factor -> literal1 .)
    FLT             reduce using rule 34 (factor -> literal1 .)
    BLN             reduce using rule 34 (factor -> literal1 .)
    CHR             reduce using rule 34 (factor -> literal1 .)
    STR             reduce using rule 34 (factor -> literal1 .)
    REVIVE          reduce using rule 34 (factor -> literal1 .)
    SHIFT           reduce using rule 34 (factor -> literal1 .)
    OTHERWISE       reduce using rule 34 (factor -> literal1 .)
    SEMICOLON       reduce using rule 34 (factor -> literal1 .)
    COLON           reduce using rule 34 (factor -> literal1 .)


state 51

    (35) factor -> TILDE . INT_LIT
    (36) factor -> TILDE . FLT_LIT

    INT_LIT         shift and go to state 94
    FLT_LIT         shift and go to state 95


state 52

    (55) literal1 -> INT_LIT .

    PLUS            reduce using rule 55 (literal1 -> INT_LIT .)
    MINUS           reduce using rule 55 (literal1 -> INT_LIT .)
    MULTIPLY        reduce using rule 55 (literal1 -> INT_LIT .)
    DIVISION        reduce using rule 55 (literal1 -> INT_LIT .)
    MODULO          reduce using rule 55 (literal1 -> INT_LIT .)
    EXPONENT        reduce using rule 55 (literal1 -> INT_LIT .)
    GT              reduce using rule 55 (literal1 -> INT_LIT .)
    LT              reduce using rule 55 (literal1 -> INT_LIT .)
    EQ_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    GT_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    LT_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    NOT_EQ          reduce using rule 55 (literal1 -> INT_LIT .)
    AND             reduce using rule 55 (literal1 -> INT_LIT .)
    OR              reduce using rule 55 (literal1 -> INT_LIT .)
    COMMA           reduce using rule 55 (literal1 -> INT_LIT .)
    NEWLINE         reduce using rule 55 (literal1 -> INT_LIT .)
    RBRACKET        reduce using rule 55 (literal1 -> INT_LIT .)
    RPAREN          reduce using rule 55 (literal1 -> INT_LIT .)
    RBRACE          reduce using rule 55 (literal1 -> INT_LIT .)
    SWAP            reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_NAME   reduce using rule 55 (literal1 -> INT_LIT .)
    IDENT           reduce using rule 55 (literal1 -> INT_LIT .)
    DISPLAY         reduce using rule 55 (literal1 -> INT_LIT .)
    CHECK           reduce using rule 55 (literal1 -> INT_LIT .)
    FOR             reduce using rule 55 (literal1 -> INT_LIT .)
    UNTIL           reduce using rule 55 (literal1 -> INT_LIT .)
    REPEAT          reduce using rule 55 (literal1 -> INT_LIT .)
    INPUT           reduce using rule 55 (literal1 -> INT_LIT .)
    INT             reduce using rule 55 (literal1 -> INT_LIT .)
    FLT             reduce using rule 55 (literal1 -> INT_LIT .)
    BLN             reduce using rule 55 (literal1 -> INT_LIT .)
    CHR             reduce using rule 55 (literal1 -> INT_LIT .)
    STR             reduce using rule 55 (literal1 -> INT_LIT .)
    REVIVE          reduce using rule 55 (literal1 -> INT_LIT .)
    SHIFT           reduce using rule 55 (literal1 -> INT_LIT .)
    OTHERWISE       reduce using rule 55 (literal1 -> INT_LIT .)
    SEMICOLON       reduce using rule 55 (literal1 -> INT_LIT .)
    COLON           reduce using rule 55 (literal1 -> INT_LIT .)


state 53

    (56) literal1 -> FLT_LIT .

    PLUS            reduce using rule 56 (literal1 -> FLT_LIT .)
    MINUS           reduce using rule 56 (literal1 -> FLT_LIT .)
    MULTIPLY        reduce using rule 56 (literal1 -> FLT_LIT .)
    DIVISION        reduce using rule 56 (literal1 -> FLT_LIT .)
    MODULO          reduce using rule 56 (literal1 -> FLT_LIT .)
    EXPONENT        reduce using rule 56 (literal1 -> FLT_LIT .)
    GT              reduce using rule 56 (literal1 -> FLT_LIT .)
    LT              reduce using rule 56 (literal1 -> FLT_LIT .)
    EQ_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    GT_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    LT_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    NOT_EQ          reduce using rule 56 (literal1 -> FLT_LIT .)
    AND             reduce using rule 56 (literal1 -> FLT_LIT .)
    OR              reduce using rule 56 (literal1 -> FLT_LIT .)
    COMMA           reduce using rule 56 (literal1 -> FLT_LIT .)
    NEWLINE         reduce using rule 56 (literal1 -> FLT_LIT .)
    RBRACKET        reduce using rule 56 (literal1 -> FLT_LIT .)
    RPAREN          reduce using rule 56 (literal1 -> FLT_LIT .)
    RBRACE          reduce using rule 56 (literal1 -> FLT_LIT .)
    SWAP            reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_NAME   reduce using rule 56 (literal1 -> FLT_LIT .)
    IDENT           reduce using rule 56 (literal1 -> FLT_LIT .)
    DISPLAY         reduce using rule 56 (literal1 -> FLT_LIT .)
    CHECK           reduce using rule 56 (literal1 -> FLT_LIT .)
    FOR             reduce using rule 56 (literal1 -> FLT_LIT .)
    UNTIL           reduce using rule 56 (literal1 -> FLT_LIT .)
    REPEAT          reduce using rule 56 (literal1 -> FLT_LIT .)
    INPUT           reduce using rule 56 (literal1 -> FLT_LIT .)
    INT             reduce using rule 56 (literal1 -> FLT_LIT .)
    FLT             reduce using rule 56 (literal1 -> FLT_LIT .)
    BLN             reduce using rule 56 (literal1 -> FLT_LIT .)
    CHR             reduce using rule 56 (literal1 -> FLT_LIT .)
    STR             reduce using rule 56 (literal1 -> FLT_LIT .)
    REVIVE          reduce using rule 56 (literal1 -> FLT_LIT .)
    SHIFT           reduce using rule 56 (literal1 -> FLT_LIT .)
    OTHERWISE       reduce using rule 56 (literal1 -> FLT_LIT .)
    SEMICOLON       reduce using rule 56 (literal1 -> FLT_LIT .)
    COLON           reduce using rule 56 (literal1 -> FLT_LIT .)


state 54

    (37) factor -> LPAREN . expression RPAREN
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 96
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 55

    (149) var_call -> IDENT . list_index
    (150) list_index -> . LBRACKET index RBRACKET list_index2
    (151) list_index -> . empty
    (169) empty -> .

    LBRACKET        shift and go to state 98
    PLUS_PLUS       reduce using rule 169 (empty -> .)
    MINUS_MINUS     reduce using rule 169 (empty -> .)
    PLUS            reduce using rule 169 (empty -> .)
    MINUS           reduce using rule 169 (empty -> .)
    MULTIPLY        reduce using rule 169 (empty -> .)
    DIVISION        reduce using rule 169 (empty -> .)
    MODULO          reduce using rule 169 (empty -> .)
    EXPONENT        reduce using rule 169 (empty -> .)
    GT              reduce using rule 169 (empty -> .)
    LT              reduce using rule 169 (empty -> .)
    EQ_EQ           reduce using rule 169 (empty -> .)
    GT_EQ           reduce using rule 169 (empty -> .)
    LT_EQ           reduce using rule 169 (empty -> .)
    NOT_EQ          reduce using rule 169 (empty -> .)
    AND             reduce using rule 169 (empty -> .)
    OR              reduce using rule 169 (empty -> .)
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)
    PLUS_EQ         reduce using rule 169 (empty -> .)
    MINUS_EQ        reduce using rule 169 (empty -> .)
    MUL_EQ          reduce using rule 169 (empty -> .)
    DIV_EQ          reduce using rule 169 (empty -> .)
    MOD_EQ          reduce using rule 169 (empty -> .)

    list_index                     shift and go to state 97
    empty                          shift and go to state 99

state 56

    (57) literal1 -> DAY .

    PLUS            reduce using rule 57 (literal1 -> DAY .)
    MINUS           reduce using rule 57 (literal1 -> DAY .)
    MULTIPLY        reduce using rule 57 (literal1 -> DAY .)
    DIVISION        reduce using rule 57 (literal1 -> DAY .)
    MODULO          reduce using rule 57 (literal1 -> DAY .)
    EXPONENT        reduce using rule 57 (literal1 -> DAY .)
    GT              reduce using rule 57 (literal1 -> DAY .)
    LT              reduce using rule 57 (literal1 -> DAY .)
    EQ_EQ           reduce using rule 57 (literal1 -> DAY .)
    GT_EQ           reduce using rule 57 (literal1 -> DAY .)
    LT_EQ           reduce using rule 57 (literal1 -> DAY .)
    NOT_EQ          reduce using rule 57 (literal1 -> DAY .)
    AND             reduce using rule 57 (literal1 -> DAY .)
    OR              reduce using rule 57 (literal1 -> DAY .)
    COMMA           reduce using rule 57 (literal1 -> DAY .)
    NEWLINE         reduce using rule 57 (literal1 -> DAY .)
    RBRACKET        reduce using rule 57 (literal1 -> DAY .)
    RPAREN          reduce using rule 57 (literal1 -> DAY .)
    RBRACE          reduce using rule 57 (literal1 -> DAY .)
    SWAP            reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_NAME   reduce using rule 57 (literal1 -> DAY .)
    IDENT           reduce using rule 57 (literal1 -> DAY .)
    DISPLAY         reduce using rule 57 (literal1 -> DAY .)
    CHECK           reduce using rule 57 (literal1 -> DAY .)
    FOR             reduce using rule 57 (literal1 -> DAY .)
    UNTIL           reduce using rule 57 (literal1 -> DAY .)
    REPEAT          reduce using rule 57 (literal1 -> DAY .)
    INPUT           reduce using rule 57 (literal1 -> DAY .)
    INT             reduce using rule 57 (literal1 -> DAY .)
    FLT             reduce using rule 57 (literal1 -> DAY .)
    BLN             reduce using rule 57 (literal1 -> DAY .)
    CHR             reduce using rule 57 (literal1 -> DAY .)
    STR             reduce using rule 57 (literal1 -> DAY .)
    REVIVE          reduce using rule 57 (literal1 -> DAY .)
    SHIFT           reduce using rule 57 (literal1 -> DAY .)
    OTHERWISE       reduce using rule 57 (literal1 -> DAY .)
    SEMICOLON       reduce using rule 57 (literal1 -> DAY .)
    COLON           reduce using rule 57 (literal1 -> DAY .)


state 57

    (58) literal1 -> NIGHT .

    PLUS            reduce using rule 58 (literal1 -> NIGHT .)
    MINUS           reduce using rule 58 (literal1 -> NIGHT .)
    MULTIPLY        reduce using rule 58 (literal1 -> NIGHT .)
    DIVISION        reduce using rule 58 (literal1 -> NIGHT .)
    MODULO          reduce using rule 58 (literal1 -> NIGHT .)
    EXPONENT        reduce using rule 58 (literal1 -> NIGHT .)
    GT              reduce using rule 58 (literal1 -> NIGHT .)
    LT              reduce using rule 58 (literal1 -> NIGHT .)
    EQ_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    GT_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    LT_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    NOT_EQ          reduce using rule 58 (literal1 -> NIGHT .)
    AND             reduce using rule 58 (literal1 -> NIGHT .)
    OR              reduce using rule 58 (literal1 -> NIGHT .)
    COMMA           reduce using rule 58 (literal1 -> NIGHT .)
    NEWLINE         reduce using rule 58 (literal1 -> NIGHT .)
    RBRACKET        reduce using rule 58 (literal1 -> NIGHT .)
    RPAREN          reduce using rule 58 (literal1 -> NIGHT .)
    RBRACE          reduce using rule 58 (literal1 -> NIGHT .)
    SWAP            reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_NAME   reduce using rule 58 (literal1 -> NIGHT .)
    IDENT           reduce using rule 58 (literal1 -> NIGHT .)
    DISPLAY         reduce using rule 58 (literal1 -> NIGHT .)
    CHECK           reduce using rule 58 (literal1 -> NIGHT .)
    FOR             reduce using rule 58 (literal1 -> NIGHT .)
    UNTIL           reduce using rule 58 (literal1 -> NIGHT .)
    REPEAT          reduce using rule 58 (literal1 -> NIGHT .)
    INPUT           reduce using rule 58 (literal1 -> NIGHT .)
    INT             reduce using rule 58 (literal1 -> NIGHT .)
    FLT             reduce using rule 58 (literal1 -> NIGHT .)
    BLN             reduce using rule 58 (literal1 -> NIGHT .)
    CHR             reduce using rule 58 (literal1 -> NIGHT .)
    STR             reduce using rule 58 (literal1 -> NIGHT .)
    REVIVE          reduce using rule 58 (literal1 -> NIGHT .)
    SHIFT           reduce using rule 58 (literal1 -> NIGHT .)
    OTHERWISE       reduce using rule 58 (literal1 -> NIGHT .)
    SEMICOLON       reduce using rule 58 (literal1 -> NIGHT .)
    COLON           reduce using rule 58 (literal1 -> NIGHT .)


state 58

    (59) literal1 -> STR_LIT .

    PLUS            reduce using rule 59 (literal1 -> STR_LIT .)
    MINUS           reduce using rule 59 (literal1 -> STR_LIT .)
    MULTIPLY        reduce using rule 59 (literal1 -> STR_LIT .)
    DIVISION        reduce using rule 59 (literal1 -> STR_LIT .)
    MODULO          reduce using rule 59 (literal1 -> STR_LIT .)
    EXPONENT        reduce using rule 59 (literal1 -> STR_LIT .)
    GT              reduce using rule 59 (literal1 -> STR_LIT .)
    LT              reduce using rule 59 (literal1 -> STR_LIT .)
    EQ_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    GT_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    LT_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    NOT_EQ          reduce using rule 59 (literal1 -> STR_LIT .)
    AND             reduce using rule 59 (literal1 -> STR_LIT .)
    OR              reduce using rule 59 (literal1 -> STR_LIT .)
    COMMA           reduce using rule 59 (literal1 -> STR_LIT .)
    NEWLINE         reduce using rule 59 (literal1 -> STR_LIT .)
    RBRACKET        reduce using rule 59 (literal1 -> STR_LIT .)
    RPAREN          reduce using rule 59 (literal1 -> STR_LIT .)
    RBRACE          reduce using rule 59 (literal1 -> STR_LIT .)
    SWAP            reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_NAME   reduce using rule 59 (literal1 -> STR_LIT .)
    IDENT           reduce using rule 59 (literal1 -> STR_LIT .)
    DISPLAY         reduce using rule 59 (literal1 -> STR_LIT .)
    CHECK           reduce using rule 59 (literal1 -> STR_LIT .)
    FOR             reduce using rule 59 (literal1 -> STR_LIT .)
    UNTIL           reduce using rule 59 (literal1 -> STR_LIT .)
    REPEAT          reduce using rule 59 (literal1 -> STR_LIT .)
    INPUT           reduce using rule 59 (literal1 -> STR_LIT .)
    INT             reduce using rule 59 (literal1 -> STR_LIT .)
    FLT             reduce using rule 59 (literal1 -> STR_LIT .)
    BLN             reduce using rule 59 (literal1 -> STR_LIT .)
    CHR             reduce using rule 59 (literal1 -> STR_LIT .)
    STR             reduce using rule 59 (literal1 -> STR_LIT .)
    REVIVE          reduce using rule 59 (literal1 -> STR_LIT .)
    SHIFT           reduce using rule 59 (literal1 -> STR_LIT .)
    OTHERWISE       reduce using rule 59 (literal1 -> STR_LIT .)
    SEMICOLON       reduce using rule 59 (literal1 -> STR_LIT .)
    COLON           reduce using rule 59 (literal1 -> STR_LIT .)


state 59

    (11) var_statement -> data_type IDENT list_dec .

    COMMA           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    EQ              reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    NEWLINE         reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    SWAP            reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_NAME   reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    IDENT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    DISPLAY         reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    CHECK           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FOR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    UNTIL           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    REPEAT          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    INPUT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    INT             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FLT             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    BLN             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    CHR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    STR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    REVIVE          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    RBRACE          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    SHIFT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    OTHERWISE       reduce using rule 11 (var_statement -> data_type IDENT list_dec .)


state 60

    (12) list_dec -> empty .

    COMMA           reduce using rule 12 (list_dec -> empty .)
    EQ              reduce using rule 12 (list_dec -> empty .)
    NEWLINE         reduce using rule 12 (list_dec -> empty .)
    SWAP            reduce using rule 12 (list_dec -> empty .)
    FUNCTION_NAME   reduce using rule 12 (list_dec -> empty .)
    IDENT           reduce using rule 12 (list_dec -> empty .)
    DISPLAY         reduce using rule 12 (list_dec -> empty .)
    CHECK           reduce using rule 12 (list_dec -> empty .)
    FOR             reduce using rule 12 (list_dec -> empty .)
    UNTIL           reduce using rule 12 (list_dec -> empty .)
    REPEAT          reduce using rule 12 (list_dec -> empty .)
    INPUT           reduce using rule 12 (list_dec -> empty .)
    INT             reduce using rule 12 (list_dec -> empty .)
    FLT             reduce using rule 12 (list_dec -> empty .)
    BLN             reduce using rule 12 (list_dec -> empty .)
    CHR             reduce using rule 12 (list_dec -> empty .)
    STR             reduce using rule 12 (list_dec -> empty .)
    REVIVE          reduce using rule 12 (list_dec -> empty .)
    RBRACE          reduce using rule 12 (list_dec -> empty .)
    SHIFT           reduce using rule 12 (list_dec -> empty .)
    OTHERWISE       reduce using rule 12 (list_dec -> empty .)


state 61

    (13) list_dec -> LBRACKET . RBRACKET _2d_list

    RBRACKET        shift and go to state 100


state 62

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 102

    main_function                  shift and go to state 101

state 63

    (61) function_statements -> ret_type FUNCTION_NAME . LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail

    LPAREN          shift and go to state 103


state 64

    (17) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 65

    (18) global_statement_tail -> EQ global_value global_statement_tail2 .

    NEWLINE         reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)


state 66

    (19) global_statement_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 104


state 67

    (20) global_statement_tail2 -> empty .

    NEWLINE         reduce using rule 20 (global_statement_tail2 -> empty .)


state 68

    (32) expression -> factor factor_tail .

    COMMA           reduce using rule 32 (expression -> factor factor_tail .)
    NEWLINE         reduce using rule 32 (expression -> factor factor_tail .)
    RPAREN          reduce using rule 32 (expression -> factor factor_tail .)
    RBRACE          reduce using rule 32 (expression -> factor factor_tail .)
    SWAP            reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_NAME   reduce using rule 32 (expression -> factor factor_tail .)
    IDENT           reduce using rule 32 (expression -> factor factor_tail .)
    DISPLAY         reduce using rule 32 (expression -> factor factor_tail .)
    CHECK           reduce using rule 32 (expression -> factor factor_tail .)
    FOR             reduce using rule 32 (expression -> factor factor_tail .)
    UNTIL           reduce using rule 32 (expression -> factor factor_tail .)
    REPEAT          reduce using rule 32 (expression -> factor factor_tail .)
    INPUT           reduce using rule 32 (expression -> factor factor_tail .)
    INT             reduce using rule 32 (expression -> factor factor_tail .)
    FLT             reduce using rule 32 (expression -> factor factor_tail .)
    BLN             reduce using rule 32 (expression -> factor factor_tail .)
    CHR             reduce using rule 32 (expression -> factor factor_tail .)
    STR             reduce using rule 32 (expression -> factor factor_tail .)
    REVIVE          reduce using rule 32 (expression -> factor factor_tail .)
    SHIFT           reduce using rule 32 (expression -> factor factor_tail .)
    OTHERWISE       reduce using rule 32 (expression -> factor factor_tail .)
    SEMICOLON       reduce using rule 32 (expression -> factor factor_tail .)
    COLON           reduce using rule 32 (expression -> factor factor_tail .)


state 69

    (38) factor_tail -> PLUS . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 105
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 70

    (39) factor_tail -> MINUS . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 106
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 71

    (40) factor_tail -> MULTIPLY . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 107
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 72

    (41) factor_tail -> DIVISION . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 108
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 73

    (42) factor_tail -> MODULO . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 109
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 74

    (43) factor_tail -> EXPONENT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 110
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 75

    (44) factor_tail -> GT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 111
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 76

    (45) factor_tail -> LT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 112
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 77

    (46) factor_tail -> EQ_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 113
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 78

    (47) factor_tail -> GT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 114
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 79

    (48) factor_tail -> LT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 115
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 80

    (49) factor_tail -> NOT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 116
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 81

    (50) factor_tail -> AND . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 117
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 82

    (51) factor_tail -> OR . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    factor                         shift and go to state 118
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 83

    (52) factor_tail -> empty .

    COMMA           reduce using rule 52 (factor_tail -> empty .)
    NEWLINE         reduce using rule 52 (factor_tail -> empty .)
    RPAREN          reduce using rule 52 (factor_tail -> empty .)
    RBRACE          reduce using rule 52 (factor_tail -> empty .)
    SWAP            reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_NAME   reduce using rule 52 (factor_tail -> empty .)
    IDENT           reduce using rule 52 (factor_tail -> empty .)
    DISPLAY         reduce using rule 52 (factor_tail -> empty .)
    CHECK           reduce using rule 52 (factor_tail -> empty .)
    FOR             reduce using rule 52 (factor_tail -> empty .)
    UNTIL           reduce using rule 52 (factor_tail -> empty .)
    REPEAT          reduce using rule 52 (factor_tail -> empty .)
    INPUT           reduce using rule 52 (factor_tail -> empty .)
    INT             reduce using rule 52 (factor_tail -> empty .)
    FLT             reduce using rule 52 (factor_tail -> empty .)
    BLN             reduce using rule 52 (factor_tail -> empty .)
    CHR             reduce using rule 52 (factor_tail -> empty .)
    STR             reduce using rule 52 (factor_tail -> empty .)
    REVIVE          reduce using rule 52 (factor_tail -> empty .)
    SHIFT           reduce using rule 52 (factor_tail -> empty .)
    OTHERWISE       reduce using rule 52 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 52 (factor_tail -> empty .)
    COLON           reduce using rule 52 (factor_tail -> empty .)


state 84

    (23) list_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 119


state 85

    (24) list_element -> literal . element_tail
    (25) element_tail -> . COMMA list_element
    (26) element_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 121
    RBRACKET        reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)

    element_tail                   shift and go to state 120
    empty                          shift and go to state 122

state 86

    (53) literal -> literal1 .

    COMMA           reduce using rule 53 (literal -> literal1 .)
    RBRACKET        reduce using rule 53 (literal -> literal1 .)
    RPAREN          reduce using rule 53 (literal -> literal1 .)


state 87

    (54) literal -> literal2 .

    COMMA           reduce using rule 54 (literal -> literal2 .)
    RBRACKET        reduce using rule 54 (literal -> literal2 .)
    RPAREN          reduce using rule 54 (literal -> literal2 .)


state 88

    (60) literal2 -> CHR_LIT .

    COMMA           reduce using rule 60 (literal2 -> CHR_LIT .)
    RBRACKET        reduce using rule 60 (literal2 -> CHR_LIT .)
    RPAREN          reduce using rule 60 (literal2 -> CHR_LIT .)


state 89

    (33) factor -> var_call postfix .

    PLUS            reduce using rule 33 (factor -> var_call postfix .)
    MINUS           reduce using rule 33 (factor -> var_call postfix .)
    MULTIPLY        reduce using rule 33 (factor -> var_call postfix .)
    DIVISION        reduce using rule 33 (factor -> var_call postfix .)
    MODULO          reduce using rule 33 (factor -> var_call postfix .)
    EXPONENT        reduce using rule 33 (factor -> var_call postfix .)
    GT              reduce using rule 33 (factor -> var_call postfix .)
    LT              reduce using rule 33 (factor -> var_call postfix .)
    EQ_EQ           reduce using rule 33 (factor -> var_call postfix .)
    GT_EQ           reduce using rule 33 (factor -> var_call postfix .)
    LT_EQ           reduce using rule 33 (factor -> var_call postfix .)
    NOT_EQ          reduce using rule 33 (factor -> var_call postfix .)
    AND             reduce using rule 33 (factor -> var_call postfix .)
    OR              reduce using rule 33 (factor -> var_call postfix .)
    COMMA           reduce using rule 33 (factor -> var_call postfix .)
    NEWLINE         reduce using rule 33 (factor -> var_call postfix .)
    RPAREN          reduce using rule 33 (factor -> var_call postfix .)
    RBRACE          reduce using rule 33 (factor -> var_call postfix .)
    SWAP            reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_NAME   reduce using rule 33 (factor -> var_call postfix .)
    IDENT           reduce using rule 33 (factor -> var_call postfix .)
    DISPLAY         reduce using rule 33 (factor -> var_call postfix .)
    CHECK           reduce using rule 33 (factor -> var_call postfix .)
    FOR             reduce using rule 33 (factor -> var_call postfix .)
    UNTIL           reduce using rule 33 (factor -> var_call postfix .)
    REPEAT          reduce using rule 33 (factor -> var_call postfix .)
    INPUT           reduce using rule 33 (factor -> var_call postfix .)
    INT             reduce using rule 33 (factor -> var_call postfix .)
    FLT             reduce using rule 33 (factor -> var_call postfix .)
    BLN             reduce using rule 33 (factor -> var_call postfix .)
    CHR             reduce using rule 33 (factor -> var_call postfix .)
    STR             reduce using rule 33 (factor -> var_call postfix .)
    REVIVE          reduce using rule 33 (factor -> var_call postfix .)
    SHIFT           reduce using rule 33 (factor -> var_call postfix .)
    OTHERWISE       reduce using rule 33 (factor -> var_call postfix .)
    SEMICOLON       reduce using rule 33 (factor -> var_call postfix .)
    COLON           reduce using rule 33 (factor -> var_call postfix .)


state 90

    (156) postfix -> empty .

    PLUS            reduce using rule 156 (postfix -> empty .)
    MINUS           reduce using rule 156 (postfix -> empty .)
    MULTIPLY        reduce using rule 156 (postfix -> empty .)
    DIVISION        reduce using rule 156 (postfix -> empty .)
    MODULO          reduce using rule 156 (postfix -> empty .)
    EXPONENT        reduce using rule 156 (postfix -> empty .)
    GT              reduce using rule 156 (postfix -> empty .)
    LT              reduce using rule 156 (postfix -> empty .)
    EQ_EQ           reduce using rule 156 (postfix -> empty .)
    GT_EQ           reduce using rule 156 (postfix -> empty .)
    LT_EQ           reduce using rule 156 (postfix -> empty .)
    NOT_EQ          reduce using rule 156 (postfix -> empty .)
    AND             reduce using rule 156 (postfix -> empty .)
    OR              reduce using rule 156 (postfix -> empty .)
    COMMA           reduce using rule 156 (postfix -> empty .)
    NEWLINE         reduce using rule 156 (postfix -> empty .)
    RPAREN          reduce using rule 156 (postfix -> empty .)
    RBRACE          reduce using rule 156 (postfix -> empty .)
    SWAP            reduce using rule 156 (postfix -> empty .)
    FUNCTION_NAME   reduce using rule 156 (postfix -> empty .)
    IDENT           reduce using rule 156 (postfix -> empty .)
    DISPLAY         reduce using rule 156 (postfix -> empty .)
    CHECK           reduce using rule 156 (postfix -> empty .)
    FOR             reduce using rule 156 (postfix -> empty .)
    UNTIL           reduce using rule 156 (postfix -> empty .)
    REPEAT          reduce using rule 156 (postfix -> empty .)
    INPUT           reduce using rule 156 (postfix -> empty .)
    INT             reduce using rule 156 (postfix -> empty .)
    FLT             reduce using rule 156 (postfix -> empty .)
    BLN             reduce using rule 156 (postfix -> empty .)
    CHR             reduce using rule 156 (postfix -> empty .)
    STR             reduce using rule 156 (postfix -> empty .)
    REVIVE          reduce using rule 156 (postfix -> empty .)
    SHIFT           reduce using rule 156 (postfix -> empty .)
    OTHERWISE       reduce using rule 156 (postfix -> empty .)
    SEMICOLON       reduce using rule 156 (postfix -> empty .)
    COLON           reduce using rule 156 (postfix -> empty .)


state 91

    (157) postfix -> postfix_op .

    PLUS            reduce using rule 157 (postfix -> postfix_op .)
    MINUS           reduce using rule 157 (postfix -> postfix_op .)
    MULTIPLY        reduce using rule 157 (postfix -> postfix_op .)
    DIVISION        reduce using rule 157 (postfix -> postfix_op .)
    MODULO          reduce using rule 157 (postfix -> postfix_op .)
    EXPONENT        reduce using rule 157 (postfix -> postfix_op .)
    GT              reduce using rule 157 (postfix -> postfix_op .)
    LT              reduce using rule 157 (postfix -> postfix_op .)
    EQ_EQ           reduce using rule 157 (postfix -> postfix_op .)
    GT_EQ           reduce using rule 157 (postfix -> postfix_op .)
    LT_EQ           reduce using rule 157 (postfix -> postfix_op .)
    NOT_EQ          reduce using rule 157 (postfix -> postfix_op .)
    AND             reduce using rule 157 (postfix -> postfix_op .)
    OR              reduce using rule 157 (postfix -> postfix_op .)
    COMMA           reduce using rule 157 (postfix -> postfix_op .)
    NEWLINE         reduce using rule 157 (postfix -> postfix_op .)
    RPAREN          reduce using rule 157 (postfix -> postfix_op .)
    RBRACE          reduce using rule 157 (postfix -> postfix_op .)
    SWAP            reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_NAME   reduce using rule 157 (postfix -> postfix_op .)
    IDENT           reduce using rule 157 (postfix -> postfix_op .)
    DISPLAY         reduce using rule 157 (postfix -> postfix_op .)
    CHECK           reduce using rule 157 (postfix -> postfix_op .)
    FOR             reduce using rule 157 (postfix -> postfix_op .)
    UNTIL           reduce using rule 157 (postfix -> postfix_op .)
    REPEAT          reduce using rule 157 (postfix -> postfix_op .)
    INPUT           reduce using rule 157 (postfix -> postfix_op .)
    INT             reduce using rule 157 (postfix -> postfix_op .)
    FLT             reduce using rule 157 (postfix -> postfix_op .)
    BLN             reduce using rule 157 (postfix -> postfix_op .)
    CHR             reduce using rule 157 (postfix -> postfix_op .)
    STR             reduce using rule 157 (postfix -> postfix_op .)
    REVIVE          reduce using rule 157 (postfix -> postfix_op .)
    SHIFT           reduce using rule 157 (postfix -> postfix_op .)
    OTHERWISE       reduce using rule 157 (postfix -> postfix_op .)
    SEMICOLON       reduce using rule 157 (postfix -> postfix_op .)
    COLON           reduce using rule 157 (postfix -> postfix_op .)


state 92

    (120) postfix_op -> PLUS_PLUS .

    PLUS            reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    MINUS           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    MULTIPLY        reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    DIVISION        reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    MODULO          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    EXPONENT        reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    GT              reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    LT              reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    EQ_EQ           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    GT_EQ           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    LT_EQ           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    NOT_EQ          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    AND             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    OR              reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    COMMA           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    NEWLINE         reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    RPAREN          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    RBRACE          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    SWAP            reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_NAME   reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    IDENT           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    DISPLAY         reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    CHECK           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FOR             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    UNTIL           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    REPEAT          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    INPUT           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    INT             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FLT             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    BLN             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    CHR             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    STR             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    REVIVE          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    SHIFT           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    OTHERWISE       reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    SEMICOLON       reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    COLON           reduce using rule 120 (postfix_op -> PLUS_PLUS .)


state 93

    (121) postfix_op -> MINUS_MINUS .

    PLUS            reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    MINUS           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    MULTIPLY        reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    DIVISION        reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    MODULO          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    EXPONENT        reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    GT              reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    LT              reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    EQ_EQ           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    GT_EQ           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    LT_EQ           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    NOT_EQ          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    AND             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    OR              reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    COMMA           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    NEWLINE         reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    RPAREN          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    RBRACE          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    SWAP            reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_NAME   reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    IDENT           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    DISPLAY         reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    CHECK           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FOR             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    UNTIL           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    REPEAT          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    INPUT           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    INT             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FLT             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    BLN             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    CHR             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    STR             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    REVIVE          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    SHIFT           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    OTHERWISE       reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    SEMICOLON       reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    COLON           reduce using rule 121 (postfix_op -> MINUS_MINUS .)


state 94

    (35) factor -> TILDE INT_LIT .

    PLUS            reduce using rule 35 (factor -> TILDE INT_LIT .)
    MINUS           reduce using rule 35 (factor -> TILDE INT_LIT .)
    MULTIPLY        reduce using rule 35 (factor -> TILDE INT_LIT .)
    DIVISION        reduce using rule 35 (factor -> TILDE INT_LIT .)
    MODULO          reduce using rule 35 (factor -> TILDE INT_LIT .)
    EXPONENT        reduce using rule 35 (factor -> TILDE INT_LIT .)
    GT              reduce using rule 35 (factor -> TILDE INT_LIT .)
    LT              reduce using rule 35 (factor -> TILDE INT_LIT .)
    EQ_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    GT_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    LT_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    NOT_EQ          reduce using rule 35 (factor -> TILDE INT_LIT .)
    AND             reduce using rule 35 (factor -> TILDE INT_LIT .)
    OR              reduce using rule 35 (factor -> TILDE INT_LIT .)
    COMMA           reduce using rule 35 (factor -> TILDE INT_LIT .)
    NEWLINE         reduce using rule 35 (factor -> TILDE INT_LIT .)
    RPAREN          reduce using rule 35 (factor -> TILDE INT_LIT .)
    RBRACE          reduce using rule 35 (factor -> TILDE INT_LIT .)
    SWAP            reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_NAME   reduce using rule 35 (factor -> TILDE INT_LIT .)
    IDENT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    DISPLAY         reduce using rule 35 (factor -> TILDE INT_LIT .)
    CHECK           reduce using rule 35 (factor -> TILDE INT_LIT .)
    FOR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    UNTIL           reduce using rule 35 (factor -> TILDE INT_LIT .)
    REPEAT          reduce using rule 35 (factor -> TILDE INT_LIT .)
    INPUT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    INT             reduce using rule 35 (factor -> TILDE INT_LIT .)
    FLT             reduce using rule 35 (factor -> TILDE INT_LIT .)
    BLN             reduce using rule 35 (factor -> TILDE INT_LIT .)
    CHR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    STR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    REVIVE          reduce using rule 35 (factor -> TILDE INT_LIT .)
    SHIFT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    OTHERWISE       reduce using rule 35 (factor -> TILDE INT_LIT .)
    SEMICOLON       reduce using rule 35 (factor -> TILDE INT_LIT .)
    COLON           reduce using rule 35 (factor -> TILDE INT_LIT .)


state 95

    (36) factor -> TILDE FLT_LIT .

    PLUS            reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MINUS           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MULTIPLY        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    DIVISION        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MODULO          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    EXPONENT        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    GT              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    LT              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    EQ_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    GT_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    LT_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    NOT_EQ          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    AND             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    OR              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    COMMA           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    NEWLINE         reduce using rule 36 (factor -> TILDE FLT_LIT .)
    RPAREN          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    RBRACE          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SWAP            reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_NAME   reduce using rule 36 (factor -> TILDE FLT_LIT .)
    IDENT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    DISPLAY         reduce using rule 36 (factor -> TILDE FLT_LIT .)
    CHECK           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FOR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    UNTIL           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    REPEAT          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    INPUT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    INT             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FLT             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    BLN             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    CHR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    STR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    REVIVE          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SHIFT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    OTHERWISE       reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SEMICOLON       reduce using rule 36 (factor -> TILDE FLT_LIT .)
    COLON           reduce using rule 36 (factor -> TILDE FLT_LIT .)


state 96

    (37) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 123


state 97

    (149) var_call -> IDENT list_index .

    PLUS_PLUS       reduce using rule 149 (var_call -> IDENT list_index .)
    MINUS_MINUS     reduce using rule 149 (var_call -> IDENT list_index .)
    PLUS            reduce using rule 149 (var_call -> IDENT list_index .)
    MINUS           reduce using rule 149 (var_call -> IDENT list_index .)
    MULTIPLY        reduce using rule 149 (var_call -> IDENT list_index .)
    DIVISION        reduce using rule 149 (var_call -> IDENT list_index .)
    MODULO          reduce using rule 149 (var_call -> IDENT list_index .)
    EXPONENT        reduce using rule 149 (var_call -> IDENT list_index .)
    GT              reduce using rule 149 (var_call -> IDENT list_index .)
    LT              reduce using rule 149 (var_call -> IDENT list_index .)
    EQ_EQ           reduce using rule 149 (var_call -> IDENT list_index .)
    GT_EQ           reduce using rule 149 (var_call -> IDENT list_index .)
    LT_EQ           reduce using rule 149 (var_call -> IDENT list_index .)
    NOT_EQ          reduce using rule 149 (var_call -> IDENT list_index .)
    AND             reduce using rule 149 (var_call -> IDENT list_index .)
    OR              reduce using rule 149 (var_call -> IDENT list_index .)
    COMMA           reduce using rule 149 (var_call -> IDENT list_index .)
    NEWLINE         reduce using rule 149 (var_call -> IDENT list_index .)
    RPAREN          reduce using rule 149 (var_call -> IDENT list_index .)
    RBRACE          reduce using rule 149 (var_call -> IDENT list_index .)
    SWAP            reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_NAME   reduce using rule 149 (var_call -> IDENT list_index .)
    IDENT           reduce using rule 149 (var_call -> IDENT list_index .)
    DISPLAY         reduce using rule 149 (var_call -> IDENT list_index .)
    CHECK           reduce using rule 149 (var_call -> IDENT list_index .)
    FOR             reduce using rule 149 (var_call -> IDENT list_index .)
    UNTIL           reduce using rule 149 (var_call -> IDENT list_index .)
    REPEAT          reduce using rule 149 (var_call -> IDENT list_index .)
    INPUT           reduce using rule 149 (var_call -> IDENT list_index .)
    INT             reduce using rule 149 (var_call -> IDENT list_index .)
    FLT             reduce using rule 149 (var_call -> IDENT list_index .)
    BLN             reduce using rule 149 (var_call -> IDENT list_index .)
    CHR             reduce using rule 149 (var_call -> IDENT list_index .)
    STR             reduce using rule 149 (var_call -> IDENT list_index .)
    REVIVE          reduce using rule 149 (var_call -> IDENT list_index .)
    SHIFT           reduce using rule 149 (var_call -> IDENT list_index .)
    OTHERWISE       reduce using rule 149 (var_call -> IDENT list_index .)
    SEMICOLON       reduce using rule 149 (var_call -> IDENT list_index .)
    COLON           reduce using rule 149 (var_call -> IDENT list_index .)
    PLUS_EQ         reduce using rule 149 (var_call -> IDENT list_index .)
    MINUS_EQ        reduce using rule 149 (var_call -> IDENT list_index .)
    MUL_EQ          reduce using rule 149 (var_call -> IDENT list_index .)
    DIV_EQ          reduce using rule 149 (var_call -> IDENT list_index .)
    MOD_EQ          reduce using rule 149 (var_call -> IDENT list_index .)


state 98

    (150) list_index -> LBRACKET . index RBRACKET list_index2
    (154) index -> . INT_LIT
    (155) index -> . IDENT

    INT_LIT         shift and go to state 125
    IDENT           shift and go to state 126

    index                          shift and go to state 124

state 99

    (151) list_index -> empty .

    PLUS_PLUS       reduce using rule 151 (list_index -> empty .)
    MINUS_MINUS     reduce using rule 151 (list_index -> empty .)
    PLUS            reduce using rule 151 (list_index -> empty .)
    MINUS           reduce using rule 151 (list_index -> empty .)
    MULTIPLY        reduce using rule 151 (list_index -> empty .)
    DIVISION        reduce using rule 151 (list_index -> empty .)
    MODULO          reduce using rule 151 (list_index -> empty .)
    EXPONENT        reduce using rule 151 (list_index -> empty .)
    GT              reduce using rule 151 (list_index -> empty .)
    LT              reduce using rule 151 (list_index -> empty .)
    EQ_EQ           reduce using rule 151 (list_index -> empty .)
    GT_EQ           reduce using rule 151 (list_index -> empty .)
    LT_EQ           reduce using rule 151 (list_index -> empty .)
    NOT_EQ          reduce using rule 151 (list_index -> empty .)
    AND             reduce using rule 151 (list_index -> empty .)
    OR              reduce using rule 151 (list_index -> empty .)
    COMMA           reduce using rule 151 (list_index -> empty .)
    NEWLINE         reduce using rule 151 (list_index -> empty .)
    RPAREN          reduce using rule 151 (list_index -> empty .)
    RBRACE          reduce using rule 151 (list_index -> empty .)
    SWAP            reduce using rule 151 (list_index -> empty .)
    FUNCTION_NAME   reduce using rule 151 (list_index -> empty .)
    IDENT           reduce using rule 151 (list_index -> empty .)
    DISPLAY         reduce using rule 151 (list_index -> empty .)
    CHECK           reduce using rule 151 (list_index -> empty .)
    FOR             reduce using rule 151 (list_index -> empty .)
    UNTIL           reduce using rule 151 (list_index -> empty .)
    REPEAT          reduce using rule 151 (list_index -> empty .)
    INPUT           reduce using rule 151 (list_index -> empty .)
    INT             reduce using rule 151 (list_index -> empty .)
    FLT             reduce using rule 151 (list_index -> empty .)
    BLN             reduce using rule 151 (list_index -> empty .)
    CHR             reduce using rule 151 (list_index -> empty .)
    STR             reduce using rule 151 (list_index -> empty .)
    REVIVE          reduce using rule 151 (list_index -> empty .)
    SHIFT           reduce using rule 151 (list_index -> empty .)
    OTHERWISE       reduce using rule 151 (list_index -> empty .)
    SEMICOLON       reduce using rule 151 (list_index -> empty .)
    COLON           reduce using rule 151 (list_index -> empty .)
    PLUS_EQ         reduce using rule 151 (list_index -> empty .)
    MINUS_EQ        reduce using rule 151 (list_index -> empty .)
    MUL_EQ          reduce using rule 151 (list_index -> empty .)
    DIV_EQ          reduce using rule 151 (list_index -> empty .)
    MOD_EQ          reduce using rule 151 (list_index -> empty .)


state 100

    (13) list_dec -> LBRACKET RBRACKET . _2d_list
    (14) _2d_list -> . empty
    (15) _2d_list -> . LBRACKET RBRACKET
    (169) empty -> .

    LBRACKET        shift and go to state 127
    COMMA           reduce using rule 169 (empty -> .)
    EQ              reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    _2d_list                       shift and go to state 128
    empty                          shift and go to state 129

state 101

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 130

state 102

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 131


state 103

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN . parameters RPAREN LBRACE statements revive RBRACE function_statements_tail
    (77) parameters -> . data_type IDENT parameters_tail
    (78) parameters -> . empty
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR
    (169) empty -> .

    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14
    RPAREN          reduce using rule 169 (empty -> .)

    parameters                     shift and go to state 132
    data_type                      shift and go to state 133
    empty                          shift and go to state 134

state 104

    (19) global_statement_tail2 -> COMMA IDENT . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (169) empty -> .

    COMMA           shift and go to state 22
    EQ              shift and go to state 23
    NEWLINE         reduce using rule 169 (empty -> .)

    global_statement_tail          shift and go to state 135
    empty                          shift and go to state 21

state 105

    (38) factor_tail -> PLUS factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 136
    empty                          shift and go to state 83

state 106

    (39) factor_tail -> MINUS factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 137
    empty                          shift and go to state 83

state 107

    (40) factor_tail -> MULTIPLY factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 138
    empty                          shift and go to state 83

state 108

    (41) factor_tail -> DIVISION factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 139
    empty                          shift and go to state 83

state 109

    (42) factor_tail -> MODULO factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 140
    empty                          shift and go to state 83

state 110

    (43) factor_tail -> EXPONENT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 141
    empty                          shift and go to state 83

state 111

    (44) factor_tail -> GT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 142
    empty                          shift and go to state 83

state 112

    (45) factor_tail -> LT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 143
    empty                          shift and go to state 83

state 113

    (46) factor_tail -> EQ_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 144
    empty                          shift and go to state 83

state 114

    (47) factor_tail -> GT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 145
    empty                          shift and go to state 83

state 115

    (48) factor_tail -> LT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 146
    empty                          shift and go to state 83

state 116

    (49) factor_tail -> NOT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 147
    empty                          shift and go to state 83

state 117

    (50) factor_tail -> AND factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 148
    empty                          shift and go to state 83

state 118

    (51) factor_tail -> OR factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    MULTIPLY        shift and go to state 71
    DIVISION        shift and go to state 72
    MODULO          shift and go to state 73
    EXPONENT        shift and go to state 74
    GT              shift and go to state 75
    LT              shift and go to state 76
    EQ_EQ           shift and go to state 77
    GT_EQ           shift and go to state 78
    LT_EQ           shift and go to state 79
    NOT_EQ          shift and go to state 80
    AND             shift and go to state 81
    OR              shift and go to state 82
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 149
    empty                          shift and go to state 83

state 119

    (23) list_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    SWAP            reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_NAME   reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    IDENT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    DISPLAY         reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    CHECK           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FOR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    UNTIL           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    REPEAT          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    INPUT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    INT             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FLT             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    BLN             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    CHR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    STR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    REVIVE          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    RBRACE          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    SHIFT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    OTHERWISE       reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)


state 120

    (24) list_element -> literal element_tail .

    RBRACKET        reduce using rule 24 (list_element -> literal element_tail .)
    RPAREN          reduce using rule 24 (list_element -> literal element_tail .)


state 121

    (25) element_tail -> COMMA . list_element
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 150
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 122

    (26) element_tail -> empty .

    RBRACKET        reduce using rule 26 (element_tail -> empty .)
    RPAREN          reduce using rule 26 (element_tail -> empty .)


state 123

    (37) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SWAP            reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_NAME   reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    IDENT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    DISPLAY         reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    CHECK           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    REPEAT          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    INPUT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    INT             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FLT             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    BLN             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    CHR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    STR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    REVIVE          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SHIFT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    OTHERWISE       reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 37 (factor -> LPAREN expression RPAREN .)


state 124

    (150) list_index -> LBRACKET index . RBRACKET list_index2

    RBRACKET        shift and go to state 151


state 125

    (154) index -> INT_LIT .

    RBRACKET        reduce using rule 154 (index -> INT_LIT .)


state 126

    (155) index -> IDENT .

    RBRACKET        reduce using rule 155 (index -> IDENT .)


state 127

    (15) _2d_list -> LBRACKET . RBRACKET

    RBRACKET        shift and go to state 152


state 128

    (13) list_dec -> LBRACKET RBRACKET _2d_list .

    COMMA           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    EQ              reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    NEWLINE         reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    SWAP            reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_NAME   reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    IDENT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    DISPLAY         reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    CHECK           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FOR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    UNTIL           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    REPEAT          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    INPUT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    INT             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FLT             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    BLN             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    CHR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    STR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    REVIVE          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    RBRACE          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    SHIFT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    OTHERWISE       reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)


state 129

    (14) _2d_list -> empty .

    COMMA           reduce using rule 14 (_2d_list -> empty .)
    EQ              reduce using rule 14 (_2d_list -> empty .)
    NEWLINE         reduce using rule 14 (_2d_list -> empty .)
    SWAP            reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_NAME   reduce using rule 14 (_2d_list -> empty .)
    IDENT           reduce using rule 14 (_2d_list -> empty .)
    DISPLAY         reduce using rule 14 (_2d_list -> empty .)
    CHECK           reduce using rule 14 (_2d_list -> empty .)
    FOR             reduce using rule 14 (_2d_list -> empty .)
    UNTIL           reduce using rule 14 (_2d_list -> empty .)
    REPEAT          reduce using rule 14 (_2d_list -> empty .)
    INPUT           reduce using rule 14 (_2d_list -> empty .)
    INT             reduce using rule 14 (_2d_list -> empty .)
    FLT             reduce using rule 14 (_2d_list -> empty .)
    BLN             reduce using rule 14 (_2d_list -> empty .)
    CHR             reduce using rule 14 (_2d_list -> empty .)
    STR             reduce using rule 14 (_2d_list -> empty .)
    REVIVE          reduce using rule 14 (_2d_list -> empty .)
    RBRACE          reduce using rule 14 (_2d_list -> empty .)
    SHIFT           reduce using rule 14 (_2d_list -> empty .)
    OTHERWISE       reduce using rule 14 (_2d_list -> empty .)


state 130

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 153


state 131

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 154


state 132

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters . RPAREN LBRACE statements revive RBRACE function_statements_tail

    RPAREN          shift and go to state 155


state 133

    (77) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 156


state 134

    (78) parameters -> empty .

    RPAREN          reduce using rule 78 (parameters -> empty .)


state 135

    (19) global_statement_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)


state 136

    (38) factor_tail -> PLUS factor factor_tail .

    COMMA           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    NEWLINE         reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    RPAREN          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    RBRACE          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SWAP            reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_NAME   reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    IDENT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    DISPLAY         reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    CHECK           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FOR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    UNTIL           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    REPEAT          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    INPUT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    INT             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FLT             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    BLN             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    CHR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    STR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    REVIVE          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SHIFT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    OTHERWISE       reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SEMICOLON       reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    COLON           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)


state 137

    (39) factor_tail -> MINUS factor factor_tail .

    COMMA           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    NEWLINE         reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    RPAREN          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    RBRACE          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SWAP            reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_NAME   reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    IDENT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    DISPLAY         reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    CHECK           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FOR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    UNTIL           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    REPEAT          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    INPUT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    INT             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FLT             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    BLN             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    CHR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    STR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    REVIVE          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SHIFT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    OTHERWISE       reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SEMICOLON       reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    COLON           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)


state 138

    (40) factor_tail -> MULTIPLY factor factor_tail .

    COMMA           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    NEWLINE         reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    RPAREN          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    RBRACE          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SWAP            reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_NAME   reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    IDENT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    DISPLAY         reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    CHECK           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FOR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    UNTIL           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    REPEAT          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    INPUT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    INT             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FLT             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    BLN             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    CHR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    STR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    REVIVE          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SHIFT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    OTHERWISE       reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SEMICOLON       reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    COLON           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)


state 139

    (41) factor_tail -> DIVISION factor factor_tail .

    COMMA           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    NEWLINE         reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    RPAREN          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    RBRACE          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SWAP            reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_NAME   reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    IDENT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    DISPLAY         reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    CHECK           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FOR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    UNTIL           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    REPEAT          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    INPUT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    INT             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FLT             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    BLN             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    CHR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    STR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    REVIVE          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SHIFT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    OTHERWISE       reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SEMICOLON       reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    COLON           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)


state 140

    (42) factor_tail -> MODULO factor factor_tail .

    COMMA           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    NEWLINE         reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    RPAREN          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    RBRACE          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SWAP            reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_NAME   reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    IDENT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    DISPLAY         reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    CHECK           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FOR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    UNTIL           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    REPEAT          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    INPUT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    INT             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FLT             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    BLN             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    CHR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    STR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    REVIVE          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SHIFT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    OTHERWISE       reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SEMICOLON       reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    COLON           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)


state 141

    (43) factor_tail -> EXPONENT factor factor_tail .

    COMMA           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    NEWLINE         reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    RPAREN          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    RBRACE          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SWAP            reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    IDENT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    DISPLAY         reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    CHECK           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FOR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    UNTIL           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    REPEAT          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    INPUT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    INT             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FLT             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    BLN             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    CHR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    STR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    REVIVE          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SHIFT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    OTHERWISE       reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SEMICOLON       reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    COLON           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)


state 142

    (44) factor_tail -> GT factor factor_tail .

    COMMA           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    NEWLINE         reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    RPAREN          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    RBRACE          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SWAP            reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    IDENT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    DISPLAY         reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    CHECK           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FOR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    UNTIL           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    REPEAT          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    INPUT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    INT             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FLT             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    BLN             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    CHR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    STR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    REVIVE          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SHIFT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    OTHERWISE       reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SEMICOLON       reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    COLON           reduce using rule 44 (factor_tail -> GT factor factor_tail .)


state 143

    (45) factor_tail -> LT factor factor_tail .

    COMMA           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    NEWLINE         reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    RPAREN          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    RBRACE          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SWAP            reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    IDENT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    DISPLAY         reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    CHECK           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FOR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    UNTIL           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    REPEAT          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    INPUT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    INT             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FLT             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    BLN             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    CHR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    STR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    REVIVE          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SHIFT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    OTHERWISE       reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SEMICOLON       reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    COLON           reduce using rule 45 (factor_tail -> LT factor factor_tail .)


state 144

    (46) factor_tail -> EQ_EQ factor factor_tail .

    COMMA           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    NEWLINE         reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    RPAREN          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    RBRACE          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SWAP            reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    IDENT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    DISPLAY         reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    CHECK           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FOR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    UNTIL           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    REPEAT          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    INPUT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    INT             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FLT             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    BLN             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    CHR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    STR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    REVIVE          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SHIFT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    COLON           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)


state 145

    (47) factor_tail -> GT_EQ factor factor_tail .

    COMMA           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    RPAREN          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    RBRACE          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SWAP            reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    IDENT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    CHECK           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FOR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    UNTIL           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    REPEAT          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    INPUT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    INT             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FLT             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    BLN             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    CHR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    STR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    REVIVE          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SHIFT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    COLON           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)


state 146

    (48) factor_tail -> LT_EQ factor factor_tail .

    COMMA           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    RPAREN          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    RBRACE          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SWAP            reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    IDENT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    CHECK           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FOR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    UNTIL           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    REPEAT          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    INPUT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    INT             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FLT             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    BLN             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    CHR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    STR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    REVIVE          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SHIFT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    COLON           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)


state 147

    (49) factor_tail -> NOT_EQ factor factor_tail .

    COMMA           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    RPAREN          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    RBRACE          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SWAP            reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    IDENT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    CHECK           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FOR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    UNTIL           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    REPEAT          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    INPUT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    INT             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FLT             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    BLN             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    CHR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    STR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    REVIVE          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SHIFT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    COLON           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)


state 148

    (50) factor_tail -> AND factor factor_tail .

    COMMA           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    NEWLINE         reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    RPAREN          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    RBRACE          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SWAP            reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_NAME   reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    IDENT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    DISPLAY         reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    CHECK           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FOR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    UNTIL           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    REPEAT          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    INPUT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    INT             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FLT             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    BLN             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    CHR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    STR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    REVIVE          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SHIFT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    OTHERWISE       reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SEMICOLON       reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    COLON           reduce using rule 50 (factor_tail -> AND factor factor_tail .)


state 149

    (51) factor_tail -> OR factor factor_tail .

    COMMA           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    NEWLINE         reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    RPAREN          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    RBRACE          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SWAP            reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_NAME   reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    IDENT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    DISPLAY         reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    CHECK           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FOR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    UNTIL           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    REPEAT          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    INPUT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    INT             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FLT             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    BLN             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    CHR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    STR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    REVIVE          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SHIFT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    OTHERWISE       reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SEMICOLON       reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    COLON           reduce using rule 51 (factor_tail -> OR factor factor_tail .)


state 150

    (25) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 25 (element_tail -> COMMA list_element .)
    RPAREN          reduce using rule 25 (element_tail -> COMMA list_element .)


state 151

    (150) list_index -> LBRACKET index RBRACKET . list_index2
    (152) list_index2 -> . LBRACKET index RBRACKET
    (153) list_index2 -> . empty
    (169) empty -> .

    LBRACKET        shift and go to state 157
    PLUS_PLUS       reduce using rule 169 (empty -> .)
    MINUS_MINUS     reduce using rule 169 (empty -> .)
    PLUS            reduce using rule 169 (empty -> .)
    MINUS           reduce using rule 169 (empty -> .)
    MULTIPLY        reduce using rule 169 (empty -> .)
    DIVISION        reduce using rule 169 (empty -> .)
    MODULO          reduce using rule 169 (empty -> .)
    EXPONENT        reduce using rule 169 (empty -> .)
    GT              reduce using rule 169 (empty -> .)
    LT              reduce using rule 169 (empty -> .)
    EQ_EQ           reduce using rule 169 (empty -> .)
    GT_EQ           reduce using rule 169 (empty -> .)
    LT_EQ           reduce using rule 169 (empty -> .)
    NOT_EQ          reduce using rule 169 (empty -> .)
    AND             reduce using rule 169 (empty -> .)
    OR              reduce using rule 169 (empty -> .)
    COMMA           reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)
    PLUS_EQ         reduce using rule 169 (empty -> .)
    MINUS_EQ        reduce using rule 169 (empty -> .)
    MUL_EQ          reduce using rule 169 (empty -> .)
    DIV_EQ          reduce using rule 169 (empty -> .)
    MOD_EQ          reduce using rule 169 (empty -> .)

    list_index2                    shift and go to state 158
    empty                          shift and go to state 159

state 152

    (15) _2d_list -> LBRACKET RBRACKET .

    COMMA           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    EQ              reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    NEWLINE         reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    SWAP            reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_NAME   reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    IDENT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    DISPLAY         reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    CHECK           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FOR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    UNTIL           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    REPEAT          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    INPUT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    INT             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FLT             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    BLN             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    CHR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    STR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    REVIVE          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    SHIFT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    OTHERWISE       reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)


state 153

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 154

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    LBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 160
    empty                          shift and go to state 17

state 155

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN . LBRACE statements revive RBRACE function_statements_tail

    LBRACE          shift and go to state 161


state 156

    (77) parameters -> data_type IDENT . parameters_tail
    (79) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (80) parameters_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 169 (empty -> .)

    parameters_tail                shift and go to state 162
    empty                          shift and go to state 164

state 157

    (152) list_index2 -> LBRACKET . index RBRACKET
    (154) index -> . INT_LIT
    (155) index -> . IDENT

    INT_LIT         shift and go to state 125
    IDENT           shift and go to state 126

    index                          shift and go to state 165

state 158

    (150) list_index -> LBRACKET index RBRACKET list_index2 .

    PLUS_PLUS       reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS_MINUS     reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    PLUS            reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MULTIPLY        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DIVISION        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MODULO          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    EXPONENT        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    GT              reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    LT              reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    EQ_EQ           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    GT_EQ           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    LT_EQ           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    NOT_EQ          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    AND             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    OR              reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    COMMA           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    NEWLINE         reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    RPAREN          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    RBRACE          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SWAP            reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_NAME   reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    IDENT           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DISPLAY         reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    CHECK           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FOR             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    UNTIL           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    REPEAT          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    INPUT           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    INT             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FLT             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    BLN             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    CHR             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    STR             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    REVIVE          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SHIFT           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    OTHERWISE       reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SEMICOLON       reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    COLON           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    PLUS_EQ         reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS_EQ        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MUL_EQ          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DIV_EQ          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MOD_EQ          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)


state 159

    (153) list_index2 -> empty .

    PLUS_PLUS       reduce using rule 153 (list_index2 -> empty .)
    MINUS_MINUS     reduce using rule 153 (list_index2 -> empty .)
    PLUS            reduce using rule 153 (list_index2 -> empty .)
    MINUS           reduce using rule 153 (list_index2 -> empty .)
    MULTIPLY        reduce using rule 153 (list_index2 -> empty .)
    DIVISION        reduce using rule 153 (list_index2 -> empty .)
    MODULO          reduce using rule 153 (list_index2 -> empty .)
    EXPONENT        reduce using rule 153 (list_index2 -> empty .)
    GT              reduce using rule 153 (list_index2 -> empty .)
    LT              reduce using rule 153 (list_index2 -> empty .)
    EQ_EQ           reduce using rule 153 (list_index2 -> empty .)
    GT_EQ           reduce using rule 153 (list_index2 -> empty .)
    LT_EQ           reduce using rule 153 (list_index2 -> empty .)
    NOT_EQ          reduce using rule 153 (list_index2 -> empty .)
    AND             reduce using rule 153 (list_index2 -> empty .)
    OR              reduce using rule 153 (list_index2 -> empty .)
    COMMA           reduce using rule 153 (list_index2 -> empty .)
    NEWLINE         reduce using rule 153 (list_index2 -> empty .)
    RPAREN          reduce using rule 153 (list_index2 -> empty .)
    RBRACE          reduce using rule 153 (list_index2 -> empty .)
    SWAP            reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_NAME   reduce using rule 153 (list_index2 -> empty .)
    IDENT           reduce using rule 153 (list_index2 -> empty .)
    DISPLAY         reduce using rule 153 (list_index2 -> empty .)
    CHECK           reduce using rule 153 (list_index2 -> empty .)
    FOR             reduce using rule 153 (list_index2 -> empty .)
    UNTIL           reduce using rule 153 (list_index2 -> empty .)
    REPEAT          reduce using rule 153 (list_index2 -> empty .)
    INPUT           reduce using rule 153 (list_index2 -> empty .)
    INT             reduce using rule 153 (list_index2 -> empty .)
    FLT             reduce using rule 153 (list_index2 -> empty .)
    BLN             reduce using rule 153 (list_index2 -> empty .)
    CHR             reduce using rule 153 (list_index2 -> empty .)
    STR             reduce using rule 153 (list_index2 -> empty .)
    REVIVE          reduce using rule 153 (list_index2 -> empty .)
    SHIFT           reduce using rule 153 (list_index2 -> empty .)
    OTHERWISE       reduce using rule 153 (list_index2 -> empty .)
    SEMICOLON       reduce using rule 153 (list_index2 -> empty .)
    COLON           reduce using rule 153 (list_index2 -> empty .)
    PLUS_EQ         reduce using rule 153 (list_index2 -> empty .)
    MINUS_EQ        reduce using rule 153 (list_index2 -> empty .)
    MUL_EQ          reduce using rule 153 (list_index2 -> empty .)
    DIV_EQ          reduce using rule 153 (list_index2 -> empty .)
    MOD_EQ          reduce using rule 153 (list_index2 -> empty .)


state 160

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 166


state 161

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE . statements revive RBRACE function_statements_tail
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 167
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 162

    (77) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 77 (parameters -> data_type IDENT parameters_tail .)


state 163

    (79) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    data_type                      shift and go to state 171

state 164

    (80) parameters_tail -> empty .

    RPAREN          reduce using rule 80 (parameters_tail -> empty .)


state 165

    (152) list_index2 -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 172


state 166

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 173
    empty                          shift and go to state 17

state 167

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements . revive RBRACE function_statements_tail
    (81) revive -> . REVIVE value
    (82) revive -> . empty
    (169) empty -> .

    REVIVE          shift and go to state 175
    RBRACE          reduce using rule 169 (empty -> .)

    revive                         shift and go to state 174
    empty                          shift and go to state 176

state 168

    (83) statements -> empty .
    (93) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 83 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 83 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 83 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 83 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 83 (statements -> empty .)
    REVIVE          reduce using rule 83 (statements -> empty .)
    RBRACE          reduce using rule 83 (statements -> empty .)
    NEWLINE         reduce using rule 83 (statements -> empty .)
    SHIFT           reduce using rule 83 (statements -> empty .)
    OTHERWISE       reduce using rule 83 (statements -> empty .)
    SWAP            reduce using rule 93 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 93 (local_dec -> empty .)
    IDENT           reduce using rule 93 (local_dec -> empty .)
    DISPLAY         reduce using rule 93 (local_dec -> empty .)
    CHECK           reduce using rule 93 (local_dec -> empty .)
    FOR             reduce using rule 93 (local_dec -> empty .)
    UNTIL           reduce using rule 93 (local_dec -> empty .)
    REPEAT          reduce using rule 93 (local_dec -> empty .)
    INPUT           reduce using rule 93 (local_dec -> empty .)
    INT             reduce using rule 93 (local_dec -> empty .)
    FLT             reduce using rule 93 (local_dec -> empty .)
    BLN             reduce using rule 93 (local_dec -> empty .)
    CHR             reduce using rule 93 (local_dec -> empty .)
    STR             reduce using rule 93 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 93 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 93 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 93 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 93 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 93 (local_dec -> empty .) ]


state 169

    (84) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 177
    empty                          shift and go to state 17

state 170

    (92) local_dec -> var_statement . local_dec_tail
    (94) local_dec_tail -> . empty
    (95) local_dec_tail -> . COMMA IDENT local_dec_tail
    (96) local_dec_tail -> . EQ local_value local_dec_tail2
    (169) empty -> .

    COMMA           shift and go to state 180
    EQ              shift and go to state 181
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    local_dec_tail                 shift and go to state 178
    empty                          shift and go to state 179

state 171

    (79) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 182


state 172

    (152) list_index2 -> LBRACKET index RBRACKET .

    PLUS_PLUS       reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    PLUS            reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    GT              reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    LT              reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    AND             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    OR              reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    SWAP            reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_NAME   reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    IDENT           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    DISPLAY         reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    CHECK           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FOR             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    UNTIL           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    REPEAT          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    INPUT           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    INT             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FLT             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    BLN             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    CHR             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    STR             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    REVIVE          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    SHIFT           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    OTHERWISE       reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)


state 173

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 183
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 174

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive . RBRACE function_statements_tail

    RBRACE          shift and go to state 184


state 175

    (81) revive -> REVIVE . value
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 189
    CONVERT_TO_FLT  shift and go to state 190
    CONVERT_TO_BLN  shift and go to state 191
    CONVERT_TO_STR  shift and go to state 192
    FUNCTION_NAME   shift and go to state 193
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 195
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 185
    type_cast                      shift and go to state 186
    expression                     shift and go to state 187
    function_call                  shift and go to state 188
    factor                         shift and go to state 47
    input_statement                shift and go to state 194
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 176

    (82) revive -> empty .

    RBRACE          reduce using rule 82 (revive -> empty .)


state 177

    (84) statements -> local_dec maybe_newline . statements_tail
    (85) statements_tail -> . switch_statement unli_newline statements
    (86) statements_tail -> . loop_statement unli_newline statements
    (87) statements_tail -> . function_call unli_newline statements
    (88) statements_tail -> . assignment_statement unli_newline statements
    (89) statements_tail -> . output_statement unli_newline statements
    (90) statements_tail -> . conditional_statement unli_newline statements
    (91) statements_tail -> . statements
    (104) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
    (108) loop_statement -> . for_loop
    (109) loop_statement -> . until_loop
    (110) loop_statement -> . repeat_until
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (133) assignment_statement -> . IDENT assign_tail
    (130) output_statement -> . DISPLAY value next_val
    (101) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (111) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (112) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (113) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SWAP            shift and go to state 204
    FUNCTION_NAME   shift and go to state 193
    IDENT           shift and go to state 205
    DISPLAY         shift and go to state 209
    CHECK           shift and go to state 210
    FOR             shift and go to state 211
    UNTIL           shift and go to state 212
    REPEAT          shift and go to state 213
    INPUT           shift and go to state 195
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! SWAP            [ reduce using rule 169 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 169 (empty -> .) ]
  ! IDENT           [ reduce using rule 169 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 169 (empty -> .) ]
  ! CHECK           [ reduce using rule 169 (empty -> .) ]
  ! FOR             [ reduce using rule 169 (empty -> .) ]
  ! UNTIL           [ reduce using rule 169 (empty -> .) ]
  ! REPEAT          [ reduce using rule 169 (empty -> .) ]
  ! INPUT           [ reduce using rule 169 (empty -> .) ]
  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    local_dec                      shift and go to state 169
    statements_tail                shift and go to state 196
    switch_statement               shift and go to state 197
    statements                     shift and go to state 198
    loop_statement                 shift and go to state 199
    function_call                  shift and go to state 200
    assignment_statement           shift and go to state 201
    output_statement               shift and go to state 202
    conditional_statement          shift and go to state 203
    for_loop                       shift and go to state 206
    until_loop                     shift and go to state 207
    repeat_until                   shift and go to state 208
    input_statement                shift and go to state 194
    empty                          shift and go to state 168
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 178

    (92) local_dec -> var_statement local_dec_tail .

    NEWLINE         reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    SWAP            reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    FUNCTION_NAME   reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    IDENT           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    DISPLAY         reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    CHECK           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    FOR             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    UNTIL           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    REPEAT          reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    INPUT           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    INT             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    FLT             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    BLN             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    CHR             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    STR             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    REVIVE          reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    RBRACE          reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    SHIFT           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    OTHERWISE       reduce using rule 92 (local_dec -> var_statement local_dec_tail .)


state 179

    (94) local_dec_tail -> empty .

    NEWLINE         reduce using rule 94 (local_dec_tail -> empty .)
    SWAP            reduce using rule 94 (local_dec_tail -> empty .)
    FUNCTION_NAME   reduce using rule 94 (local_dec_tail -> empty .)
    IDENT           reduce using rule 94 (local_dec_tail -> empty .)
    DISPLAY         reduce using rule 94 (local_dec_tail -> empty .)
    CHECK           reduce using rule 94 (local_dec_tail -> empty .)
    FOR             reduce using rule 94 (local_dec_tail -> empty .)
    UNTIL           reduce using rule 94 (local_dec_tail -> empty .)
    REPEAT          reduce using rule 94 (local_dec_tail -> empty .)
    INPUT           reduce using rule 94 (local_dec_tail -> empty .)
    INT             reduce using rule 94 (local_dec_tail -> empty .)
    FLT             reduce using rule 94 (local_dec_tail -> empty .)
    BLN             reduce using rule 94 (local_dec_tail -> empty .)
    CHR             reduce using rule 94 (local_dec_tail -> empty .)
    STR             reduce using rule 94 (local_dec_tail -> empty .)
    REVIVE          reduce using rule 94 (local_dec_tail -> empty .)
    RBRACE          reduce using rule 94 (local_dec_tail -> empty .)
    SHIFT           reduce using rule 94 (local_dec_tail -> empty .)
    OTHERWISE       reduce using rule 94 (local_dec_tail -> empty .)


state 180

    (95) local_dec_tail -> COMMA . IDENT local_dec_tail

    IDENT           shift and go to state 214


state 181

    (96) local_dec_tail -> EQ . local_value local_dec_tail2
    (99) local_value -> . value
    (100) local_value -> . list_value
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (23) list_value -> . LBRACKET list_element RBRACKET
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    LBRACKET        shift and go to state 48
    CONVERT_TO_INT  shift and go to state 189
    CONVERT_TO_FLT  shift and go to state 190
    CONVERT_TO_BLN  shift and go to state 191
    CONVERT_TO_STR  shift and go to state 192
    FUNCTION_NAME   shift and go to state 193
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 195
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    local_value                    shift and go to state 215
    value                          shift and go to state 216
    list_value                     shift and go to state 217
    type_cast                      shift and go to state 186
    expression                     shift and go to state 187
    function_call                  shift and go to state 188
    factor                         shift and go to state 47
    input_statement                shift and go to state 194
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 182

    (79) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (79) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (80) parameters_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 169 (empty -> .)

    parameters_tail                shift and go to state 218
    empty                          shift and go to state 164

state 183

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 219
    empty                          shift and go to state 17

state 184

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE . function_statements_tail
    (63) function_statements_tail -> . function_statements
    (64) function_statements_tail -> . empty
    (61) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail
    (62) function_statements -> . empty
    (169) empty -> .
    (65) ret_type -> . FUNCTION
    (66) ret_type -> . function_dtype
    (67) function_dtype -> . FUNCTION_INT
    (68) function_dtype -> . FUNCTION_FLT
    (69) function_dtype -> . FUNCTION_CHR
    (70) function_dtype -> . FUNCTION_BLN
    (71) function_dtype -> . FUNCTION_STR
    (72) function_dtype -> . FUNCTION_LIST_INT
    (73) function_dtype -> . FUNCTION_LIST_FLT
    (74) function_dtype -> . FUNCTION_LIST_CHR
    (75) function_dtype -> . FUNCTION_LIST_STR
    (76) function_dtype -> . FUNCTION_LIST_BLN

    NEWLINE         reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    FUNCTION        shift and go to state 28
    FUNCTION_INT    shift and go to state 30
    FUNCTION_FLT    shift and go to state 31
    FUNCTION_CHR    shift and go to state 32
    FUNCTION_BLN    shift and go to state 33
    FUNCTION_STR    shift and go to state 34
    FUNCTION_LIST_INT shift and go to state 35
    FUNCTION_LIST_FLT shift and go to state 36
    FUNCTION_LIST_CHR shift and go to state 37
    FUNCTION_LIST_STR shift and go to state 38
    FUNCTION_LIST_BLN shift and go to state 39

    ret_type                       shift and go to state 26
    function_statements_tail       shift and go to state 220
    function_statements            shift and go to state 221
    empty                          shift and go to state 222
    function_dtype                 shift and go to state 29

state 185

    (81) revive -> REVIVE value .

    RBRACE          reduce using rule 81 (revive -> REVIVE value .)


state 186

    (158) value -> type_cast .

    RBRACE          reduce using rule 158 (value -> type_cast .)
    COMMA           reduce using rule 158 (value -> type_cast .)
    NEWLINE         reduce using rule 158 (value -> type_cast .)
    SWAP            reduce using rule 158 (value -> type_cast .)
    FUNCTION_NAME   reduce using rule 158 (value -> type_cast .)
    IDENT           reduce using rule 158 (value -> type_cast .)
    DISPLAY         reduce using rule 158 (value -> type_cast .)
    CHECK           reduce using rule 158 (value -> type_cast .)
    FOR             reduce using rule 158 (value -> type_cast .)
    UNTIL           reduce using rule 158 (value -> type_cast .)
    REPEAT          reduce using rule 158 (value -> type_cast .)
    INPUT           reduce using rule 158 (value -> type_cast .)
    INT             reduce using rule 158 (value -> type_cast .)
    FLT             reduce using rule 158 (value -> type_cast .)
    BLN             reduce using rule 158 (value -> type_cast .)
    CHR             reduce using rule 158 (value -> type_cast .)
    STR             reduce using rule 158 (value -> type_cast .)
    REVIVE          reduce using rule 158 (value -> type_cast .)
    SHIFT           reduce using rule 158 (value -> type_cast .)
    OTHERWISE       reduce using rule 158 (value -> type_cast .)
    COLON           reduce using rule 158 (value -> type_cast .)
    RPAREN          reduce using rule 158 (value -> type_cast .)


state 187

    (159) value -> expression .

    RBRACE          reduce using rule 159 (value -> expression .)
    COMMA           reduce using rule 159 (value -> expression .)
    NEWLINE         reduce using rule 159 (value -> expression .)
    SWAP            reduce using rule 159 (value -> expression .)
    FUNCTION_NAME   reduce using rule 159 (value -> expression .)
    IDENT           reduce using rule 159 (value -> expression .)
    DISPLAY         reduce using rule 159 (value -> expression .)
    CHECK           reduce using rule 159 (value -> expression .)
    FOR             reduce using rule 159 (value -> expression .)
    UNTIL           reduce using rule 159 (value -> expression .)
    REPEAT          reduce using rule 159 (value -> expression .)
    INPUT           reduce using rule 159 (value -> expression .)
    INT             reduce using rule 159 (value -> expression .)
    FLT             reduce using rule 159 (value -> expression .)
    BLN             reduce using rule 159 (value -> expression .)
    CHR             reduce using rule 159 (value -> expression .)
    STR             reduce using rule 159 (value -> expression .)
    REVIVE          reduce using rule 159 (value -> expression .)
    SHIFT           reduce using rule 159 (value -> expression .)
    OTHERWISE       reduce using rule 159 (value -> expression .)
    COLON           reduce using rule 159 (value -> expression .)
    RPAREN          reduce using rule 159 (value -> expression .)


state 188

    (160) value -> function_call .

    RBRACE          reduce using rule 160 (value -> function_call .)
    COMMA           reduce using rule 160 (value -> function_call .)
    NEWLINE         reduce using rule 160 (value -> function_call .)
    SWAP            reduce using rule 160 (value -> function_call .)
    FUNCTION_NAME   reduce using rule 160 (value -> function_call .)
    IDENT           reduce using rule 160 (value -> function_call .)
    DISPLAY         reduce using rule 160 (value -> function_call .)
    CHECK           reduce using rule 160 (value -> function_call .)
    FOR             reduce using rule 160 (value -> function_call .)
    UNTIL           reduce using rule 160 (value -> function_call .)
    REPEAT          reduce using rule 160 (value -> function_call .)
    INPUT           reduce using rule 160 (value -> function_call .)
    INT             reduce using rule 160 (value -> function_call .)
    FLT             reduce using rule 160 (value -> function_call .)
    BLN             reduce using rule 160 (value -> function_call .)
    CHR             reduce using rule 160 (value -> function_call .)
    STR             reduce using rule 160 (value -> function_call .)
    REVIVE          reduce using rule 160 (value -> function_call .)
    SHIFT           reduce using rule 160 (value -> function_call .)
    OTHERWISE       reduce using rule 160 (value -> function_call .)
    COLON           reduce using rule 160 (value -> function_call .)
    RPAREN          reduce using rule 160 (value -> function_call .)


state 189

    (161) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 223


state 190

    (162) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 224


state 191

    (163) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 225


state 192

    (164) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 226


state 193

    (122) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 227


state 194

    (123) function_call -> input_statement .

    RBRACE          reduce using rule 123 (function_call -> input_statement .)
    NEWLINE         reduce using rule 123 (function_call -> input_statement .)
    COMMA           reduce using rule 123 (function_call -> input_statement .)
    SWAP            reduce using rule 123 (function_call -> input_statement .)
    FUNCTION_NAME   reduce using rule 123 (function_call -> input_statement .)
    IDENT           reduce using rule 123 (function_call -> input_statement .)
    DISPLAY         reduce using rule 123 (function_call -> input_statement .)
    CHECK           reduce using rule 123 (function_call -> input_statement .)
    FOR             reduce using rule 123 (function_call -> input_statement .)
    UNTIL           reduce using rule 123 (function_call -> input_statement .)
    REPEAT          reduce using rule 123 (function_call -> input_statement .)
    INPUT           reduce using rule 123 (function_call -> input_statement .)
    INT             reduce using rule 123 (function_call -> input_statement .)
    FLT             reduce using rule 123 (function_call -> input_statement .)
    BLN             reduce using rule 123 (function_call -> input_statement .)
    CHR             reduce using rule 123 (function_call -> input_statement .)
    STR             reduce using rule 123 (function_call -> input_statement .)
    REVIVE          reduce using rule 123 (function_call -> input_statement .)
    SHIFT           reduce using rule 123 (function_call -> input_statement .)
    OTHERWISE       reduce using rule 123 (function_call -> input_statement .)
    COLON           reduce using rule 123 (function_call -> input_statement .)
    RPAREN          reduce using rule 123 (function_call -> input_statement .)


state 195

    (168) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 228


state 196

    (84) statements -> local_dec maybe_newline statements_tail .

    REVIVE          reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)
    NEWLINE         reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)


state 197

    (85) statements_tail -> switch_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 229

state 198

    (91) statements_tail -> statements .

    REVIVE          reduce using rule 91 (statements_tail -> statements .)
    RBRACE          reduce using rule 91 (statements_tail -> statements .)
    NEWLINE         reduce using rule 91 (statements_tail -> statements .)
    SHIFT           reduce using rule 91 (statements_tail -> statements .)
    OTHERWISE       reduce using rule 91 (statements_tail -> statements .)


state 199

    (86) statements_tail -> loop_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 230

state 200

    (87) statements_tail -> function_call . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 231

state 201

    (88) statements_tail -> assignment_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 232

state 202

    (89) statements_tail -> output_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 233

state 203

    (90) statements_tail -> conditional_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 234

state 204

    (104) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    LPAREN          shift and go to state 235


state 205

    (133) assignment_statement -> IDENT . assign_tail
    (134) assign_tail -> . DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
    (135) assign_tail -> . DOT PUSH LPAREN list_element RPAREN
    (136) assign_tail -> . assign_op value
    (137) assign_op -> . compound_op
    (138) assign_op -> . EQ
    (139) compound_op -> . PLUS_EQ
    (140) compound_op -> . MINUS_EQ
    (141) compound_op -> . MUL_EQ
    (142) compound_op -> . DIV_EQ
    (143) compound_op -> . MOD_EQ

    DOT             shift and go to state 237
    EQ              shift and go to state 240
    PLUS_EQ         shift and go to state 241
    MINUS_EQ        shift and go to state 242
    MUL_EQ          shift and go to state 243
    DIV_EQ          shift and go to state 244
    MOD_EQ          shift and go to state 245

    assign_tail                    shift and go to state 236
    assign_op                      shift and go to state 238
    compound_op                    shift and go to state 239

state 206

    (108) loop_statement -> for_loop .

    NEWLINE         reduce using rule 108 (loop_statement -> for_loop .)


state 207

    (109) loop_statement -> until_loop .

    NEWLINE         reduce using rule 109 (loop_statement -> until_loop .)


state 208

    (110) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 110 (loop_statement -> repeat_until .)


state 209

    (130) output_statement -> DISPLAY . value next_val
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 189
    CONVERT_TO_FLT  shift and go to state 190
    CONVERT_TO_BLN  shift and go to state 191
    CONVERT_TO_STR  shift and go to state 192
    FUNCTION_NAME   shift and go to state 193
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 195
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 246
    type_cast                      shift and go to state 186
    expression                     shift and go to state 187
    function_call                  shift and go to state 188
    factor                         shift and go to state 47
    input_statement                shift and go to state 194
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 210

    (101) conditional_statement -> CHECK . LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 247


state 211

    (111) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 248


state 212

    (112) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 249


state 213

    (113) repeat_until -> REPEAT . LBRACE statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 250


state 214

    (95) local_dec_tail -> COMMA IDENT . local_dec_tail
    (94) local_dec_tail -> . empty
    (95) local_dec_tail -> . COMMA IDENT local_dec_tail
    (96) local_dec_tail -> . EQ local_value local_dec_tail2
    (169) empty -> .

    COMMA           shift and go to state 180
    EQ              shift and go to state 181
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    local_dec_tail                 shift and go to state 251
    empty                          shift and go to state 179

state 215

    (96) local_dec_tail -> EQ local_value . local_dec_tail2
    (97) local_dec_tail2 -> . COMMA IDENT local_dec_tail
    (98) local_dec_tail2 -> . empty
    (169) empty -> .

    COMMA           shift and go to state 253
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    local_dec_tail2                shift and go to state 252
    empty                          shift and go to state 254

state 216

    (99) local_value -> value .

    COMMA           reduce using rule 99 (local_value -> value .)
    NEWLINE         reduce using rule 99 (local_value -> value .)
    SWAP            reduce using rule 99 (local_value -> value .)
    FUNCTION_NAME   reduce using rule 99 (local_value -> value .)
    IDENT           reduce using rule 99 (local_value -> value .)
    DISPLAY         reduce using rule 99 (local_value -> value .)
    CHECK           reduce using rule 99 (local_value -> value .)
    FOR             reduce using rule 99 (local_value -> value .)
    UNTIL           reduce using rule 99 (local_value -> value .)
    REPEAT          reduce using rule 99 (local_value -> value .)
    INPUT           reduce using rule 99 (local_value -> value .)
    INT             reduce using rule 99 (local_value -> value .)
    FLT             reduce using rule 99 (local_value -> value .)
    BLN             reduce using rule 99 (local_value -> value .)
    CHR             reduce using rule 99 (local_value -> value .)
    STR             reduce using rule 99 (local_value -> value .)
    REVIVE          reduce using rule 99 (local_value -> value .)
    RBRACE          reduce using rule 99 (local_value -> value .)
    SHIFT           reduce using rule 99 (local_value -> value .)
    OTHERWISE       reduce using rule 99 (local_value -> value .)


state 217

    (100) local_value -> list_value .

    COMMA           reduce using rule 100 (local_value -> list_value .)
    NEWLINE         reduce using rule 100 (local_value -> list_value .)
    SWAP            reduce using rule 100 (local_value -> list_value .)
    FUNCTION_NAME   reduce using rule 100 (local_value -> list_value .)
    IDENT           reduce using rule 100 (local_value -> list_value .)
    DISPLAY         reduce using rule 100 (local_value -> list_value .)
    CHECK           reduce using rule 100 (local_value -> list_value .)
    FOR             reduce using rule 100 (local_value -> list_value .)
    UNTIL           reduce using rule 100 (local_value -> list_value .)
    REPEAT          reduce using rule 100 (local_value -> list_value .)
    INPUT           reduce using rule 100 (local_value -> list_value .)
    INT             reduce using rule 100 (local_value -> list_value .)
    FLT             reduce using rule 100 (local_value -> list_value .)
    BLN             reduce using rule 100 (local_value -> list_value .)
    CHR             reduce using rule 100 (local_value -> list_value .)
    STR             reduce using rule 100 (local_value -> list_value .)
    REVIVE          reduce using rule 100 (local_value -> list_value .)
    RBRACE          reduce using rule 100 (local_value -> list_value .)
    SHIFT           reduce using rule 100 (local_value -> list_value .)
    OTHERWISE       reduce using rule 100 (local_value -> list_value .)


state 218

    (79) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 79 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 219

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 255


state 220

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail .

    NEWLINE         reduce using rule 61 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail .)
    MAIN_CASPER     reduce using rule 61 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail .)


state 221

    (63) function_statements_tail -> function_statements .

    NEWLINE         reduce using rule 63 (function_statements_tail -> function_statements .)
    MAIN_CASPER     reduce using rule 63 (function_statements_tail -> function_statements .)


state 222

    (64) function_statements_tail -> empty .
    (62) function_statements -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 62 (function_statements -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 62 (function_statements -> empty .)
    NEWLINE         reduce using rule 62 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 62 (function_statements -> empty .)

  ! NEWLINE         [ reduce using rule 64 (function_statements_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 64 (function_statements_tail -> empty .) ]


state 223

    (161) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (165) typecast_value -> . expression
    (166) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (167) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (168) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 258
    INPUT           shift and go to state 195
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 256
    expression                     shift and go to state 257
    input_statement                shift and go to state 259
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 224

    (162) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (165) typecast_value -> . expression
    (166) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (167) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (168) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 258
    INPUT           shift and go to state 195
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 260
    expression                     shift and go to state 257
    input_statement                shift and go to state 259
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 225

    (163) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (165) typecast_value -> . expression
    (166) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (167) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (168) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 258
    INPUT           shift and go to state 195
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 261
    expression                     shift and go to state 257
    input_statement                shift and go to state 259
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 226

    (164) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (165) typecast_value -> . expression
    (166) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (167) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (168) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 258
    INPUT           shift and go to state 195
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    typecast_value                 shift and go to state 262
    expression                     shift and go to state 257
    input_statement                shift and go to state 259
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 227

    (122) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (124) arguments -> . empty
    (125) arguments -> . arg_value arg_tail
    (169) empty -> .
    (128) arg_value -> . literal
    (129) arg_value -> . var_call
    (53) literal -> . literal1
    (54) literal -> . literal2
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    RPAREN          reduce using rule 169 (empty -> .)
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    arguments                      shift and go to state 263
    empty                          shift and go to state 264
    arg_value                      shift and go to state 265
    literal                        shift and go to state 266
    var_call                       shift and go to state 267
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 228

    (168) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 268


state 229

    (85) statements_tail -> switch_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 269
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 230

    (86) statements_tail -> loop_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 270
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 231

    (87) statements_tail -> function_call unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 271
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 232

    (88) statements_tail -> assignment_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 272
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 233

    (89) statements_tail -> output_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 273
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 234

    (90) statements_tail -> conditional_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 274
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 235

    (104) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    IDENT           shift and go to state 275


state 236

    (133) assignment_statement -> IDENT assign_tail .

    NEWLINE         reduce using rule 133 (assignment_statement -> IDENT assign_tail .)


state 237

    (134) assign_tail -> DOT . SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
    (135) assign_tail -> DOT . PUSH LPAREN list_element RPAREN

    SPLICE          shift and go to state 276
    PUSH            shift and go to state 277


state 238

    (136) assign_tail -> assign_op . value
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 189
    CONVERT_TO_FLT  shift and go to state 190
    CONVERT_TO_BLN  shift and go to state 191
    CONVERT_TO_STR  shift and go to state 192
    FUNCTION_NAME   shift and go to state 193
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 195
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 278
    type_cast                      shift and go to state 186
    expression                     shift and go to state 187
    function_call                  shift and go to state 188
    factor                         shift and go to state 47
    input_statement                shift and go to state 194
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 239

    (137) assign_op -> compound_op .

    CONVERT_TO_INT  reduce using rule 137 (assign_op -> compound_op .)
    CONVERT_TO_FLT  reduce using rule 137 (assign_op -> compound_op .)
    CONVERT_TO_BLN  reduce using rule 137 (assign_op -> compound_op .)
    CONVERT_TO_STR  reduce using rule 137 (assign_op -> compound_op .)
    FUNCTION_NAME   reduce using rule 137 (assign_op -> compound_op .)
    TILDE           reduce using rule 137 (assign_op -> compound_op .)
    LPAREN          reduce using rule 137 (assign_op -> compound_op .)
    INPUT           reduce using rule 137 (assign_op -> compound_op .)
    IDENT           reduce using rule 137 (assign_op -> compound_op .)
    INT_LIT         reduce using rule 137 (assign_op -> compound_op .)
    FLT_LIT         reduce using rule 137 (assign_op -> compound_op .)
    DAY             reduce using rule 137 (assign_op -> compound_op .)
    NIGHT           reduce using rule 137 (assign_op -> compound_op .)
    STR_LIT         reduce using rule 137 (assign_op -> compound_op .)


state 240

    (138) assign_op -> EQ .

    CONVERT_TO_INT  reduce using rule 138 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 138 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 138 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 138 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 138 (assign_op -> EQ .)
    TILDE           reduce using rule 138 (assign_op -> EQ .)
    LPAREN          reduce using rule 138 (assign_op -> EQ .)
    INPUT           reduce using rule 138 (assign_op -> EQ .)
    IDENT           reduce using rule 138 (assign_op -> EQ .)
    INT_LIT         reduce using rule 138 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 138 (assign_op -> EQ .)
    DAY             reduce using rule 138 (assign_op -> EQ .)
    NIGHT           reduce using rule 138 (assign_op -> EQ .)
    STR_LIT         reduce using rule 138 (assign_op -> EQ .)


state 241

    (139) compound_op -> PLUS_EQ .

    CONVERT_TO_INT  reduce using rule 139 (compound_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 139 (compound_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 139 (compound_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 139 (compound_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 139 (compound_op -> PLUS_EQ .)
    TILDE           reduce using rule 139 (compound_op -> PLUS_EQ .)
    LPAREN          reduce using rule 139 (compound_op -> PLUS_EQ .)
    INPUT           reduce using rule 139 (compound_op -> PLUS_EQ .)
    IDENT           reduce using rule 139 (compound_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 139 (compound_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 139 (compound_op -> PLUS_EQ .)
    DAY             reduce using rule 139 (compound_op -> PLUS_EQ .)
    NIGHT           reduce using rule 139 (compound_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 139 (compound_op -> PLUS_EQ .)


state 242

    (140) compound_op -> MINUS_EQ .

    CONVERT_TO_INT  reduce using rule 140 (compound_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 140 (compound_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 140 (compound_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 140 (compound_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 140 (compound_op -> MINUS_EQ .)
    TILDE           reduce using rule 140 (compound_op -> MINUS_EQ .)
    LPAREN          reduce using rule 140 (compound_op -> MINUS_EQ .)
    INPUT           reduce using rule 140 (compound_op -> MINUS_EQ .)
    IDENT           reduce using rule 140 (compound_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 140 (compound_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 140 (compound_op -> MINUS_EQ .)
    DAY             reduce using rule 140 (compound_op -> MINUS_EQ .)
    NIGHT           reduce using rule 140 (compound_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 140 (compound_op -> MINUS_EQ .)


state 243

    (141) compound_op -> MUL_EQ .

    CONVERT_TO_INT  reduce using rule 141 (compound_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 141 (compound_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 141 (compound_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 141 (compound_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 141 (compound_op -> MUL_EQ .)
    TILDE           reduce using rule 141 (compound_op -> MUL_EQ .)
    LPAREN          reduce using rule 141 (compound_op -> MUL_EQ .)
    INPUT           reduce using rule 141 (compound_op -> MUL_EQ .)
    IDENT           reduce using rule 141 (compound_op -> MUL_EQ .)
    INT_LIT         reduce using rule 141 (compound_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 141 (compound_op -> MUL_EQ .)
    DAY             reduce using rule 141 (compound_op -> MUL_EQ .)
    NIGHT           reduce using rule 141 (compound_op -> MUL_EQ .)
    STR_LIT         reduce using rule 141 (compound_op -> MUL_EQ .)


state 244

    (142) compound_op -> DIV_EQ .

    CONVERT_TO_INT  reduce using rule 142 (compound_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 142 (compound_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 142 (compound_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 142 (compound_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 142 (compound_op -> DIV_EQ .)
    TILDE           reduce using rule 142 (compound_op -> DIV_EQ .)
    LPAREN          reduce using rule 142 (compound_op -> DIV_EQ .)
    INPUT           reduce using rule 142 (compound_op -> DIV_EQ .)
    IDENT           reduce using rule 142 (compound_op -> DIV_EQ .)
    INT_LIT         reduce using rule 142 (compound_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 142 (compound_op -> DIV_EQ .)
    DAY             reduce using rule 142 (compound_op -> DIV_EQ .)
    NIGHT           reduce using rule 142 (compound_op -> DIV_EQ .)
    STR_LIT         reduce using rule 142 (compound_op -> DIV_EQ .)


state 245

    (143) compound_op -> MOD_EQ .

    CONVERT_TO_INT  reduce using rule 143 (compound_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 143 (compound_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 143 (compound_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 143 (compound_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 143 (compound_op -> MOD_EQ .)
    TILDE           reduce using rule 143 (compound_op -> MOD_EQ .)
    LPAREN          reduce using rule 143 (compound_op -> MOD_EQ .)
    INPUT           reduce using rule 143 (compound_op -> MOD_EQ .)
    IDENT           reduce using rule 143 (compound_op -> MOD_EQ .)
    INT_LIT         reduce using rule 143 (compound_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 143 (compound_op -> MOD_EQ .)
    DAY             reduce using rule 143 (compound_op -> MOD_EQ .)
    NIGHT           reduce using rule 143 (compound_op -> MOD_EQ .)
    STR_LIT         reduce using rule 143 (compound_op -> MOD_EQ .)


state 246

    (130) output_statement -> DISPLAY value . next_val
    (131) next_val -> . COMMA value next_val
    (132) next_val -> . empty
    (169) empty -> .

    COMMA           shift and go to state 280
    NEWLINE         reduce using rule 169 (empty -> .)

    next_val                       shift and go to state 279
    empty                          shift and go to state 281

state 247

    (101) conditional_statement -> CHECK LPAREN . expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 282
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 248

    (111) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (114) control_variable -> . INT IDENT EQ control_var_tail

    INT             shift and go to state 284

    control_variable               shift and go to state 283

state 249

    (112) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE statements RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 285
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 250

    (113) repeat_until -> REPEAT LBRACE . statements RBRACE UNTIL LPAREN expression RPAREN
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 286
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 251

    (95) local_dec_tail -> COMMA IDENT local_dec_tail .

    NEWLINE         reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    SWAP            reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FUNCTION_NAME   reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    IDENT           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    DISPLAY         reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    CHECK           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FOR             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    UNTIL           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    REPEAT          reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    INPUT           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    INT             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FLT             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    BLN             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    CHR             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    STR             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    REVIVE          reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    RBRACE          reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    SHIFT           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    OTHERWISE       reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)


state 252

    (96) local_dec_tail -> EQ local_value local_dec_tail2 .

    NEWLINE         reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    SWAP            reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FUNCTION_NAME   reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    IDENT           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    DISPLAY         reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    CHECK           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FOR             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    UNTIL           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    REPEAT          reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    INPUT           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    INT             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FLT             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    BLN             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    CHR             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    STR             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    REVIVE          reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    RBRACE          reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    SHIFT           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    OTHERWISE       reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)


state 253

    (97) local_dec_tail2 -> COMMA . IDENT local_dec_tail

    IDENT           shift and go to state 287


state 254

    (98) local_dec_tail2 -> empty .

    NEWLINE         reduce using rule 98 (local_dec_tail2 -> empty .)
    SWAP            reduce using rule 98 (local_dec_tail2 -> empty .)
    FUNCTION_NAME   reduce using rule 98 (local_dec_tail2 -> empty .)
    IDENT           reduce using rule 98 (local_dec_tail2 -> empty .)
    DISPLAY         reduce using rule 98 (local_dec_tail2 -> empty .)
    CHECK           reduce using rule 98 (local_dec_tail2 -> empty .)
    FOR             reduce using rule 98 (local_dec_tail2 -> empty .)
    UNTIL           reduce using rule 98 (local_dec_tail2 -> empty .)
    REPEAT          reduce using rule 98 (local_dec_tail2 -> empty .)
    INPUT           reduce using rule 98 (local_dec_tail2 -> empty .)
    INT             reduce using rule 98 (local_dec_tail2 -> empty .)
    FLT             reduce using rule 98 (local_dec_tail2 -> empty .)
    BLN             reduce using rule 98 (local_dec_tail2 -> empty .)
    CHR             reduce using rule 98 (local_dec_tail2 -> empty .)
    STR             reduce using rule 98 (local_dec_tail2 -> empty .)
    REVIVE          reduce using rule 98 (local_dec_tail2 -> empty .)
    RBRACE          reduce using rule 98 (local_dec_tail2 -> empty .)
    SHIFT           reduce using rule 98 (local_dec_tail2 -> empty .)
    OTHERWISE       reduce using rule 98 (local_dec_tail2 -> empty .)


state 255

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)


state 256

    (161) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 288


state 257

    (165) typecast_value -> expression .

    RPAREN          reduce using rule 165 (typecast_value -> expression .)


state 258

    (166) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 289


state 259

    (167) typecast_value -> input_statement .

    RPAREN          reduce using rule 167 (typecast_value -> input_statement .)


state 260

    (162) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 290


state 261

    (163) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 291


state 262

    (164) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 292


state 263

    (122) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 293


state 264

    (124) arguments -> empty .

    RPAREN          reduce using rule 124 (arguments -> empty .)


state 265

    (125) arguments -> arg_value . arg_tail
    (126) arg_tail -> . COMMA arg_value arg_tail
    (127) arg_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 295
    RPAREN          reduce using rule 169 (empty -> .)

    arg_tail                       shift and go to state 294
    empty                          shift and go to state 296

state 266

    (128) arg_value -> literal .

    COMMA           reduce using rule 128 (arg_value -> literal .)
    RPAREN          reduce using rule 128 (arg_value -> literal .)


state 267

    (129) arg_value -> var_call .

    COMMA           reduce using rule 129 (arg_value -> var_call .)
    RPAREN          reduce using rule 129 (arg_value -> var_call .)


state 268

    (168) input_statement -> INPUT LPAREN RPAREN .

    RBRACE          reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    NEWLINE         reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    SWAP            reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION_NAME   reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    IDENT           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    DISPLAY         reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    CHECK           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    UNTIL           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    REPEAT          reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    FLT             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    BLN             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    CHR             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    STR             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    REVIVE          reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    SHIFT           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    OTHERWISE       reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)


state 269

    (85) statements_tail -> switch_statement unli_newline statements .

    REVIVE          reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)
    RBRACE          reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)
    NEWLINE         reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)
    SHIFT           reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)
    OTHERWISE       reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)


state 270

    (86) statements_tail -> loop_statement unli_newline statements .

    REVIVE          reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)
    RBRACE          reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)
    NEWLINE         reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)
    SHIFT           reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)
    OTHERWISE       reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)


state 271

    (87) statements_tail -> function_call unli_newline statements .

    REVIVE          reduce using rule 87 (statements_tail -> function_call unli_newline statements .)
    RBRACE          reduce using rule 87 (statements_tail -> function_call unli_newline statements .)
    NEWLINE         reduce using rule 87 (statements_tail -> function_call unli_newline statements .)
    SHIFT           reduce using rule 87 (statements_tail -> function_call unli_newline statements .)
    OTHERWISE       reduce using rule 87 (statements_tail -> function_call unli_newline statements .)


state 272

    (88) statements_tail -> assignment_statement unli_newline statements .

    REVIVE          reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)
    RBRACE          reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)
    NEWLINE         reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)
    SHIFT           reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)
    OTHERWISE       reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)


state 273

    (89) statements_tail -> output_statement unli_newline statements .

    REVIVE          reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)
    RBRACE          reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)
    NEWLINE         reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)
    SHIFT           reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)
    OTHERWISE       reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)


state 274

    (90) statements_tail -> conditional_statement unli_newline statements .

    REVIVE          reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)
    RBRACE          reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)
    NEWLINE         reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)
    SHIFT           reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)
    OTHERWISE       reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)


state 275

    (104) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    RPAREN          shift and go to state 297


state 276

    (134) assign_tail -> DOT SPLICE . LPAREN start COMMA deleteCount COMMA splice_items RPAREN

    LPAREN          shift and go to state 298


state 277

    (135) assign_tail -> DOT PUSH . LPAREN list_element RPAREN

    LPAREN          shift and go to state 299


state 278

    (136) assign_tail -> assign_op value .

    NEWLINE         reduce using rule 136 (assign_tail -> assign_op value .)


state 279

    (130) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 130 (output_statement -> DISPLAY value next_val .)


state 280

    (131) next_val -> COMMA . value next_val
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 189
    CONVERT_TO_FLT  shift and go to state 190
    CONVERT_TO_BLN  shift and go to state 191
    CONVERT_TO_STR  shift and go to state 192
    FUNCTION_NAME   shift and go to state 193
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 195
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 300
    type_cast                      shift and go to state 186
    expression                     shift and go to state 187
    function_call                  shift and go to state 188
    factor                         shift and go to state 47
    input_statement                shift and go to state 194
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 281

    (132) next_val -> empty .

    NEWLINE         reduce using rule 132 (next_val -> empty .)


state 282

    (101) conditional_statement -> CHECK LPAREN expression . RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 301


state 283

    (111) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 302


state 284

    (114) control_variable -> INT . IDENT EQ control_var_tail

    IDENT           shift and go to state 303


state 285

    (112) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 304


state 286

    (113) repeat_until -> REPEAT LBRACE statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 305


state 287

    (97) local_dec_tail2 -> COMMA IDENT . local_dec_tail
    (94) local_dec_tail -> . empty
    (95) local_dec_tail -> . COMMA IDENT local_dec_tail
    (96) local_dec_tail -> . EQ local_value local_dec_tail2
    (169) empty -> .

    COMMA           shift and go to state 180
    EQ              shift and go to state 181
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    local_dec_tail                 shift and go to state 306
    empty                          shift and go to state 179

state 288

    (161) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    RBRACE          reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 289

    (166) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 307


state 290

    (162) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    RBRACE          reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 291

    (163) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    RBRACE          reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INT             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    STR             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 292

    (164) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    RBRACE          reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INT             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    STR             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 293

    (122) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    RBRACE          reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    NEWLINE         reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SWAP            reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FUNCTION_NAME   reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    IDENT           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    DISPLAY         reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHECK           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FOR             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    UNTIL           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REPEAT          reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INPUT           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INT             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FLT             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    BLN             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHR             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    STR             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REVIVE          reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SHIFT           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    OTHERWISE       reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 294

    (125) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 125 (arguments -> arg_value arg_tail .)


state 295

    (126) arg_tail -> COMMA . arg_value arg_tail
    (128) arg_value -> . literal
    (129) arg_value -> . var_call
    (53) literal -> . literal1
    (54) literal -> . literal2
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    arg_value                      shift and go to state 308
    literal                        shift and go to state 266
    var_call                       shift and go to state 267
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 296

    (127) arg_tail -> empty .

    RPAREN          reduce using rule 127 (arg_tail -> empty .)


state 297

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    LBRACE          shift and go to state 309


state 298

    (134) assign_tail -> DOT SPLICE LPAREN . start COMMA deleteCount COMMA splice_items RPAREN
    (144) start -> . INT_LIT

    INT_LIT         shift and go to state 311

    start                          shift and go to state 310

state 299

    (135) assign_tail -> DOT PUSH LPAREN . list_element RPAREN
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    list_element                   shift and go to state 312
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 300

    (131) next_val -> COMMA value . next_val
    (131) next_val -> . COMMA value next_val
    (132) next_val -> . empty
    (169) empty -> .

    COMMA           shift and go to state 280
    NEWLINE         reduce using rule 169 (empty -> .)

    next_val                       shift and go to state 313
    empty                          shift and go to state 281

state 301

    (101) conditional_statement -> CHECK LPAREN expression RPAREN . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 314


state 302

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 315
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 303

    (114) control_variable -> INT IDENT . EQ control_var_tail

    EQ              shift and go to state 316


state 304

    (112) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 317


state 305

    (113) repeat_until -> REPEAT LBRACE statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 318


state 306

    (97) local_dec_tail2 -> COMMA IDENT local_dec_tail .

    NEWLINE         reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    SWAP            reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FUNCTION_NAME   reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    IDENT           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    DISPLAY         reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    CHECK           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FOR             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    UNTIL           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    REPEAT          reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    INPUT           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    INT             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FLT             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    BLN             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    CHR             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    STR             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    REVIVE          reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    RBRACE          reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    SHIFT           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    OTHERWISE       reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)


state 307

    (166) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 166 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 308

    (126) arg_tail -> COMMA arg_value . arg_tail
    (126) arg_tail -> . COMMA arg_value arg_tail
    (127) arg_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 295
    RPAREN          reduce using rule 169 (empty -> .)

    arg_tail                       shift and go to state 319
    empty                          shift and go to state 296

state 309

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
    (105) switch_condition -> . SHIFT value COLON statements switchcond_tail

    SHIFT           shift and go to state 321

    switch_condition               shift and go to state 320

state 310

    (134) assign_tail -> DOT SPLICE LPAREN start . COMMA deleteCount COMMA splice_items RPAREN

    COMMA           shift and go to state 322


state 311

    (144) start -> INT_LIT .

    COMMA           reduce using rule 144 (start -> INT_LIT .)


state 312

    (135) assign_tail -> DOT PUSH LPAREN list_element . RPAREN

    RPAREN          shift and go to state 323


state 313

    (131) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 131 (next_val -> COMMA value next_val .)


state 314

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 324
    empty                          shift and go to state 17

state 315

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 325


state 316

    (114) control_variable -> INT IDENT EQ . control_var_tail
    (115) control_var_tail -> . INT_LIT
    (116) control_var_tail -> . var_call
    (149) var_call -> . IDENT list_index

    INT_LIT         shift and go to state 327
    IDENT           shift and go to state 55

    control_var_tail               shift and go to state 326
    var_call                       shift and go to state 328

state 317

    (112) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . statements RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 329
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 318

    (113) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 330


state 319

    (126) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 126 (arg_tail -> COMMA arg_value arg_tail .)


state 320

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition . OTHERWISE LBRACE statements RBRACE RBRACE

    OTHERWISE       shift and go to state 331


state 321

    (105) switch_condition -> SHIFT . value COLON statements switchcond_tail
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 189
    CONVERT_TO_FLT  shift and go to state 190
    CONVERT_TO_BLN  shift and go to state 191
    CONVERT_TO_STR  shift and go to state 192
    FUNCTION_NAME   shift and go to state 193
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 195
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 332
    type_cast                      shift and go to state 186
    expression                     shift and go to state 187
    function_call                  shift and go to state 188
    factor                         shift and go to state 47
    input_statement                shift and go to state 194
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 322

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA . deleteCount COMMA splice_items RPAREN
    (145) deleteCount -> . empty
    (146) deleteCount -> . INT_LIT
    (169) empty -> .

    INT_LIT         shift and go to state 335
    COMMA           reduce using rule 169 (empty -> .)

    deleteCount                    shift and go to state 333
    empty                          shift and go to state 334

state 323

    (135) assign_tail -> DOT PUSH LPAREN list_element RPAREN .

    NEWLINE         reduce using rule 135 (assign_tail -> DOT PUSH LPAREN list_element RPAREN .)


state 324

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 336
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 325

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN LBRACE statements RBRACE
    (117) update -> . var_call update_tail
    (149) var_call -> . IDENT list_index

    IDENT           shift and go to state 55

    update                         shift and go to state 337
    var_call                       shift and go to state 338

state 326

    (114) control_variable -> INT IDENT EQ control_var_tail .

    SEMICOLON       reduce using rule 114 (control_variable -> INT IDENT EQ control_var_tail .)


state 327

    (115) control_var_tail -> INT_LIT .

    SEMICOLON       reduce using rule 115 (control_var_tail -> INT_LIT .)


state 328

    (116) control_var_tail -> var_call .

    SEMICOLON       reduce using rule 116 (control_var_tail -> var_call .)


state 329

    (112) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 339


state 330

    (113) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN . expression RPAREN
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 340
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 331

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE . LBRACE statements RBRACE RBRACE

    LBRACE          shift and go to state 341


state 332

    (105) switch_condition -> SHIFT value . COLON statements switchcond_tail

    COLON           shift and go to state 342


state 333

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount . COMMA splice_items RPAREN

    COMMA           shift and go to state 343


state 334

    (145) deleteCount -> empty .

    COMMA           reduce using rule 145 (deleteCount -> empty .)


state 335

    (146) deleteCount -> INT_LIT .

    COMMA           reduce using rule 146 (deleteCount -> INT_LIT .)


state 336

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 344
    empty                          shift and go to state 17

state 337

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 345


state 338

    (117) update -> var_call . update_tail
    (118) update_tail -> . postfix_op
    (119) update_tail -> . compound_op value
    (120) postfix_op -> . PLUS_PLUS
    (121) postfix_op -> . MINUS_MINUS
    (139) compound_op -> . PLUS_EQ
    (140) compound_op -> . MINUS_EQ
    (141) compound_op -> . MUL_EQ
    (142) compound_op -> . DIV_EQ
    (143) compound_op -> . MOD_EQ

    PLUS_PLUS       shift and go to state 92
    MINUS_MINUS     shift and go to state 93
    PLUS_EQ         shift and go to state 241
    MINUS_EQ        shift and go to state 242
    MUL_EQ          shift and go to state 243
    DIV_EQ          shift and go to state 244
    MOD_EQ          shift and go to state 245

    update_tail                    shift and go to state 346
    postfix_op                     shift and go to state 347
    compound_op                    shift and go to state 348

state 339

    (112) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 112 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .)


state 340

    (113) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 349


state 341

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE . statements RBRACE RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 350
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 342

    (105) switch_condition -> SHIFT value COLON . statements switchcond_tail
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 351
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 343

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA . splice_items RPAREN
    (147) splice_items -> . empty
    (148) splice_items -> . list_element
    (169) empty -> .
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    RPAREN          reduce using rule 169 (empty -> .)
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58
    CHR_LIT         shift and go to state 88

    splice_items                   shift and go to state 352
    empty                          shift and go to state 353
    list_element                   shift and go to state 354
    literal                        shift and go to state 85
    literal1                       shift and go to state 86
    literal2                       shift and go to state 87

state 344

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RBRACE          shift and go to state 355


state 345

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 356


state 346

    (117) update -> var_call update_tail .

    RPAREN          reduce using rule 117 (update -> var_call update_tail .)


state 347

    (118) update_tail -> postfix_op .

    RPAREN          reduce using rule 118 (update_tail -> postfix_op .)


state 348

    (119) update_tail -> compound_op . value
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 189
    CONVERT_TO_FLT  shift and go to state 190
    CONVERT_TO_BLN  shift and go to state 191
    CONVERT_TO_STR  shift and go to state 192
    FUNCTION_NAME   shift and go to state 193
    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    INPUT           shift and go to state 195
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    value                          shift and go to state 357
    type_cast                      shift and go to state 186
    expression                     shift and go to state 187
    function_call                  shift and go to state 188
    factor                         shift and go to state 47
    input_statement                shift and go to state 194
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 349

    (113) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 113 (repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .)


state 350

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements . RBRACE RBRACE

    RBRACE          shift and go to state 358


state 351

    (105) switch_condition -> SHIFT value COLON statements . switchcond_tail
    (106) switchcond_tail -> . switch_condition
    (107) switchcond_tail -> . empty
    (105) switch_condition -> . SHIFT value COLON statements switchcond_tail
    (169) empty -> .

    SHIFT           shift and go to state 321
    OTHERWISE       reduce using rule 169 (empty -> .)

    switchcond_tail                shift and go to state 359
    switch_condition               shift and go to state 360
    empty                          shift and go to state 361

state 352

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items . RPAREN

    RPAREN          shift and go to state 362


state 353

    (147) splice_items -> empty .

    RPAREN          reduce using rule 147 (splice_items -> empty .)


state 354

    (148) splice_items -> list_element .

    RPAREN          reduce using rule 148 (splice_items -> list_element .)


state 355

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    OTHERWISE_CHECK reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 363
    empty                          shift and go to state 17

state 356

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE . statements RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 364
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 357

    (119) update_tail -> compound_op value .

    RPAREN          reduce using rule 119 (update_tail -> compound_op value .)


state 358

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE . RBRACE

    RBRACE          shift and go to state 365


state 359

    (105) switch_condition -> SHIFT value COLON statements switchcond_tail .

    OTHERWISE       reduce using rule 105 (switch_condition -> SHIFT value COLON statements switchcond_tail .)


state 360

    (106) switchcond_tail -> switch_condition .

    OTHERWISE       reduce using rule 106 (switchcond_tail -> switch_condition .)


state 361

    (107) switchcond_tail -> empty .

    OTHERWISE       reduce using rule 107 (switchcond_tail -> empty .)


state 362

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN .

    NEWLINE         reduce using rule 134 (assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN .)


state 363

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (102) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (103) conditional_tail -> . empty
    (169) empty -> .

    OTHERWISE_CHECK shift and go to state 367
    NEWLINE         reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    conditional_tail               shift and go to state 366
    empty                          shift and go to state 368

state 364

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 369


state 365

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE .

    NEWLINE         reduce using rule 104 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE .)


state 366

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    OTHERWISE       reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 370
    empty                          shift and go to state 17

state 367

    (102) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail

    LPAREN          shift and go to state 371


state 368

    (103) conditional_tail -> empty .

    NEWLINE         reduce using rule 103 (conditional_tail -> empty .)
    OTHERWISE       reduce using rule 103 (conditional_tail -> empty .)


state 369

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 111 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE .)


state 370

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    OTHERWISE       shift and go to state 372


state 371

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN LBRACE statements RBRACE conditional_tail
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 51
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 55
    INT_LIT         shift and go to state 52
    FLT_LIT         shift and go to state 53
    DAY             shift and go to state 56
    NIGHT           shift and go to state 57
    STR_LIT         shift and go to state 58

    expression                     shift and go to state 373
    factor                         shift and go to state 47
    var_call                       shift and go to state 49
    literal1                       shift and go to state 50

state 372

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    LBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 374
    empty                          shift and go to state 17

state 373

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN LBRACE statements RBRACE conditional_tail

    RPAREN          shift and go to state 375


state 374

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 376


state 375

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . LBRACE statements RBRACE conditional_tail

    LBRACE          shift and go to state 377


state 376

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 378
    empty                          shift and go to state 17

state 377

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE . statements RBRACE conditional_tail
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 379
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 378

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 380
    empty                          shift and go to state 168
    local_dec                      shift and go to state 169
    var_statement                  shift and go to state 170
    data_type                      shift and go to state 9

state 379

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements . RBRACE conditional_tail

    RBRACE          shift and go to state 381


state 380

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 382
    empty                          shift and go to state 17

state 381

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE . conditional_tail
    (102) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (103) conditional_tail -> . empty
    (169) empty -> .

    OTHERWISE_CHECK shift and go to state 367
    NEWLINE         reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    conditional_tail               shift and go to state 383
    empty                          shift and go to state 368

state 382

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 384


state 383

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .

    NEWLINE         reduce using rule 102 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .)
    OTHERWISE       reduce using rule 102 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .)


state 384

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 101 (conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 18 resolved as shift
WARNING: shift/reduce conflict for INT in state 161 resolved as shift
WARNING: shift/reduce conflict for FLT in state 161 resolved as shift
WARNING: shift/reduce conflict for BLN in state 161 resolved as shift
WARNING: shift/reduce conflict for CHR in state 161 resolved as shift
WARNING: shift/reduce conflict for STR in state 161 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 166 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 169 resolved as shift
WARNING: shift/reduce conflict for INT in state 173 resolved as shift
WARNING: shift/reduce conflict for FLT in state 173 resolved as shift
WARNING: shift/reduce conflict for BLN in state 173 resolved as shift
WARNING: shift/reduce conflict for CHR in state 173 resolved as shift
WARNING: shift/reduce conflict for STR in state 173 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 177 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 177 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 177 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 177 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 177 resolved as shift
WARNING: shift/reduce conflict for FOR in state 177 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 177 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 177 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 177 resolved as shift
WARNING: shift/reduce conflict for INT in state 177 resolved as shift
WARNING: shift/reduce conflict for FLT in state 177 resolved as shift
WARNING: shift/reduce conflict for BLN in state 177 resolved as shift
WARNING: shift/reduce conflict for CHR in state 177 resolved as shift
WARNING: shift/reduce conflict for STR in state 177 resolved as shift
WARNING: shift/reduce conflict for INT in state 229 resolved as shift
WARNING: shift/reduce conflict for FLT in state 229 resolved as shift
WARNING: shift/reduce conflict for BLN in state 229 resolved as shift
WARNING: shift/reduce conflict for CHR in state 229 resolved as shift
WARNING: shift/reduce conflict for STR in state 229 resolved as shift
WARNING: shift/reduce conflict for INT in state 230 resolved as shift
WARNING: shift/reduce conflict for FLT in state 230 resolved as shift
WARNING: shift/reduce conflict for BLN in state 230 resolved as shift
WARNING: shift/reduce conflict for CHR in state 230 resolved as shift
WARNING: shift/reduce conflict for STR in state 230 resolved as shift
WARNING: shift/reduce conflict for INT in state 231 resolved as shift
WARNING: shift/reduce conflict for FLT in state 231 resolved as shift
WARNING: shift/reduce conflict for BLN in state 231 resolved as shift
WARNING: shift/reduce conflict for CHR in state 231 resolved as shift
WARNING: shift/reduce conflict for STR in state 231 resolved as shift
WARNING: shift/reduce conflict for INT in state 232 resolved as shift
WARNING: shift/reduce conflict for FLT in state 232 resolved as shift
WARNING: shift/reduce conflict for BLN in state 232 resolved as shift
WARNING: shift/reduce conflict for CHR in state 232 resolved as shift
WARNING: shift/reduce conflict for STR in state 232 resolved as shift
WARNING: shift/reduce conflict for INT in state 233 resolved as shift
WARNING: shift/reduce conflict for FLT in state 233 resolved as shift
WARNING: shift/reduce conflict for BLN in state 233 resolved as shift
WARNING: shift/reduce conflict for CHR in state 233 resolved as shift
WARNING: shift/reduce conflict for STR in state 233 resolved as shift
WARNING: shift/reduce conflict for INT in state 234 resolved as shift
WARNING: shift/reduce conflict for FLT in state 234 resolved as shift
WARNING: shift/reduce conflict for BLN in state 234 resolved as shift
WARNING: shift/reduce conflict for CHR in state 234 resolved as shift
WARNING: shift/reduce conflict for STR in state 234 resolved as shift
WARNING: shift/reduce conflict for INT in state 250 resolved as shift
WARNING: shift/reduce conflict for FLT in state 250 resolved as shift
WARNING: shift/reduce conflict for BLN in state 250 resolved as shift
WARNING: shift/reduce conflict for CHR in state 250 resolved as shift
WARNING: shift/reduce conflict for STR in state 250 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 314 resolved as shift
WARNING: shift/reduce conflict for INT in state 317 resolved as shift
WARNING: shift/reduce conflict for FLT in state 317 resolved as shift
WARNING: shift/reduce conflict for BLN in state 317 resolved as shift
WARNING: shift/reduce conflict for CHR in state 317 resolved as shift
WARNING: shift/reduce conflict for STR in state 317 resolved as shift
WARNING: shift/reduce conflict for INT in state 324 resolved as shift
WARNING: shift/reduce conflict for FLT in state 324 resolved as shift
WARNING: shift/reduce conflict for BLN in state 324 resolved as shift
WARNING: shift/reduce conflict for CHR in state 324 resolved as shift
WARNING: shift/reduce conflict for STR in state 324 resolved as shift
WARNING: shift/reduce conflict for INT in state 341 resolved as shift
WARNING: shift/reduce conflict for FLT in state 341 resolved as shift
WARNING: shift/reduce conflict for BLN in state 341 resolved as shift
WARNING: shift/reduce conflict for CHR in state 341 resolved as shift
WARNING: shift/reduce conflict for STR in state 341 resolved as shift
WARNING: shift/reduce conflict for INT in state 342 resolved as shift
WARNING: shift/reduce conflict for FLT in state 342 resolved as shift
WARNING: shift/reduce conflict for BLN in state 342 resolved as shift
WARNING: shift/reduce conflict for CHR in state 342 resolved as shift
WARNING: shift/reduce conflict for STR in state 342 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 355 resolved as shift
WARNING: shift/reduce conflict for INT in state 356 resolved as shift
WARNING: shift/reduce conflict for FLT in state 356 resolved as shift
WARNING: shift/reduce conflict for BLN in state 356 resolved as shift
WARNING: shift/reduce conflict for CHR in state 356 resolved as shift
WARNING: shift/reduce conflict for STR in state 356 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 376 resolved as shift
WARNING: shift/reduce conflict for INT in state 377 resolved as shift
WARNING: shift/reduce conflict for FLT in state 377 resolved as shift
WARNING: shift/reduce conflict for BLN in state 377 resolved as shift
WARNING: shift/reduce conflict for CHR in state 377 resolved as shift
WARNING: shift/reduce conflict for STR in state 377 resolved as shift
WARNING: shift/reduce conflict for INT in state 378 resolved as shift
WARNING: shift/reduce conflict for FLT in state 378 resolved as shift
WARNING: shift/reduce conflict for BLN in state 378 resolved as shift
WARNING: shift/reduce conflict for CHR in state 378 resolved as shift
WARNING: shift/reduce conflict for STR in state 378 resolved as shift
WARNING: reduce/reduce conflict in state 168 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 168
WARNING: reduce/reduce conflict in state 222 resolved using rule (function_statements -> empty)
WARNING: rejected rule (function_statements_tail -> empty) in state 222
WARNING: Rule (function_statements_tail -> empty) is never reduced
