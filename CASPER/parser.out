Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_statement -> data_type IDENT global_statement_tail
Rule 11    global_statement_tail -> empty
Rule 12    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 13    global_statement_tail -> EQ global_dec_value global_tail2
Rule 14    global_tail2 -> empty
Rule 15    global_tail2 -> COMMA IDENT global_statement_tail
Rule 16    global_dec_value -> global_value
Rule 17    global_dec_value -> LBRACKET list_element RBRACKET
Rule 18    global_value -> expression
Rule 19    var_statement -> data_type IDENT var_tail unli_newline
Rule 20    var_tail -> empty
Rule 21    var_tail -> EQ tail_value var_tail2
Rule 22    var_tail -> COMMA IDENT var_tail
Rule 23    var_tail2 -> empty
Rule 24    var_tail2 -> COMMA IDENT var_tail
Rule 25    tail_value -> value
Rule 26    tail_value -> LBRACKET list_element RBRACKET
Rule 27    list_element -> literal element_tail
Rule 28    element_tail -> empty
Rule 29    element_tail -> COMMA list_element
Rule 30    index -> INT_LIT
Rule 31    index -> IDENT
Rule 32    data_type -> INT
Rule 33    data_type -> FLT
Rule 34    data_type -> BLN
Rule 35    data_type -> CHR
Rule 36    data_type -> STR
Rule 37    value -> type_cast
Rule 38    value -> expression
Rule 39    value -> function_call
Rule 40    type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 41    type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 42    type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 43    type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 44    typecast_value -> expression
Rule 45    typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 46    typecast_value -> input_statement
Rule 47    literal -> INT_LIT
Rule 48    literal -> FLT_LIT
Rule 49    literal -> DAY
Rule 50    literal -> NIGHT
Rule 51    literal -> CHR_LIT
Rule 52    literal -> STR_LIT
Rule 53    expression -> expr_head expr_tail
Rule 54    expr_head -> term term_tail
Rule 55    term -> factor factor_tail
Rule 56    factor -> var_call
Rule 57    factor -> literal
Rule 58    factor -> TILDE literal
Rule 59    factor -> LPAREN expression RPAREN
Rule 60    factor_tail -> empty
Rule 61    factor_tail -> PLUS expression
Rule 62    factor_tail -> MINUS expression
Rule 63    factor_tail -> MULTIPLY expression
Rule 64    factor_tail -> DIVISION expression
Rule 65    factor_tail -> MODULO expression
Rule 66    factor_tail -> EXPONENT expression
Rule 67    term_tail -> empty
Rule 68    term_tail -> GT expression
Rule 69    term_tail -> LT expression
Rule 70    term_tail -> EQ_EQ expression
Rule 71    term_tail -> GT_EQ expression
Rule 72    term_tail -> LT_EQ expression
Rule 73    term_tail -> NOT_EQ expression
Rule 74    expr_tail -> empty
Rule 75    expr_tail -> AND expression
Rule 76    expr_tail -> OR expression
Rule 77    var_call -> IDENT var_call_tail
Rule 78    var_call_tail -> empty
Rule 79    var_call_tail -> LBRACKET index RBRACKET
Rule 80    function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
Rule 81    function_statements -> empty
Rule 82    ret_type -> FUNCTION
Rule 83    ret_type -> function_dtype
Rule 84    function_dtype -> FUNCTION_INT
Rule 85    function_dtype -> FUNCTION_FLT
Rule 86    function_dtype -> FUNCTION_CHR
Rule 87    function_dtype -> FUNCTION_BLN
Rule 88    function_dtype -> FUNCTION_STR
Rule 89    function_dtype -> FUNCTION_LIST_INT
Rule 90    function_dtype -> FUNCTION_LIST_FLT
Rule 91    function_dtype -> FUNCTION_LIST_CHR
Rule 92    function_dtype -> FUNCTION_LIST_STR
Rule 93    function_dtype -> FUNCTION_LIST_BLN
Rule 94    parameters -> data_type IDENT parameters_tail
Rule 95    parameters -> empty
Rule 96    parameters_tail -> empty
Rule 97    parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 98    revive -> REVIVE value
Rule 99    revive -> empty
Rule 100   statements -> empty
Rule 101   statements -> local_dec maybe_newline statements_tail
Rule 102   statements_tail -> string_operation_statement unli_newline statements_tail2
Rule 103   statements_tail -> conditional_statement unli_newline statements_tail2
Rule 104   statements_tail -> switch_statement unli_newline statements_tail2
Rule 105   statements_tail -> loop_statement unli_newline statements_tail2
Rule 106   statements_tail -> function_call unli_newline statements_tail2
Rule 107   statements_tail -> output_statement unli_newline statements_tail2
Rule 108   statements_tail2 -> statements
Rule 109   local_dec -> empty
Rule 110   local_dec -> var_statement
Rule 111   conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
Rule 112   conditional_tail -> empty
Rule 113   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
Rule 114   conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
Rule 115   conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
Rule 116   conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
Rule 117   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
Rule 118   switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail
Rule 119   switchcond_tail -> empty
Rule 120   switchcond_tail -> switch_condition
Rule 121   loop_statement -> for_loop
Rule 122   loop_statement -> until_loop
Rule 123   loop_statement -> repeat_until
Rule 124   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
Rule 125   until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
Rule 126   repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
Rule 127   control_variable -> INT IDENT EQ INT_LIT
Rule 128   update -> var_call update_tail
Rule 129   update_tail -> postfix
Rule 130   update_tail -> assign_op value
Rule 131   postfix -> PLUS_PLUS
Rule 132   postfix -> MINUS_MINUS
Rule 133   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 134   function_call -> output_statement
Rule 135   arguments -> empty
Rule 136   arguments -> arg_value arg_tail
Rule 137   arg_tail -> empty
Rule 138   arg_tail -> COMMA arg_value arg_tail
Rule 139   arg_value -> literal
Rule 140   arg_value -> var_call
Rule 141   output_statement -> DISPLAY value next_val
Rule 142   output_statement -> DISPLAY LPAREN value next_val RPAREN
Rule 143   next_val -> empty
Rule 144   next_val -> COMMA value next_val
Rule 145   input_statement -> INPUT LPAREN RPAREN
Rule 146   string_operation_statement -> var_call string_operation_tail
Rule 147   string_operation_tail -> PLUS string_val stringcon_tail
Rule 148   string_operation_tail -> update_tail
Rule 149   assign_op -> PLUS_EQ
Rule 150   assign_op -> MINUS_EQ
Rule 151   assign_op -> MUL_EQ
Rule 152   assign_op -> DIV_EQ
Rule 153   assign_op -> MOD_EQ
Rule 154   assign_op -> EQ
Rule 155   stringcon_tail -> empty
Rule 156   stringcon_tail -> PLUS string_val stringcon_tail
Rule 157   string_val -> var_call
Rule 158   string_val -> STR_LIT
Rule 159   empty -> <empty>

Terminals, with rules where they appear

AND                  : 75
BIRTH                : 1
BLN                  : 34
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 111
CHR                  : 35
CHR_LIT              : 51
COLON                : 118
COMMA                : 12 15 22 24 29 97 138 144
COMMENT              : 
CONVERT_TO_BLN       : 42
CONVERT_TO_FLT       : 41
CONVERT_TO_INT       : 40
CONVERT_TO_STR       : 43
DAY                  : 49
DISPLAY              : 141 142
DIVISION             : 64
DIV_EQ               : 152
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 13 21 127 154
EQ_EQ                : 70
EXPONENT             : 66
FLT                  : 33
FLT_LIT              : 48
FOR                  : 124
FUNCTION             : 82
FUNCTION_BLN         : 87
FUNCTION_CHR         : 86
FUNCTION_FLT         : 85
FUNCTION_INT         : 84
FUNCTION_LIST_BLN    : 93
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 91
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 90
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 89
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 92
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 45 80 133
FUNCTION_STR         : 88
GHOST                : 1
GT                   : 68
GT_EQ                : 71
IDENT                : 10 12 15 19 22 24 31 77 94 97 117 127
ILLEGAL              : 
IN                   : 
INPUT                : 145
INT                  : 32 127
INT_LIT              : 30 47 127
LBRACE               : 6 80 111 113 114 115 116 117 117 124 125 126
LBRACKET             : 17 26 79
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 40 41 42 43 45 59 80 111 113 115 117 124 125 126 133 142 145
LT                   : 69
LT_EQ                : 72
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 62
MINUS_EQ             : 150
MINUS_MINUS          : 132
MODULO               : 65
MOD_EQ               : 153
MULTIPLY             : 63
MUL_EQ               : 151
NEWLINE              : 3 4 5
NIGHT                : 50
NOT                  : 
NOT_EQ               : 73
OR                   : 76
OTHERWISE            : 114 116 117
OTHERWISE_CHECK      : 113 115
PLUS                 : 61 147 156
PLUS_EQ              : 149
PLUS_PLUS            : 131
POW                  : 
RBRACE               : 6 80 111 113 114 115 116 117 117 124 125 126
RBRACKET             : 17 26 79
REPEAT               : 126
REVIVE               : 98
RPAREN               : 6 40 41 42 43 45 59 80 111 113 115 117 124 125 126 133 142 145
SEMICOLON            : 124 124
SHIFT                : 118
SKIP                 : 
STOP                 : 
STR                  : 36
STR_LIT              : 52 158
SWAP                 : 117
TILDE                : 58
TYPE                 : 
UNTIL                : 125 126
error                : 

Nonterminals, with rules where they appear

arg_tail             : 136 138
arg_value            : 136 138
arguments            : 133
assign_op            : 130
conditional_statement : 103
conditional_tail     : 111
conditional_tail2    : 113 115
control_variable     : 124
data_type            : 10 19 94 97
element_tail         : 27
empty                : 2 8 11 14 20 23 28 60 67 74 78 81 95 96 99 100 109 112 119 135 137 143 155
expr_head            : 53
expr_tail            : 53
expression           : 18 38 44 59 61 62 63 64 65 66 68 69 70 71 72 73 75 76 111 113 115 124 125 126
factor               : 55
factor_tail          : 55
for_loop             : 121
function_call        : 39 106
function_dtype       : 83
function_statements  : 1
global_dec           : 1 9
global_dec_value     : 13
global_statement     : 7
global_statement_tail : 10 12 15
global_tail          : 7
global_tail2         : 13
global_value         : 16
index                : 79
input_statement      : 46
list_element         : 17 26 29
literal              : 27 57 58 139
local_dec            : 101
loop_statement       : 105
main_function        : 1
maybe_newline        : 1 1 3 6 6 6 80 80 80 101 111 111 111 113 113 113 114 114 115 115 115 116 116 117 117 117 117 117 117 118 124 124 125 126
next_val             : 141 142 144
output_statement     : 107 134
parameters           : 80
parameters_tail      : 94 97
postfix              : 129
program              : 0
repeat_until         : 123
ret_type             : 80
revive               : 80
statements           : 6 80 108 111 113 114 115 116 117 118 124 125 126
statements_tail      : 101
statements_tail2     : 102 103 104 105 106 107
string_operation_statement : 102
string_operation_tail : 146
string_val           : 147 156
stringcon_tail       : 147 156
switch_condition     : 117 120
switch_statement     : 104
switchcond_tail      : 118
tail_value           : 21
term                 : 54
term_tail            : 54
type_cast            : 37
typecast_value       : 40 41 42 43
unli_newline         : 1 1 5 7 19 80 102 103 104 105 106 107
until_loop           : 122
update               : 124
update_tail          : 128 148
value                : 25 98 118 130 141 142 144
var_call             : 56 128 140 146 157
var_call_tail        : 77
var_statement        : 110
var_tail             : 19 22 24
var_tail2            : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . data_type IDENT global_statement_tail
    (159) empty -> .
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    MAIN_CASPER     reduce using rule 159 (empty -> .)
    FUNCTION        reduce using rule 159 (empty -> .)
    FUNCTION_INT    reduce using rule 159 (empty -> .)
    FUNCTION_FLT    reduce using rule 159 (empty -> .)
    FUNCTION_CHR    reduce using rule 159 (empty -> .)
    FUNCTION_BLN    reduce using rule 159 (empty -> .)
    FUNCTION_STR    reduce using rule 159 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 14

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 159 (empty -> .)
    FUNCTION        reduce using rule 159 (empty -> .)
    FUNCTION_INT    reduce using rule 159 (empty -> .)
    FUNCTION_FLT    reduce using rule 159 (empty -> .)
    FUNCTION_CHR    reduce using rule 159 (empty -> .)
    FUNCTION_BLN    reduce using rule 159 (empty -> .)
    FUNCTION_STR    reduce using rule 159 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 15
    empty                          shift and go to state 16

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 18

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)


state 8

    (10) global_statement -> data_type . IDENT global_statement_tail

    IDENT           shift and go to state 19


state 9

    (32) data_type -> INT .

    IDENT           reduce using rule 32 (data_type -> INT .)


state 10

    (33) data_type -> FLT .

    IDENT           reduce using rule 33 (data_type -> FLT .)


state 11

    (34) data_type -> BLN .

    IDENT           reduce using rule 34 (data_type -> BLN .)


state 12

    (35) data_type -> CHR .

    IDENT           reduce using rule 35 (data_type -> CHR .)


state 13

    (36) data_type -> STR .

    IDENT           reduce using rule 36 (data_type -> STR .)


state 14

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 15

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (80) function_statements -> . maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (81) function_statements -> . empty
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 159 (empty -> .)
    FUNCTION        reduce using rule 159 (empty -> .)
    FUNCTION_INT    reduce using rule 159 (empty -> .)
    FUNCTION_FLT    reduce using rule 159 (empty -> .)
    FUNCTION_CHR    reduce using rule 159 (empty -> .)
    FUNCTION_BLN    reduce using rule 159 (empty -> .)
    FUNCTION_STR    reduce using rule 159 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 20
    function_statements            shift and go to state 21
    empty                          shift and go to state 22

state 16

    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE_CHECK reduce using rule 2 (maybe_newline -> empty .)


state 17

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 159 (empty -> .)
    FUNCTION        reduce using rule 159 (empty -> .)
    FUNCTION_INT    reduce using rule 159 (empty -> .)
    FUNCTION_FLT    reduce using rule 159 (empty -> .)
    FUNCTION_CHR    reduce using rule 159 (empty -> .)
    FUNCTION_BLN    reduce using rule 159 (empty -> .)
    FUNCTION_STR    reduce using rule 159 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 159 (empty -> .)
    LBRACE          reduce using rule 159 (empty -> .)
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    SHIFT           reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    OTHERWISE_CHECK reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 23
    empty                          shift and go to state 16

state 18

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . data_type IDENT global_statement_tail
    (159) empty -> .
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    MAIN_CASPER     reduce using rule 159 (empty -> .)
    FUNCTION        reduce using rule 159 (empty -> .)
    FUNCTION_INT    reduce using rule 159 (empty -> .)
    FUNCTION_FLT    reduce using rule 159 (empty -> .)
    FUNCTION_CHR    reduce using rule 159 (empty -> .)
    FUNCTION_BLN    reduce using rule 159 (empty -> .)
    FUNCTION_STR    reduce using rule 159 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 159 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 159 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 24
    global_dec                     shift and go to state 25
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 19

    (10) global_statement -> data_type IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (159) empty -> .

    COMMA           shift and go to state 28
    EQ              shift and go to state 29
    NEWLINE         reduce using rule 159 (empty -> .)

    global_statement_tail          shift and go to state 26
    empty                          shift and go to state 27

state 20

    (80) function_statements -> maybe_newline . ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (82) ret_type -> . FUNCTION
    (83) ret_type -> . function_dtype
    (84) function_dtype -> . FUNCTION_INT
    (85) function_dtype -> . FUNCTION_FLT
    (86) function_dtype -> . FUNCTION_CHR
    (87) function_dtype -> . FUNCTION_BLN
    (88) function_dtype -> . FUNCTION_STR
    (89) function_dtype -> . FUNCTION_LIST_INT
    (90) function_dtype -> . FUNCTION_LIST_FLT
    (91) function_dtype -> . FUNCTION_LIST_CHR
    (92) function_dtype -> . FUNCTION_LIST_STR
    (93) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 31
    FUNCTION_INT    shift and go to state 33
    FUNCTION_FLT    shift and go to state 34
    FUNCTION_CHR    shift and go to state 35
    FUNCTION_BLN    shift and go to state 36
    FUNCTION_STR    shift and go to state 37
    FUNCTION_LIST_INT shift and go to state 38
    FUNCTION_LIST_FLT shift and go to state 39
    FUNCTION_LIST_CHR shift and go to state 40
    FUNCTION_LIST_STR shift and go to state 41
    FUNCTION_LIST_BLN shift and go to state 42

    ret_type                       shift and go to state 30
    function_dtype                 shift and go to state 32

state 21

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 43
    empty                          shift and go to state 16

state 22

    (81) function_statements -> empty .
    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 81 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 81 (function_statements -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)


state 23

    (3) maybe_newline -> NEWLINE maybe_newline .

    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE_CHECK reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 24

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 25

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)


state 26

    (10) global_statement -> data_type IDENT global_statement_tail .

    NEWLINE         reduce using rule 10 (global_statement -> data_type IDENT global_statement_tail .)


state 27

    (11) global_statement_tail -> empty .

    NEWLINE         reduce using rule 11 (global_statement_tail -> empty .)


state 28

    (12) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 44


state 29

    (13) global_statement_tail -> EQ . global_dec_value global_tail2
    (16) global_dec_value -> . global_value
    (17) global_dec_value -> . LBRACKET list_element RBRACKET
    (18) global_value -> . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LBRACKET        shift and go to state 47
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    global_dec_value               shift and go to state 45
    global_value                   shift and go to state 46
    expression                     shift and go to state 48
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 30

    (80) function_statements -> maybe_newline ret_type . FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    FUNCTION_NAME   shift and go to state 63


state 31

    (82) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 82 (ret_type -> FUNCTION .)


state 32

    (83) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 83 (ret_type -> function_dtype .)


state 33

    (84) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 84 (function_dtype -> FUNCTION_INT .)


state 34

    (85) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 85 (function_dtype -> FUNCTION_FLT .)


state 35

    (86) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 86 (function_dtype -> FUNCTION_CHR .)


state 36

    (87) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 87 (function_dtype -> FUNCTION_BLN .)


state 37

    (88) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 88 (function_dtype -> FUNCTION_STR .)


state 38

    (89) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 89 (function_dtype -> FUNCTION_LIST_INT .)


state 39

    (90) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 90 (function_dtype -> FUNCTION_LIST_FLT .)


state 40

    (91) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 91 (function_dtype -> FUNCTION_LIST_CHR .)


state 41

    (92) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 92 (function_dtype -> FUNCTION_LIST_STR .)


state 42

    (93) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 93 (function_dtype -> FUNCTION_LIST_BLN .)


state 43

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 65

    main_function                  shift and go to state 64

state 44

    (12) global_statement_tail -> COMMA IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (159) empty -> .

    COMMA           shift and go to state 28
    EQ              shift and go to state 29
    NEWLINE         reduce using rule 159 (empty -> .)

    global_statement_tail          shift and go to state 66
    empty                          shift and go to state 27

state 45

    (13) global_statement_tail -> EQ global_dec_value . global_tail2
    (14) global_tail2 -> . empty
    (15) global_tail2 -> . COMMA IDENT global_statement_tail
    (159) empty -> .

    COMMA           shift and go to state 69
    NEWLINE         reduce using rule 159 (empty -> .)

    global_tail2                   shift and go to state 67
    empty                          shift and go to state 68

state 46

    (16) global_dec_value -> global_value .

    COMMA           reduce using rule 16 (global_dec_value -> global_value .)
    NEWLINE         reduce using rule 16 (global_dec_value -> global_value .)


state 47

    (17) global_dec_value -> LBRACKET . list_element RBRACKET
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 70
    literal                        shift and go to state 71

state 48

    (18) global_value -> expression .

    COMMA           reduce using rule 18 (global_value -> expression .)
    NEWLINE         reduce using rule 18 (global_value -> expression .)


state 49

    (53) expression -> expr_head . expr_tail
    (74) expr_tail -> . empty
    (75) expr_tail -> . AND expression
    (76) expr_tail -> . OR expression
    (159) empty -> .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    AND             shift and go to state 74
    OR              shift and go to state 75
    COMMA           reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    RPAREN          reduce using rule 159 (empty -> .)
    GT              reduce using rule 159 (empty -> .)
    LT              reduce using rule 159 (empty -> .)
    EQ_EQ           reduce using rule 159 (empty -> .)
    GT_EQ           reduce using rule 159 (empty -> .)
    LT_EQ           reduce using rule 159 (empty -> .)
    NOT_EQ          reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    COLON           reduce using rule 159 (empty -> .)
    SEMICOLON       reduce using rule 159 (empty -> .)

  ! AND             [ reduce using rule 159 (empty -> .) ]
  ! OR              [ reduce using rule 159 (empty -> .) ]

    expr_tail                      shift and go to state 72
    empty                          shift and go to state 73

state 50

    (54) expr_head -> term . term_tail
    (67) term_tail -> . empty
    (68) term_tail -> . GT expression
    (69) term_tail -> . LT expression
    (70) term_tail -> . EQ_EQ expression
    (71) term_tail -> . GT_EQ expression
    (72) term_tail -> . LT_EQ expression
    (73) term_tail -> . NOT_EQ expression
    (159) empty -> .

  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ_EQ resolved as shift
  ! shift/reduce conflict for GT_EQ resolved as shift
  ! shift/reduce conflict for LT_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
    GT              shift and go to state 78
    LT              shift and go to state 79
    EQ_EQ           shift and go to state 80
    GT_EQ           shift and go to state 81
    LT_EQ           shift and go to state 82
    NOT_EQ          shift and go to state 83
    COMMA           reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    RPAREN          reduce using rule 159 (empty -> .)
    AND             reduce using rule 159 (empty -> .)
    OR              reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    COLON           reduce using rule 159 (empty -> .)
    SEMICOLON       reduce using rule 159 (empty -> .)

  ! GT              [ reduce using rule 159 (empty -> .) ]
  ! LT              [ reduce using rule 159 (empty -> .) ]
  ! EQ_EQ           [ reduce using rule 159 (empty -> .) ]
  ! GT_EQ           [ reduce using rule 159 (empty -> .) ]
  ! LT_EQ           [ reduce using rule 159 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 159 (empty -> .) ]

    term_tail                      shift and go to state 76
    empty                          shift and go to state 77

state 51

    (55) term -> factor . factor_tail
    (60) factor_tail -> . empty
    (61) factor_tail -> . PLUS expression
    (62) factor_tail -> . MINUS expression
    (63) factor_tail -> . MULTIPLY expression
    (64) factor_tail -> . DIVISION expression
    (65) factor_tail -> . MODULO expression
    (66) factor_tail -> . EXPONENT expression
    (159) empty -> .

    PLUS            shift and go to state 86
    MINUS           shift and go to state 87
    MULTIPLY        shift and go to state 88
    DIVISION        shift and go to state 89
    MODULO          shift and go to state 90
    EXPONENT        shift and go to state 91
    COMMA           reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    RPAREN          reduce using rule 159 (empty -> .)
    AND             reduce using rule 159 (empty -> .)
    OR              reduce using rule 159 (empty -> .)
    GT              reduce using rule 159 (empty -> .)
    LT              reduce using rule 159 (empty -> .)
    EQ_EQ           reduce using rule 159 (empty -> .)
    GT_EQ           reduce using rule 159 (empty -> .)
    LT_EQ           reduce using rule 159 (empty -> .)
    NOT_EQ          reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    COLON           reduce using rule 159 (empty -> .)
    SEMICOLON       reduce using rule 159 (empty -> .)

    factor_tail                    shift and go to state 84
    empty                          shift and go to state 85

state 52

    (56) factor -> var_call .

    PLUS            reduce using rule 56 (factor -> var_call .)
    MINUS           reduce using rule 56 (factor -> var_call .)
    MULTIPLY        reduce using rule 56 (factor -> var_call .)
    DIVISION        reduce using rule 56 (factor -> var_call .)
    MODULO          reduce using rule 56 (factor -> var_call .)
    EXPONENT        reduce using rule 56 (factor -> var_call .)
    GT              reduce using rule 56 (factor -> var_call .)
    LT              reduce using rule 56 (factor -> var_call .)
    EQ_EQ           reduce using rule 56 (factor -> var_call .)
    GT_EQ           reduce using rule 56 (factor -> var_call .)
    LT_EQ           reduce using rule 56 (factor -> var_call .)
    NOT_EQ          reduce using rule 56 (factor -> var_call .)
    AND             reduce using rule 56 (factor -> var_call .)
    OR              reduce using rule 56 (factor -> var_call .)
    COMMA           reduce using rule 56 (factor -> var_call .)
    NEWLINE         reduce using rule 56 (factor -> var_call .)
    RPAREN          reduce using rule 56 (factor -> var_call .)
    RBRACE          reduce using rule 56 (factor -> var_call .)
    COLON           reduce using rule 56 (factor -> var_call .)
    SEMICOLON       reduce using rule 56 (factor -> var_call .)


state 53

    (57) factor -> literal .

    PLUS            reduce using rule 57 (factor -> literal .)
    MINUS           reduce using rule 57 (factor -> literal .)
    MULTIPLY        reduce using rule 57 (factor -> literal .)
    DIVISION        reduce using rule 57 (factor -> literal .)
    MODULO          reduce using rule 57 (factor -> literal .)
    EXPONENT        reduce using rule 57 (factor -> literal .)
    GT              reduce using rule 57 (factor -> literal .)
    LT              reduce using rule 57 (factor -> literal .)
    EQ_EQ           reduce using rule 57 (factor -> literal .)
    GT_EQ           reduce using rule 57 (factor -> literal .)
    LT_EQ           reduce using rule 57 (factor -> literal .)
    NOT_EQ          reduce using rule 57 (factor -> literal .)
    AND             reduce using rule 57 (factor -> literal .)
    OR              reduce using rule 57 (factor -> literal .)
    COMMA           reduce using rule 57 (factor -> literal .)
    NEWLINE         reduce using rule 57 (factor -> literal .)
    RPAREN          reduce using rule 57 (factor -> literal .)
    RBRACE          reduce using rule 57 (factor -> literal .)
    COLON           reduce using rule 57 (factor -> literal .)
    SEMICOLON       reduce using rule 57 (factor -> literal .)


state 54

    (58) factor -> TILDE . literal
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    literal                        shift and go to state 92

state 55

    (59) factor -> LPAREN . expression RPAREN
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 93
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 56

    (77) var_call -> IDENT . var_call_tail
    (78) var_call_tail -> . empty
    (79) var_call_tail -> . LBRACKET index RBRACKET
    (159) empty -> .

    LBRACKET        shift and go to state 96
    PLUS            reduce using rule 159 (empty -> .)
    MINUS           reduce using rule 159 (empty -> .)
    MULTIPLY        reduce using rule 159 (empty -> .)
    DIVISION        reduce using rule 159 (empty -> .)
    MODULO          reduce using rule 159 (empty -> .)
    EXPONENT        reduce using rule 159 (empty -> .)
    GT              reduce using rule 159 (empty -> .)
    LT              reduce using rule 159 (empty -> .)
    EQ_EQ           reduce using rule 159 (empty -> .)
    GT_EQ           reduce using rule 159 (empty -> .)
    LT_EQ           reduce using rule 159 (empty -> .)
    NOT_EQ          reduce using rule 159 (empty -> .)
    AND             reduce using rule 159 (empty -> .)
    OR              reduce using rule 159 (empty -> .)
    COMMA           reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    RPAREN          reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    COLON           reduce using rule 159 (empty -> .)
    SEMICOLON       reduce using rule 159 (empty -> .)
    PLUS_PLUS       reduce using rule 159 (empty -> .)
    MINUS_MINUS     reduce using rule 159 (empty -> .)
    PLUS_EQ         reduce using rule 159 (empty -> .)
    MINUS_EQ        reduce using rule 159 (empty -> .)
    MUL_EQ          reduce using rule 159 (empty -> .)
    DIV_EQ          reduce using rule 159 (empty -> .)
    MOD_EQ          reduce using rule 159 (empty -> .)
    EQ              reduce using rule 159 (empty -> .)

    var_call_tail                  shift and go to state 94
    empty                          shift and go to state 95

state 57

    (47) literal -> INT_LIT .

    PLUS            reduce using rule 47 (literal -> INT_LIT .)
    MINUS           reduce using rule 47 (literal -> INT_LIT .)
    MULTIPLY        reduce using rule 47 (literal -> INT_LIT .)
    DIVISION        reduce using rule 47 (literal -> INT_LIT .)
    MODULO          reduce using rule 47 (literal -> INT_LIT .)
    EXPONENT        reduce using rule 47 (literal -> INT_LIT .)
    GT              reduce using rule 47 (literal -> INT_LIT .)
    LT              reduce using rule 47 (literal -> INT_LIT .)
    EQ_EQ           reduce using rule 47 (literal -> INT_LIT .)
    GT_EQ           reduce using rule 47 (literal -> INT_LIT .)
    LT_EQ           reduce using rule 47 (literal -> INT_LIT .)
    NOT_EQ          reduce using rule 47 (literal -> INT_LIT .)
    AND             reduce using rule 47 (literal -> INT_LIT .)
    OR              reduce using rule 47 (literal -> INT_LIT .)
    COMMA           reduce using rule 47 (literal -> INT_LIT .)
    NEWLINE         reduce using rule 47 (literal -> INT_LIT .)
    RBRACKET        reduce using rule 47 (literal -> INT_LIT .)
    RPAREN          reduce using rule 47 (literal -> INT_LIT .)
    RBRACE          reduce using rule 47 (literal -> INT_LIT .)
    COLON           reduce using rule 47 (literal -> INT_LIT .)
    SEMICOLON       reduce using rule 47 (literal -> INT_LIT .)


state 58

    (48) literal -> FLT_LIT .

    PLUS            reduce using rule 48 (literal -> FLT_LIT .)
    MINUS           reduce using rule 48 (literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 48 (literal -> FLT_LIT .)
    DIVISION        reduce using rule 48 (literal -> FLT_LIT .)
    MODULO          reduce using rule 48 (literal -> FLT_LIT .)
    EXPONENT        reduce using rule 48 (literal -> FLT_LIT .)
    GT              reduce using rule 48 (literal -> FLT_LIT .)
    LT              reduce using rule 48 (literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    GT_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    LT_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 48 (literal -> FLT_LIT .)
    AND             reduce using rule 48 (literal -> FLT_LIT .)
    OR              reduce using rule 48 (literal -> FLT_LIT .)
    COMMA           reduce using rule 48 (literal -> FLT_LIT .)
    NEWLINE         reduce using rule 48 (literal -> FLT_LIT .)
    RBRACKET        reduce using rule 48 (literal -> FLT_LIT .)
    RPAREN          reduce using rule 48 (literal -> FLT_LIT .)
    RBRACE          reduce using rule 48 (literal -> FLT_LIT .)
    COLON           reduce using rule 48 (literal -> FLT_LIT .)
    SEMICOLON       reduce using rule 48 (literal -> FLT_LIT .)


state 59

    (49) literal -> DAY .

    PLUS            reduce using rule 49 (literal -> DAY .)
    MINUS           reduce using rule 49 (literal -> DAY .)
    MULTIPLY        reduce using rule 49 (literal -> DAY .)
    DIVISION        reduce using rule 49 (literal -> DAY .)
    MODULO          reduce using rule 49 (literal -> DAY .)
    EXPONENT        reduce using rule 49 (literal -> DAY .)
    GT              reduce using rule 49 (literal -> DAY .)
    LT              reduce using rule 49 (literal -> DAY .)
    EQ_EQ           reduce using rule 49 (literal -> DAY .)
    GT_EQ           reduce using rule 49 (literal -> DAY .)
    LT_EQ           reduce using rule 49 (literal -> DAY .)
    NOT_EQ          reduce using rule 49 (literal -> DAY .)
    AND             reduce using rule 49 (literal -> DAY .)
    OR              reduce using rule 49 (literal -> DAY .)
    COMMA           reduce using rule 49 (literal -> DAY .)
    NEWLINE         reduce using rule 49 (literal -> DAY .)
    RBRACKET        reduce using rule 49 (literal -> DAY .)
    RPAREN          reduce using rule 49 (literal -> DAY .)
    RBRACE          reduce using rule 49 (literal -> DAY .)
    COLON           reduce using rule 49 (literal -> DAY .)
    SEMICOLON       reduce using rule 49 (literal -> DAY .)


state 60

    (50) literal -> NIGHT .

    PLUS            reduce using rule 50 (literal -> NIGHT .)
    MINUS           reduce using rule 50 (literal -> NIGHT .)
    MULTIPLY        reduce using rule 50 (literal -> NIGHT .)
    DIVISION        reduce using rule 50 (literal -> NIGHT .)
    MODULO          reduce using rule 50 (literal -> NIGHT .)
    EXPONENT        reduce using rule 50 (literal -> NIGHT .)
    GT              reduce using rule 50 (literal -> NIGHT .)
    LT              reduce using rule 50 (literal -> NIGHT .)
    EQ_EQ           reduce using rule 50 (literal -> NIGHT .)
    GT_EQ           reduce using rule 50 (literal -> NIGHT .)
    LT_EQ           reduce using rule 50 (literal -> NIGHT .)
    NOT_EQ          reduce using rule 50 (literal -> NIGHT .)
    AND             reduce using rule 50 (literal -> NIGHT .)
    OR              reduce using rule 50 (literal -> NIGHT .)
    COMMA           reduce using rule 50 (literal -> NIGHT .)
    NEWLINE         reduce using rule 50 (literal -> NIGHT .)
    RBRACKET        reduce using rule 50 (literal -> NIGHT .)
    RPAREN          reduce using rule 50 (literal -> NIGHT .)
    RBRACE          reduce using rule 50 (literal -> NIGHT .)
    COLON           reduce using rule 50 (literal -> NIGHT .)
    SEMICOLON       reduce using rule 50 (literal -> NIGHT .)


state 61

    (51) literal -> CHR_LIT .

    PLUS            reduce using rule 51 (literal -> CHR_LIT .)
    MINUS           reduce using rule 51 (literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 51 (literal -> CHR_LIT .)
    DIVISION        reduce using rule 51 (literal -> CHR_LIT .)
    MODULO          reduce using rule 51 (literal -> CHR_LIT .)
    EXPONENT        reduce using rule 51 (literal -> CHR_LIT .)
    GT              reduce using rule 51 (literal -> CHR_LIT .)
    LT              reduce using rule 51 (literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    GT_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    LT_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 51 (literal -> CHR_LIT .)
    AND             reduce using rule 51 (literal -> CHR_LIT .)
    OR              reduce using rule 51 (literal -> CHR_LIT .)
    COMMA           reduce using rule 51 (literal -> CHR_LIT .)
    NEWLINE         reduce using rule 51 (literal -> CHR_LIT .)
    RBRACKET        reduce using rule 51 (literal -> CHR_LIT .)
    RPAREN          reduce using rule 51 (literal -> CHR_LIT .)
    RBRACE          reduce using rule 51 (literal -> CHR_LIT .)
    COLON           reduce using rule 51 (literal -> CHR_LIT .)
    SEMICOLON       reduce using rule 51 (literal -> CHR_LIT .)


state 62

    (52) literal -> STR_LIT .

    PLUS            reduce using rule 52 (literal -> STR_LIT .)
    MINUS           reduce using rule 52 (literal -> STR_LIT .)
    MULTIPLY        reduce using rule 52 (literal -> STR_LIT .)
    DIVISION        reduce using rule 52 (literal -> STR_LIT .)
    MODULO          reduce using rule 52 (literal -> STR_LIT .)
    EXPONENT        reduce using rule 52 (literal -> STR_LIT .)
    GT              reduce using rule 52 (literal -> STR_LIT .)
    LT              reduce using rule 52 (literal -> STR_LIT .)
    EQ_EQ           reduce using rule 52 (literal -> STR_LIT .)
    GT_EQ           reduce using rule 52 (literal -> STR_LIT .)
    LT_EQ           reduce using rule 52 (literal -> STR_LIT .)
    NOT_EQ          reduce using rule 52 (literal -> STR_LIT .)
    AND             reduce using rule 52 (literal -> STR_LIT .)
    OR              reduce using rule 52 (literal -> STR_LIT .)
    COMMA           reduce using rule 52 (literal -> STR_LIT .)
    NEWLINE         reduce using rule 52 (literal -> STR_LIT .)
    RBRACKET        reduce using rule 52 (literal -> STR_LIT .)
    RPAREN          reduce using rule 52 (literal -> STR_LIT .)
    RBRACE          reduce using rule 52 (literal -> STR_LIT .)
    COLON           reduce using rule 52 (literal -> STR_LIT .)
    SEMICOLON       reduce using rule 52 (literal -> STR_LIT .)


state 63

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME . LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    LPAREN          shift and go to state 97


state 64

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 98

state 65

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 99


state 66

    (12) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 12 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 67

    (13) global_statement_tail -> EQ global_dec_value global_tail2 .

    NEWLINE         reduce using rule 13 (global_statement_tail -> EQ global_dec_value global_tail2 .)


state 68

    (14) global_tail2 -> empty .

    NEWLINE         reduce using rule 14 (global_tail2 -> empty .)


state 69

    (15) global_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 100


state 70

    (17) global_dec_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 101


state 71

    (27) list_element -> literal . element_tail
    (28) element_tail -> . empty
    (29) element_tail -> . COMMA list_element
    (159) empty -> .

    COMMA           shift and go to state 104
    RBRACKET        reduce using rule 159 (empty -> .)

    element_tail                   shift and go to state 102
    empty                          shift and go to state 103

state 72

    (53) expression -> expr_head expr_tail .

    COMMA           reduce using rule 53 (expression -> expr_head expr_tail .)
    NEWLINE         reduce using rule 53 (expression -> expr_head expr_tail .)
    RPAREN          reduce using rule 53 (expression -> expr_head expr_tail .)
    AND             reduce using rule 53 (expression -> expr_head expr_tail .)
    OR              reduce using rule 53 (expression -> expr_head expr_tail .)
    GT              reduce using rule 53 (expression -> expr_head expr_tail .)
    LT              reduce using rule 53 (expression -> expr_head expr_tail .)
    EQ_EQ           reduce using rule 53 (expression -> expr_head expr_tail .)
    GT_EQ           reduce using rule 53 (expression -> expr_head expr_tail .)
    LT_EQ           reduce using rule 53 (expression -> expr_head expr_tail .)
    NOT_EQ          reduce using rule 53 (expression -> expr_head expr_tail .)
    RBRACE          reduce using rule 53 (expression -> expr_head expr_tail .)
    COLON           reduce using rule 53 (expression -> expr_head expr_tail .)
    SEMICOLON       reduce using rule 53 (expression -> expr_head expr_tail .)


state 73

    (74) expr_tail -> empty .

    COMMA           reduce using rule 74 (expr_tail -> empty .)
    NEWLINE         reduce using rule 74 (expr_tail -> empty .)
    RPAREN          reduce using rule 74 (expr_tail -> empty .)
    AND             reduce using rule 74 (expr_tail -> empty .)
    OR              reduce using rule 74 (expr_tail -> empty .)
    GT              reduce using rule 74 (expr_tail -> empty .)
    LT              reduce using rule 74 (expr_tail -> empty .)
    EQ_EQ           reduce using rule 74 (expr_tail -> empty .)
    GT_EQ           reduce using rule 74 (expr_tail -> empty .)
    LT_EQ           reduce using rule 74 (expr_tail -> empty .)
    NOT_EQ          reduce using rule 74 (expr_tail -> empty .)
    RBRACE          reduce using rule 74 (expr_tail -> empty .)
    COLON           reduce using rule 74 (expr_tail -> empty .)
    SEMICOLON       reduce using rule 74 (expr_tail -> empty .)


state 74

    (75) expr_tail -> AND . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 105
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 75

    (76) expr_tail -> OR . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 106
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 76

    (54) expr_head -> term term_tail .

    AND             reduce using rule 54 (expr_head -> term term_tail .)
    OR              reduce using rule 54 (expr_head -> term term_tail .)
    COMMA           reduce using rule 54 (expr_head -> term term_tail .)
    NEWLINE         reduce using rule 54 (expr_head -> term term_tail .)
    RPAREN          reduce using rule 54 (expr_head -> term term_tail .)
    GT              reduce using rule 54 (expr_head -> term term_tail .)
    LT              reduce using rule 54 (expr_head -> term term_tail .)
    EQ_EQ           reduce using rule 54 (expr_head -> term term_tail .)
    GT_EQ           reduce using rule 54 (expr_head -> term term_tail .)
    LT_EQ           reduce using rule 54 (expr_head -> term term_tail .)
    NOT_EQ          reduce using rule 54 (expr_head -> term term_tail .)
    RBRACE          reduce using rule 54 (expr_head -> term term_tail .)
    COLON           reduce using rule 54 (expr_head -> term term_tail .)
    SEMICOLON       reduce using rule 54 (expr_head -> term term_tail .)


state 77

    (67) term_tail -> empty .

    COMMA           reduce using rule 67 (term_tail -> empty .)
    NEWLINE         reduce using rule 67 (term_tail -> empty .)
    RPAREN          reduce using rule 67 (term_tail -> empty .)
    AND             reduce using rule 67 (term_tail -> empty .)
    OR              reduce using rule 67 (term_tail -> empty .)
    GT              reduce using rule 67 (term_tail -> empty .)
    LT              reduce using rule 67 (term_tail -> empty .)
    EQ_EQ           reduce using rule 67 (term_tail -> empty .)
    GT_EQ           reduce using rule 67 (term_tail -> empty .)
    LT_EQ           reduce using rule 67 (term_tail -> empty .)
    NOT_EQ          reduce using rule 67 (term_tail -> empty .)
    RBRACE          reduce using rule 67 (term_tail -> empty .)
    COLON           reduce using rule 67 (term_tail -> empty .)
    SEMICOLON       reduce using rule 67 (term_tail -> empty .)


state 78

    (68) term_tail -> GT . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 107
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 79

    (69) term_tail -> LT . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 108
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 80

    (70) term_tail -> EQ_EQ . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 109
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 81

    (71) term_tail -> GT_EQ . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 110
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 82

    (72) term_tail -> LT_EQ . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 111
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 83

    (73) term_tail -> NOT_EQ . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 112
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 84

    (55) term -> factor factor_tail .

    GT              reduce using rule 55 (term -> factor factor_tail .)
    LT              reduce using rule 55 (term -> factor factor_tail .)
    EQ_EQ           reduce using rule 55 (term -> factor factor_tail .)
    GT_EQ           reduce using rule 55 (term -> factor factor_tail .)
    LT_EQ           reduce using rule 55 (term -> factor factor_tail .)
    NOT_EQ          reduce using rule 55 (term -> factor factor_tail .)
    AND             reduce using rule 55 (term -> factor factor_tail .)
    OR              reduce using rule 55 (term -> factor factor_tail .)
    COMMA           reduce using rule 55 (term -> factor factor_tail .)
    NEWLINE         reduce using rule 55 (term -> factor factor_tail .)
    RPAREN          reduce using rule 55 (term -> factor factor_tail .)
    RBRACE          reduce using rule 55 (term -> factor factor_tail .)
    COLON           reduce using rule 55 (term -> factor factor_tail .)
    SEMICOLON       reduce using rule 55 (term -> factor factor_tail .)


state 85

    (60) factor_tail -> empty .

    COMMA           reduce using rule 60 (factor_tail -> empty .)
    NEWLINE         reduce using rule 60 (factor_tail -> empty .)
    RPAREN          reduce using rule 60 (factor_tail -> empty .)
    AND             reduce using rule 60 (factor_tail -> empty .)
    OR              reduce using rule 60 (factor_tail -> empty .)
    GT              reduce using rule 60 (factor_tail -> empty .)
    LT              reduce using rule 60 (factor_tail -> empty .)
    EQ_EQ           reduce using rule 60 (factor_tail -> empty .)
    GT_EQ           reduce using rule 60 (factor_tail -> empty .)
    LT_EQ           reduce using rule 60 (factor_tail -> empty .)
    NOT_EQ          reduce using rule 60 (factor_tail -> empty .)
    RBRACE          reduce using rule 60 (factor_tail -> empty .)
    COLON           reduce using rule 60 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 60 (factor_tail -> empty .)


state 86

    (61) factor_tail -> PLUS . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 113
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 87

    (62) factor_tail -> MINUS . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 114
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 88

    (63) factor_tail -> MULTIPLY . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 115
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 89

    (64) factor_tail -> DIVISION . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 116
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 90

    (65) factor_tail -> MODULO . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 117
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 91

    (66) factor_tail -> EXPONENT . expression
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 118
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 92

    (58) factor -> TILDE literal .

    PLUS            reduce using rule 58 (factor -> TILDE literal .)
    MINUS           reduce using rule 58 (factor -> TILDE literal .)
    MULTIPLY        reduce using rule 58 (factor -> TILDE literal .)
    DIVISION        reduce using rule 58 (factor -> TILDE literal .)
    MODULO          reduce using rule 58 (factor -> TILDE literal .)
    EXPONENT        reduce using rule 58 (factor -> TILDE literal .)
    GT              reduce using rule 58 (factor -> TILDE literal .)
    LT              reduce using rule 58 (factor -> TILDE literal .)
    EQ_EQ           reduce using rule 58 (factor -> TILDE literal .)
    GT_EQ           reduce using rule 58 (factor -> TILDE literal .)
    LT_EQ           reduce using rule 58 (factor -> TILDE literal .)
    NOT_EQ          reduce using rule 58 (factor -> TILDE literal .)
    AND             reduce using rule 58 (factor -> TILDE literal .)
    OR              reduce using rule 58 (factor -> TILDE literal .)
    COMMA           reduce using rule 58 (factor -> TILDE literal .)
    NEWLINE         reduce using rule 58 (factor -> TILDE literal .)
    RPAREN          reduce using rule 58 (factor -> TILDE literal .)
    RBRACE          reduce using rule 58 (factor -> TILDE literal .)
    COLON           reduce using rule 58 (factor -> TILDE literal .)
    SEMICOLON       reduce using rule 58 (factor -> TILDE literal .)


state 93

    (59) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 119


state 94

    (77) var_call -> IDENT var_call_tail .

    PLUS            reduce using rule 77 (var_call -> IDENT var_call_tail .)
    MINUS           reduce using rule 77 (var_call -> IDENT var_call_tail .)
    MULTIPLY        reduce using rule 77 (var_call -> IDENT var_call_tail .)
    DIVISION        reduce using rule 77 (var_call -> IDENT var_call_tail .)
    MODULO          reduce using rule 77 (var_call -> IDENT var_call_tail .)
    EXPONENT        reduce using rule 77 (var_call -> IDENT var_call_tail .)
    GT              reduce using rule 77 (var_call -> IDENT var_call_tail .)
    LT              reduce using rule 77 (var_call -> IDENT var_call_tail .)
    EQ_EQ           reduce using rule 77 (var_call -> IDENT var_call_tail .)
    GT_EQ           reduce using rule 77 (var_call -> IDENT var_call_tail .)
    LT_EQ           reduce using rule 77 (var_call -> IDENT var_call_tail .)
    NOT_EQ          reduce using rule 77 (var_call -> IDENT var_call_tail .)
    AND             reduce using rule 77 (var_call -> IDENT var_call_tail .)
    OR              reduce using rule 77 (var_call -> IDENT var_call_tail .)
    COMMA           reduce using rule 77 (var_call -> IDENT var_call_tail .)
    NEWLINE         reduce using rule 77 (var_call -> IDENT var_call_tail .)
    RPAREN          reduce using rule 77 (var_call -> IDENT var_call_tail .)
    RBRACE          reduce using rule 77 (var_call -> IDENT var_call_tail .)
    COLON           reduce using rule 77 (var_call -> IDENT var_call_tail .)
    SEMICOLON       reduce using rule 77 (var_call -> IDENT var_call_tail .)
    PLUS_PLUS       reduce using rule 77 (var_call -> IDENT var_call_tail .)
    MINUS_MINUS     reduce using rule 77 (var_call -> IDENT var_call_tail .)
    PLUS_EQ         reduce using rule 77 (var_call -> IDENT var_call_tail .)
    MINUS_EQ        reduce using rule 77 (var_call -> IDENT var_call_tail .)
    MUL_EQ          reduce using rule 77 (var_call -> IDENT var_call_tail .)
    DIV_EQ          reduce using rule 77 (var_call -> IDENT var_call_tail .)
    MOD_EQ          reduce using rule 77 (var_call -> IDENT var_call_tail .)
    EQ              reduce using rule 77 (var_call -> IDENT var_call_tail .)


state 95

    (78) var_call_tail -> empty .

    PLUS            reduce using rule 78 (var_call_tail -> empty .)
    MINUS           reduce using rule 78 (var_call_tail -> empty .)
    MULTIPLY        reduce using rule 78 (var_call_tail -> empty .)
    DIVISION        reduce using rule 78 (var_call_tail -> empty .)
    MODULO          reduce using rule 78 (var_call_tail -> empty .)
    EXPONENT        reduce using rule 78 (var_call_tail -> empty .)
    GT              reduce using rule 78 (var_call_tail -> empty .)
    LT              reduce using rule 78 (var_call_tail -> empty .)
    EQ_EQ           reduce using rule 78 (var_call_tail -> empty .)
    GT_EQ           reduce using rule 78 (var_call_tail -> empty .)
    LT_EQ           reduce using rule 78 (var_call_tail -> empty .)
    NOT_EQ          reduce using rule 78 (var_call_tail -> empty .)
    AND             reduce using rule 78 (var_call_tail -> empty .)
    OR              reduce using rule 78 (var_call_tail -> empty .)
    COMMA           reduce using rule 78 (var_call_tail -> empty .)
    NEWLINE         reduce using rule 78 (var_call_tail -> empty .)
    RPAREN          reduce using rule 78 (var_call_tail -> empty .)
    RBRACE          reduce using rule 78 (var_call_tail -> empty .)
    COLON           reduce using rule 78 (var_call_tail -> empty .)
    SEMICOLON       reduce using rule 78 (var_call_tail -> empty .)
    PLUS_PLUS       reduce using rule 78 (var_call_tail -> empty .)
    MINUS_MINUS     reduce using rule 78 (var_call_tail -> empty .)
    PLUS_EQ         reduce using rule 78 (var_call_tail -> empty .)
    MINUS_EQ        reduce using rule 78 (var_call_tail -> empty .)
    MUL_EQ          reduce using rule 78 (var_call_tail -> empty .)
    DIV_EQ          reduce using rule 78 (var_call_tail -> empty .)
    MOD_EQ          reduce using rule 78 (var_call_tail -> empty .)
    EQ              reduce using rule 78 (var_call_tail -> empty .)


state 96

    (79) var_call_tail -> LBRACKET . index RBRACKET
    (30) index -> . INT_LIT
    (31) index -> . IDENT

    INT_LIT         shift and go to state 121
    IDENT           shift and go to state 122

    index                          shift and go to state 120

state 97

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN . parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (94) parameters -> . data_type IDENT parameters_tail
    (95) parameters -> . empty
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR
    (159) empty -> .

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13
    RPAREN          reduce using rule 159 (empty -> .)

    parameters                     shift and go to state 123
    data_type                      shift and go to state 124
    empty                          shift and go to state 125

state 98

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 126


state 99

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 127


state 100

    (15) global_tail2 -> COMMA IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (159) empty -> .

    COMMA           shift and go to state 28
    EQ              shift and go to state 29
    NEWLINE         reduce using rule 159 (empty -> .)

    global_statement_tail          shift and go to state 128
    empty                          shift and go to state 27

state 101

    (17) global_dec_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 17 (global_dec_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 17 (global_dec_value -> LBRACKET list_element RBRACKET .)


state 102

    (27) list_element -> literal element_tail .

    RBRACKET        reduce using rule 27 (list_element -> literal element_tail .)


state 103

    (28) element_tail -> empty .

    RBRACKET        reduce using rule 28 (element_tail -> empty .)


state 104

    (29) element_tail -> COMMA . list_element
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 129
    literal                        shift and go to state 71

state 105

    (75) expr_tail -> AND expression .

    COMMA           reduce using rule 75 (expr_tail -> AND expression .)
    NEWLINE         reduce using rule 75 (expr_tail -> AND expression .)
    RPAREN          reduce using rule 75 (expr_tail -> AND expression .)
    AND             reduce using rule 75 (expr_tail -> AND expression .)
    OR              reduce using rule 75 (expr_tail -> AND expression .)
    GT              reduce using rule 75 (expr_tail -> AND expression .)
    LT              reduce using rule 75 (expr_tail -> AND expression .)
    EQ_EQ           reduce using rule 75 (expr_tail -> AND expression .)
    GT_EQ           reduce using rule 75 (expr_tail -> AND expression .)
    LT_EQ           reduce using rule 75 (expr_tail -> AND expression .)
    NOT_EQ          reduce using rule 75 (expr_tail -> AND expression .)
    RBRACE          reduce using rule 75 (expr_tail -> AND expression .)
    COLON           reduce using rule 75 (expr_tail -> AND expression .)
    SEMICOLON       reduce using rule 75 (expr_tail -> AND expression .)


state 106

    (76) expr_tail -> OR expression .

    COMMA           reduce using rule 76 (expr_tail -> OR expression .)
    NEWLINE         reduce using rule 76 (expr_tail -> OR expression .)
    RPAREN          reduce using rule 76 (expr_tail -> OR expression .)
    AND             reduce using rule 76 (expr_tail -> OR expression .)
    OR              reduce using rule 76 (expr_tail -> OR expression .)
    GT              reduce using rule 76 (expr_tail -> OR expression .)
    LT              reduce using rule 76 (expr_tail -> OR expression .)
    EQ_EQ           reduce using rule 76 (expr_tail -> OR expression .)
    GT_EQ           reduce using rule 76 (expr_tail -> OR expression .)
    LT_EQ           reduce using rule 76 (expr_tail -> OR expression .)
    NOT_EQ          reduce using rule 76 (expr_tail -> OR expression .)
    RBRACE          reduce using rule 76 (expr_tail -> OR expression .)
    COLON           reduce using rule 76 (expr_tail -> OR expression .)
    SEMICOLON       reduce using rule 76 (expr_tail -> OR expression .)


state 107

    (68) term_tail -> GT expression .

    COMMA           reduce using rule 68 (term_tail -> GT expression .)
    NEWLINE         reduce using rule 68 (term_tail -> GT expression .)
    RPAREN          reduce using rule 68 (term_tail -> GT expression .)
    AND             reduce using rule 68 (term_tail -> GT expression .)
    OR              reduce using rule 68 (term_tail -> GT expression .)
    GT              reduce using rule 68 (term_tail -> GT expression .)
    LT              reduce using rule 68 (term_tail -> GT expression .)
    EQ_EQ           reduce using rule 68 (term_tail -> GT expression .)
    GT_EQ           reduce using rule 68 (term_tail -> GT expression .)
    LT_EQ           reduce using rule 68 (term_tail -> GT expression .)
    NOT_EQ          reduce using rule 68 (term_tail -> GT expression .)
    RBRACE          reduce using rule 68 (term_tail -> GT expression .)
    COLON           reduce using rule 68 (term_tail -> GT expression .)
    SEMICOLON       reduce using rule 68 (term_tail -> GT expression .)


state 108

    (69) term_tail -> LT expression .

    COMMA           reduce using rule 69 (term_tail -> LT expression .)
    NEWLINE         reduce using rule 69 (term_tail -> LT expression .)
    RPAREN          reduce using rule 69 (term_tail -> LT expression .)
    AND             reduce using rule 69 (term_tail -> LT expression .)
    OR              reduce using rule 69 (term_tail -> LT expression .)
    GT              reduce using rule 69 (term_tail -> LT expression .)
    LT              reduce using rule 69 (term_tail -> LT expression .)
    EQ_EQ           reduce using rule 69 (term_tail -> LT expression .)
    GT_EQ           reduce using rule 69 (term_tail -> LT expression .)
    LT_EQ           reduce using rule 69 (term_tail -> LT expression .)
    NOT_EQ          reduce using rule 69 (term_tail -> LT expression .)
    RBRACE          reduce using rule 69 (term_tail -> LT expression .)
    COLON           reduce using rule 69 (term_tail -> LT expression .)
    SEMICOLON       reduce using rule 69 (term_tail -> LT expression .)


state 109

    (70) term_tail -> EQ_EQ expression .

    COMMA           reduce using rule 70 (term_tail -> EQ_EQ expression .)
    NEWLINE         reduce using rule 70 (term_tail -> EQ_EQ expression .)
    RPAREN          reduce using rule 70 (term_tail -> EQ_EQ expression .)
    AND             reduce using rule 70 (term_tail -> EQ_EQ expression .)
    OR              reduce using rule 70 (term_tail -> EQ_EQ expression .)
    GT              reduce using rule 70 (term_tail -> EQ_EQ expression .)
    LT              reduce using rule 70 (term_tail -> EQ_EQ expression .)
    EQ_EQ           reduce using rule 70 (term_tail -> EQ_EQ expression .)
    GT_EQ           reduce using rule 70 (term_tail -> EQ_EQ expression .)
    LT_EQ           reduce using rule 70 (term_tail -> EQ_EQ expression .)
    NOT_EQ          reduce using rule 70 (term_tail -> EQ_EQ expression .)
    RBRACE          reduce using rule 70 (term_tail -> EQ_EQ expression .)
    COLON           reduce using rule 70 (term_tail -> EQ_EQ expression .)
    SEMICOLON       reduce using rule 70 (term_tail -> EQ_EQ expression .)


state 110

    (71) term_tail -> GT_EQ expression .

    COMMA           reduce using rule 71 (term_tail -> GT_EQ expression .)
    NEWLINE         reduce using rule 71 (term_tail -> GT_EQ expression .)
    RPAREN          reduce using rule 71 (term_tail -> GT_EQ expression .)
    AND             reduce using rule 71 (term_tail -> GT_EQ expression .)
    OR              reduce using rule 71 (term_tail -> GT_EQ expression .)
    GT              reduce using rule 71 (term_tail -> GT_EQ expression .)
    LT              reduce using rule 71 (term_tail -> GT_EQ expression .)
    EQ_EQ           reduce using rule 71 (term_tail -> GT_EQ expression .)
    GT_EQ           reduce using rule 71 (term_tail -> GT_EQ expression .)
    LT_EQ           reduce using rule 71 (term_tail -> GT_EQ expression .)
    NOT_EQ          reduce using rule 71 (term_tail -> GT_EQ expression .)
    RBRACE          reduce using rule 71 (term_tail -> GT_EQ expression .)
    COLON           reduce using rule 71 (term_tail -> GT_EQ expression .)
    SEMICOLON       reduce using rule 71 (term_tail -> GT_EQ expression .)


state 111

    (72) term_tail -> LT_EQ expression .

    COMMA           reduce using rule 72 (term_tail -> LT_EQ expression .)
    NEWLINE         reduce using rule 72 (term_tail -> LT_EQ expression .)
    RPAREN          reduce using rule 72 (term_tail -> LT_EQ expression .)
    AND             reduce using rule 72 (term_tail -> LT_EQ expression .)
    OR              reduce using rule 72 (term_tail -> LT_EQ expression .)
    GT              reduce using rule 72 (term_tail -> LT_EQ expression .)
    LT              reduce using rule 72 (term_tail -> LT_EQ expression .)
    EQ_EQ           reduce using rule 72 (term_tail -> LT_EQ expression .)
    GT_EQ           reduce using rule 72 (term_tail -> LT_EQ expression .)
    LT_EQ           reduce using rule 72 (term_tail -> LT_EQ expression .)
    NOT_EQ          reduce using rule 72 (term_tail -> LT_EQ expression .)
    RBRACE          reduce using rule 72 (term_tail -> LT_EQ expression .)
    COLON           reduce using rule 72 (term_tail -> LT_EQ expression .)
    SEMICOLON       reduce using rule 72 (term_tail -> LT_EQ expression .)


state 112

    (73) term_tail -> NOT_EQ expression .

    COMMA           reduce using rule 73 (term_tail -> NOT_EQ expression .)
    NEWLINE         reduce using rule 73 (term_tail -> NOT_EQ expression .)
    RPAREN          reduce using rule 73 (term_tail -> NOT_EQ expression .)
    AND             reduce using rule 73 (term_tail -> NOT_EQ expression .)
    OR              reduce using rule 73 (term_tail -> NOT_EQ expression .)
    GT              reduce using rule 73 (term_tail -> NOT_EQ expression .)
    LT              reduce using rule 73 (term_tail -> NOT_EQ expression .)
    EQ_EQ           reduce using rule 73 (term_tail -> NOT_EQ expression .)
    GT_EQ           reduce using rule 73 (term_tail -> NOT_EQ expression .)
    LT_EQ           reduce using rule 73 (term_tail -> NOT_EQ expression .)
    NOT_EQ          reduce using rule 73 (term_tail -> NOT_EQ expression .)
    RBRACE          reduce using rule 73 (term_tail -> NOT_EQ expression .)
    COLON           reduce using rule 73 (term_tail -> NOT_EQ expression .)
    SEMICOLON       reduce using rule 73 (term_tail -> NOT_EQ expression .)


state 113

    (61) factor_tail -> PLUS expression .

    COMMA           reduce using rule 61 (factor_tail -> PLUS expression .)
    NEWLINE         reduce using rule 61 (factor_tail -> PLUS expression .)
    RPAREN          reduce using rule 61 (factor_tail -> PLUS expression .)
    AND             reduce using rule 61 (factor_tail -> PLUS expression .)
    OR              reduce using rule 61 (factor_tail -> PLUS expression .)
    GT              reduce using rule 61 (factor_tail -> PLUS expression .)
    LT              reduce using rule 61 (factor_tail -> PLUS expression .)
    EQ_EQ           reduce using rule 61 (factor_tail -> PLUS expression .)
    GT_EQ           reduce using rule 61 (factor_tail -> PLUS expression .)
    LT_EQ           reduce using rule 61 (factor_tail -> PLUS expression .)
    NOT_EQ          reduce using rule 61 (factor_tail -> PLUS expression .)
    RBRACE          reduce using rule 61 (factor_tail -> PLUS expression .)
    COLON           reduce using rule 61 (factor_tail -> PLUS expression .)
    SEMICOLON       reduce using rule 61 (factor_tail -> PLUS expression .)


state 114

    (62) factor_tail -> MINUS expression .

    COMMA           reduce using rule 62 (factor_tail -> MINUS expression .)
    NEWLINE         reduce using rule 62 (factor_tail -> MINUS expression .)
    RPAREN          reduce using rule 62 (factor_tail -> MINUS expression .)
    AND             reduce using rule 62 (factor_tail -> MINUS expression .)
    OR              reduce using rule 62 (factor_tail -> MINUS expression .)
    GT              reduce using rule 62 (factor_tail -> MINUS expression .)
    LT              reduce using rule 62 (factor_tail -> MINUS expression .)
    EQ_EQ           reduce using rule 62 (factor_tail -> MINUS expression .)
    GT_EQ           reduce using rule 62 (factor_tail -> MINUS expression .)
    LT_EQ           reduce using rule 62 (factor_tail -> MINUS expression .)
    NOT_EQ          reduce using rule 62 (factor_tail -> MINUS expression .)
    RBRACE          reduce using rule 62 (factor_tail -> MINUS expression .)
    COLON           reduce using rule 62 (factor_tail -> MINUS expression .)
    SEMICOLON       reduce using rule 62 (factor_tail -> MINUS expression .)


state 115

    (63) factor_tail -> MULTIPLY expression .

    COMMA           reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    NEWLINE         reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    RPAREN          reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    AND             reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    OR              reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    GT              reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    LT              reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    EQ_EQ           reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    GT_EQ           reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    LT_EQ           reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    NOT_EQ          reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    RBRACE          reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    COLON           reduce using rule 63 (factor_tail -> MULTIPLY expression .)
    SEMICOLON       reduce using rule 63 (factor_tail -> MULTIPLY expression .)


state 116

    (64) factor_tail -> DIVISION expression .

    COMMA           reduce using rule 64 (factor_tail -> DIVISION expression .)
    NEWLINE         reduce using rule 64 (factor_tail -> DIVISION expression .)
    RPAREN          reduce using rule 64 (factor_tail -> DIVISION expression .)
    AND             reduce using rule 64 (factor_tail -> DIVISION expression .)
    OR              reduce using rule 64 (factor_tail -> DIVISION expression .)
    GT              reduce using rule 64 (factor_tail -> DIVISION expression .)
    LT              reduce using rule 64 (factor_tail -> DIVISION expression .)
    EQ_EQ           reduce using rule 64 (factor_tail -> DIVISION expression .)
    GT_EQ           reduce using rule 64 (factor_tail -> DIVISION expression .)
    LT_EQ           reduce using rule 64 (factor_tail -> DIVISION expression .)
    NOT_EQ          reduce using rule 64 (factor_tail -> DIVISION expression .)
    RBRACE          reduce using rule 64 (factor_tail -> DIVISION expression .)
    COLON           reduce using rule 64 (factor_tail -> DIVISION expression .)
    SEMICOLON       reduce using rule 64 (factor_tail -> DIVISION expression .)


state 117

    (65) factor_tail -> MODULO expression .

    COMMA           reduce using rule 65 (factor_tail -> MODULO expression .)
    NEWLINE         reduce using rule 65 (factor_tail -> MODULO expression .)
    RPAREN          reduce using rule 65 (factor_tail -> MODULO expression .)
    AND             reduce using rule 65 (factor_tail -> MODULO expression .)
    OR              reduce using rule 65 (factor_tail -> MODULO expression .)
    GT              reduce using rule 65 (factor_tail -> MODULO expression .)
    LT              reduce using rule 65 (factor_tail -> MODULO expression .)
    EQ_EQ           reduce using rule 65 (factor_tail -> MODULO expression .)
    GT_EQ           reduce using rule 65 (factor_tail -> MODULO expression .)
    LT_EQ           reduce using rule 65 (factor_tail -> MODULO expression .)
    NOT_EQ          reduce using rule 65 (factor_tail -> MODULO expression .)
    RBRACE          reduce using rule 65 (factor_tail -> MODULO expression .)
    COLON           reduce using rule 65 (factor_tail -> MODULO expression .)
    SEMICOLON       reduce using rule 65 (factor_tail -> MODULO expression .)


state 118

    (66) factor_tail -> EXPONENT expression .

    COMMA           reduce using rule 66 (factor_tail -> EXPONENT expression .)
    NEWLINE         reduce using rule 66 (factor_tail -> EXPONENT expression .)
    RPAREN          reduce using rule 66 (factor_tail -> EXPONENT expression .)
    AND             reduce using rule 66 (factor_tail -> EXPONENT expression .)
    OR              reduce using rule 66 (factor_tail -> EXPONENT expression .)
    GT              reduce using rule 66 (factor_tail -> EXPONENT expression .)
    LT              reduce using rule 66 (factor_tail -> EXPONENT expression .)
    EQ_EQ           reduce using rule 66 (factor_tail -> EXPONENT expression .)
    GT_EQ           reduce using rule 66 (factor_tail -> EXPONENT expression .)
    LT_EQ           reduce using rule 66 (factor_tail -> EXPONENT expression .)
    NOT_EQ          reduce using rule 66 (factor_tail -> EXPONENT expression .)
    RBRACE          reduce using rule 66 (factor_tail -> EXPONENT expression .)
    COLON           reduce using rule 66 (factor_tail -> EXPONENT expression .)
    SEMICOLON       reduce using rule 66 (factor_tail -> EXPONENT expression .)


state 119

    (59) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 59 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 59 (factor -> LPAREN expression RPAREN .)


state 120

    (79) var_call_tail -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 130


state 121

    (30) index -> INT_LIT .

    RBRACKET        reduce using rule 30 (index -> INT_LIT .)


state 122

    (31) index -> IDENT .

    RBRACKET        reduce using rule 31 (index -> IDENT .)


state 123

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters . RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    RPAREN          shift and go to state 131


state 124

    (94) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 132


state 125

    (95) parameters -> empty .

    RPAREN          reduce using rule 95 (parameters -> empty .)


state 126

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 127

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 133
    empty                          shift and go to state 16

state 128

    (15) global_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 15 (global_tail2 -> COMMA IDENT global_statement_tail .)


state 129

    (29) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 29 (element_tail -> COMMA list_element .)


state 130

    (79) var_call_tail -> LBRACKET index RBRACKET .

    PLUS            reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    GT              reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    LT              reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    AND             reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    OR              reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_PLUS       reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ              reduce using rule 79 (var_call_tail -> LBRACKET index RBRACKET .)


state 131

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN . maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 134
    empty                          shift and go to state 16

state 132

    (94) parameters -> data_type IDENT . parameters_tail
    (96) parameters_tail -> . empty
    (97) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (159) empty -> .

    COMMA           shift and go to state 137
    RPAREN          reduce using rule 159 (empty -> .)

    parameters_tail                shift and go to state 135
    empty                          shift and go to state 136

state 133

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 138


state 134

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline . LBRACE unli_newline statements revive maybe_newline RBRACE

    LBRACE          shift and go to state 139


state 135

    (94) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 94 (parameters -> data_type IDENT parameters_tail .)


state 136

    (96) parameters_tail -> empty .

    RPAREN          reduce using rule 96 (parameters_tail -> empty .)


state 137

    (97) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    data_type                      shift and go to state 140

state 138

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 141
    empty                          shift and go to state 16

state 139

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE . unli_newline statements revive maybe_newline RBRACE
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 142

state 140

    (97) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 143


state 141

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 144
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 142

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline . statements revive maybe_newline RBRACE
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    REVIVE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 149
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 143

    (97) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (96) parameters_tail -> . empty
    (97) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (159) empty -> .

    COMMA           shift and go to state 137
    RPAREN          reduce using rule 159 (empty -> .)

    parameters_tail                shift and go to state 150
    empty                          shift and go to state 136

state 144

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 151
    empty                          shift and go to state 16

state 145

    (100) statements -> empty .
    (109) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 100 (statements -> empty .)
    NEWLINE         reduce using rule 100 (statements -> empty .)
    RBRACE          reduce using rule 100 (statements -> empty .)
    REVIVE          reduce using rule 100 (statements -> empty .)
    SHIFT           reduce using rule 100 (statements -> empty .)
    OTHERWISE       reduce using rule 100 (statements -> empty .)
    CHECK           reduce using rule 109 (local_dec -> empty .)
    SWAP            reduce using rule 109 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 109 (local_dec -> empty .)
    DISPLAY         reduce using rule 109 (local_dec -> empty .)
    IDENT           reduce using rule 109 (local_dec -> empty .)
    FOR             reduce using rule 109 (local_dec -> empty .)
    UNTIL           reduce using rule 109 (local_dec -> empty .)
    REPEAT          reduce using rule 109 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 109 (local_dec -> empty .) ]


state 146

    (101) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 152
    empty                          shift and go to state 16

state 147

    (110) local_dec -> var_statement .

    NEWLINE         reduce using rule 110 (local_dec -> var_statement .)
    CHECK           reduce using rule 110 (local_dec -> var_statement .)
    SWAP            reduce using rule 110 (local_dec -> var_statement .)
    FUNCTION_NAME   reduce using rule 110 (local_dec -> var_statement .)
    DISPLAY         reduce using rule 110 (local_dec -> var_statement .)
    IDENT           reduce using rule 110 (local_dec -> var_statement .)
    FOR             reduce using rule 110 (local_dec -> var_statement .)
    UNTIL           reduce using rule 110 (local_dec -> var_statement .)
    REPEAT          reduce using rule 110 (local_dec -> var_statement .)


state 148

    (19) var_statement -> data_type . IDENT var_tail unli_newline

    IDENT           shift and go to state 153


state 149

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements . revive maybe_newline RBRACE
    (98) revive -> . REVIVE value
    (99) revive -> . empty
    (159) empty -> .

    REVIVE          shift and go to state 155
    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)

    revive                         shift and go to state 154
    empty                          shift and go to state 156

state 150

    (97) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 97 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 151

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 157


state 152

    (101) statements -> local_dec maybe_newline . statements_tail
    (102) statements_tail -> . string_operation_statement unli_newline statements_tail2
    (103) statements_tail -> . conditional_statement unli_newline statements_tail2
    (104) statements_tail -> . switch_statement unli_newline statements_tail2
    (105) statements_tail -> . loop_statement unli_newline statements_tail2
    (106) statements_tail -> . function_call unli_newline statements_tail2
    (107) statements_tail -> . output_statement unli_newline statements_tail2
    (146) string_operation_statement -> . var_call string_operation_tail
    (111) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (117) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (121) loop_statement -> . for_loop
    (122) loop_statement -> . until_loop
    (123) loop_statement -> . repeat_until
    (133) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (134) function_call -> . output_statement
    (141) output_statement -> . DISPLAY value next_val
    (142) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (77) var_call -> . IDENT var_call_tail
    (124) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (125) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (126) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN

    CHECK           shift and go to state 166
    SWAP            shift and go to state 167
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 172
    IDENT           shift and go to state 56
    FOR             shift and go to state 173
    UNTIL           shift and go to state 174
    REPEAT          shift and go to state 175

    statements_tail                shift and go to state 158
    string_operation_statement     shift and go to state 159
    conditional_statement          shift and go to state 160
    switch_statement               shift and go to state 161
    loop_statement                 shift and go to state 162
    function_call                  shift and go to state 163
    output_statement               shift and go to state 164
    var_call                       shift and go to state 165
    for_loop                       shift and go to state 168
    until_loop                     shift and go to state 169
    repeat_until                   shift and go to state 170

state 153

    (19) var_statement -> data_type IDENT . var_tail unli_newline
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (159) empty -> .

    EQ              shift and go to state 178
    COMMA           shift and go to state 179
    NEWLINE         reduce using rule 159 (empty -> .)

    var_tail                       shift and go to state 176
    empty                          shift and go to state 177

state 154

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 180
    empty                          shift and go to state 16

state 155

    (98) revive -> REVIVE . value
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . expr_head expr_tail
    (133) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (134) function_call -> . output_statement
    (54) expr_head -> . term term_tail
    (141) output_statement -> . DISPLAY value next_val
    (142) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 185
    CONVERT_TO_FLT  shift and go to state 186
    CONVERT_TO_BLN  shift and go to state 187
    CONVERT_TO_STR  shift and go to state 188
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 172
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    value                          shift and go to state 181
    type_cast                      shift and go to state 182
    expression                     shift and go to state 183
    function_call                  shift and go to state 184
    expr_head                      shift and go to state 49
    output_statement               shift and go to state 189
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 156

    (99) revive -> empty .

    NEWLINE         reduce using rule 99 (revive -> empty .)
    RBRACE          reduce using rule 99 (revive -> empty .)


state 157

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)


state 158

    (101) statements -> local_dec maybe_newline statements_tail .

    NEWLINE         reduce using rule 101 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 101 (statements -> local_dec maybe_newline statements_tail .)
    REVIVE          reduce using rule 101 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 101 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 101 (statements -> local_dec maybe_newline statements_tail .)


state 159

    (102) statements_tail -> string_operation_statement . unli_newline statements_tail2
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 190

state 160

    (103) statements_tail -> conditional_statement . unli_newline statements_tail2
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 191

state 161

    (104) statements_tail -> switch_statement . unli_newline statements_tail2
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 192

state 162

    (105) statements_tail -> loop_statement . unli_newline statements_tail2
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 193

state 163

    (106) statements_tail -> function_call . unli_newline statements_tail2
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 194

state 164

    (107) statements_tail -> output_statement . unli_newline statements_tail2
    (134) function_call -> output_statement .
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 134 (function_call -> output_statement .) ]

    unli_newline                   shift and go to state 195

state 165

    (146) string_operation_statement -> var_call . string_operation_tail
    (147) string_operation_tail -> . PLUS string_val stringcon_tail
    (148) string_operation_tail -> . update_tail
    (129) update_tail -> . postfix
    (130) update_tail -> . assign_op value
    (131) postfix -> . PLUS_PLUS
    (132) postfix -> . MINUS_MINUS
    (149) assign_op -> . PLUS_EQ
    (150) assign_op -> . MINUS_EQ
    (151) assign_op -> . MUL_EQ
    (152) assign_op -> . DIV_EQ
    (153) assign_op -> . MOD_EQ
    (154) assign_op -> . EQ

    PLUS            shift and go to state 197
    PLUS_PLUS       shift and go to state 201
    MINUS_MINUS     shift and go to state 202
    PLUS_EQ         shift and go to state 203
    MINUS_EQ        shift and go to state 204
    MUL_EQ          shift and go to state 205
    DIV_EQ          shift and go to state 206
    MOD_EQ          shift and go to state 207
    EQ              shift and go to state 208

    string_operation_tail          shift and go to state 196
    update_tail                    shift and go to state 198
    postfix                        shift and go to state 199
    assign_op                      shift and go to state 200

state 166

    (111) conditional_statement -> CHECK . LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    LPAREN          shift and go to state 209


state 167

    (117) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LPAREN          shift and go to state 210


state 168

    (121) loop_statement -> for_loop .

    NEWLINE         reduce using rule 121 (loop_statement -> for_loop .)


state 169

    (122) loop_statement -> until_loop .

    NEWLINE         reduce using rule 122 (loop_statement -> until_loop .)


state 170

    (123) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 123 (loop_statement -> repeat_until .)


state 171

    (133) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 211


state 172

    (141) output_statement -> DISPLAY . value next_val
    (142) output_statement -> DISPLAY . LPAREN value next_val RPAREN
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . expr_head expr_tail
    (133) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (134) function_call -> . output_statement
    (54) expr_head -> . term term_tail
    (141) output_statement -> . DISPLAY value next_val
    (142) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LPAREN          shift and go to state 213
    CONVERT_TO_INT  shift and go to state 185
    CONVERT_TO_FLT  shift and go to state 186
    CONVERT_TO_BLN  shift and go to state 187
    CONVERT_TO_STR  shift and go to state 188
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 172
    TILDE           shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    value                          shift and go to state 212
    type_cast                      shift and go to state 182
    expression                     shift and go to state 183
    function_call                  shift and go to state 184
    expr_head                      shift and go to state 49
    output_statement               shift and go to state 189
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 173

    (124) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 214


state 174

    (125) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 215


state 175

    (126) repeat_until -> REPEAT . LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 216


state 176

    (19) var_statement -> data_type IDENT var_tail . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 217

state 177

    (20) var_tail -> empty .

    NEWLINE         reduce using rule 20 (var_tail -> empty .)


state 178

    (21) var_tail -> EQ . tail_value var_tail2
    (25) tail_value -> . value
    (26) tail_value -> . LBRACKET list_element RBRACKET
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . expr_head expr_tail
    (133) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (134) function_call -> . output_statement
    (54) expr_head -> . term term_tail
    (141) output_statement -> . DISPLAY value next_val
    (142) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LBRACKET        shift and go to state 220
    CONVERT_TO_INT  shift and go to state 185
    CONVERT_TO_FLT  shift and go to state 186
    CONVERT_TO_BLN  shift and go to state 187
    CONVERT_TO_STR  shift and go to state 188
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 172
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    tail_value                     shift and go to state 218
    value                          shift and go to state 219
    type_cast                      shift and go to state 182
    expression                     shift and go to state 183
    function_call                  shift and go to state 184
    expr_head                      shift and go to state 49
    output_statement               shift and go to state 189
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 179

    (22) var_tail -> COMMA . IDENT var_tail

    IDENT           shift and go to state 221


state 180

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline . RBRACE

    RBRACE          shift and go to state 222


state 181

    (98) revive -> REVIVE value .

    NEWLINE         reduce using rule 98 (revive -> REVIVE value .)
    RBRACE          reduce using rule 98 (revive -> REVIVE value .)


state 182

    (37) value -> type_cast .

    NEWLINE         reduce using rule 37 (value -> type_cast .)
    RBRACE          reduce using rule 37 (value -> type_cast .)
    COMMA           reduce using rule 37 (value -> type_cast .)
    RPAREN          reduce using rule 37 (value -> type_cast .)
    COLON           reduce using rule 37 (value -> type_cast .)


state 183

    (38) value -> expression .

    NEWLINE         reduce using rule 38 (value -> expression .)
    RBRACE          reduce using rule 38 (value -> expression .)
    COMMA           reduce using rule 38 (value -> expression .)
    RPAREN          reduce using rule 38 (value -> expression .)
    COLON           reduce using rule 38 (value -> expression .)


state 184

    (39) value -> function_call .

    NEWLINE         reduce using rule 39 (value -> function_call .)
    RBRACE          reduce using rule 39 (value -> function_call .)
    COMMA           reduce using rule 39 (value -> function_call .)
    RPAREN          reduce using rule 39 (value -> function_call .)
    COLON           reduce using rule 39 (value -> function_call .)


state 185

    (40) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 223


state 186

    (41) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 224


state 187

    (42) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 225


state 188

    (43) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 226


state 189

    (134) function_call -> output_statement .

    NEWLINE         reduce using rule 134 (function_call -> output_statement .)
    RBRACE          reduce using rule 134 (function_call -> output_statement .)
    COMMA           reduce using rule 134 (function_call -> output_statement .)
    RPAREN          reduce using rule 134 (function_call -> output_statement .)
    COLON           reduce using rule 134 (function_call -> output_statement .)


state 190

    (102) statements_tail -> string_operation_statement unli_newline . statements_tail2
    (108) statements_tail2 -> . statements
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    REVIVE          reduce using rule 159 (empty -> .)
    SHIFT           reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements_tail2               shift and go to state 227
    statements                     shift and go to state 228
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 191

    (103) statements_tail -> conditional_statement unli_newline . statements_tail2
    (108) statements_tail2 -> . statements
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    REVIVE          reduce using rule 159 (empty -> .)
    SHIFT           reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements_tail2               shift and go to state 229
    statements                     shift and go to state 228
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 192

    (104) statements_tail -> switch_statement unli_newline . statements_tail2
    (108) statements_tail2 -> . statements
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    REVIVE          reduce using rule 159 (empty -> .)
    SHIFT           reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements_tail2               shift and go to state 230
    statements                     shift and go to state 228
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 193

    (105) statements_tail -> loop_statement unli_newline . statements_tail2
    (108) statements_tail2 -> . statements
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    REVIVE          reduce using rule 159 (empty -> .)
    SHIFT           reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements_tail2               shift and go to state 231
    statements                     shift and go to state 228
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 194

    (106) statements_tail -> function_call unli_newline . statements_tail2
    (108) statements_tail2 -> . statements
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    REVIVE          reduce using rule 159 (empty -> .)
    SHIFT           reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements_tail2               shift and go to state 232
    statements                     shift and go to state 228
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 195

    (107) statements_tail -> output_statement unli_newline . statements_tail2
    (108) statements_tail2 -> . statements
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    REVIVE          reduce using rule 159 (empty -> .)
    SHIFT           reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements_tail2               shift and go to state 233
    statements                     shift and go to state 228
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 196

    (146) string_operation_statement -> var_call string_operation_tail .

    NEWLINE         reduce using rule 146 (string_operation_statement -> var_call string_operation_tail .)


state 197

    (147) string_operation_tail -> PLUS . string_val stringcon_tail
    (157) string_val -> . var_call
    (158) string_val -> . STR_LIT
    (77) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 236
    IDENT           shift and go to state 56

    string_val                     shift and go to state 234
    var_call                       shift and go to state 235

state 198

    (148) string_operation_tail -> update_tail .

    NEWLINE         reduce using rule 148 (string_operation_tail -> update_tail .)


state 199

    (129) update_tail -> postfix .

    NEWLINE         reduce using rule 129 (update_tail -> postfix .)
    RPAREN          reduce using rule 129 (update_tail -> postfix .)


state 200

    (130) update_tail -> assign_op . value
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . expr_head expr_tail
    (133) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (134) function_call -> . output_statement
    (54) expr_head -> . term term_tail
    (141) output_statement -> . DISPLAY value next_val
    (142) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 185
    CONVERT_TO_FLT  shift and go to state 186
    CONVERT_TO_BLN  shift and go to state 187
    CONVERT_TO_STR  shift and go to state 188
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 172
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    value                          shift and go to state 237
    type_cast                      shift and go to state 182
    expression                     shift and go to state 183
    function_call                  shift and go to state 184
    expr_head                      shift and go to state 49
    output_statement               shift and go to state 189
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 201

    (131) postfix -> PLUS_PLUS .

    NEWLINE         reduce using rule 131 (postfix -> PLUS_PLUS .)
    RPAREN          reduce using rule 131 (postfix -> PLUS_PLUS .)


state 202

    (132) postfix -> MINUS_MINUS .

    NEWLINE         reduce using rule 132 (postfix -> MINUS_MINUS .)
    RPAREN          reduce using rule 132 (postfix -> MINUS_MINUS .)


state 203

    (149) assign_op -> PLUS_EQ .

    CONVERT_TO_INT  reduce using rule 149 (assign_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 149 (assign_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 149 (assign_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 149 (assign_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 149 (assign_op -> PLUS_EQ .)
    DISPLAY         reduce using rule 149 (assign_op -> PLUS_EQ .)
    TILDE           reduce using rule 149 (assign_op -> PLUS_EQ .)
    LPAREN          reduce using rule 149 (assign_op -> PLUS_EQ .)
    IDENT           reduce using rule 149 (assign_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 149 (assign_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 149 (assign_op -> PLUS_EQ .)
    DAY             reduce using rule 149 (assign_op -> PLUS_EQ .)
    NIGHT           reduce using rule 149 (assign_op -> PLUS_EQ .)
    CHR_LIT         reduce using rule 149 (assign_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 149 (assign_op -> PLUS_EQ .)


state 204

    (150) assign_op -> MINUS_EQ .

    CONVERT_TO_INT  reduce using rule 150 (assign_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 150 (assign_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 150 (assign_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 150 (assign_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 150 (assign_op -> MINUS_EQ .)
    DISPLAY         reduce using rule 150 (assign_op -> MINUS_EQ .)
    TILDE           reduce using rule 150 (assign_op -> MINUS_EQ .)
    LPAREN          reduce using rule 150 (assign_op -> MINUS_EQ .)
    IDENT           reduce using rule 150 (assign_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 150 (assign_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 150 (assign_op -> MINUS_EQ .)
    DAY             reduce using rule 150 (assign_op -> MINUS_EQ .)
    NIGHT           reduce using rule 150 (assign_op -> MINUS_EQ .)
    CHR_LIT         reduce using rule 150 (assign_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 150 (assign_op -> MINUS_EQ .)


state 205

    (151) assign_op -> MUL_EQ .

    CONVERT_TO_INT  reduce using rule 151 (assign_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 151 (assign_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 151 (assign_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 151 (assign_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 151 (assign_op -> MUL_EQ .)
    DISPLAY         reduce using rule 151 (assign_op -> MUL_EQ .)
    TILDE           reduce using rule 151 (assign_op -> MUL_EQ .)
    LPAREN          reduce using rule 151 (assign_op -> MUL_EQ .)
    IDENT           reduce using rule 151 (assign_op -> MUL_EQ .)
    INT_LIT         reduce using rule 151 (assign_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 151 (assign_op -> MUL_EQ .)
    DAY             reduce using rule 151 (assign_op -> MUL_EQ .)
    NIGHT           reduce using rule 151 (assign_op -> MUL_EQ .)
    CHR_LIT         reduce using rule 151 (assign_op -> MUL_EQ .)
    STR_LIT         reduce using rule 151 (assign_op -> MUL_EQ .)


state 206

    (152) assign_op -> DIV_EQ .

    CONVERT_TO_INT  reduce using rule 152 (assign_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 152 (assign_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 152 (assign_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 152 (assign_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 152 (assign_op -> DIV_EQ .)
    DISPLAY         reduce using rule 152 (assign_op -> DIV_EQ .)
    TILDE           reduce using rule 152 (assign_op -> DIV_EQ .)
    LPAREN          reduce using rule 152 (assign_op -> DIV_EQ .)
    IDENT           reduce using rule 152 (assign_op -> DIV_EQ .)
    INT_LIT         reduce using rule 152 (assign_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 152 (assign_op -> DIV_EQ .)
    DAY             reduce using rule 152 (assign_op -> DIV_EQ .)
    NIGHT           reduce using rule 152 (assign_op -> DIV_EQ .)
    CHR_LIT         reduce using rule 152 (assign_op -> DIV_EQ .)
    STR_LIT         reduce using rule 152 (assign_op -> DIV_EQ .)


state 207

    (153) assign_op -> MOD_EQ .

    CONVERT_TO_INT  reduce using rule 153 (assign_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 153 (assign_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 153 (assign_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 153 (assign_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 153 (assign_op -> MOD_EQ .)
    DISPLAY         reduce using rule 153 (assign_op -> MOD_EQ .)
    TILDE           reduce using rule 153 (assign_op -> MOD_EQ .)
    LPAREN          reduce using rule 153 (assign_op -> MOD_EQ .)
    IDENT           reduce using rule 153 (assign_op -> MOD_EQ .)
    INT_LIT         reduce using rule 153 (assign_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 153 (assign_op -> MOD_EQ .)
    DAY             reduce using rule 153 (assign_op -> MOD_EQ .)
    NIGHT           reduce using rule 153 (assign_op -> MOD_EQ .)
    CHR_LIT         reduce using rule 153 (assign_op -> MOD_EQ .)
    STR_LIT         reduce using rule 153 (assign_op -> MOD_EQ .)


state 208

    (154) assign_op -> EQ .

    CONVERT_TO_INT  reduce using rule 154 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 154 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 154 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 154 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 154 (assign_op -> EQ .)
    DISPLAY         reduce using rule 154 (assign_op -> EQ .)
    TILDE           reduce using rule 154 (assign_op -> EQ .)
    LPAREN          reduce using rule 154 (assign_op -> EQ .)
    IDENT           reduce using rule 154 (assign_op -> EQ .)
    INT_LIT         reduce using rule 154 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 154 (assign_op -> EQ .)
    DAY             reduce using rule 154 (assign_op -> EQ .)
    NIGHT           reduce using rule 154 (assign_op -> EQ .)
    CHR_LIT         reduce using rule 154 (assign_op -> EQ .)
    STR_LIT         reduce using rule 154 (assign_op -> EQ .)


state 209

    (111) conditional_statement -> CHECK LPAREN . expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 238
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 210

    (117) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    IDENT           shift and go to state 239


state 211

    (133) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (135) arguments -> . empty
    (136) arguments -> . arg_value arg_tail
    (159) empty -> .
    (139) arg_value -> . literal
    (140) arg_value -> . var_call
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT
    (77) var_call -> . IDENT var_call_tail

    RPAREN          reduce using rule 159 (empty -> .)
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    IDENT           shift and go to state 56

    arguments                      shift and go to state 240
    empty                          shift and go to state 241
    arg_value                      shift and go to state 242
    literal                        shift and go to state 243
    var_call                       shift and go to state 244

state 212

    (141) output_statement -> DISPLAY value . next_val
    (143) next_val -> . empty
    (144) next_val -> . COMMA value next_val
    (159) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 247
    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    RPAREN          reduce using rule 159 (empty -> .)
    COLON           reduce using rule 159 (empty -> .)

  ! COMMA           [ reduce using rule 159 (empty -> .) ]

    next_val                       shift and go to state 245
    empty                          shift and go to state 246

state 213

    (142) output_statement -> DISPLAY LPAREN . value next_val RPAREN
    (59) factor -> LPAREN . expression RPAREN
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (53) expression -> . expr_head expr_tail
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (133) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (134) function_call -> . output_statement
    (54) expr_head -> . term term_tail
    (141) output_statement -> . DISPLAY value next_val
    (142) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 185
    CONVERT_TO_FLT  shift and go to state 186
    CONVERT_TO_BLN  shift and go to state 187
    CONVERT_TO_STR  shift and go to state 188
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 172
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    value                          shift and go to state 248
    expression                     shift and go to state 249
    type_cast                      shift and go to state 182
    function_call                  shift and go to state 184
    expr_head                      shift and go to state 49
    output_statement               shift and go to state 189
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 214

    (124) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (127) control_variable -> . INT IDENT EQ INT_LIT

    INT             shift and go to state 251

    control_variable               shift and go to state 250

state 215

    (125) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE maybe_newline statements RBRACE
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 252
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 216

    (126) repeat_until -> REPEAT LBRACE . maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 253
    empty                          shift and go to state 16

state 217

    (19) var_statement -> data_type IDENT var_tail unli_newline .

    NEWLINE         reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    CHECK           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    SWAP            reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    FUNCTION_NAME   reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    DISPLAY         reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    IDENT           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    FOR             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    UNTIL           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    REPEAT          reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)


state 218

    (21) var_tail -> EQ tail_value . var_tail2
    (23) var_tail2 -> . empty
    (24) var_tail2 -> . COMMA IDENT var_tail
    (159) empty -> .

    COMMA           shift and go to state 256
    NEWLINE         reduce using rule 159 (empty -> .)

    var_tail2                      shift and go to state 254
    empty                          shift and go to state 255

state 219

    (25) tail_value -> value .

    COMMA           reduce using rule 25 (tail_value -> value .)
    NEWLINE         reduce using rule 25 (tail_value -> value .)


state 220

    (26) tail_value -> LBRACKET . list_element RBRACKET
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 257
    literal                        shift and go to state 71

state 221

    (22) var_tail -> COMMA IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (159) empty -> .

    EQ              shift and go to state 178
    COMMA           shift and go to state 179
    NEWLINE         reduce using rule 159 (empty -> .)

    var_tail                       shift and go to state 258
    empty                          shift and go to state 177

state 222

    (80) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .

    NEWLINE         reduce using rule 80 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .)
    MAIN_CASPER     reduce using rule 80 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .)


state 223

    (40) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . expr_head expr_tail
    (145) input_statement -> . INPUT LPAREN RPAREN
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 261
    INPUT           shift and go to state 263
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    typecast_value                 shift and go to state 259
    expression                     shift and go to state 260
    input_statement                shift and go to state 262
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 224

    (41) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . expr_head expr_tail
    (145) input_statement -> . INPUT LPAREN RPAREN
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 261
    INPUT           shift and go to state 263
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    typecast_value                 shift and go to state 264
    expression                     shift and go to state 260
    input_statement                shift and go to state 262
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 225

    (42) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . expr_head expr_tail
    (145) input_statement -> . INPUT LPAREN RPAREN
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 261
    INPUT           shift and go to state 263
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    typecast_value                 shift and go to state 265
    expression                     shift and go to state 260
    input_statement                shift and go to state 262
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 226

    (43) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . expr_head expr_tail
    (145) input_statement -> . INPUT LPAREN RPAREN
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 261
    INPUT           shift and go to state 263
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    typecast_value                 shift and go to state 266
    expression                     shift and go to state 260
    input_statement                shift and go to state 262
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 227

    (102) statements_tail -> string_operation_statement unli_newline statements_tail2 .

    NEWLINE         reduce using rule 102 (statements_tail -> string_operation_statement unli_newline statements_tail2 .)
    RBRACE          reduce using rule 102 (statements_tail -> string_operation_statement unli_newline statements_tail2 .)
    REVIVE          reduce using rule 102 (statements_tail -> string_operation_statement unli_newline statements_tail2 .)
    SHIFT           reduce using rule 102 (statements_tail -> string_operation_statement unli_newline statements_tail2 .)
    OTHERWISE       reduce using rule 102 (statements_tail -> string_operation_statement unli_newline statements_tail2 .)


state 228

    (108) statements_tail2 -> statements .

    NEWLINE         reduce using rule 108 (statements_tail2 -> statements .)
    RBRACE          reduce using rule 108 (statements_tail2 -> statements .)
    REVIVE          reduce using rule 108 (statements_tail2 -> statements .)
    SHIFT           reduce using rule 108 (statements_tail2 -> statements .)
    OTHERWISE       reduce using rule 108 (statements_tail2 -> statements .)


state 229

    (103) statements_tail -> conditional_statement unli_newline statements_tail2 .

    NEWLINE         reduce using rule 103 (statements_tail -> conditional_statement unli_newline statements_tail2 .)
    RBRACE          reduce using rule 103 (statements_tail -> conditional_statement unli_newline statements_tail2 .)
    REVIVE          reduce using rule 103 (statements_tail -> conditional_statement unli_newline statements_tail2 .)
    SHIFT           reduce using rule 103 (statements_tail -> conditional_statement unli_newline statements_tail2 .)
    OTHERWISE       reduce using rule 103 (statements_tail -> conditional_statement unli_newline statements_tail2 .)


state 230

    (104) statements_tail -> switch_statement unli_newline statements_tail2 .

    NEWLINE         reduce using rule 104 (statements_tail -> switch_statement unli_newline statements_tail2 .)
    RBRACE          reduce using rule 104 (statements_tail -> switch_statement unli_newline statements_tail2 .)
    REVIVE          reduce using rule 104 (statements_tail -> switch_statement unli_newline statements_tail2 .)
    SHIFT           reduce using rule 104 (statements_tail -> switch_statement unli_newline statements_tail2 .)
    OTHERWISE       reduce using rule 104 (statements_tail -> switch_statement unli_newline statements_tail2 .)


state 231

    (105) statements_tail -> loop_statement unli_newline statements_tail2 .

    NEWLINE         reduce using rule 105 (statements_tail -> loop_statement unli_newline statements_tail2 .)
    RBRACE          reduce using rule 105 (statements_tail -> loop_statement unli_newline statements_tail2 .)
    REVIVE          reduce using rule 105 (statements_tail -> loop_statement unli_newline statements_tail2 .)
    SHIFT           reduce using rule 105 (statements_tail -> loop_statement unli_newline statements_tail2 .)
    OTHERWISE       reduce using rule 105 (statements_tail -> loop_statement unli_newline statements_tail2 .)


state 232

    (106) statements_tail -> function_call unli_newline statements_tail2 .

    NEWLINE         reduce using rule 106 (statements_tail -> function_call unli_newline statements_tail2 .)
    RBRACE          reduce using rule 106 (statements_tail -> function_call unli_newline statements_tail2 .)
    REVIVE          reduce using rule 106 (statements_tail -> function_call unli_newline statements_tail2 .)
    SHIFT           reduce using rule 106 (statements_tail -> function_call unli_newline statements_tail2 .)
    OTHERWISE       reduce using rule 106 (statements_tail -> function_call unli_newline statements_tail2 .)


state 233

    (107) statements_tail -> output_statement unli_newline statements_tail2 .

    NEWLINE         reduce using rule 107 (statements_tail -> output_statement unli_newline statements_tail2 .)
    RBRACE          reduce using rule 107 (statements_tail -> output_statement unli_newline statements_tail2 .)
    REVIVE          reduce using rule 107 (statements_tail -> output_statement unli_newline statements_tail2 .)
    SHIFT           reduce using rule 107 (statements_tail -> output_statement unli_newline statements_tail2 .)
    OTHERWISE       reduce using rule 107 (statements_tail -> output_statement unli_newline statements_tail2 .)


state 234

    (147) string_operation_tail -> PLUS string_val . stringcon_tail
    (155) stringcon_tail -> . empty
    (156) stringcon_tail -> . PLUS string_val stringcon_tail
    (159) empty -> .

    PLUS            shift and go to state 267
    NEWLINE         reduce using rule 159 (empty -> .)

    stringcon_tail                 shift and go to state 268
    empty                          shift and go to state 269

state 235

    (157) string_val -> var_call .

    PLUS            reduce using rule 157 (string_val -> var_call .)
    NEWLINE         reduce using rule 157 (string_val -> var_call .)


state 236

    (158) string_val -> STR_LIT .

    PLUS            reduce using rule 158 (string_val -> STR_LIT .)
    NEWLINE         reduce using rule 158 (string_val -> STR_LIT .)


state 237

    (130) update_tail -> assign_op value .

    NEWLINE         reduce using rule 130 (update_tail -> assign_op value .)
    RPAREN          reduce using rule 130 (update_tail -> assign_op value .)


state 238

    (111) conditional_statement -> CHECK LPAREN expression . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    RPAREN          shift and go to state 270


state 239

    (117) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    RPAREN          shift and go to state 271


state 240

    (133) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 272


state 241

    (135) arguments -> empty .

    RPAREN          reduce using rule 135 (arguments -> empty .)


state 242

    (136) arguments -> arg_value . arg_tail
    (137) arg_tail -> . empty
    (138) arg_tail -> . COMMA arg_value arg_tail
    (159) empty -> .

    COMMA           shift and go to state 275
    RPAREN          reduce using rule 159 (empty -> .)

    arg_tail                       shift and go to state 273
    empty                          shift and go to state 274

state 243

    (139) arg_value -> literal .

    COMMA           reduce using rule 139 (arg_value -> literal .)
    RPAREN          reduce using rule 139 (arg_value -> literal .)


state 244

    (140) arg_value -> var_call .

    COMMA           reduce using rule 140 (arg_value -> var_call .)
    RPAREN          reduce using rule 140 (arg_value -> var_call .)


state 245

    (141) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 141 (output_statement -> DISPLAY value next_val .)
    RBRACE          reduce using rule 141 (output_statement -> DISPLAY value next_val .)
    COMMA           reduce using rule 141 (output_statement -> DISPLAY value next_val .)
    RPAREN          reduce using rule 141 (output_statement -> DISPLAY value next_val .)
    COLON           reduce using rule 141 (output_statement -> DISPLAY value next_val .)


state 246

    (143) next_val -> empty .

    COMMA           reduce using rule 143 (next_val -> empty .)
    NEWLINE         reduce using rule 143 (next_val -> empty .)
    RBRACE          reduce using rule 143 (next_val -> empty .)
    RPAREN          reduce using rule 143 (next_val -> empty .)
    COLON           reduce using rule 143 (next_val -> empty .)


state 247

    (144) next_val -> COMMA . value next_val
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . expr_head expr_tail
    (133) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (134) function_call -> . output_statement
    (54) expr_head -> . term term_tail
    (141) output_statement -> . DISPLAY value next_val
    (142) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 185
    CONVERT_TO_FLT  shift and go to state 186
    CONVERT_TO_BLN  shift and go to state 187
    CONVERT_TO_STR  shift and go to state 188
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 172
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    value                          shift and go to state 276
    type_cast                      shift and go to state 182
    expression                     shift and go to state 183
    function_call                  shift and go to state 184
    expr_head                      shift and go to state 49
    output_statement               shift and go to state 189
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 248

    (142) output_statement -> DISPLAY LPAREN value . next_val RPAREN
    (143) next_val -> . empty
    (144) next_val -> . COMMA value next_val
    (159) empty -> .

    COMMA           shift and go to state 247
    RPAREN          reduce using rule 159 (empty -> .)

    next_val                       shift and go to state 277
    empty                          shift and go to state 246

state 249

    (59) factor -> LPAREN expression . RPAREN
    (38) value -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 119
    COMMA           reduce using rule 38 (value -> expression .)

  ! RPAREN          [ reduce using rule 38 (value -> expression .) ]


state 250

    (124) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 278


state 251

    (127) control_variable -> INT . IDENT EQ INT_LIT

    IDENT           shift and go to state 279


state 252

    (125) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 280


state 253

    (126) repeat_until -> REPEAT LBRACE maybe_newline . statements RBRACE UNTIL LPAREN expression RPAREN
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 281
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 254

    (21) var_tail -> EQ tail_value var_tail2 .

    NEWLINE         reduce using rule 21 (var_tail -> EQ tail_value var_tail2 .)


state 255

    (23) var_tail2 -> empty .

    NEWLINE         reduce using rule 23 (var_tail2 -> empty .)


state 256

    (24) var_tail2 -> COMMA . IDENT var_tail

    IDENT           shift and go to state 282


state 257

    (26) tail_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 283


state 258

    (22) var_tail -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 22 (var_tail -> COMMA IDENT var_tail .)


state 259

    (40) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 284


state 260

    (44) typecast_value -> expression .

    RPAREN          reduce using rule 44 (typecast_value -> expression .)


state 261

    (45) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 285


state 262

    (46) typecast_value -> input_statement .

    RPAREN          reduce using rule 46 (typecast_value -> input_statement .)


state 263

    (145) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 286


state 264

    (41) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 287


state 265

    (42) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 288


state 266

    (43) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 289


state 267

    (156) stringcon_tail -> PLUS . string_val stringcon_tail
    (157) string_val -> . var_call
    (158) string_val -> . STR_LIT
    (77) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 236
    IDENT           shift and go to state 56

    string_val                     shift and go to state 290
    var_call                       shift and go to state 235

state 268

    (147) string_operation_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 147 (string_operation_tail -> PLUS string_val stringcon_tail .)


state 269

    (155) stringcon_tail -> empty .

    NEWLINE         reduce using rule 155 (stringcon_tail -> empty .)


state 270

    (111) conditional_statement -> CHECK LPAREN expression RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 291
    empty                          shift and go to state 16

state 271

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 292


state 272

    (133) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 133 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 133 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 133 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 133 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 133 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 273

    (136) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 136 (arguments -> arg_value arg_tail .)


state 274

    (137) arg_tail -> empty .

    RPAREN          reduce using rule 137 (arg_tail -> empty .)


state 275

    (138) arg_tail -> COMMA . arg_value arg_tail
    (139) arg_value -> . literal
    (140) arg_value -> . var_call
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT
    (77) var_call -> . IDENT var_call_tail

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    IDENT           shift and go to state 56

    arg_value                      shift and go to state 293
    literal                        shift and go to state 243
    var_call                       shift and go to state 244

state 276

    (144) next_val -> COMMA value . next_val
    (143) next_val -> . empty
    (144) next_val -> . COMMA value next_val
    (159) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 247
    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    RPAREN          reduce using rule 159 (empty -> .)
    COLON           reduce using rule 159 (empty -> .)

  ! COMMA           [ reduce using rule 159 (empty -> .) ]

    next_val                       shift and go to state 294
    empty                          shift and go to state 246

state 277

    (142) output_statement -> DISPLAY LPAREN value next_val . RPAREN

    RPAREN          shift and go to state 295


state 278

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 296
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 279

    (127) control_variable -> INT IDENT . EQ INT_LIT

    EQ              shift and go to state 297


state 280

    (125) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 298


state 281

    (126) repeat_until -> REPEAT LBRACE maybe_newline statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 299


state 282

    (24) var_tail2 -> COMMA IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (159) empty -> .

    EQ              shift and go to state 178
    COMMA           shift and go to state 179
    NEWLINE         reduce using rule 159 (empty -> .)

    var_tail                       shift and go to state 300
    empty                          shift and go to state 177

state 283

    (26) tail_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 26 (tail_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 26 (tail_value -> LBRACKET list_element RBRACKET .)


state 284

    (40) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 285

    (45) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 301


state 286

    (145) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 302


state 287

    (41) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 288

    (42) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 289

    (43) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 290

    (156) stringcon_tail -> PLUS string_val . stringcon_tail
    (155) stringcon_tail -> . empty
    (156) stringcon_tail -> . PLUS string_val stringcon_tail
    (159) empty -> .

    PLUS            shift and go to state 267
    NEWLINE         reduce using rule 159 (empty -> .)

    stringcon_tail                 shift and go to state 303
    empty                          shift and go to state 269

state 291

    (111) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    LBRACE          shift and go to state 304


state 292

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    SHIFT           reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 305
    empty                          shift and go to state 16

state 293

    (138) arg_tail -> COMMA arg_value . arg_tail
    (137) arg_tail -> . empty
    (138) arg_tail -> . COMMA arg_value arg_tail
    (159) empty -> .

    COMMA           shift and go to state 275
    RPAREN          reduce using rule 159 (empty -> .)

    arg_tail                       shift and go to state 306
    empty                          shift and go to state 274

state 294

    (144) next_val -> COMMA value next_val .

    COMMA           reduce using rule 144 (next_val -> COMMA value next_val .)
    NEWLINE         reduce using rule 144 (next_val -> COMMA value next_val .)
    RBRACE          reduce using rule 144 (next_val -> COMMA value next_val .)
    RPAREN          reduce using rule 144 (next_val -> COMMA value next_val .)
    COLON           reduce using rule 144 (next_val -> COMMA value next_val .)


state 295

    (142) output_statement -> DISPLAY LPAREN value next_val RPAREN .

    NEWLINE         reduce using rule 142 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)
    RBRACE          reduce using rule 142 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)
    COMMA           reduce using rule 142 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)
    RPAREN          reduce using rule 142 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)
    COLON           reduce using rule 142 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)


state 296

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 307


state 297

    (127) control_variable -> INT IDENT EQ . INT_LIT

    INT_LIT         shift and go to state 308


state 298

    (125) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 309
    empty                          shift and go to state 16

state 299

    (126) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 310


state 300

    (24) var_tail2 -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 24 (var_tail2 -> COMMA IDENT var_tail .)


state 301

    (45) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 45 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 302

    (145) input_statement -> INPUT LPAREN RPAREN .

    RPAREN          reduce using rule 145 (input_statement -> INPUT LPAREN RPAREN .)


state 303

    (156) stringcon_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 156 (stringcon_tail -> PLUS string_val stringcon_tail .)


state 304

    (111) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 311
    empty                          shift and go to state 16

state 305

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline . switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (118) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    SHIFT           shift and go to state 313

    switch_condition               shift and go to state 312

state 306

    (138) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 138 (arg_tail -> COMMA arg_value arg_tail .)


state 307

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (128) update -> . var_call update_tail
    (77) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 56

    update                         shift and go to state 314
    var_call                       shift and go to state 315

state 308

    (127) control_variable -> INT IDENT EQ INT_LIT .

    SEMICOLON       reduce using rule 127 (control_variable -> INT IDENT EQ INT_LIT .)


state 309

    (125) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline . statements RBRACE
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 316
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 310

    (126) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 317


state 311

    (111) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 318
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 312

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE       reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 319
    empty                          shift and go to state 16

state 313

    (118) switch_condition -> SHIFT . value COLON maybe_newline statements switchcond_tail
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . expr_head expr_tail
    (133) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (134) function_call -> . output_statement
    (54) expr_head -> . term term_tail
    (141) output_statement -> . DISPLAY value next_val
    (142) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 185
    CONVERT_TO_FLT  shift and go to state 186
    CONVERT_TO_BLN  shift and go to state 187
    CONVERT_TO_STR  shift and go to state 188
    FUNCTION_NAME   shift and go to state 171
    DISPLAY         shift and go to state 172
    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    value                          shift and go to state 320
    type_cast                      shift and go to state 182
    expression                     shift and go to state 183
    function_call                  shift and go to state 184
    expr_head                      shift and go to state 49
    output_statement               shift and go to state 189
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 314

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 321


state 315

    (128) update -> var_call . update_tail
    (129) update_tail -> . postfix
    (130) update_tail -> . assign_op value
    (131) postfix -> . PLUS_PLUS
    (132) postfix -> . MINUS_MINUS
    (149) assign_op -> . PLUS_EQ
    (150) assign_op -> . MINUS_EQ
    (151) assign_op -> . MUL_EQ
    (152) assign_op -> . DIV_EQ
    (153) assign_op -> . MOD_EQ
    (154) assign_op -> . EQ

    PLUS_PLUS       shift and go to state 201
    MINUS_MINUS     shift and go to state 202
    PLUS_EQ         shift and go to state 203
    MINUS_EQ        shift and go to state 204
    MUL_EQ          shift and go to state 205
    DIV_EQ          shift and go to state 206
    MOD_EQ          shift and go to state 207
    EQ              shift and go to state 208

    update_tail                    shift and go to state 322
    postfix                        shift and go to state 199
    assign_op                      shift and go to state 200

state 316

    (125) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 323


state 317

    (126) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN . expression RPAREN
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 324
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 318

    (111) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail

    RBRACE          shift and go to state 325


state 319

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    OTHERWISE       shift and go to state 326


state 320

    (118) switch_condition -> SHIFT value . COLON maybe_newline statements switchcond_tail

    COLON           shift and go to state 327


state 321

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 328
    empty                          shift and go to state 16

state 322

    (128) update -> var_call update_tail .

    RPAREN          reduce using rule 128 (update -> var_call update_tail .)


state 323

    (125) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 125 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .)


state 324

    (126) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 329


state 325

    (111) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 330
    empty                          shift and go to state 16

state 326

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 331
    empty                          shift and go to state 16

state 327

    (118) switch_condition -> SHIFT value COLON . maybe_newline statements switchcond_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    SHIFT           reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 332
    empty                          shift and go to state 16

state 328

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 333


state 329

    (126) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 126 (repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN .)


state 330

    (111) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail
    (112) conditional_tail -> . empty
    (113) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (114) conditional_tail -> . OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (159) empty -> .

    OTHERWISE_CHECK shift and go to state 336
    OTHERWISE       shift and go to state 337
    NEWLINE         reduce using rule 159 (empty -> .)

    conditional_tail               shift and go to state 334
    empty                          shift and go to state 335

state 331

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 338


state 332

    (118) switch_condition -> SHIFT value COLON maybe_newline . statements switchcond_tail
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    SHIFT           reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 339
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 333

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 340
    empty                          shift and go to state 16

state 334

    (111) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .

    NEWLINE         reduce using rule 111 (conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .)


state 335

    (112) conditional_tail -> empty .

    NEWLINE         reduce using rule 112 (conditional_tail -> empty .)


state 336

    (113) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    LPAREN          shift and go to state 341


state 337

    (114) conditional_tail -> OTHERWISE . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 342
    empty                          shift and go to state 16

state 338

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 343
    empty                          shift and go to state 16

state 339

    (118) switch_condition -> SHIFT value COLON maybe_newline statements . switchcond_tail
    (119) switchcond_tail -> . empty
    (120) switchcond_tail -> . switch_condition
    (159) empty -> .
    (118) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    NEWLINE         reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)
    SHIFT           shift and go to state 313

    switchcond_tail                shift and go to state 344
    empty                          shift and go to state 345
    switch_condition               shift and go to state 346

state 340

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 347
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 341

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 348
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 342

    (114) conditional_tail -> OTHERWISE maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 349


state 343

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline RBRACE
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 350
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 344

    (118) switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .

    NEWLINE         reduce using rule 118 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)
    OTHERWISE       reduce using rule 118 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)


state 345

    (119) switchcond_tail -> empty .

    NEWLINE         reduce using rule 119 (switchcond_tail -> empty .)
    OTHERWISE       reduce using rule 119 (switchcond_tail -> empty .)


state 346

    (120) switchcond_tail -> switch_condition .

    NEWLINE         reduce using rule 120 (switchcond_tail -> switch_condition .)
    OTHERWISE       reduce using rule 120 (switchcond_tail -> switch_condition .)


state 347

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 351


state 348

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    RPAREN          shift and go to state 352


state 349

    (114) conditional_tail -> OTHERWISE maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 353
    empty                          shift and go to state 16

state 350

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 354
    empty                          shift and go to state 16

state 351

    (124) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 124 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .)


state 352

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 355
    empty                          shift and go to state 16

state 353

    (114) conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline . statements RBRACE
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 356
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 354

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline RBRACE

    RBRACE          shift and go to state 357


state 355

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    LBRACE          shift and go to state 358


state 356

    (114) conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 359


state 357

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 360
    empty                          shift and go to state 16

state 358

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 361
    empty                          shift and go to state 16

state 359

    (114) conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 114 (conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .)


state 360

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . RBRACE

    RBRACE          shift and go to state 362


state 361

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail2
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 363
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 362

    (117) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .

    NEWLINE         reduce using rule 117 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .)


state 363

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail2

    RBRACE          shift and go to state 364


state 364

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 365
    empty                          shift and go to state 16

state 365

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail2
    (115) conditional_tail2 -> . OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (116) conditional_tail2 -> . OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    OTHERWISE_CHECK shift and go to state 366
    OTHERWISE       shift and go to state 368

    conditional_tail2              shift and go to state 367

state 366

    (115) conditional_tail2 -> OTHERWISE_CHECK . LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    LPAREN          shift and go to state 369


state 367

    (113) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2 .

    NEWLINE         reduce using rule 113 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2 .)


state 368

    (116) conditional_tail2 -> OTHERWISE . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 370
    empty                          shift and go to state 16

state 369

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN . expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (53) expression -> . expr_head expr_tail
    (54) expr_head -> . term term_tail
    (55) term -> . factor factor_tail
    (56) factor -> . var_call
    (57) factor -> . literal
    (58) factor -> . TILDE literal
    (59) factor -> . LPAREN expression RPAREN
    (77) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 54
    LPAREN          shift and go to state 55
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 371
    expr_head                      shift and go to state 49
    term                           shift and go to state 50
    factor                         shift and go to state 51
    var_call                       shift and go to state 52
    literal                        shift and go to state 53

state 370

    (116) conditional_tail2 -> OTHERWISE maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 372


state 371

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    RPAREN          shift and go to state 373


state 372

    (116) conditional_tail2 -> OTHERWISE maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 374
    empty                          shift and go to state 16

state 373

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 375
    empty                          shift and go to state 16

state 374

    (116) conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline . statements RBRACE
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 376
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 375

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    LBRACE          shift and go to state 377


state 376

    (116) conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 378


state 377

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 159 (empty -> .)
    FLT             reduce using rule 159 (empty -> .)
    BLN             reduce using rule 159 (empty -> .)
    CHR             reduce using rule 159 (empty -> .)
    STR             reduce using rule 159 (empty -> .)
    RBRACE          reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)

  ! NEWLINE         [ reduce using rule 159 (empty -> .) ]

    maybe_newline                  shift and go to state 379
    empty                          shift and go to state 16

state 378

    (116) conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 116 (conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .)


state 379

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail2
    (100) statements -> . empty
    (101) statements -> . local_dec maybe_newline statements_tail
    (159) empty -> .
    (109) local_dec -> . empty
    (110) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    RBRACE          reduce using rule 159 (empty -> .)
    NEWLINE         reduce using rule 159 (empty -> .)
    CHECK           reduce using rule 159 (empty -> .)
    SWAP            reduce using rule 159 (empty -> .)
    FUNCTION_NAME   reduce using rule 159 (empty -> .)
    DISPLAY         reduce using rule 159 (empty -> .)
    IDENT           reduce using rule 159 (empty -> .)
    FOR             reduce using rule 159 (empty -> .)
    UNTIL           reduce using rule 159 (empty -> .)
    REPEAT          reduce using rule 159 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    statements                     shift and go to state 380
    empty                          shift and go to state 145
    local_dec                      shift and go to state 146
    var_statement                  shift and go to state 147
    data_type                      shift and go to state 148

state 380

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail2

    RBRACE          shift and go to state 381


state 381

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (159) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 159 (empty -> .)
    OTHERWISE       reduce using rule 159 (empty -> .)

    maybe_newline                  shift and go to state 382
    empty                          shift and go to state 16

state 382

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail2
    (115) conditional_tail2 -> . OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (116) conditional_tail2 -> . OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    OTHERWISE_CHECK shift and go to state 366
    OTHERWISE       shift and go to state 368

    conditional_tail2              shift and go to state 383

state 383

    (115) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2 .

    NEWLINE         reduce using rule 115 (conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 15 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 17 resolved as shift
WARNING: shift/reduce conflict for AND in state 49 resolved as shift
WARNING: shift/reduce conflict for OR in state 49 resolved as shift
WARNING: shift/reduce conflict for GT in state 50 resolved as shift
WARNING: shift/reduce conflict for LT in state 50 resolved as shift
WARNING: shift/reduce conflict for EQ_EQ in state 50 resolved as shift
WARNING: shift/reduce conflict for GT_EQ in state 50 resolved as shift
WARNING: shift/reduce conflict for LT_EQ in state 50 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 50 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 138 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 164 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 212 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 216 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 249 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 276 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 298 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 304 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 325 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 327 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 333 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 338 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 349 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 358 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 372 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 377 resolved as shift
WARNING: reduce/reduce conflict in state 145 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 145
