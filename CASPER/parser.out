Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_statement -> var_statement global_statement_tail
Rule 11    var_statement -> data_type IDENT list_dec
Rule 12    list_dec -> empty
Rule 13    list_dec -> LBRACKET RBRACKET _2d_list
Rule 14    _2d_list -> empty
Rule 15    _2d_list -> LBRACKET RBRACKET
Rule 16    global_statement_tail -> empty
Rule 17    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 18    global_statement_tail -> EQ global_value global_statement_tail2
Rule 19    global_statement_tail2 -> COMMA IDENT global_statement_tail
Rule 20    global_statement_tail2 -> empty
Rule 21    global_value -> expression
Rule 22    global_value -> list_value
Rule 23    list_value -> LBRACKET list_element RBRACKET
Rule 24    list_element -> literal element_tail
Rule 25    element_tail -> COMMA list_element
Rule 26    element_tail -> empty
Rule 27    data_type -> INT
Rule 28    data_type -> FLT
Rule 29    data_type -> BLN
Rule 30    data_type -> CHR
Rule 31    data_type -> STR
Rule 32    expression -> factor factor_tail
Rule 33    factor -> var_call postfix
Rule 34    factor -> literal1
Rule 35    factor -> TILDE INT_LIT
Rule 36    factor -> TILDE FLT_LIT
Rule 37    factor -> LPAREN expression RPAREN
Rule 38    factor_tail -> PLUS factor factor_tail
Rule 39    factor_tail -> MINUS factor factor_tail
Rule 40    factor_tail -> MULTIPLY factor factor_tail
Rule 41    factor_tail -> DIVISION factor factor_tail
Rule 42    factor_tail -> MODULO factor factor_tail
Rule 43    factor_tail -> EXPONENT factor factor_tail
Rule 44    factor_tail -> GT factor factor_tail
Rule 45    factor_tail -> LT factor factor_tail
Rule 46    factor_tail -> EQ_EQ factor factor_tail
Rule 47    factor_tail -> GT_EQ factor factor_tail
Rule 48    factor_tail -> LT_EQ factor factor_tail
Rule 49    factor_tail -> NOT_EQ factor factor_tail
Rule 50    factor_tail -> AND factor factor_tail
Rule 51    factor_tail -> OR factor factor_tail
Rule 52    factor_tail -> empty
Rule 53    literal -> literal1
Rule 54    literal -> literal2
Rule 55    literal1 -> INT_LIT
Rule 56    literal1 -> FLT_LIT
Rule 57    literal1 -> DAY
Rule 58    literal1 -> NIGHT
Rule 59    literal1 -> STR_LIT
Rule 60    literal2 -> CHR_LIT
Rule 61    function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail
Rule 62    function_statements -> empty
Rule 63    function_statements_tail -> function_statements
Rule 64    function_statements_tail -> empty
Rule 65    ret_type -> FUNCTION
Rule 66    ret_type -> function_dtype
Rule 67    function_dtype -> FUNCTION_INT
Rule 68    function_dtype -> FUNCTION_FLT
Rule 69    function_dtype -> FUNCTION_CHR
Rule 70    function_dtype -> FUNCTION_BLN
Rule 71    function_dtype -> FUNCTION_STR
Rule 72    function_dtype -> FUNCTION_LIST_INT
Rule 73    function_dtype -> FUNCTION_LIST_FLT
Rule 74    function_dtype -> FUNCTION_LIST_CHR
Rule 75    function_dtype -> FUNCTION_LIST_STR
Rule 76    function_dtype -> FUNCTION_LIST_BLN
Rule 77    parameters -> data_type IDENT parameters_tail
Rule 78    parameters -> empty
Rule 79    parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 80    parameters_tail -> empty
Rule 81    revive -> REVIVE value
Rule 82    revive -> empty
Rule 83    statements -> empty
Rule 84    statements -> local_dec maybe_newline statements_tail
Rule 85    statements_tail -> switch_statement unli_newline statements
Rule 86    statements_tail -> loop_statement unli_newline statements
Rule 87    statements_tail -> function_call unli_newline statements
Rule 88    statements_tail -> assignment_statement unli_newline statements
Rule 89    statements_tail -> output_statement unli_newline statements
Rule 90    statements_tail -> conditional_statement unli_newline statements
Rule 91    statements_tail -> statements
Rule 92    local_dec -> var_statement local_dec_tail
Rule 93    local_dec -> empty
Rule 94    local_dec_tail -> empty
Rule 95    local_dec_tail -> COMMA IDENT local_dec_tail
Rule 96    local_dec_tail -> EQ local_value local_dec_tail2
Rule 97    local_dec_tail2 -> COMMA IDENT local_dec_tail
Rule 98    local_dec_tail2 -> empty
Rule 99    local_value -> value
Rule 100   local_value -> list_value
Rule 101   conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 102   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
Rule 103   conditional_tail -> empty
Rule 104   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
Rule 105   switch_condition -> SHIFT value COLON statements switchcond_tail
Rule 106   switchcond_tail -> switch_condition
Rule 107   switchcond_tail -> empty
Rule 108   loop_statement -> for_loop
Rule 109   loop_statement -> until_loop
Rule 110   loop_statement -> repeat_until
Rule 111   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
Rule 112   until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
Rule 113   repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
Rule 114   control_variable -> INT IDENT EQ control_var_tail
Rule 115   control_var_tail -> INT_LIT
Rule 116   control_var_tail -> var_call
Rule 117   update -> var_call update_tail
Rule 118   update_tail -> postfix_op
Rule 119   update_tail -> compound_op value
Rule 120   postfix_op -> PLUS_PLUS
Rule 121   postfix_op -> MINUS_MINUS
Rule 122   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 123   function_call -> input_statement
Rule 124   arguments -> empty
Rule 125   arguments -> arg_value arg_tail
Rule 126   arg_tail -> COMMA arg_value arg_tail
Rule 127   arg_tail -> empty
Rule 128   arg_value -> literal
Rule 129   arg_value -> var_call
Rule 130   output_statement -> DISPLAY value next_val
Rule 131   next_val -> COMMA value next_val
Rule 132   next_val -> empty
Rule 133   assignment_statement -> IDENT assign_tail
Rule 134   assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
Rule 135   assign_tail -> DOT PUSH LPAREN list_element RPAREN
Rule 136   assign_tail -> assign_op value
Rule 137   assign_op -> compound_op
Rule 138   assign_op -> EQ
Rule 139   compound_op -> PLUS_EQ
Rule 140   compound_op -> MINUS_EQ
Rule 141   compound_op -> MUL_EQ
Rule 142   compound_op -> DIV_EQ
Rule 143   compound_op -> MOD_EQ
Rule 144   start -> INT_LIT
Rule 145   deleteCount -> empty
Rule 146   deleteCount -> INT_LIT
Rule 147   splice_items -> empty
Rule 148   splice_items -> list_element
Rule 149   var_call -> IDENT list_index
Rule 150   list_index -> LBRACKET index RBRACKET list_index2
Rule 151   list_index -> empty
Rule 152   list_index2 -> LBRACKET index RBRACKET
Rule 153   list_index2 -> empty
Rule 154   index -> INT_LIT
Rule 155   index -> IDENT
Rule 156   postfix -> empty
Rule 157   postfix -> postfix_op
Rule 158   value -> type_cast
Rule 159   value -> expression
Rule 160   value -> function_call
Rule 161   type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 162   type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 163   type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 164   type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 165   typecast_value -> expression
Rule 166   typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 167   typecast_value -> input_statement
Rule 168   input_statement -> INPUT LPAREN RPAREN
Rule 169   empty -> <empty>

Terminals, with rules where they appear

AND                  : 50
BIRTH                : 1
BLN                  : 29
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 101
CHR                  : 30
CHR_LIT              : 60
COLON                : 105
COMMA                : 17 19 25 79 95 97 126 131 134 134
COMMENT              : 
CONVERT_TO_BLN       : 163
CONVERT_TO_FLT       : 162
CONVERT_TO_INT       : 161
CONVERT_TO_STR       : 164
DAY                  : 57
DISPLAY              : 130
DIVISION             : 41
DIV_EQ               : 142
DOT                  : 134 135
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 18 96 114 138
EQ_EQ                : 46
EXPONENT             : 43
FLT                  : 28
FLT_LIT              : 36 56
FOR                  : 111
FUNCTION             : 65
FUNCTION_BLN         : 70
FUNCTION_CHR         : 69
FUNCTION_FLT         : 68
FUNCTION_INT         : 67
FUNCTION_LIST_BLN    : 76
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 74
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 73
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 72
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 75
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 61 122 166
FUNCTION_STR         : 71
GHOST                : 1
GT                   : 44
GT_EQ                : 47
IDENT                : 11 17 19 77 79 95 97 104 114 133 149 155
ILLEGAL              : 
IN                   : 
INPUT                : 168
INT                  : 27 114
INT_LIT              : 35 55 115 144 146 154
LBRACE               : 6 61 101 101 102 104 104 111 112 113
LBRACKET             : 13 15 23 150 152
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 37 61 101 102 104 111 112 113 122 134 135 161 162 163 164 166 168
LT                   : 45
LT_EQ                : 48
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 39
MINUS_EQ             : 140
MINUS_MINUS          : 121
MODULO               : 42
MOD_EQ               : 143
MULTIPLY             : 40
MUL_EQ               : 141
NEWLINE              : 3 4 5
NIGHT                : 58
NOT                  : 
NOT_EQ               : 49
OR                   : 51
OTHERWISE            : 101 104
OTHERWISE_CHECK      : 102
PLUS                 : 38
PLUS_EQ              : 139
PLUS_PLUS            : 120
POW                  : 
PUSH                 : 135
RBRACE               : 6 61 101 101 102 104 104 111 112 113
RBRACKET             : 13 15 23 150 152
REPEAT               : 113
REVIVE               : 81
RPAREN               : 6 37 61 101 102 104 111 112 113 122 134 135 161 162 163 164 166 168
SEMICOLON            : 111 111
SHIFT                : 105
SKIP                 : 
SPLICE               : 134
STOP                 : 
STR                  : 31
STR_LIT              : 59
SWAP                 : 104
TILDE                : 35 36
TYPE                 : 
UNTIL                : 112 113
error                : 

Nonterminals, with rules where they appear

_2d_list             : 13
arg_tail             : 125 126
arg_value            : 125 126
arguments            : 122
assign_op            : 136
assign_tail          : 133
assignment_statement : 88
compound_op          : 119 137
conditional_statement : 90
conditional_tail     : 101 102
control_var_tail     : 114
control_variable     : 111
data_type            : 11 77 79
deleteCount          : 134
element_tail         : 24
empty                : 2 8 12 14 16 20 26 52 62 64 78 80 82 83 93 94 98 103 107 124 127 132 145 147 151 153 156
expression           : 21 37 101 102 111 112 113 159 165
factor               : 32 38 39 40 41 42 43 44 45 46 47 48 49 50 51
factor_tail          : 32 38 39 40 41 42 43 44 45 46 47 48 49 50 51
for_loop             : 108
function_call        : 87 160
function_dtype       : 66
function_statements  : 1 63
function_statements_tail : 61
global_dec           : 1 9
global_statement     : 7
global_statement_tail : 10 17 19
global_statement_tail2 : 18
global_tail          : 7
global_value         : 18
index                : 150 152
input_statement      : 123 167
list_dec             : 11
list_element         : 23 25 135 148
list_index           : 149
list_index2          : 150
list_value           : 22 100
literal              : 24 128
literal1             : 34 53
literal2             : 54
local_dec            : 84
local_dec_tail       : 92 95 97
local_dec_tail2      : 96
local_value          : 96
loop_statement       : 86
main_function        : 1
maybe_newline        : 1 1 3 6 6 6 84 101 101 101 101 101 101 101
next_val             : 130 131
output_statement     : 89
parameters           : 61
parameters_tail      : 77 79
postfix              : 33
postfix_op           : 118 157
program              : 0
repeat_until         : 110
ret_type             : 61
revive               : 61
splice_items         : 134
start                : 134
statements           : 6 61 85 86 87 88 89 90 91 101 101 102 104 105 111 112 113
statements_tail      : 84
switch_condition     : 104 106
switch_statement     : 85
switchcond_tail      : 105
type_cast            : 158
typecast_value       : 161 162 163 164
unli_newline         : 1 1 5 85 86 87 88 89 90
until_loop           : 109
update               : 111
update_tail          : 117
value                : 81 99 105 119 130 131 136
var_call             : 33 116 117 129
var_statement        : 10 92

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . var_statement global_statement_tail
    (169) empty -> .
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    var_statement                  shift and go to state 8
    data_type                      shift and go to state 9

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    INPUT           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 15

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 16
    empty                          shift and go to state 17

state 6

    (7) global_dec -> global_statement . global_tail
    (9) global_tail -> . global_dec
    (7) global_dec -> . global_statement global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . var_statement global_statement_tail
    (169) empty -> .
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 19
    global_dec                     shift and go to state 20
    empty                          shift and go to state 7
    var_statement                  shift and go to state 8
    data_type                      shift and go to state 9

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)


state 8

    (10) global_statement -> var_statement . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (169) empty -> .

    COMMA           shift and go to state 23
    EQ              shift and go to state 24
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)

    global_statement_tail          shift and go to state 21
    empty                          shift and go to state 22

state 9

    (11) var_statement -> data_type . IDENT list_dec

    IDENT           shift and go to state 25


state 10

    (27) data_type -> INT .

    IDENT           reduce using rule 27 (data_type -> INT .)


state 11

    (28) data_type -> FLT .

    IDENT           reduce using rule 28 (data_type -> FLT .)


state 12

    (29) data_type -> BLN .

    IDENT           reduce using rule 29 (data_type -> BLN .)


state 13

    (30) data_type -> CHR .

    IDENT           reduce using rule 30 (data_type -> CHR .)


state 14

    (31) data_type -> STR .

    IDENT           reduce using rule 31 (data_type -> STR .)


state 15

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    INPUT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 16

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (61) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail
    (62) function_statements -> . empty
    (65) ret_type -> . FUNCTION
    (66) ret_type -> . function_dtype
    (169) empty -> .
    (67) function_dtype -> . FUNCTION_INT
    (68) function_dtype -> . FUNCTION_FLT
    (69) function_dtype -> . FUNCTION_CHR
    (70) function_dtype -> . FUNCTION_BLN
    (71) function_dtype -> . FUNCTION_STR
    (72) function_dtype -> . FUNCTION_LIST_INT
    (73) function_dtype -> . FUNCTION_LIST_FLT
    (74) function_dtype -> . FUNCTION_LIST_CHR
    (75) function_dtype -> . FUNCTION_LIST_STR
    (76) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 29
    NEWLINE         reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    FUNCTION_INT    shift and go to state 31
    FUNCTION_FLT    shift and go to state 32
    FUNCTION_CHR    shift and go to state 33
    FUNCTION_BLN    shift and go to state 34
    FUNCTION_STR    shift and go to state 35
    FUNCTION_LIST_INT shift and go to state 36
    FUNCTION_LIST_FLT shift and go to state 37
    FUNCTION_LIST_CHR shift and go to state 38
    FUNCTION_LIST_STR shift and go to state 39
    FUNCTION_LIST_BLN shift and go to state 40

    function_statements            shift and go to state 26
    ret_type                       shift and go to state 27
    empty                          shift and go to state 28
    function_dtype                 shift and go to state 30

state 17

    (2) maybe_newline -> empty .

    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    INPUT           reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE_CHECK reduce using rule 2 (maybe_newline -> empty .)


state 18

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    LBRACE          reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    OTHERWISE_CHECK reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 41
    empty                          shift and go to state 17

state 19

    (7) global_dec -> global_statement global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement global_tail .)


state 20

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)


state 21

    (10) global_statement -> var_statement global_statement_tail .

    INT             reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FLT             reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    BLN             reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    CHR             reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    STR             reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    NEWLINE         reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION        reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_INT    reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_FLT    reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_CHR    reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_BLN    reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_STR    reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_LIST_INT reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_LIST_FLT reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_LIST_CHR reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_LIST_STR reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    FUNCTION_LIST_BLN reduce using rule 10 (global_statement -> var_statement global_statement_tail .)
    MAIN_CASPER     reduce using rule 10 (global_statement -> var_statement global_statement_tail .)


state 22

    (16) global_statement_tail -> empty .

    INT             reduce using rule 16 (global_statement_tail -> empty .)
    FLT             reduce using rule 16 (global_statement_tail -> empty .)
    BLN             reduce using rule 16 (global_statement_tail -> empty .)
    CHR             reduce using rule 16 (global_statement_tail -> empty .)
    STR             reduce using rule 16 (global_statement_tail -> empty .)
    NEWLINE         reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION        reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_INT    reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_FLT    reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_CHR    reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_BLN    reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_STR    reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_LIST_INT reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_LIST_FLT reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_LIST_CHR reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_LIST_STR reduce using rule 16 (global_statement_tail -> empty .)
    FUNCTION_LIST_BLN reduce using rule 16 (global_statement_tail -> empty .)
    MAIN_CASPER     reduce using rule 16 (global_statement_tail -> empty .)


state 23

    (17) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 42


state 24

    (18) global_statement_tail -> EQ . global_value global_statement_tail2
    (21) global_value -> . expression
    (22) global_value -> . list_value
    (32) expression -> . factor factor_tail
    (23) list_value -> . LBRACKET list_element RBRACKET
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    LBRACKET        shift and go to state 47
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    global_value                   shift and go to state 43
    expression                     shift and go to state 44
    list_value                     shift and go to state 45
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 25

    (11) var_statement -> data_type IDENT . list_dec
    (12) list_dec -> . empty
    (13) list_dec -> . LBRACKET RBRACKET _2d_list
    (169) empty -> .

    LBRACKET        shift and go to state 60
    COMMA           reduce using rule 169 (empty -> .)
    EQ              reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    list_dec                       shift and go to state 58
    empty                          shift and go to state 59

state 26

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    MAIN_CASPER     reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 61
    empty                          shift and go to state 17

state 27

    (61) function_statements -> ret_type . FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail

    FUNCTION_NAME   shift and go to state 62


state 28

    (62) function_statements -> empty .

    NEWLINE         reduce using rule 62 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 62 (function_statements -> empty .)


state 29

    (65) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 65 (ret_type -> FUNCTION .)


state 30

    (66) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 66 (ret_type -> function_dtype .)


state 31

    (67) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 67 (function_dtype -> FUNCTION_INT .)


state 32

    (68) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 68 (function_dtype -> FUNCTION_FLT .)


state 33

    (69) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 69 (function_dtype -> FUNCTION_CHR .)


state 34

    (70) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 70 (function_dtype -> FUNCTION_BLN .)


state 35

    (71) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 71 (function_dtype -> FUNCTION_STR .)


state 36

    (72) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 72 (function_dtype -> FUNCTION_LIST_INT .)


state 37

    (73) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 73 (function_dtype -> FUNCTION_LIST_FLT .)


state 38

    (74) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 74 (function_dtype -> FUNCTION_LIST_CHR .)


state 39

    (75) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 75 (function_dtype -> FUNCTION_LIST_STR .)


state 40

    (76) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 76 (function_dtype -> FUNCTION_LIST_BLN .)


state 41

    (3) maybe_newline -> NEWLINE maybe_newline .

    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INPUT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE_CHECK reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 42

    (17) global_statement_tail -> COMMA IDENT . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (169) empty -> .

    COMMA           shift and go to state 23
    EQ              shift and go to state 24
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)

    global_statement_tail          shift and go to state 63
    empty                          shift and go to state 22

state 43

    (18) global_statement_tail -> EQ global_value . global_statement_tail2
    (19) global_statement_tail2 -> . COMMA IDENT global_statement_tail
    (20) global_statement_tail2 -> . empty
    (169) empty -> .

    COMMA           shift and go to state 65
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)

    global_statement_tail2         shift and go to state 64
    empty                          shift and go to state 66

state 44

    (21) global_value -> expression .

    COMMA           reduce using rule 21 (global_value -> expression .)
    INT             reduce using rule 21 (global_value -> expression .)
    FLT             reduce using rule 21 (global_value -> expression .)
    BLN             reduce using rule 21 (global_value -> expression .)
    CHR             reduce using rule 21 (global_value -> expression .)
    STR             reduce using rule 21 (global_value -> expression .)
    NEWLINE         reduce using rule 21 (global_value -> expression .)
    FUNCTION        reduce using rule 21 (global_value -> expression .)
    FUNCTION_INT    reduce using rule 21 (global_value -> expression .)
    FUNCTION_FLT    reduce using rule 21 (global_value -> expression .)
    FUNCTION_CHR    reduce using rule 21 (global_value -> expression .)
    FUNCTION_BLN    reduce using rule 21 (global_value -> expression .)
    FUNCTION_STR    reduce using rule 21 (global_value -> expression .)
    FUNCTION_LIST_INT reduce using rule 21 (global_value -> expression .)
    FUNCTION_LIST_FLT reduce using rule 21 (global_value -> expression .)
    FUNCTION_LIST_CHR reduce using rule 21 (global_value -> expression .)
    FUNCTION_LIST_STR reduce using rule 21 (global_value -> expression .)
    FUNCTION_LIST_BLN reduce using rule 21 (global_value -> expression .)
    MAIN_CASPER     reduce using rule 21 (global_value -> expression .)


state 45

    (22) global_value -> list_value .

    COMMA           reduce using rule 22 (global_value -> list_value .)
    INT             reduce using rule 22 (global_value -> list_value .)
    FLT             reduce using rule 22 (global_value -> list_value .)
    BLN             reduce using rule 22 (global_value -> list_value .)
    CHR             reduce using rule 22 (global_value -> list_value .)
    STR             reduce using rule 22 (global_value -> list_value .)
    NEWLINE         reduce using rule 22 (global_value -> list_value .)
    FUNCTION        reduce using rule 22 (global_value -> list_value .)
    FUNCTION_INT    reduce using rule 22 (global_value -> list_value .)
    FUNCTION_FLT    reduce using rule 22 (global_value -> list_value .)
    FUNCTION_CHR    reduce using rule 22 (global_value -> list_value .)
    FUNCTION_BLN    reduce using rule 22 (global_value -> list_value .)
    FUNCTION_STR    reduce using rule 22 (global_value -> list_value .)
    FUNCTION_LIST_INT reduce using rule 22 (global_value -> list_value .)
    FUNCTION_LIST_FLT reduce using rule 22 (global_value -> list_value .)
    FUNCTION_LIST_CHR reduce using rule 22 (global_value -> list_value .)
    FUNCTION_LIST_STR reduce using rule 22 (global_value -> list_value .)
    FUNCTION_LIST_BLN reduce using rule 22 (global_value -> list_value .)
    MAIN_CASPER     reduce using rule 22 (global_value -> list_value .)


state 46

    (32) expression -> factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 67
    empty                          shift and go to state 82

state 47

    (23) list_value -> LBRACKET . list_element RBRACKET
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57
    CHR_LIT         shift and go to state 87

    list_element                   shift and go to state 83
    literal                        shift and go to state 84
    literal1                       shift and go to state 85
    literal2                       shift and go to state 86

state 48

    (33) factor -> var_call . postfix
    (156) postfix -> . empty
    (157) postfix -> . postfix_op
    (169) empty -> .
    (120) postfix_op -> . PLUS_PLUS
    (121) postfix_op -> . MINUS_MINUS

    PLUS            reduce using rule 169 (empty -> .)
    MINUS           reduce using rule 169 (empty -> .)
    MULTIPLY        reduce using rule 169 (empty -> .)
    DIVISION        reduce using rule 169 (empty -> .)
    MODULO          reduce using rule 169 (empty -> .)
    EXPONENT        reduce using rule 169 (empty -> .)
    GT              reduce using rule 169 (empty -> .)
    LT              reduce using rule 169 (empty -> .)
    EQ_EQ           reduce using rule 169 (empty -> .)
    GT_EQ           reduce using rule 169 (empty -> .)
    LT_EQ           reduce using rule 169 (empty -> .)
    NOT_EQ          reduce using rule 169 (empty -> .)
    AND             reduce using rule 169 (empty -> .)
    OR              reduce using rule 169 (empty -> .)
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)
    PLUS_PLUS       shift and go to state 91
    MINUS_MINUS     shift and go to state 92

    postfix                        shift and go to state 88
    empty                          shift and go to state 89
    postfix_op                     shift and go to state 90

state 49

    (34) factor -> literal1 .

    PLUS            reduce using rule 34 (factor -> literal1 .)
    MINUS           reduce using rule 34 (factor -> literal1 .)
    MULTIPLY        reduce using rule 34 (factor -> literal1 .)
    DIVISION        reduce using rule 34 (factor -> literal1 .)
    MODULO          reduce using rule 34 (factor -> literal1 .)
    EXPONENT        reduce using rule 34 (factor -> literal1 .)
    GT              reduce using rule 34 (factor -> literal1 .)
    LT              reduce using rule 34 (factor -> literal1 .)
    EQ_EQ           reduce using rule 34 (factor -> literal1 .)
    GT_EQ           reduce using rule 34 (factor -> literal1 .)
    LT_EQ           reduce using rule 34 (factor -> literal1 .)
    NOT_EQ          reduce using rule 34 (factor -> literal1 .)
    AND             reduce using rule 34 (factor -> literal1 .)
    OR              reduce using rule 34 (factor -> literal1 .)
    COMMA           reduce using rule 34 (factor -> literal1 .)
    INT             reduce using rule 34 (factor -> literal1 .)
    FLT             reduce using rule 34 (factor -> literal1 .)
    BLN             reduce using rule 34 (factor -> literal1 .)
    CHR             reduce using rule 34 (factor -> literal1 .)
    STR             reduce using rule 34 (factor -> literal1 .)
    NEWLINE         reduce using rule 34 (factor -> literal1 .)
    FUNCTION        reduce using rule 34 (factor -> literal1 .)
    FUNCTION_INT    reduce using rule 34 (factor -> literal1 .)
    FUNCTION_FLT    reduce using rule 34 (factor -> literal1 .)
    FUNCTION_CHR    reduce using rule 34 (factor -> literal1 .)
    FUNCTION_BLN    reduce using rule 34 (factor -> literal1 .)
    FUNCTION_STR    reduce using rule 34 (factor -> literal1 .)
    FUNCTION_LIST_INT reduce using rule 34 (factor -> literal1 .)
    FUNCTION_LIST_FLT reduce using rule 34 (factor -> literal1 .)
    FUNCTION_LIST_CHR reduce using rule 34 (factor -> literal1 .)
    FUNCTION_LIST_STR reduce using rule 34 (factor -> literal1 .)
    FUNCTION_LIST_BLN reduce using rule 34 (factor -> literal1 .)
    MAIN_CASPER     reduce using rule 34 (factor -> literal1 .)
    RPAREN          reduce using rule 34 (factor -> literal1 .)
    RBRACE          reduce using rule 34 (factor -> literal1 .)
    SWAP            reduce using rule 34 (factor -> literal1 .)
    FUNCTION_NAME   reduce using rule 34 (factor -> literal1 .)
    IDENT           reduce using rule 34 (factor -> literal1 .)
    DISPLAY         reduce using rule 34 (factor -> literal1 .)
    CHECK           reduce using rule 34 (factor -> literal1 .)
    FOR             reduce using rule 34 (factor -> literal1 .)
    UNTIL           reduce using rule 34 (factor -> literal1 .)
    REPEAT          reduce using rule 34 (factor -> literal1 .)
    INPUT           reduce using rule 34 (factor -> literal1 .)
    REVIVE          reduce using rule 34 (factor -> literal1 .)
    SHIFT           reduce using rule 34 (factor -> literal1 .)
    OTHERWISE       reduce using rule 34 (factor -> literal1 .)
    SEMICOLON       reduce using rule 34 (factor -> literal1 .)
    COLON           reduce using rule 34 (factor -> literal1 .)


state 50

    (35) factor -> TILDE . INT_LIT
    (36) factor -> TILDE . FLT_LIT

    INT_LIT         shift and go to state 93
    FLT_LIT         shift and go to state 94


state 51

    (55) literal1 -> INT_LIT .

    PLUS            reduce using rule 55 (literal1 -> INT_LIT .)
    MINUS           reduce using rule 55 (literal1 -> INT_LIT .)
    MULTIPLY        reduce using rule 55 (literal1 -> INT_LIT .)
    DIVISION        reduce using rule 55 (literal1 -> INT_LIT .)
    MODULO          reduce using rule 55 (literal1 -> INT_LIT .)
    EXPONENT        reduce using rule 55 (literal1 -> INT_LIT .)
    GT              reduce using rule 55 (literal1 -> INT_LIT .)
    LT              reduce using rule 55 (literal1 -> INT_LIT .)
    EQ_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    GT_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    LT_EQ           reduce using rule 55 (literal1 -> INT_LIT .)
    NOT_EQ          reduce using rule 55 (literal1 -> INT_LIT .)
    AND             reduce using rule 55 (literal1 -> INT_LIT .)
    OR              reduce using rule 55 (literal1 -> INT_LIT .)
    COMMA           reduce using rule 55 (literal1 -> INT_LIT .)
    INT             reduce using rule 55 (literal1 -> INT_LIT .)
    FLT             reduce using rule 55 (literal1 -> INT_LIT .)
    BLN             reduce using rule 55 (literal1 -> INT_LIT .)
    CHR             reduce using rule 55 (literal1 -> INT_LIT .)
    STR             reduce using rule 55 (literal1 -> INT_LIT .)
    NEWLINE         reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION        reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_INT    reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_FLT    reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_CHR    reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_BLN    reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_STR    reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_LIST_INT reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_LIST_FLT reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_LIST_CHR reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_LIST_STR reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_LIST_BLN reduce using rule 55 (literal1 -> INT_LIT .)
    MAIN_CASPER     reduce using rule 55 (literal1 -> INT_LIT .)
    RBRACKET        reduce using rule 55 (literal1 -> INT_LIT .)
    RPAREN          reduce using rule 55 (literal1 -> INT_LIT .)
    RBRACE          reduce using rule 55 (literal1 -> INT_LIT .)
    SWAP            reduce using rule 55 (literal1 -> INT_LIT .)
    FUNCTION_NAME   reduce using rule 55 (literal1 -> INT_LIT .)
    IDENT           reduce using rule 55 (literal1 -> INT_LIT .)
    DISPLAY         reduce using rule 55 (literal1 -> INT_LIT .)
    CHECK           reduce using rule 55 (literal1 -> INT_LIT .)
    FOR             reduce using rule 55 (literal1 -> INT_LIT .)
    UNTIL           reduce using rule 55 (literal1 -> INT_LIT .)
    REPEAT          reduce using rule 55 (literal1 -> INT_LIT .)
    INPUT           reduce using rule 55 (literal1 -> INT_LIT .)
    REVIVE          reduce using rule 55 (literal1 -> INT_LIT .)
    SHIFT           reduce using rule 55 (literal1 -> INT_LIT .)
    OTHERWISE       reduce using rule 55 (literal1 -> INT_LIT .)
    SEMICOLON       reduce using rule 55 (literal1 -> INT_LIT .)
    COLON           reduce using rule 55 (literal1 -> INT_LIT .)


state 52

    (56) literal1 -> FLT_LIT .

    PLUS            reduce using rule 56 (literal1 -> FLT_LIT .)
    MINUS           reduce using rule 56 (literal1 -> FLT_LIT .)
    MULTIPLY        reduce using rule 56 (literal1 -> FLT_LIT .)
    DIVISION        reduce using rule 56 (literal1 -> FLT_LIT .)
    MODULO          reduce using rule 56 (literal1 -> FLT_LIT .)
    EXPONENT        reduce using rule 56 (literal1 -> FLT_LIT .)
    GT              reduce using rule 56 (literal1 -> FLT_LIT .)
    LT              reduce using rule 56 (literal1 -> FLT_LIT .)
    EQ_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    GT_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    LT_EQ           reduce using rule 56 (literal1 -> FLT_LIT .)
    NOT_EQ          reduce using rule 56 (literal1 -> FLT_LIT .)
    AND             reduce using rule 56 (literal1 -> FLT_LIT .)
    OR              reduce using rule 56 (literal1 -> FLT_LIT .)
    COMMA           reduce using rule 56 (literal1 -> FLT_LIT .)
    INT             reduce using rule 56 (literal1 -> FLT_LIT .)
    FLT             reduce using rule 56 (literal1 -> FLT_LIT .)
    BLN             reduce using rule 56 (literal1 -> FLT_LIT .)
    CHR             reduce using rule 56 (literal1 -> FLT_LIT .)
    STR             reduce using rule 56 (literal1 -> FLT_LIT .)
    NEWLINE         reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION        reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_INT    reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_FLT    reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_CHR    reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_BLN    reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_STR    reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_LIST_INT reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_LIST_FLT reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_LIST_CHR reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_LIST_STR reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_LIST_BLN reduce using rule 56 (literal1 -> FLT_LIT .)
    MAIN_CASPER     reduce using rule 56 (literal1 -> FLT_LIT .)
    RBRACKET        reduce using rule 56 (literal1 -> FLT_LIT .)
    RPAREN          reduce using rule 56 (literal1 -> FLT_LIT .)
    RBRACE          reduce using rule 56 (literal1 -> FLT_LIT .)
    SWAP            reduce using rule 56 (literal1 -> FLT_LIT .)
    FUNCTION_NAME   reduce using rule 56 (literal1 -> FLT_LIT .)
    IDENT           reduce using rule 56 (literal1 -> FLT_LIT .)
    DISPLAY         reduce using rule 56 (literal1 -> FLT_LIT .)
    CHECK           reduce using rule 56 (literal1 -> FLT_LIT .)
    FOR             reduce using rule 56 (literal1 -> FLT_LIT .)
    UNTIL           reduce using rule 56 (literal1 -> FLT_LIT .)
    REPEAT          reduce using rule 56 (literal1 -> FLT_LIT .)
    INPUT           reduce using rule 56 (literal1 -> FLT_LIT .)
    REVIVE          reduce using rule 56 (literal1 -> FLT_LIT .)
    SHIFT           reduce using rule 56 (literal1 -> FLT_LIT .)
    OTHERWISE       reduce using rule 56 (literal1 -> FLT_LIT .)
    SEMICOLON       reduce using rule 56 (literal1 -> FLT_LIT .)
    COLON           reduce using rule 56 (literal1 -> FLT_LIT .)


state 53

    (37) factor -> LPAREN . expression RPAREN
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    expression                     shift and go to state 95
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 54

    (149) var_call -> IDENT . list_index
    (150) list_index -> . LBRACKET index RBRACKET list_index2
    (151) list_index -> . empty
    (169) empty -> .

    LBRACKET        shift and go to state 97
    PLUS_PLUS       reduce using rule 169 (empty -> .)
    MINUS_MINUS     reduce using rule 169 (empty -> .)
    PLUS            reduce using rule 169 (empty -> .)
    MINUS           reduce using rule 169 (empty -> .)
    MULTIPLY        reduce using rule 169 (empty -> .)
    DIVISION        reduce using rule 169 (empty -> .)
    MODULO          reduce using rule 169 (empty -> .)
    EXPONENT        reduce using rule 169 (empty -> .)
    GT              reduce using rule 169 (empty -> .)
    LT              reduce using rule 169 (empty -> .)
    EQ_EQ           reduce using rule 169 (empty -> .)
    GT_EQ           reduce using rule 169 (empty -> .)
    LT_EQ           reduce using rule 169 (empty -> .)
    NOT_EQ          reduce using rule 169 (empty -> .)
    AND             reduce using rule 169 (empty -> .)
    OR              reduce using rule 169 (empty -> .)
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)
    PLUS_EQ         reduce using rule 169 (empty -> .)
    MINUS_EQ        reduce using rule 169 (empty -> .)
    MUL_EQ          reduce using rule 169 (empty -> .)
    DIV_EQ          reduce using rule 169 (empty -> .)
    MOD_EQ          reduce using rule 169 (empty -> .)

    list_index                     shift and go to state 96
    empty                          shift and go to state 98

state 55

    (57) literal1 -> DAY .

    PLUS            reduce using rule 57 (literal1 -> DAY .)
    MINUS           reduce using rule 57 (literal1 -> DAY .)
    MULTIPLY        reduce using rule 57 (literal1 -> DAY .)
    DIVISION        reduce using rule 57 (literal1 -> DAY .)
    MODULO          reduce using rule 57 (literal1 -> DAY .)
    EXPONENT        reduce using rule 57 (literal1 -> DAY .)
    GT              reduce using rule 57 (literal1 -> DAY .)
    LT              reduce using rule 57 (literal1 -> DAY .)
    EQ_EQ           reduce using rule 57 (literal1 -> DAY .)
    GT_EQ           reduce using rule 57 (literal1 -> DAY .)
    LT_EQ           reduce using rule 57 (literal1 -> DAY .)
    NOT_EQ          reduce using rule 57 (literal1 -> DAY .)
    AND             reduce using rule 57 (literal1 -> DAY .)
    OR              reduce using rule 57 (literal1 -> DAY .)
    COMMA           reduce using rule 57 (literal1 -> DAY .)
    INT             reduce using rule 57 (literal1 -> DAY .)
    FLT             reduce using rule 57 (literal1 -> DAY .)
    BLN             reduce using rule 57 (literal1 -> DAY .)
    CHR             reduce using rule 57 (literal1 -> DAY .)
    STR             reduce using rule 57 (literal1 -> DAY .)
    NEWLINE         reduce using rule 57 (literal1 -> DAY .)
    FUNCTION        reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_INT    reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_FLT    reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_CHR    reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_BLN    reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_STR    reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_LIST_INT reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_LIST_FLT reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_LIST_CHR reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_LIST_STR reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_LIST_BLN reduce using rule 57 (literal1 -> DAY .)
    MAIN_CASPER     reduce using rule 57 (literal1 -> DAY .)
    RBRACKET        reduce using rule 57 (literal1 -> DAY .)
    RPAREN          reduce using rule 57 (literal1 -> DAY .)
    RBRACE          reduce using rule 57 (literal1 -> DAY .)
    SWAP            reduce using rule 57 (literal1 -> DAY .)
    FUNCTION_NAME   reduce using rule 57 (literal1 -> DAY .)
    IDENT           reduce using rule 57 (literal1 -> DAY .)
    DISPLAY         reduce using rule 57 (literal1 -> DAY .)
    CHECK           reduce using rule 57 (literal1 -> DAY .)
    FOR             reduce using rule 57 (literal1 -> DAY .)
    UNTIL           reduce using rule 57 (literal1 -> DAY .)
    REPEAT          reduce using rule 57 (literal1 -> DAY .)
    INPUT           reduce using rule 57 (literal1 -> DAY .)
    REVIVE          reduce using rule 57 (literal1 -> DAY .)
    SHIFT           reduce using rule 57 (literal1 -> DAY .)
    OTHERWISE       reduce using rule 57 (literal1 -> DAY .)
    SEMICOLON       reduce using rule 57 (literal1 -> DAY .)
    COLON           reduce using rule 57 (literal1 -> DAY .)


state 56

    (58) literal1 -> NIGHT .

    PLUS            reduce using rule 58 (literal1 -> NIGHT .)
    MINUS           reduce using rule 58 (literal1 -> NIGHT .)
    MULTIPLY        reduce using rule 58 (literal1 -> NIGHT .)
    DIVISION        reduce using rule 58 (literal1 -> NIGHT .)
    MODULO          reduce using rule 58 (literal1 -> NIGHT .)
    EXPONENT        reduce using rule 58 (literal1 -> NIGHT .)
    GT              reduce using rule 58 (literal1 -> NIGHT .)
    LT              reduce using rule 58 (literal1 -> NIGHT .)
    EQ_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    GT_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    LT_EQ           reduce using rule 58 (literal1 -> NIGHT .)
    NOT_EQ          reduce using rule 58 (literal1 -> NIGHT .)
    AND             reduce using rule 58 (literal1 -> NIGHT .)
    OR              reduce using rule 58 (literal1 -> NIGHT .)
    COMMA           reduce using rule 58 (literal1 -> NIGHT .)
    INT             reduce using rule 58 (literal1 -> NIGHT .)
    FLT             reduce using rule 58 (literal1 -> NIGHT .)
    BLN             reduce using rule 58 (literal1 -> NIGHT .)
    CHR             reduce using rule 58 (literal1 -> NIGHT .)
    STR             reduce using rule 58 (literal1 -> NIGHT .)
    NEWLINE         reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION        reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_INT    reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_FLT    reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_CHR    reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_BLN    reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_STR    reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_LIST_INT reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_LIST_FLT reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_LIST_CHR reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_LIST_STR reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_LIST_BLN reduce using rule 58 (literal1 -> NIGHT .)
    MAIN_CASPER     reduce using rule 58 (literal1 -> NIGHT .)
    RBRACKET        reduce using rule 58 (literal1 -> NIGHT .)
    RPAREN          reduce using rule 58 (literal1 -> NIGHT .)
    RBRACE          reduce using rule 58 (literal1 -> NIGHT .)
    SWAP            reduce using rule 58 (literal1 -> NIGHT .)
    FUNCTION_NAME   reduce using rule 58 (literal1 -> NIGHT .)
    IDENT           reduce using rule 58 (literal1 -> NIGHT .)
    DISPLAY         reduce using rule 58 (literal1 -> NIGHT .)
    CHECK           reduce using rule 58 (literal1 -> NIGHT .)
    FOR             reduce using rule 58 (literal1 -> NIGHT .)
    UNTIL           reduce using rule 58 (literal1 -> NIGHT .)
    REPEAT          reduce using rule 58 (literal1 -> NIGHT .)
    INPUT           reduce using rule 58 (literal1 -> NIGHT .)
    REVIVE          reduce using rule 58 (literal1 -> NIGHT .)
    SHIFT           reduce using rule 58 (literal1 -> NIGHT .)
    OTHERWISE       reduce using rule 58 (literal1 -> NIGHT .)
    SEMICOLON       reduce using rule 58 (literal1 -> NIGHT .)
    COLON           reduce using rule 58 (literal1 -> NIGHT .)


state 57

    (59) literal1 -> STR_LIT .

    PLUS            reduce using rule 59 (literal1 -> STR_LIT .)
    MINUS           reduce using rule 59 (literal1 -> STR_LIT .)
    MULTIPLY        reduce using rule 59 (literal1 -> STR_LIT .)
    DIVISION        reduce using rule 59 (literal1 -> STR_LIT .)
    MODULO          reduce using rule 59 (literal1 -> STR_LIT .)
    EXPONENT        reduce using rule 59 (literal1 -> STR_LIT .)
    GT              reduce using rule 59 (literal1 -> STR_LIT .)
    LT              reduce using rule 59 (literal1 -> STR_LIT .)
    EQ_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    GT_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    LT_EQ           reduce using rule 59 (literal1 -> STR_LIT .)
    NOT_EQ          reduce using rule 59 (literal1 -> STR_LIT .)
    AND             reduce using rule 59 (literal1 -> STR_LIT .)
    OR              reduce using rule 59 (literal1 -> STR_LIT .)
    COMMA           reduce using rule 59 (literal1 -> STR_LIT .)
    INT             reduce using rule 59 (literal1 -> STR_LIT .)
    FLT             reduce using rule 59 (literal1 -> STR_LIT .)
    BLN             reduce using rule 59 (literal1 -> STR_LIT .)
    CHR             reduce using rule 59 (literal1 -> STR_LIT .)
    STR             reduce using rule 59 (literal1 -> STR_LIT .)
    NEWLINE         reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION        reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_INT    reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_FLT    reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_CHR    reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_BLN    reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_STR    reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_LIST_INT reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_LIST_FLT reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_LIST_CHR reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_LIST_STR reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_LIST_BLN reduce using rule 59 (literal1 -> STR_LIT .)
    MAIN_CASPER     reduce using rule 59 (literal1 -> STR_LIT .)
    RBRACKET        reduce using rule 59 (literal1 -> STR_LIT .)
    RPAREN          reduce using rule 59 (literal1 -> STR_LIT .)
    RBRACE          reduce using rule 59 (literal1 -> STR_LIT .)
    SWAP            reduce using rule 59 (literal1 -> STR_LIT .)
    FUNCTION_NAME   reduce using rule 59 (literal1 -> STR_LIT .)
    IDENT           reduce using rule 59 (literal1 -> STR_LIT .)
    DISPLAY         reduce using rule 59 (literal1 -> STR_LIT .)
    CHECK           reduce using rule 59 (literal1 -> STR_LIT .)
    FOR             reduce using rule 59 (literal1 -> STR_LIT .)
    UNTIL           reduce using rule 59 (literal1 -> STR_LIT .)
    REPEAT          reduce using rule 59 (literal1 -> STR_LIT .)
    INPUT           reduce using rule 59 (literal1 -> STR_LIT .)
    REVIVE          reduce using rule 59 (literal1 -> STR_LIT .)
    SHIFT           reduce using rule 59 (literal1 -> STR_LIT .)
    OTHERWISE       reduce using rule 59 (literal1 -> STR_LIT .)
    SEMICOLON       reduce using rule 59 (literal1 -> STR_LIT .)
    COLON           reduce using rule 59 (literal1 -> STR_LIT .)


state 58

    (11) var_statement -> data_type IDENT list_dec .

    COMMA           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    EQ              reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    INT             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FLT             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    BLN             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    CHR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    STR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    NEWLINE         reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION        reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_INT    reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_FLT    reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_CHR    reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_BLN    reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_STR    reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_LIST_INT reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_LIST_FLT reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_LIST_CHR reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_LIST_STR reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_LIST_BLN reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    MAIN_CASPER     reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    SWAP            reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FUNCTION_NAME   reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    IDENT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    DISPLAY         reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    CHECK           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    FOR             reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    UNTIL           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    REPEAT          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    INPUT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    REVIVE          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    RBRACE          reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    SHIFT           reduce using rule 11 (var_statement -> data_type IDENT list_dec .)
    OTHERWISE       reduce using rule 11 (var_statement -> data_type IDENT list_dec .)


state 59

    (12) list_dec -> empty .

    COMMA           reduce using rule 12 (list_dec -> empty .)
    EQ              reduce using rule 12 (list_dec -> empty .)
    INT             reduce using rule 12 (list_dec -> empty .)
    FLT             reduce using rule 12 (list_dec -> empty .)
    BLN             reduce using rule 12 (list_dec -> empty .)
    CHR             reduce using rule 12 (list_dec -> empty .)
    STR             reduce using rule 12 (list_dec -> empty .)
    NEWLINE         reduce using rule 12 (list_dec -> empty .)
    FUNCTION        reduce using rule 12 (list_dec -> empty .)
    FUNCTION_INT    reduce using rule 12 (list_dec -> empty .)
    FUNCTION_FLT    reduce using rule 12 (list_dec -> empty .)
    FUNCTION_CHR    reduce using rule 12 (list_dec -> empty .)
    FUNCTION_BLN    reduce using rule 12 (list_dec -> empty .)
    FUNCTION_STR    reduce using rule 12 (list_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 12 (list_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 12 (list_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 12 (list_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 12 (list_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 12 (list_dec -> empty .)
    MAIN_CASPER     reduce using rule 12 (list_dec -> empty .)
    SWAP            reduce using rule 12 (list_dec -> empty .)
    FUNCTION_NAME   reduce using rule 12 (list_dec -> empty .)
    IDENT           reduce using rule 12 (list_dec -> empty .)
    DISPLAY         reduce using rule 12 (list_dec -> empty .)
    CHECK           reduce using rule 12 (list_dec -> empty .)
    FOR             reduce using rule 12 (list_dec -> empty .)
    UNTIL           reduce using rule 12 (list_dec -> empty .)
    REPEAT          reduce using rule 12 (list_dec -> empty .)
    INPUT           reduce using rule 12 (list_dec -> empty .)
    REVIVE          reduce using rule 12 (list_dec -> empty .)
    RBRACE          reduce using rule 12 (list_dec -> empty .)
    SHIFT           reduce using rule 12 (list_dec -> empty .)
    OTHERWISE       reduce using rule 12 (list_dec -> empty .)


state 60

    (13) list_dec -> LBRACKET . RBRACKET _2d_list

    RBRACKET        shift and go to state 99


state 61

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 101

    main_function                  shift and go to state 100

state 62

    (61) function_statements -> ret_type FUNCTION_NAME . LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail

    LPAREN          shift and go to state 102


state 63

    (17) global_statement_tail -> COMMA IDENT global_statement_tail .

    INT             reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FLT             reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    BLN             reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    CHR             reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    STR             reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    NEWLINE         reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION        reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_INT    reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_FLT    reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_CHR    reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_BLN    reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_STR    reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_INT reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_FLT reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_CHR reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_STR reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_BLN reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)
    MAIN_CASPER     reduce using rule 17 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 64

    (18) global_statement_tail -> EQ global_value global_statement_tail2 .

    INT             reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FLT             reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    BLN             reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    CHR             reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    STR             reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    NEWLINE         reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION        reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_INT    reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_FLT    reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_CHR    reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_BLN    reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_STR    reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_LIST_INT reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_LIST_FLT reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_LIST_CHR reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_LIST_STR reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    FUNCTION_LIST_BLN reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)
    MAIN_CASPER     reduce using rule 18 (global_statement_tail -> EQ global_value global_statement_tail2 .)


state 65

    (19) global_statement_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 103


state 66

    (20) global_statement_tail2 -> empty .

    INT             reduce using rule 20 (global_statement_tail2 -> empty .)
    FLT             reduce using rule 20 (global_statement_tail2 -> empty .)
    BLN             reduce using rule 20 (global_statement_tail2 -> empty .)
    CHR             reduce using rule 20 (global_statement_tail2 -> empty .)
    STR             reduce using rule 20 (global_statement_tail2 -> empty .)
    NEWLINE         reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION        reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_INT    reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_FLT    reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_CHR    reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_BLN    reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_STR    reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_LIST_INT reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_LIST_FLT reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_LIST_CHR reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_LIST_STR reduce using rule 20 (global_statement_tail2 -> empty .)
    FUNCTION_LIST_BLN reduce using rule 20 (global_statement_tail2 -> empty .)
    MAIN_CASPER     reduce using rule 20 (global_statement_tail2 -> empty .)


state 67

    (32) expression -> factor factor_tail .

    COMMA           reduce using rule 32 (expression -> factor factor_tail .)
    INT             reduce using rule 32 (expression -> factor factor_tail .)
    FLT             reduce using rule 32 (expression -> factor factor_tail .)
    BLN             reduce using rule 32 (expression -> factor factor_tail .)
    CHR             reduce using rule 32 (expression -> factor factor_tail .)
    STR             reduce using rule 32 (expression -> factor factor_tail .)
    NEWLINE         reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION        reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_INT    reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_FLT    reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_CHR    reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_BLN    reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_STR    reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 32 (expression -> factor factor_tail .)
    MAIN_CASPER     reduce using rule 32 (expression -> factor factor_tail .)
    RPAREN          reduce using rule 32 (expression -> factor factor_tail .)
    RBRACE          reduce using rule 32 (expression -> factor factor_tail .)
    SWAP            reduce using rule 32 (expression -> factor factor_tail .)
    FUNCTION_NAME   reduce using rule 32 (expression -> factor factor_tail .)
    IDENT           reduce using rule 32 (expression -> factor factor_tail .)
    DISPLAY         reduce using rule 32 (expression -> factor factor_tail .)
    CHECK           reduce using rule 32 (expression -> factor factor_tail .)
    FOR             reduce using rule 32 (expression -> factor factor_tail .)
    UNTIL           reduce using rule 32 (expression -> factor factor_tail .)
    REPEAT          reduce using rule 32 (expression -> factor factor_tail .)
    INPUT           reduce using rule 32 (expression -> factor factor_tail .)
    REVIVE          reduce using rule 32 (expression -> factor factor_tail .)
    SHIFT           reduce using rule 32 (expression -> factor factor_tail .)
    OTHERWISE       reduce using rule 32 (expression -> factor factor_tail .)
    SEMICOLON       reduce using rule 32 (expression -> factor factor_tail .)
    COLON           reduce using rule 32 (expression -> factor factor_tail .)


state 68

    (38) factor_tail -> PLUS . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 104
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 69

    (39) factor_tail -> MINUS . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 105
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 70

    (40) factor_tail -> MULTIPLY . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 106
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 71

    (41) factor_tail -> DIVISION . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 107
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 72

    (42) factor_tail -> MODULO . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 108
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 73

    (43) factor_tail -> EXPONENT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 109
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 74

    (44) factor_tail -> GT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 110
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 75

    (45) factor_tail -> LT . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 111
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 76

    (46) factor_tail -> EQ_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 112
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 77

    (47) factor_tail -> GT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 113
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 78

    (48) factor_tail -> LT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 114
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 79

    (49) factor_tail -> NOT_EQ . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 115
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 80

    (50) factor_tail -> AND . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 116
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 81

    (51) factor_tail -> OR . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    factor                         shift and go to state 117
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 82

    (52) factor_tail -> empty .

    COMMA           reduce using rule 52 (factor_tail -> empty .)
    INT             reduce using rule 52 (factor_tail -> empty .)
    FLT             reduce using rule 52 (factor_tail -> empty .)
    BLN             reduce using rule 52 (factor_tail -> empty .)
    CHR             reduce using rule 52 (factor_tail -> empty .)
    STR             reduce using rule 52 (factor_tail -> empty .)
    NEWLINE         reduce using rule 52 (factor_tail -> empty .)
    FUNCTION        reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_INT    reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_FLT    reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_CHR    reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_BLN    reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_STR    reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_LIST_INT reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_LIST_FLT reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_LIST_CHR reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_LIST_STR reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_LIST_BLN reduce using rule 52 (factor_tail -> empty .)
    MAIN_CASPER     reduce using rule 52 (factor_tail -> empty .)
    RPAREN          reduce using rule 52 (factor_tail -> empty .)
    RBRACE          reduce using rule 52 (factor_tail -> empty .)
    SWAP            reduce using rule 52 (factor_tail -> empty .)
    FUNCTION_NAME   reduce using rule 52 (factor_tail -> empty .)
    IDENT           reduce using rule 52 (factor_tail -> empty .)
    DISPLAY         reduce using rule 52 (factor_tail -> empty .)
    CHECK           reduce using rule 52 (factor_tail -> empty .)
    FOR             reduce using rule 52 (factor_tail -> empty .)
    UNTIL           reduce using rule 52 (factor_tail -> empty .)
    REPEAT          reduce using rule 52 (factor_tail -> empty .)
    INPUT           reduce using rule 52 (factor_tail -> empty .)
    REVIVE          reduce using rule 52 (factor_tail -> empty .)
    SHIFT           reduce using rule 52 (factor_tail -> empty .)
    OTHERWISE       reduce using rule 52 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 52 (factor_tail -> empty .)
    COLON           reduce using rule 52 (factor_tail -> empty .)


state 83

    (23) list_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 118


state 84

    (24) list_element -> literal . element_tail
    (25) element_tail -> . COMMA list_element
    (26) element_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 120
    RBRACKET        reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)

    element_tail                   shift and go to state 119
    empty                          shift and go to state 121

state 85

    (53) literal -> literal1 .

    COMMA           reduce using rule 53 (literal -> literal1 .)
    RBRACKET        reduce using rule 53 (literal -> literal1 .)
    RPAREN          reduce using rule 53 (literal -> literal1 .)


state 86

    (54) literal -> literal2 .

    COMMA           reduce using rule 54 (literal -> literal2 .)
    RBRACKET        reduce using rule 54 (literal -> literal2 .)
    RPAREN          reduce using rule 54 (literal -> literal2 .)


state 87

    (60) literal2 -> CHR_LIT .

    COMMA           reduce using rule 60 (literal2 -> CHR_LIT .)
    RBRACKET        reduce using rule 60 (literal2 -> CHR_LIT .)
    RPAREN          reduce using rule 60 (literal2 -> CHR_LIT .)


state 88

    (33) factor -> var_call postfix .

    PLUS            reduce using rule 33 (factor -> var_call postfix .)
    MINUS           reduce using rule 33 (factor -> var_call postfix .)
    MULTIPLY        reduce using rule 33 (factor -> var_call postfix .)
    DIVISION        reduce using rule 33 (factor -> var_call postfix .)
    MODULO          reduce using rule 33 (factor -> var_call postfix .)
    EXPONENT        reduce using rule 33 (factor -> var_call postfix .)
    GT              reduce using rule 33 (factor -> var_call postfix .)
    LT              reduce using rule 33 (factor -> var_call postfix .)
    EQ_EQ           reduce using rule 33 (factor -> var_call postfix .)
    GT_EQ           reduce using rule 33 (factor -> var_call postfix .)
    LT_EQ           reduce using rule 33 (factor -> var_call postfix .)
    NOT_EQ          reduce using rule 33 (factor -> var_call postfix .)
    AND             reduce using rule 33 (factor -> var_call postfix .)
    OR              reduce using rule 33 (factor -> var_call postfix .)
    COMMA           reduce using rule 33 (factor -> var_call postfix .)
    INT             reduce using rule 33 (factor -> var_call postfix .)
    FLT             reduce using rule 33 (factor -> var_call postfix .)
    BLN             reduce using rule 33 (factor -> var_call postfix .)
    CHR             reduce using rule 33 (factor -> var_call postfix .)
    STR             reduce using rule 33 (factor -> var_call postfix .)
    NEWLINE         reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION        reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_INT    reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_FLT    reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_CHR    reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_BLN    reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_STR    reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_LIST_INT reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_LIST_FLT reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_LIST_CHR reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_LIST_STR reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_LIST_BLN reduce using rule 33 (factor -> var_call postfix .)
    MAIN_CASPER     reduce using rule 33 (factor -> var_call postfix .)
    RPAREN          reduce using rule 33 (factor -> var_call postfix .)
    RBRACE          reduce using rule 33 (factor -> var_call postfix .)
    SWAP            reduce using rule 33 (factor -> var_call postfix .)
    FUNCTION_NAME   reduce using rule 33 (factor -> var_call postfix .)
    IDENT           reduce using rule 33 (factor -> var_call postfix .)
    DISPLAY         reduce using rule 33 (factor -> var_call postfix .)
    CHECK           reduce using rule 33 (factor -> var_call postfix .)
    FOR             reduce using rule 33 (factor -> var_call postfix .)
    UNTIL           reduce using rule 33 (factor -> var_call postfix .)
    REPEAT          reduce using rule 33 (factor -> var_call postfix .)
    INPUT           reduce using rule 33 (factor -> var_call postfix .)
    REVIVE          reduce using rule 33 (factor -> var_call postfix .)
    SHIFT           reduce using rule 33 (factor -> var_call postfix .)
    OTHERWISE       reduce using rule 33 (factor -> var_call postfix .)
    SEMICOLON       reduce using rule 33 (factor -> var_call postfix .)
    COLON           reduce using rule 33 (factor -> var_call postfix .)


state 89

    (156) postfix -> empty .

    PLUS            reduce using rule 156 (postfix -> empty .)
    MINUS           reduce using rule 156 (postfix -> empty .)
    MULTIPLY        reduce using rule 156 (postfix -> empty .)
    DIVISION        reduce using rule 156 (postfix -> empty .)
    MODULO          reduce using rule 156 (postfix -> empty .)
    EXPONENT        reduce using rule 156 (postfix -> empty .)
    GT              reduce using rule 156 (postfix -> empty .)
    LT              reduce using rule 156 (postfix -> empty .)
    EQ_EQ           reduce using rule 156 (postfix -> empty .)
    GT_EQ           reduce using rule 156 (postfix -> empty .)
    LT_EQ           reduce using rule 156 (postfix -> empty .)
    NOT_EQ          reduce using rule 156 (postfix -> empty .)
    AND             reduce using rule 156 (postfix -> empty .)
    OR              reduce using rule 156 (postfix -> empty .)
    COMMA           reduce using rule 156 (postfix -> empty .)
    INT             reduce using rule 156 (postfix -> empty .)
    FLT             reduce using rule 156 (postfix -> empty .)
    BLN             reduce using rule 156 (postfix -> empty .)
    CHR             reduce using rule 156 (postfix -> empty .)
    STR             reduce using rule 156 (postfix -> empty .)
    NEWLINE         reduce using rule 156 (postfix -> empty .)
    FUNCTION        reduce using rule 156 (postfix -> empty .)
    FUNCTION_INT    reduce using rule 156 (postfix -> empty .)
    FUNCTION_FLT    reduce using rule 156 (postfix -> empty .)
    FUNCTION_CHR    reduce using rule 156 (postfix -> empty .)
    FUNCTION_BLN    reduce using rule 156 (postfix -> empty .)
    FUNCTION_STR    reduce using rule 156 (postfix -> empty .)
    FUNCTION_LIST_INT reduce using rule 156 (postfix -> empty .)
    FUNCTION_LIST_FLT reduce using rule 156 (postfix -> empty .)
    FUNCTION_LIST_CHR reduce using rule 156 (postfix -> empty .)
    FUNCTION_LIST_STR reduce using rule 156 (postfix -> empty .)
    FUNCTION_LIST_BLN reduce using rule 156 (postfix -> empty .)
    MAIN_CASPER     reduce using rule 156 (postfix -> empty .)
    RPAREN          reduce using rule 156 (postfix -> empty .)
    RBRACE          reduce using rule 156 (postfix -> empty .)
    SWAP            reduce using rule 156 (postfix -> empty .)
    FUNCTION_NAME   reduce using rule 156 (postfix -> empty .)
    IDENT           reduce using rule 156 (postfix -> empty .)
    DISPLAY         reduce using rule 156 (postfix -> empty .)
    CHECK           reduce using rule 156 (postfix -> empty .)
    FOR             reduce using rule 156 (postfix -> empty .)
    UNTIL           reduce using rule 156 (postfix -> empty .)
    REPEAT          reduce using rule 156 (postfix -> empty .)
    INPUT           reduce using rule 156 (postfix -> empty .)
    REVIVE          reduce using rule 156 (postfix -> empty .)
    SHIFT           reduce using rule 156 (postfix -> empty .)
    OTHERWISE       reduce using rule 156 (postfix -> empty .)
    SEMICOLON       reduce using rule 156 (postfix -> empty .)
    COLON           reduce using rule 156 (postfix -> empty .)


state 90

    (157) postfix -> postfix_op .

    PLUS            reduce using rule 157 (postfix -> postfix_op .)
    MINUS           reduce using rule 157 (postfix -> postfix_op .)
    MULTIPLY        reduce using rule 157 (postfix -> postfix_op .)
    DIVISION        reduce using rule 157 (postfix -> postfix_op .)
    MODULO          reduce using rule 157 (postfix -> postfix_op .)
    EXPONENT        reduce using rule 157 (postfix -> postfix_op .)
    GT              reduce using rule 157 (postfix -> postfix_op .)
    LT              reduce using rule 157 (postfix -> postfix_op .)
    EQ_EQ           reduce using rule 157 (postfix -> postfix_op .)
    GT_EQ           reduce using rule 157 (postfix -> postfix_op .)
    LT_EQ           reduce using rule 157 (postfix -> postfix_op .)
    NOT_EQ          reduce using rule 157 (postfix -> postfix_op .)
    AND             reduce using rule 157 (postfix -> postfix_op .)
    OR              reduce using rule 157 (postfix -> postfix_op .)
    COMMA           reduce using rule 157 (postfix -> postfix_op .)
    INT             reduce using rule 157 (postfix -> postfix_op .)
    FLT             reduce using rule 157 (postfix -> postfix_op .)
    BLN             reduce using rule 157 (postfix -> postfix_op .)
    CHR             reduce using rule 157 (postfix -> postfix_op .)
    STR             reduce using rule 157 (postfix -> postfix_op .)
    NEWLINE         reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION        reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_INT    reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_FLT    reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_CHR    reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_BLN    reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_STR    reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_LIST_INT reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_LIST_FLT reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_LIST_CHR reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_LIST_STR reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_LIST_BLN reduce using rule 157 (postfix -> postfix_op .)
    MAIN_CASPER     reduce using rule 157 (postfix -> postfix_op .)
    RPAREN          reduce using rule 157 (postfix -> postfix_op .)
    RBRACE          reduce using rule 157 (postfix -> postfix_op .)
    SWAP            reduce using rule 157 (postfix -> postfix_op .)
    FUNCTION_NAME   reduce using rule 157 (postfix -> postfix_op .)
    IDENT           reduce using rule 157 (postfix -> postfix_op .)
    DISPLAY         reduce using rule 157 (postfix -> postfix_op .)
    CHECK           reduce using rule 157 (postfix -> postfix_op .)
    FOR             reduce using rule 157 (postfix -> postfix_op .)
    UNTIL           reduce using rule 157 (postfix -> postfix_op .)
    REPEAT          reduce using rule 157 (postfix -> postfix_op .)
    INPUT           reduce using rule 157 (postfix -> postfix_op .)
    REVIVE          reduce using rule 157 (postfix -> postfix_op .)
    SHIFT           reduce using rule 157 (postfix -> postfix_op .)
    OTHERWISE       reduce using rule 157 (postfix -> postfix_op .)
    SEMICOLON       reduce using rule 157 (postfix -> postfix_op .)
    COLON           reduce using rule 157 (postfix -> postfix_op .)


state 91

    (120) postfix_op -> PLUS_PLUS .

    PLUS            reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    MINUS           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    MULTIPLY        reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    DIVISION        reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    MODULO          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    EXPONENT        reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    GT              reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    LT              reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    EQ_EQ           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    GT_EQ           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    LT_EQ           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    NOT_EQ          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    AND             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    OR              reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    COMMA           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    INT             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FLT             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    BLN             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    CHR             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    STR             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    NEWLINE         reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION        reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_INT    reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_FLT    reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_CHR    reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_BLN    reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_STR    reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_LIST_INT reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_LIST_FLT reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_LIST_CHR reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_LIST_STR reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_LIST_BLN reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    MAIN_CASPER     reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    RPAREN          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    RBRACE          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    SWAP            reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FUNCTION_NAME   reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    IDENT           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    DISPLAY         reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    CHECK           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    FOR             reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    UNTIL           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    REPEAT          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    INPUT           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    REVIVE          reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    SHIFT           reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    OTHERWISE       reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    SEMICOLON       reduce using rule 120 (postfix_op -> PLUS_PLUS .)
    COLON           reduce using rule 120 (postfix_op -> PLUS_PLUS .)


state 92

    (121) postfix_op -> MINUS_MINUS .

    PLUS            reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    MINUS           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    MULTIPLY        reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    DIVISION        reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    MODULO          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    EXPONENT        reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    GT              reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    LT              reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    EQ_EQ           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    GT_EQ           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    LT_EQ           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    NOT_EQ          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    AND             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    OR              reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    COMMA           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    INT             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FLT             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    BLN             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    CHR             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    STR             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    NEWLINE         reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION        reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_INT    reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_FLT    reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_CHR    reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_BLN    reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_STR    reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_LIST_INT reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_LIST_FLT reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_LIST_CHR reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_LIST_STR reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_LIST_BLN reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    MAIN_CASPER     reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    RPAREN          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    RBRACE          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    SWAP            reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FUNCTION_NAME   reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    IDENT           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    DISPLAY         reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    CHECK           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    FOR             reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    UNTIL           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    REPEAT          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    INPUT           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    REVIVE          reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    SHIFT           reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    OTHERWISE       reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    SEMICOLON       reduce using rule 121 (postfix_op -> MINUS_MINUS .)
    COLON           reduce using rule 121 (postfix_op -> MINUS_MINUS .)


state 93

    (35) factor -> TILDE INT_LIT .

    PLUS            reduce using rule 35 (factor -> TILDE INT_LIT .)
    MINUS           reduce using rule 35 (factor -> TILDE INT_LIT .)
    MULTIPLY        reduce using rule 35 (factor -> TILDE INT_LIT .)
    DIVISION        reduce using rule 35 (factor -> TILDE INT_LIT .)
    MODULO          reduce using rule 35 (factor -> TILDE INT_LIT .)
    EXPONENT        reduce using rule 35 (factor -> TILDE INT_LIT .)
    GT              reduce using rule 35 (factor -> TILDE INT_LIT .)
    LT              reduce using rule 35 (factor -> TILDE INT_LIT .)
    EQ_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    GT_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    LT_EQ           reduce using rule 35 (factor -> TILDE INT_LIT .)
    NOT_EQ          reduce using rule 35 (factor -> TILDE INT_LIT .)
    AND             reduce using rule 35 (factor -> TILDE INT_LIT .)
    OR              reduce using rule 35 (factor -> TILDE INT_LIT .)
    COMMA           reduce using rule 35 (factor -> TILDE INT_LIT .)
    INT             reduce using rule 35 (factor -> TILDE INT_LIT .)
    FLT             reduce using rule 35 (factor -> TILDE INT_LIT .)
    BLN             reduce using rule 35 (factor -> TILDE INT_LIT .)
    CHR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    STR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    NEWLINE         reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION        reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_INT    reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_FLT    reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_CHR    reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_BLN    reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_STR    reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_LIST_INT reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_LIST_FLT reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_LIST_CHR reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_LIST_STR reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_LIST_BLN reduce using rule 35 (factor -> TILDE INT_LIT .)
    MAIN_CASPER     reduce using rule 35 (factor -> TILDE INT_LIT .)
    RPAREN          reduce using rule 35 (factor -> TILDE INT_LIT .)
    RBRACE          reduce using rule 35 (factor -> TILDE INT_LIT .)
    SWAP            reduce using rule 35 (factor -> TILDE INT_LIT .)
    FUNCTION_NAME   reduce using rule 35 (factor -> TILDE INT_LIT .)
    IDENT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    DISPLAY         reduce using rule 35 (factor -> TILDE INT_LIT .)
    CHECK           reduce using rule 35 (factor -> TILDE INT_LIT .)
    FOR             reduce using rule 35 (factor -> TILDE INT_LIT .)
    UNTIL           reduce using rule 35 (factor -> TILDE INT_LIT .)
    REPEAT          reduce using rule 35 (factor -> TILDE INT_LIT .)
    INPUT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    REVIVE          reduce using rule 35 (factor -> TILDE INT_LIT .)
    SHIFT           reduce using rule 35 (factor -> TILDE INT_LIT .)
    OTHERWISE       reduce using rule 35 (factor -> TILDE INT_LIT .)
    SEMICOLON       reduce using rule 35 (factor -> TILDE INT_LIT .)
    COLON           reduce using rule 35 (factor -> TILDE INT_LIT .)


state 94

    (36) factor -> TILDE FLT_LIT .

    PLUS            reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MINUS           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MULTIPLY        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    DIVISION        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MODULO          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    EXPONENT        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    GT              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    LT              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    EQ_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    GT_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    LT_EQ           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    NOT_EQ          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    AND             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    OR              reduce using rule 36 (factor -> TILDE FLT_LIT .)
    COMMA           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    INT             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FLT             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    BLN             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    CHR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    STR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    NEWLINE         reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION        reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_INT    reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_FLT    reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_CHR    reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_BLN    reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_STR    reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_LIST_INT reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_LIST_FLT reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_LIST_CHR reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_LIST_STR reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_LIST_BLN reduce using rule 36 (factor -> TILDE FLT_LIT .)
    MAIN_CASPER     reduce using rule 36 (factor -> TILDE FLT_LIT .)
    RPAREN          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    RBRACE          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SWAP            reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FUNCTION_NAME   reduce using rule 36 (factor -> TILDE FLT_LIT .)
    IDENT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    DISPLAY         reduce using rule 36 (factor -> TILDE FLT_LIT .)
    CHECK           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    FOR             reduce using rule 36 (factor -> TILDE FLT_LIT .)
    UNTIL           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    REPEAT          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    INPUT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    REVIVE          reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SHIFT           reduce using rule 36 (factor -> TILDE FLT_LIT .)
    OTHERWISE       reduce using rule 36 (factor -> TILDE FLT_LIT .)
    SEMICOLON       reduce using rule 36 (factor -> TILDE FLT_LIT .)
    COLON           reduce using rule 36 (factor -> TILDE FLT_LIT .)


state 95

    (37) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 122


state 96

    (149) var_call -> IDENT list_index .

    PLUS_PLUS       reduce using rule 149 (var_call -> IDENT list_index .)
    MINUS_MINUS     reduce using rule 149 (var_call -> IDENT list_index .)
    PLUS            reduce using rule 149 (var_call -> IDENT list_index .)
    MINUS           reduce using rule 149 (var_call -> IDENT list_index .)
    MULTIPLY        reduce using rule 149 (var_call -> IDENT list_index .)
    DIVISION        reduce using rule 149 (var_call -> IDENT list_index .)
    MODULO          reduce using rule 149 (var_call -> IDENT list_index .)
    EXPONENT        reduce using rule 149 (var_call -> IDENT list_index .)
    GT              reduce using rule 149 (var_call -> IDENT list_index .)
    LT              reduce using rule 149 (var_call -> IDENT list_index .)
    EQ_EQ           reduce using rule 149 (var_call -> IDENT list_index .)
    GT_EQ           reduce using rule 149 (var_call -> IDENT list_index .)
    LT_EQ           reduce using rule 149 (var_call -> IDENT list_index .)
    NOT_EQ          reduce using rule 149 (var_call -> IDENT list_index .)
    AND             reduce using rule 149 (var_call -> IDENT list_index .)
    OR              reduce using rule 149 (var_call -> IDENT list_index .)
    COMMA           reduce using rule 149 (var_call -> IDENT list_index .)
    INT             reduce using rule 149 (var_call -> IDENT list_index .)
    FLT             reduce using rule 149 (var_call -> IDENT list_index .)
    BLN             reduce using rule 149 (var_call -> IDENT list_index .)
    CHR             reduce using rule 149 (var_call -> IDENT list_index .)
    STR             reduce using rule 149 (var_call -> IDENT list_index .)
    NEWLINE         reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION        reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_INT    reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_FLT    reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_CHR    reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_BLN    reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_STR    reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_LIST_INT reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_LIST_FLT reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_LIST_CHR reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_LIST_STR reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_LIST_BLN reduce using rule 149 (var_call -> IDENT list_index .)
    MAIN_CASPER     reduce using rule 149 (var_call -> IDENT list_index .)
    RPAREN          reduce using rule 149 (var_call -> IDENT list_index .)
    RBRACE          reduce using rule 149 (var_call -> IDENT list_index .)
    SWAP            reduce using rule 149 (var_call -> IDENT list_index .)
    FUNCTION_NAME   reduce using rule 149 (var_call -> IDENT list_index .)
    IDENT           reduce using rule 149 (var_call -> IDENT list_index .)
    DISPLAY         reduce using rule 149 (var_call -> IDENT list_index .)
    CHECK           reduce using rule 149 (var_call -> IDENT list_index .)
    FOR             reduce using rule 149 (var_call -> IDENT list_index .)
    UNTIL           reduce using rule 149 (var_call -> IDENT list_index .)
    REPEAT          reduce using rule 149 (var_call -> IDENT list_index .)
    INPUT           reduce using rule 149 (var_call -> IDENT list_index .)
    REVIVE          reduce using rule 149 (var_call -> IDENT list_index .)
    SHIFT           reduce using rule 149 (var_call -> IDENT list_index .)
    OTHERWISE       reduce using rule 149 (var_call -> IDENT list_index .)
    SEMICOLON       reduce using rule 149 (var_call -> IDENT list_index .)
    COLON           reduce using rule 149 (var_call -> IDENT list_index .)
    PLUS_EQ         reduce using rule 149 (var_call -> IDENT list_index .)
    MINUS_EQ        reduce using rule 149 (var_call -> IDENT list_index .)
    MUL_EQ          reduce using rule 149 (var_call -> IDENT list_index .)
    DIV_EQ          reduce using rule 149 (var_call -> IDENT list_index .)
    MOD_EQ          reduce using rule 149 (var_call -> IDENT list_index .)


state 97

    (150) list_index -> LBRACKET . index RBRACKET list_index2
    (154) index -> . INT_LIT
    (155) index -> . IDENT

    INT_LIT         shift and go to state 124
    IDENT           shift and go to state 125

    index                          shift and go to state 123

state 98

    (151) list_index -> empty .

    PLUS_PLUS       reduce using rule 151 (list_index -> empty .)
    MINUS_MINUS     reduce using rule 151 (list_index -> empty .)
    PLUS            reduce using rule 151 (list_index -> empty .)
    MINUS           reduce using rule 151 (list_index -> empty .)
    MULTIPLY        reduce using rule 151 (list_index -> empty .)
    DIVISION        reduce using rule 151 (list_index -> empty .)
    MODULO          reduce using rule 151 (list_index -> empty .)
    EXPONENT        reduce using rule 151 (list_index -> empty .)
    GT              reduce using rule 151 (list_index -> empty .)
    LT              reduce using rule 151 (list_index -> empty .)
    EQ_EQ           reduce using rule 151 (list_index -> empty .)
    GT_EQ           reduce using rule 151 (list_index -> empty .)
    LT_EQ           reduce using rule 151 (list_index -> empty .)
    NOT_EQ          reduce using rule 151 (list_index -> empty .)
    AND             reduce using rule 151 (list_index -> empty .)
    OR              reduce using rule 151 (list_index -> empty .)
    COMMA           reduce using rule 151 (list_index -> empty .)
    INT             reduce using rule 151 (list_index -> empty .)
    FLT             reduce using rule 151 (list_index -> empty .)
    BLN             reduce using rule 151 (list_index -> empty .)
    CHR             reduce using rule 151 (list_index -> empty .)
    STR             reduce using rule 151 (list_index -> empty .)
    NEWLINE         reduce using rule 151 (list_index -> empty .)
    FUNCTION        reduce using rule 151 (list_index -> empty .)
    FUNCTION_INT    reduce using rule 151 (list_index -> empty .)
    FUNCTION_FLT    reduce using rule 151 (list_index -> empty .)
    FUNCTION_CHR    reduce using rule 151 (list_index -> empty .)
    FUNCTION_BLN    reduce using rule 151 (list_index -> empty .)
    FUNCTION_STR    reduce using rule 151 (list_index -> empty .)
    FUNCTION_LIST_INT reduce using rule 151 (list_index -> empty .)
    FUNCTION_LIST_FLT reduce using rule 151 (list_index -> empty .)
    FUNCTION_LIST_CHR reduce using rule 151 (list_index -> empty .)
    FUNCTION_LIST_STR reduce using rule 151 (list_index -> empty .)
    FUNCTION_LIST_BLN reduce using rule 151 (list_index -> empty .)
    MAIN_CASPER     reduce using rule 151 (list_index -> empty .)
    RPAREN          reduce using rule 151 (list_index -> empty .)
    RBRACE          reduce using rule 151 (list_index -> empty .)
    SWAP            reduce using rule 151 (list_index -> empty .)
    FUNCTION_NAME   reduce using rule 151 (list_index -> empty .)
    IDENT           reduce using rule 151 (list_index -> empty .)
    DISPLAY         reduce using rule 151 (list_index -> empty .)
    CHECK           reduce using rule 151 (list_index -> empty .)
    FOR             reduce using rule 151 (list_index -> empty .)
    UNTIL           reduce using rule 151 (list_index -> empty .)
    REPEAT          reduce using rule 151 (list_index -> empty .)
    INPUT           reduce using rule 151 (list_index -> empty .)
    REVIVE          reduce using rule 151 (list_index -> empty .)
    SHIFT           reduce using rule 151 (list_index -> empty .)
    OTHERWISE       reduce using rule 151 (list_index -> empty .)
    SEMICOLON       reduce using rule 151 (list_index -> empty .)
    COLON           reduce using rule 151 (list_index -> empty .)
    PLUS_EQ         reduce using rule 151 (list_index -> empty .)
    MINUS_EQ        reduce using rule 151 (list_index -> empty .)
    MUL_EQ          reduce using rule 151 (list_index -> empty .)
    DIV_EQ          reduce using rule 151 (list_index -> empty .)
    MOD_EQ          reduce using rule 151 (list_index -> empty .)


state 99

    (13) list_dec -> LBRACKET RBRACKET . _2d_list
    (14) _2d_list -> . empty
    (15) _2d_list -> . LBRACKET RBRACKET
    (169) empty -> .

    LBRACKET        shift and go to state 126
    COMMA           reduce using rule 169 (empty -> .)
    EQ              reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    _2d_list                       shift and go to state 127
    empty                          shift and go to state 128

state 100

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 129

state 101

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 130


state 102

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN . parameters RPAREN LBRACE statements revive RBRACE function_statements_tail
    (77) parameters -> . data_type IDENT parameters_tail
    (78) parameters -> . empty
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR
    (169) empty -> .

    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14
    RPAREN          reduce using rule 169 (empty -> .)

    parameters                     shift and go to state 131
    data_type                      shift and go to state 132
    empty                          shift and go to state 133

state 103

    (19) global_statement_tail2 -> COMMA IDENT . global_statement_tail
    (16) global_statement_tail -> . empty
    (17) global_statement_tail -> . COMMA IDENT global_statement_tail
    (18) global_statement_tail -> . EQ global_value global_statement_tail2
    (169) empty -> .

    COMMA           shift and go to state 23
    EQ              shift and go to state 24
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)

    global_statement_tail          shift and go to state 134
    empty                          shift and go to state 22

state 104

    (38) factor_tail -> PLUS factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 135
    empty                          shift and go to state 82

state 105

    (39) factor_tail -> MINUS factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 136
    empty                          shift and go to state 82

state 106

    (40) factor_tail -> MULTIPLY factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 137
    empty                          shift and go to state 82

state 107

    (41) factor_tail -> DIVISION factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 138
    empty                          shift and go to state 82

state 108

    (42) factor_tail -> MODULO factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 139
    empty                          shift and go to state 82

state 109

    (43) factor_tail -> EXPONENT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 140
    empty                          shift and go to state 82

state 110

    (44) factor_tail -> GT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 141
    empty                          shift and go to state 82

state 111

    (45) factor_tail -> LT factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 142
    empty                          shift and go to state 82

state 112

    (46) factor_tail -> EQ_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 143
    empty                          shift and go to state 82

state 113

    (47) factor_tail -> GT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 144
    empty                          shift and go to state 82

state 114

    (48) factor_tail -> LT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 145
    empty                          shift and go to state 82

state 115

    (49) factor_tail -> NOT_EQ factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 146
    empty                          shift and go to state 82

state 116

    (50) factor_tail -> AND factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 147
    empty                          shift and go to state 82

state 117

    (51) factor_tail -> OR factor . factor_tail
    (38) factor_tail -> . PLUS factor factor_tail
    (39) factor_tail -> . MINUS factor factor_tail
    (40) factor_tail -> . MULTIPLY factor factor_tail
    (41) factor_tail -> . DIVISION factor factor_tail
    (42) factor_tail -> . MODULO factor factor_tail
    (43) factor_tail -> . EXPONENT factor factor_tail
    (44) factor_tail -> . GT factor factor_tail
    (45) factor_tail -> . LT factor factor_tail
    (46) factor_tail -> . EQ_EQ factor factor_tail
    (47) factor_tail -> . GT_EQ factor factor_tail
    (48) factor_tail -> . LT_EQ factor factor_tail
    (49) factor_tail -> . NOT_EQ factor factor_tail
    (50) factor_tail -> . AND factor factor_tail
    (51) factor_tail -> . OR factor factor_tail
    (52) factor_tail -> . empty
    (169) empty -> .

    PLUS            shift and go to state 68
    MINUS           shift and go to state 69
    MULTIPLY        shift and go to state 70
    DIVISION        shift and go to state 71
    MODULO          shift and go to state 72
    EXPONENT        shift and go to state 73
    GT              shift and go to state 74
    LT              shift and go to state 75
    EQ_EQ           shift and go to state 76
    GT_EQ           shift and go to state 77
    LT_EQ           shift and go to state 78
    NOT_EQ          shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)

    factor_tail                    shift and go to state 148
    empty                          shift and go to state 82

state 118

    (23) list_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    INT             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FLT             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    BLN             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    CHR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    STR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION        reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_INT    reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_FLT    reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_CHR    reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_BLN    reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_STR    reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_INT reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_FLT reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_CHR reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_STR reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_LIST_BLN reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    MAIN_CASPER     reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    SWAP            reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_NAME   reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    IDENT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    DISPLAY         reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    CHECK           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    FOR             reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    UNTIL           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    REPEAT          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    INPUT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    REVIVE          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    RBRACE          reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    SHIFT           reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)
    OTHERWISE       reduce using rule 23 (list_value -> LBRACKET list_element RBRACKET .)


state 119

    (24) list_element -> literal element_tail .

    RBRACKET        reduce using rule 24 (list_element -> literal element_tail .)
    RPAREN          reduce using rule 24 (list_element -> literal element_tail .)


state 120

    (25) element_tail -> COMMA . list_element
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57
    CHR_LIT         shift and go to state 87

    list_element                   shift and go to state 149
    literal                        shift and go to state 84
    literal1                       shift and go to state 85
    literal2                       shift and go to state 86

state 121

    (26) element_tail -> empty .

    RBRACKET        reduce using rule 26 (element_tail -> empty .)
    RPAREN          reduce using rule 26 (element_tail -> empty .)


state 122

    (37) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    INT             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FLT             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    BLN             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    CHR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    STR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION        reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_INT    reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_FLT    reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_CHR    reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_BLN    reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_STR    reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_INT reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_FLT reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_CHR reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_STR reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_LIST_BLN reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    MAIN_CASPER     reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SWAP            reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FUNCTION_NAME   reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    IDENT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    DISPLAY         reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    CHECK           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    REPEAT          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    INPUT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    REVIVE          reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SHIFT           reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    OTHERWISE       reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 37 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 37 (factor -> LPAREN expression RPAREN .)


state 123

    (150) list_index -> LBRACKET index . RBRACKET list_index2

    RBRACKET        shift and go to state 150


state 124

    (154) index -> INT_LIT .

    RBRACKET        reduce using rule 154 (index -> INT_LIT .)


state 125

    (155) index -> IDENT .

    RBRACKET        reduce using rule 155 (index -> IDENT .)


state 126

    (15) _2d_list -> LBRACKET . RBRACKET

    RBRACKET        shift and go to state 151


state 127

    (13) list_dec -> LBRACKET RBRACKET _2d_list .

    COMMA           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    EQ              reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    INT             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FLT             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    BLN             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    CHR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    STR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    NEWLINE         reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION        reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_INT    reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_FLT    reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_CHR    reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_BLN    reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_STR    reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_LIST_INT reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_LIST_FLT reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_LIST_CHR reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_LIST_STR reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_LIST_BLN reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    MAIN_CASPER     reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    SWAP            reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FUNCTION_NAME   reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    IDENT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    DISPLAY         reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    CHECK           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    FOR             reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    UNTIL           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    REPEAT          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    INPUT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    REVIVE          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    RBRACE          reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    SHIFT           reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)
    OTHERWISE       reduce using rule 13 (list_dec -> LBRACKET RBRACKET _2d_list .)


state 128

    (14) _2d_list -> empty .

    COMMA           reduce using rule 14 (_2d_list -> empty .)
    EQ              reduce using rule 14 (_2d_list -> empty .)
    INT             reduce using rule 14 (_2d_list -> empty .)
    FLT             reduce using rule 14 (_2d_list -> empty .)
    BLN             reduce using rule 14 (_2d_list -> empty .)
    CHR             reduce using rule 14 (_2d_list -> empty .)
    STR             reduce using rule 14 (_2d_list -> empty .)
    NEWLINE         reduce using rule 14 (_2d_list -> empty .)
    FUNCTION        reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_INT    reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_FLT    reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_CHR    reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_BLN    reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_STR    reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_LIST_INT reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_LIST_FLT reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_LIST_CHR reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_LIST_STR reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_LIST_BLN reduce using rule 14 (_2d_list -> empty .)
    MAIN_CASPER     reduce using rule 14 (_2d_list -> empty .)
    SWAP            reduce using rule 14 (_2d_list -> empty .)
    FUNCTION_NAME   reduce using rule 14 (_2d_list -> empty .)
    IDENT           reduce using rule 14 (_2d_list -> empty .)
    DISPLAY         reduce using rule 14 (_2d_list -> empty .)
    CHECK           reduce using rule 14 (_2d_list -> empty .)
    FOR             reduce using rule 14 (_2d_list -> empty .)
    UNTIL           reduce using rule 14 (_2d_list -> empty .)
    REPEAT          reduce using rule 14 (_2d_list -> empty .)
    INPUT           reduce using rule 14 (_2d_list -> empty .)
    REVIVE          reduce using rule 14 (_2d_list -> empty .)
    RBRACE          reduce using rule 14 (_2d_list -> empty .)
    SHIFT           reduce using rule 14 (_2d_list -> empty .)
    OTHERWISE       reduce using rule 14 (_2d_list -> empty .)


state 129

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 152


state 130

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 153


state 131

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters . RPAREN LBRACE statements revive RBRACE function_statements_tail

    RPAREN          shift and go to state 154


state 132

    (77) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 155


state 133

    (78) parameters -> empty .

    RPAREN          reduce using rule 78 (parameters -> empty .)


state 134

    (19) global_statement_tail2 -> COMMA IDENT global_statement_tail .

    INT             reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FLT             reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    BLN             reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    CHR             reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    STR             reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    NEWLINE         reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION        reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_INT    reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_FLT    reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_CHR    reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_BLN    reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_STR    reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_INT reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_FLT reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_CHR reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_STR reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    FUNCTION_LIST_BLN reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)
    MAIN_CASPER     reduce using rule 19 (global_statement_tail2 -> COMMA IDENT global_statement_tail .)


state 135

    (38) factor_tail -> PLUS factor factor_tail .

    COMMA           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    INT             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FLT             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    BLN             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    CHR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    STR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    NEWLINE         reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION        reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_INT    reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_FLT    reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_CHR    reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_BLN    reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_STR    reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    MAIN_CASPER     reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    RPAREN          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    RBRACE          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SWAP            reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FUNCTION_NAME   reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    IDENT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    DISPLAY         reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    CHECK           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    FOR             reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    UNTIL           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    REPEAT          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    INPUT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    REVIVE          reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SHIFT           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    OTHERWISE       reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    SEMICOLON       reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)
    COLON           reduce using rule 38 (factor_tail -> PLUS factor factor_tail .)


state 136

    (39) factor_tail -> MINUS factor factor_tail .

    COMMA           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    INT             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FLT             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    BLN             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    CHR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    STR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    NEWLINE         reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION        reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_INT    reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_FLT    reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_CHR    reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_BLN    reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_STR    reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    MAIN_CASPER     reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    RPAREN          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    RBRACE          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SWAP            reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FUNCTION_NAME   reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    IDENT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    DISPLAY         reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    CHECK           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    FOR             reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    UNTIL           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    REPEAT          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    INPUT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    REVIVE          reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SHIFT           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    OTHERWISE       reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    SEMICOLON       reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)
    COLON           reduce using rule 39 (factor_tail -> MINUS factor factor_tail .)


state 137

    (40) factor_tail -> MULTIPLY factor factor_tail .

    COMMA           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    INT             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FLT             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    BLN             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    CHR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    STR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    NEWLINE         reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION        reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_INT    reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_FLT    reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_CHR    reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_BLN    reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_STR    reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    MAIN_CASPER     reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    RPAREN          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    RBRACE          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SWAP            reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FUNCTION_NAME   reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    IDENT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    DISPLAY         reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    CHECK           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    FOR             reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    UNTIL           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    REPEAT          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    INPUT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    REVIVE          reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SHIFT           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    OTHERWISE       reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    SEMICOLON       reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)
    COLON           reduce using rule 40 (factor_tail -> MULTIPLY factor factor_tail .)


state 138

    (41) factor_tail -> DIVISION factor factor_tail .

    COMMA           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    INT             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FLT             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    BLN             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    CHR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    STR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    NEWLINE         reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION        reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_INT    reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_FLT    reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_CHR    reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_BLN    reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_STR    reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    MAIN_CASPER     reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    RPAREN          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    RBRACE          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SWAP            reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FUNCTION_NAME   reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    IDENT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    DISPLAY         reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    CHECK           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    FOR             reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    UNTIL           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    REPEAT          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    INPUT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    REVIVE          reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SHIFT           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    OTHERWISE       reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    SEMICOLON       reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)
    COLON           reduce using rule 41 (factor_tail -> DIVISION factor factor_tail .)


state 139

    (42) factor_tail -> MODULO factor factor_tail .

    COMMA           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    INT             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FLT             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    BLN             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    CHR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    STR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    NEWLINE         reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION        reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_INT    reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_FLT    reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_CHR    reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_BLN    reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_STR    reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    MAIN_CASPER     reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    RPAREN          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    RBRACE          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SWAP            reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FUNCTION_NAME   reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    IDENT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    DISPLAY         reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    CHECK           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    FOR             reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    UNTIL           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    REPEAT          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    INPUT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    REVIVE          reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SHIFT           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    OTHERWISE       reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    SEMICOLON       reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)
    COLON           reduce using rule 42 (factor_tail -> MODULO factor factor_tail .)


state 140

    (43) factor_tail -> EXPONENT factor factor_tail .

    COMMA           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    INT             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FLT             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    BLN             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    CHR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    STR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    NEWLINE         reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION        reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_INT    reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_FLT    reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_CHR    reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_BLN    reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_STR    reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    MAIN_CASPER     reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    RPAREN          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    RBRACE          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SWAP            reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    IDENT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    DISPLAY         reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    CHECK           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    FOR             reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    UNTIL           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    REPEAT          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    INPUT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    REVIVE          reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SHIFT           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    OTHERWISE       reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    SEMICOLON       reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)
    COLON           reduce using rule 43 (factor_tail -> EXPONENT factor factor_tail .)


state 141

    (44) factor_tail -> GT factor factor_tail .

    COMMA           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    INT             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FLT             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    BLN             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    CHR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    STR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    NEWLINE         reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION        reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_INT    reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_FLT    reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_CHR    reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_BLN    reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_STR    reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    MAIN_CASPER     reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    RPAREN          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    RBRACE          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SWAP            reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    IDENT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    DISPLAY         reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    CHECK           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    FOR             reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    UNTIL           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    REPEAT          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    INPUT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    REVIVE          reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SHIFT           reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    OTHERWISE       reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    SEMICOLON       reduce using rule 44 (factor_tail -> GT factor factor_tail .)
    COLON           reduce using rule 44 (factor_tail -> GT factor factor_tail .)


state 142

    (45) factor_tail -> LT factor factor_tail .

    COMMA           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    INT             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FLT             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    BLN             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    CHR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    STR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    NEWLINE         reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION        reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_INT    reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_FLT    reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_CHR    reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_BLN    reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_STR    reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    MAIN_CASPER     reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    RPAREN          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    RBRACE          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SWAP            reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FUNCTION_NAME   reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    IDENT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    DISPLAY         reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    CHECK           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    FOR             reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    UNTIL           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    REPEAT          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    INPUT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    REVIVE          reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SHIFT           reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    OTHERWISE       reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    SEMICOLON       reduce using rule 45 (factor_tail -> LT factor factor_tail .)
    COLON           reduce using rule 45 (factor_tail -> LT factor factor_tail .)


state 143

    (46) factor_tail -> EQ_EQ factor factor_tail .

    COMMA           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    INT             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FLT             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    BLN             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    CHR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    STR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    NEWLINE         reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION        reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_INT    reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_FLT    reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_CHR    reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_BLN    reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_STR    reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    MAIN_CASPER     reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    RPAREN          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    RBRACE          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SWAP            reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    IDENT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    DISPLAY         reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    CHECK           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    FOR             reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    UNTIL           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    REPEAT          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    INPUT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    REVIVE          reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SHIFT           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)
    COLON           reduce using rule 46 (factor_tail -> EQ_EQ factor factor_tail .)


state 144

    (47) factor_tail -> GT_EQ factor factor_tail .

    COMMA           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    INT             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FLT             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    BLN             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    CHR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    STR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION        reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_INT    reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_FLT    reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_CHR    reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_BLN    reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_STR    reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    MAIN_CASPER     reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    RPAREN          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    RBRACE          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SWAP            reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    IDENT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    CHECK           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    FOR             reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    UNTIL           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    REPEAT          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    INPUT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    REVIVE          reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SHIFT           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)
    COLON           reduce using rule 47 (factor_tail -> GT_EQ factor factor_tail .)


state 145

    (48) factor_tail -> LT_EQ factor factor_tail .

    COMMA           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    INT             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FLT             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    BLN             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    CHR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    STR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION        reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_INT    reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_FLT    reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_CHR    reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_BLN    reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_STR    reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    MAIN_CASPER     reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    RPAREN          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    RBRACE          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SWAP            reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    IDENT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    CHECK           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    FOR             reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    UNTIL           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    REPEAT          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    INPUT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    REVIVE          reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SHIFT           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)
    COLON           reduce using rule 48 (factor_tail -> LT_EQ factor factor_tail .)


state 146

    (49) factor_tail -> NOT_EQ factor factor_tail .

    COMMA           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    INT             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FLT             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    BLN             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    CHR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    STR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    NEWLINE         reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION        reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_INT    reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_FLT    reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_CHR    reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_BLN    reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_STR    reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    MAIN_CASPER     reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    RPAREN          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    RBRACE          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SWAP            reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FUNCTION_NAME   reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    IDENT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    DISPLAY         reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    CHECK           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    FOR             reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    UNTIL           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    REPEAT          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    INPUT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    REVIVE          reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SHIFT           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    OTHERWISE       reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    SEMICOLON       reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)
    COLON           reduce using rule 49 (factor_tail -> NOT_EQ factor factor_tail .)


state 147

    (50) factor_tail -> AND factor factor_tail .

    COMMA           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    INT             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FLT             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    BLN             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    CHR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    STR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    NEWLINE         reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION        reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_INT    reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_FLT    reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_CHR    reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_BLN    reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_STR    reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    MAIN_CASPER     reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    RPAREN          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    RBRACE          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SWAP            reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FUNCTION_NAME   reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    IDENT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    DISPLAY         reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    CHECK           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    FOR             reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    UNTIL           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    REPEAT          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    INPUT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    REVIVE          reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SHIFT           reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    OTHERWISE       reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    SEMICOLON       reduce using rule 50 (factor_tail -> AND factor factor_tail .)
    COLON           reduce using rule 50 (factor_tail -> AND factor factor_tail .)


state 148

    (51) factor_tail -> OR factor factor_tail .

    COMMA           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    INT             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FLT             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    BLN             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    CHR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    STR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    NEWLINE         reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION        reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_INT    reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_FLT    reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_CHR    reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_BLN    reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_STR    reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_LIST_INT reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_LIST_FLT reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_LIST_CHR reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_LIST_STR reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_LIST_BLN reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    MAIN_CASPER     reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    RPAREN          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    RBRACE          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SWAP            reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FUNCTION_NAME   reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    IDENT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    DISPLAY         reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    CHECK           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    FOR             reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    UNTIL           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    REPEAT          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    INPUT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    REVIVE          reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SHIFT           reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    OTHERWISE       reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    SEMICOLON       reduce using rule 51 (factor_tail -> OR factor factor_tail .)
    COLON           reduce using rule 51 (factor_tail -> OR factor factor_tail .)


state 149

    (25) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 25 (element_tail -> COMMA list_element .)
    RPAREN          reduce using rule 25 (element_tail -> COMMA list_element .)


state 150

    (150) list_index -> LBRACKET index RBRACKET . list_index2
    (152) list_index2 -> . LBRACKET index RBRACKET
    (153) list_index2 -> . empty
    (169) empty -> .

    LBRACKET        shift and go to state 156
    PLUS_PLUS       reduce using rule 169 (empty -> .)
    MINUS_MINUS     reduce using rule 169 (empty -> .)
    PLUS            reduce using rule 169 (empty -> .)
    MINUS           reduce using rule 169 (empty -> .)
    MULTIPLY        reduce using rule 169 (empty -> .)
    DIVISION        reduce using rule 169 (empty -> .)
    MODULO          reduce using rule 169 (empty -> .)
    EXPONENT        reduce using rule 169 (empty -> .)
    GT              reduce using rule 169 (empty -> .)
    LT              reduce using rule 169 (empty -> .)
    EQ_EQ           reduce using rule 169 (empty -> .)
    GT_EQ           reduce using rule 169 (empty -> .)
    LT_EQ           reduce using rule 169 (empty -> .)
    NOT_EQ          reduce using rule 169 (empty -> .)
    AND             reduce using rule 169 (empty -> .)
    OR              reduce using rule 169 (empty -> .)
    COMMA           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    FUNCTION        reduce using rule 169 (empty -> .)
    FUNCTION_INT    reduce using rule 169 (empty -> .)
    FUNCTION_FLT    reduce using rule 169 (empty -> .)
    FUNCTION_CHR    reduce using rule 169 (empty -> .)
    FUNCTION_BLN    reduce using rule 169 (empty -> .)
    FUNCTION_STR    reduce using rule 169 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 169 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 169 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    RPAREN          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SEMICOLON       reduce using rule 169 (empty -> .)
    COLON           reduce using rule 169 (empty -> .)
    PLUS_EQ         reduce using rule 169 (empty -> .)
    MINUS_EQ        reduce using rule 169 (empty -> .)
    MUL_EQ          reduce using rule 169 (empty -> .)
    DIV_EQ          reduce using rule 169 (empty -> .)
    MOD_EQ          reduce using rule 169 (empty -> .)

    list_index2                    shift and go to state 157
    empty                          shift and go to state 158

state 151

    (15) _2d_list -> LBRACKET RBRACKET .

    COMMA           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    EQ              reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    INT             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FLT             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    BLN             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    CHR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    STR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    NEWLINE         reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION        reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_INT    reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_FLT    reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_CHR    reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_BLN    reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_STR    reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_LIST_INT reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_LIST_FLT reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_LIST_CHR reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_LIST_STR reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_LIST_BLN reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    MAIN_CASPER     reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    SWAP            reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FUNCTION_NAME   reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    IDENT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    DISPLAY         reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    CHECK           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    FOR             reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    UNTIL           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    REPEAT          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    INPUT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    REVIVE          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    SHIFT           reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)
    OTHERWISE       reduce using rule 15 (_2d_list -> LBRACKET RBRACKET .)


state 152

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 153

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    LBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 159
    empty                          shift and go to state 17

state 154

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN . LBRACE statements revive RBRACE function_statements_tail

    LBRACE          shift and go to state 160


state 155

    (77) parameters -> data_type IDENT . parameters_tail
    (79) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (80) parameters_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 169 (empty -> .)

    parameters_tail                shift and go to state 161
    empty                          shift and go to state 163

state 156

    (152) list_index2 -> LBRACKET . index RBRACKET
    (154) index -> . INT_LIT
    (155) index -> . IDENT

    INT_LIT         shift and go to state 124
    IDENT           shift and go to state 125

    index                          shift and go to state 164

state 157

    (150) list_index -> LBRACKET index RBRACKET list_index2 .

    PLUS_PLUS       reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS_MINUS     reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    PLUS            reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MULTIPLY        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DIVISION        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MODULO          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    EXPONENT        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    GT              reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    LT              reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    EQ_EQ           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    GT_EQ           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    LT_EQ           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    NOT_EQ          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    AND             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    OR              reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    COMMA           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    INT             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FLT             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    BLN             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    CHR             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    STR             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    NEWLINE         reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_INT    reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_FLT    reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_CHR    reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_BLN    reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_STR    reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_LIST_INT reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_LIST_FLT reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_LIST_CHR reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_LIST_STR reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_LIST_BLN reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MAIN_CASPER     reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    RPAREN          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    RBRACE          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SWAP            reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FUNCTION_NAME   reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    IDENT           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DISPLAY         reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    CHECK           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    FOR             reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    UNTIL           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    REPEAT          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    INPUT           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    REVIVE          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SHIFT           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    OTHERWISE       reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    SEMICOLON       reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    COLON           reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    PLUS_EQ         reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MINUS_EQ        reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MUL_EQ          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    DIV_EQ          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)
    MOD_EQ          reduce using rule 150 (list_index -> LBRACKET index RBRACKET list_index2 .)


state 158

    (153) list_index2 -> empty .

    PLUS_PLUS       reduce using rule 153 (list_index2 -> empty .)
    MINUS_MINUS     reduce using rule 153 (list_index2 -> empty .)
    PLUS            reduce using rule 153 (list_index2 -> empty .)
    MINUS           reduce using rule 153 (list_index2 -> empty .)
    MULTIPLY        reduce using rule 153 (list_index2 -> empty .)
    DIVISION        reduce using rule 153 (list_index2 -> empty .)
    MODULO          reduce using rule 153 (list_index2 -> empty .)
    EXPONENT        reduce using rule 153 (list_index2 -> empty .)
    GT              reduce using rule 153 (list_index2 -> empty .)
    LT              reduce using rule 153 (list_index2 -> empty .)
    EQ_EQ           reduce using rule 153 (list_index2 -> empty .)
    GT_EQ           reduce using rule 153 (list_index2 -> empty .)
    LT_EQ           reduce using rule 153 (list_index2 -> empty .)
    NOT_EQ          reduce using rule 153 (list_index2 -> empty .)
    AND             reduce using rule 153 (list_index2 -> empty .)
    OR              reduce using rule 153 (list_index2 -> empty .)
    COMMA           reduce using rule 153 (list_index2 -> empty .)
    INT             reduce using rule 153 (list_index2 -> empty .)
    FLT             reduce using rule 153 (list_index2 -> empty .)
    BLN             reduce using rule 153 (list_index2 -> empty .)
    CHR             reduce using rule 153 (list_index2 -> empty .)
    STR             reduce using rule 153 (list_index2 -> empty .)
    NEWLINE         reduce using rule 153 (list_index2 -> empty .)
    FUNCTION        reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_INT    reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_FLT    reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_CHR    reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_BLN    reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_STR    reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_LIST_INT reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_LIST_FLT reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_LIST_CHR reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_LIST_STR reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_LIST_BLN reduce using rule 153 (list_index2 -> empty .)
    MAIN_CASPER     reduce using rule 153 (list_index2 -> empty .)
    RPAREN          reduce using rule 153 (list_index2 -> empty .)
    RBRACE          reduce using rule 153 (list_index2 -> empty .)
    SWAP            reduce using rule 153 (list_index2 -> empty .)
    FUNCTION_NAME   reduce using rule 153 (list_index2 -> empty .)
    IDENT           reduce using rule 153 (list_index2 -> empty .)
    DISPLAY         reduce using rule 153 (list_index2 -> empty .)
    CHECK           reduce using rule 153 (list_index2 -> empty .)
    FOR             reduce using rule 153 (list_index2 -> empty .)
    UNTIL           reduce using rule 153 (list_index2 -> empty .)
    REPEAT          reduce using rule 153 (list_index2 -> empty .)
    INPUT           reduce using rule 153 (list_index2 -> empty .)
    REVIVE          reduce using rule 153 (list_index2 -> empty .)
    SHIFT           reduce using rule 153 (list_index2 -> empty .)
    OTHERWISE       reduce using rule 153 (list_index2 -> empty .)
    SEMICOLON       reduce using rule 153 (list_index2 -> empty .)
    COLON           reduce using rule 153 (list_index2 -> empty .)
    PLUS_EQ         reduce using rule 153 (list_index2 -> empty .)
    MINUS_EQ        reduce using rule 153 (list_index2 -> empty .)
    MUL_EQ          reduce using rule 153 (list_index2 -> empty .)
    DIV_EQ          reduce using rule 153 (list_index2 -> empty .)
    MOD_EQ          reduce using rule 153 (list_index2 -> empty .)


state 159

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 165


state 160

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE . statements revive RBRACE function_statements_tail
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 166
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 161

    (77) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 77 (parameters -> data_type IDENT parameters_tail .)


state 162

    (79) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

    data_type                      shift and go to state 170

state 163

    (80) parameters_tail -> empty .

    RPAREN          reduce using rule 80 (parameters_tail -> empty .)


state 164

    (152) list_index2 -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 171


state 165

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 172
    empty                          shift and go to state 17

state 166

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements . revive RBRACE function_statements_tail
    (81) revive -> . REVIVE value
    (82) revive -> . empty
    (169) empty -> .

    REVIVE          shift and go to state 174
    RBRACE          reduce using rule 169 (empty -> .)

    revive                         shift and go to state 173
    empty                          shift and go to state 175

state 167

    (83) statements -> empty .
    (93) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 83 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 83 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 83 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 83 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 83 (statements -> empty .)
    REVIVE          reduce using rule 83 (statements -> empty .)
    RBRACE          reduce using rule 83 (statements -> empty .)
    NEWLINE         reduce using rule 83 (statements -> empty .)
    SHIFT           reduce using rule 83 (statements -> empty .)
    OTHERWISE       reduce using rule 83 (statements -> empty .)
    SWAP            reduce using rule 93 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 93 (local_dec -> empty .)
    IDENT           reduce using rule 93 (local_dec -> empty .)
    DISPLAY         reduce using rule 93 (local_dec -> empty .)
    CHECK           reduce using rule 93 (local_dec -> empty .)
    FOR             reduce using rule 93 (local_dec -> empty .)
    UNTIL           reduce using rule 93 (local_dec -> empty .)
    REPEAT          reduce using rule 93 (local_dec -> empty .)
    INPUT           reduce using rule 93 (local_dec -> empty .)
    INT             reduce using rule 93 (local_dec -> empty .)
    FLT             reduce using rule 93 (local_dec -> empty .)
    BLN             reduce using rule 93 (local_dec -> empty .)
    CHR             reduce using rule 93 (local_dec -> empty .)
    STR             reduce using rule 93 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 93 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 93 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 93 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 93 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 93 (local_dec -> empty .) ]


state 168

    (84) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 176
    empty                          shift and go to state 17

state 169

    (92) local_dec -> var_statement . local_dec_tail
    (94) local_dec_tail -> . empty
    (95) local_dec_tail -> . COMMA IDENT local_dec_tail
    (96) local_dec_tail -> . EQ local_value local_dec_tail2
    (169) empty -> .

    COMMA           shift and go to state 179
    EQ              shift and go to state 180
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    local_dec_tail                 shift and go to state 177
    empty                          shift and go to state 178

state 170

    (79) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 181


state 171

    (152) list_index2 -> LBRACKET index RBRACKET .

    PLUS_PLUS       reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    PLUS            reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    GT              reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    LT              reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    AND             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    OR              reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    INT             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FLT             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    BLN             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    CHR             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    STR             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_INT    reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_FLT    reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_CHR    reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_BLN    reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_STR    reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_INT reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_FLT reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_CHR reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_STR reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_LIST_BLN reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MAIN_CASPER     reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    SWAP            reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FUNCTION_NAME   reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    IDENT           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    DISPLAY         reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    CHECK           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    FOR             reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    UNTIL           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    REPEAT          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    INPUT           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    REVIVE          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    SHIFT           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    OTHERWISE       reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 152 (list_index2 -> LBRACKET index RBRACKET .)


state 172

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 182
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 173

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive . RBRACE function_statements_tail

    RBRACE          shift and go to state 183


state 174

    (81) revive -> REVIVE . value
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 188
    CONVERT_TO_FLT  shift and go to state 189
    CONVERT_TO_BLN  shift and go to state 190
    CONVERT_TO_STR  shift and go to state 191
    FUNCTION_NAME   shift and go to state 192
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 194
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    value                          shift and go to state 184
    type_cast                      shift and go to state 185
    expression                     shift and go to state 186
    function_call                  shift and go to state 187
    factor                         shift and go to state 46
    input_statement                shift and go to state 193
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 175

    (82) revive -> empty .

    RBRACE          reduce using rule 82 (revive -> empty .)


state 176

    (84) statements -> local_dec maybe_newline . statements_tail
    (85) statements_tail -> . switch_statement unli_newline statements
    (86) statements_tail -> . loop_statement unli_newline statements
    (87) statements_tail -> . function_call unli_newline statements
    (88) statements_tail -> . assignment_statement unli_newline statements
    (89) statements_tail -> . output_statement unli_newline statements
    (90) statements_tail -> . conditional_statement unli_newline statements
    (91) statements_tail -> . statements
    (104) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
    (108) loop_statement -> . for_loop
    (109) loop_statement -> . until_loop
    (110) loop_statement -> . repeat_until
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (133) assignment_statement -> . IDENT assign_tail
    (130) output_statement -> . DISPLAY value next_val
    (101) conditional_statement -> . CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (111) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (112) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE statements RBRACE
    (113) repeat_until -> . REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SWAP            shift and go to state 203
    FUNCTION_NAME   shift and go to state 192
    IDENT           shift and go to state 204
    DISPLAY         shift and go to state 208
    CHECK           shift and go to state 209
    FOR             shift and go to state 210
    UNTIL           shift and go to state 211
    REPEAT          shift and go to state 212
    INPUT           shift and go to state 194
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! SWAP            [ reduce using rule 169 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 169 (empty -> .) ]
  ! IDENT           [ reduce using rule 169 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 169 (empty -> .) ]
  ! CHECK           [ reduce using rule 169 (empty -> .) ]
  ! FOR             [ reduce using rule 169 (empty -> .) ]
  ! UNTIL           [ reduce using rule 169 (empty -> .) ]
  ! REPEAT          [ reduce using rule 169 (empty -> .) ]
  ! INPUT           [ reduce using rule 169 (empty -> .) ]
  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    local_dec                      shift and go to state 168
    statements_tail                shift and go to state 195
    switch_statement               shift and go to state 196
    statements                     shift and go to state 197
    loop_statement                 shift and go to state 198
    function_call                  shift and go to state 199
    assignment_statement           shift and go to state 200
    output_statement               shift and go to state 201
    conditional_statement          shift and go to state 202
    for_loop                       shift and go to state 205
    until_loop                     shift and go to state 206
    repeat_until                   shift and go to state 207
    input_statement                shift and go to state 193
    empty                          shift and go to state 167
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 177

    (92) local_dec -> var_statement local_dec_tail .

    NEWLINE         reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    SWAP            reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    FUNCTION_NAME   reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    IDENT           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    DISPLAY         reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    CHECK           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    FOR             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    UNTIL           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    REPEAT          reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    INPUT           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    INT             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    FLT             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    BLN             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    CHR             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    STR             reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    REVIVE          reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    RBRACE          reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    SHIFT           reduce using rule 92 (local_dec -> var_statement local_dec_tail .)
    OTHERWISE       reduce using rule 92 (local_dec -> var_statement local_dec_tail .)


state 178

    (94) local_dec_tail -> empty .

    NEWLINE         reduce using rule 94 (local_dec_tail -> empty .)
    SWAP            reduce using rule 94 (local_dec_tail -> empty .)
    FUNCTION_NAME   reduce using rule 94 (local_dec_tail -> empty .)
    IDENT           reduce using rule 94 (local_dec_tail -> empty .)
    DISPLAY         reduce using rule 94 (local_dec_tail -> empty .)
    CHECK           reduce using rule 94 (local_dec_tail -> empty .)
    FOR             reduce using rule 94 (local_dec_tail -> empty .)
    UNTIL           reduce using rule 94 (local_dec_tail -> empty .)
    REPEAT          reduce using rule 94 (local_dec_tail -> empty .)
    INPUT           reduce using rule 94 (local_dec_tail -> empty .)
    INT             reduce using rule 94 (local_dec_tail -> empty .)
    FLT             reduce using rule 94 (local_dec_tail -> empty .)
    BLN             reduce using rule 94 (local_dec_tail -> empty .)
    CHR             reduce using rule 94 (local_dec_tail -> empty .)
    STR             reduce using rule 94 (local_dec_tail -> empty .)
    REVIVE          reduce using rule 94 (local_dec_tail -> empty .)
    RBRACE          reduce using rule 94 (local_dec_tail -> empty .)
    SHIFT           reduce using rule 94 (local_dec_tail -> empty .)
    OTHERWISE       reduce using rule 94 (local_dec_tail -> empty .)


state 179

    (95) local_dec_tail -> COMMA . IDENT local_dec_tail

    IDENT           shift and go to state 213


state 180

    (96) local_dec_tail -> EQ . local_value local_dec_tail2
    (99) local_value -> . value
    (100) local_value -> . list_value
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (23) list_value -> . LBRACKET list_element RBRACKET
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    LBRACKET        shift and go to state 47
    CONVERT_TO_INT  shift and go to state 188
    CONVERT_TO_FLT  shift and go to state 189
    CONVERT_TO_BLN  shift and go to state 190
    CONVERT_TO_STR  shift and go to state 191
    FUNCTION_NAME   shift and go to state 192
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 194
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    local_value                    shift and go to state 214
    value                          shift and go to state 215
    list_value                     shift and go to state 216
    type_cast                      shift and go to state 185
    expression                     shift and go to state 186
    function_call                  shift and go to state 187
    factor                         shift and go to state 46
    input_statement                shift and go to state 193
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 181

    (79) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (79) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (80) parameters_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 169 (empty -> .)

    parameters_tail                shift and go to state 217
    empty                          shift and go to state 163

state 182

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 218
    empty                          shift and go to state 17

state 183

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE . function_statements_tail
    (63) function_statements_tail -> . function_statements
    (64) function_statements_tail -> . empty
    (61) function_statements -> . ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail
    (62) function_statements -> . empty
    (169) empty -> .
    (65) ret_type -> . FUNCTION
    (66) ret_type -> . function_dtype
    (67) function_dtype -> . FUNCTION_INT
    (68) function_dtype -> . FUNCTION_FLT
    (69) function_dtype -> . FUNCTION_CHR
    (70) function_dtype -> . FUNCTION_BLN
    (71) function_dtype -> . FUNCTION_STR
    (72) function_dtype -> . FUNCTION_LIST_INT
    (73) function_dtype -> . FUNCTION_LIST_FLT
    (74) function_dtype -> . FUNCTION_LIST_CHR
    (75) function_dtype -> . FUNCTION_LIST_STR
    (76) function_dtype -> . FUNCTION_LIST_BLN

    NEWLINE         reduce using rule 169 (empty -> .)
    MAIN_CASPER     reduce using rule 169 (empty -> .)
    FUNCTION        shift and go to state 29
    FUNCTION_INT    shift and go to state 31
    FUNCTION_FLT    shift and go to state 32
    FUNCTION_CHR    shift and go to state 33
    FUNCTION_BLN    shift and go to state 34
    FUNCTION_STR    shift and go to state 35
    FUNCTION_LIST_INT shift and go to state 36
    FUNCTION_LIST_FLT shift and go to state 37
    FUNCTION_LIST_CHR shift and go to state 38
    FUNCTION_LIST_STR shift and go to state 39
    FUNCTION_LIST_BLN shift and go to state 40

    ret_type                       shift and go to state 27
    function_statements_tail       shift and go to state 219
    function_statements            shift and go to state 220
    empty                          shift and go to state 221
    function_dtype                 shift and go to state 30

state 184

    (81) revive -> REVIVE value .

    RBRACE          reduce using rule 81 (revive -> REVIVE value .)


state 185

    (158) value -> type_cast .

    RBRACE          reduce using rule 158 (value -> type_cast .)
    COMMA           reduce using rule 158 (value -> type_cast .)
    NEWLINE         reduce using rule 158 (value -> type_cast .)
    SWAP            reduce using rule 158 (value -> type_cast .)
    FUNCTION_NAME   reduce using rule 158 (value -> type_cast .)
    IDENT           reduce using rule 158 (value -> type_cast .)
    DISPLAY         reduce using rule 158 (value -> type_cast .)
    CHECK           reduce using rule 158 (value -> type_cast .)
    FOR             reduce using rule 158 (value -> type_cast .)
    UNTIL           reduce using rule 158 (value -> type_cast .)
    REPEAT          reduce using rule 158 (value -> type_cast .)
    INPUT           reduce using rule 158 (value -> type_cast .)
    INT             reduce using rule 158 (value -> type_cast .)
    FLT             reduce using rule 158 (value -> type_cast .)
    BLN             reduce using rule 158 (value -> type_cast .)
    CHR             reduce using rule 158 (value -> type_cast .)
    STR             reduce using rule 158 (value -> type_cast .)
    REVIVE          reduce using rule 158 (value -> type_cast .)
    SHIFT           reduce using rule 158 (value -> type_cast .)
    OTHERWISE       reduce using rule 158 (value -> type_cast .)
    COLON           reduce using rule 158 (value -> type_cast .)
    RPAREN          reduce using rule 158 (value -> type_cast .)


state 186

    (159) value -> expression .

    RBRACE          reduce using rule 159 (value -> expression .)
    COMMA           reduce using rule 159 (value -> expression .)
    NEWLINE         reduce using rule 159 (value -> expression .)
    SWAP            reduce using rule 159 (value -> expression .)
    FUNCTION_NAME   reduce using rule 159 (value -> expression .)
    IDENT           reduce using rule 159 (value -> expression .)
    DISPLAY         reduce using rule 159 (value -> expression .)
    CHECK           reduce using rule 159 (value -> expression .)
    FOR             reduce using rule 159 (value -> expression .)
    UNTIL           reduce using rule 159 (value -> expression .)
    REPEAT          reduce using rule 159 (value -> expression .)
    INPUT           reduce using rule 159 (value -> expression .)
    INT             reduce using rule 159 (value -> expression .)
    FLT             reduce using rule 159 (value -> expression .)
    BLN             reduce using rule 159 (value -> expression .)
    CHR             reduce using rule 159 (value -> expression .)
    STR             reduce using rule 159 (value -> expression .)
    REVIVE          reduce using rule 159 (value -> expression .)
    SHIFT           reduce using rule 159 (value -> expression .)
    OTHERWISE       reduce using rule 159 (value -> expression .)
    COLON           reduce using rule 159 (value -> expression .)
    RPAREN          reduce using rule 159 (value -> expression .)


state 187

    (160) value -> function_call .

    RBRACE          reduce using rule 160 (value -> function_call .)
    COMMA           reduce using rule 160 (value -> function_call .)
    NEWLINE         reduce using rule 160 (value -> function_call .)
    SWAP            reduce using rule 160 (value -> function_call .)
    FUNCTION_NAME   reduce using rule 160 (value -> function_call .)
    IDENT           reduce using rule 160 (value -> function_call .)
    DISPLAY         reduce using rule 160 (value -> function_call .)
    CHECK           reduce using rule 160 (value -> function_call .)
    FOR             reduce using rule 160 (value -> function_call .)
    UNTIL           reduce using rule 160 (value -> function_call .)
    REPEAT          reduce using rule 160 (value -> function_call .)
    INPUT           reduce using rule 160 (value -> function_call .)
    INT             reduce using rule 160 (value -> function_call .)
    FLT             reduce using rule 160 (value -> function_call .)
    BLN             reduce using rule 160 (value -> function_call .)
    CHR             reduce using rule 160 (value -> function_call .)
    STR             reduce using rule 160 (value -> function_call .)
    REVIVE          reduce using rule 160 (value -> function_call .)
    SHIFT           reduce using rule 160 (value -> function_call .)
    OTHERWISE       reduce using rule 160 (value -> function_call .)
    COLON           reduce using rule 160 (value -> function_call .)
    RPAREN          reduce using rule 160 (value -> function_call .)


state 188

    (161) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 222


state 189

    (162) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 223


state 190

    (163) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 224


state 191

    (164) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 225


state 192

    (122) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 226


state 193

    (123) function_call -> input_statement .

    RBRACE          reduce using rule 123 (function_call -> input_statement .)
    NEWLINE         reduce using rule 123 (function_call -> input_statement .)
    COMMA           reduce using rule 123 (function_call -> input_statement .)
    SWAP            reduce using rule 123 (function_call -> input_statement .)
    FUNCTION_NAME   reduce using rule 123 (function_call -> input_statement .)
    IDENT           reduce using rule 123 (function_call -> input_statement .)
    DISPLAY         reduce using rule 123 (function_call -> input_statement .)
    CHECK           reduce using rule 123 (function_call -> input_statement .)
    FOR             reduce using rule 123 (function_call -> input_statement .)
    UNTIL           reduce using rule 123 (function_call -> input_statement .)
    REPEAT          reduce using rule 123 (function_call -> input_statement .)
    INPUT           reduce using rule 123 (function_call -> input_statement .)
    INT             reduce using rule 123 (function_call -> input_statement .)
    FLT             reduce using rule 123 (function_call -> input_statement .)
    BLN             reduce using rule 123 (function_call -> input_statement .)
    CHR             reduce using rule 123 (function_call -> input_statement .)
    STR             reduce using rule 123 (function_call -> input_statement .)
    REVIVE          reduce using rule 123 (function_call -> input_statement .)
    SHIFT           reduce using rule 123 (function_call -> input_statement .)
    OTHERWISE       reduce using rule 123 (function_call -> input_statement .)
    COLON           reduce using rule 123 (function_call -> input_statement .)
    RPAREN          reduce using rule 123 (function_call -> input_statement .)


state 194

    (168) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 227


state 195

    (84) statements -> local_dec maybe_newline statements_tail .

    REVIVE          reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)
    NEWLINE         reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 84 (statements -> local_dec maybe_newline statements_tail .)


state 196

    (85) statements_tail -> switch_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 228

state 197

    (91) statements_tail -> statements .

    REVIVE          reduce using rule 91 (statements_tail -> statements .)
    RBRACE          reduce using rule 91 (statements_tail -> statements .)
    NEWLINE         reduce using rule 91 (statements_tail -> statements .)
    SHIFT           reduce using rule 91 (statements_tail -> statements .)
    OTHERWISE       reduce using rule 91 (statements_tail -> statements .)


state 198

    (86) statements_tail -> loop_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 229

state 199

    (87) statements_tail -> function_call . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 230

state 200

    (88) statements_tail -> assignment_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 231

state 201

    (89) statements_tail -> output_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 232

state 202

    (90) statements_tail -> conditional_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 233

state 203

    (104) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    LPAREN          shift and go to state 234


state 204

    (133) assignment_statement -> IDENT . assign_tail
    (134) assign_tail -> . DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
    (135) assign_tail -> . DOT PUSH LPAREN list_element RPAREN
    (136) assign_tail -> . assign_op value
    (137) assign_op -> . compound_op
    (138) assign_op -> . EQ
    (139) compound_op -> . PLUS_EQ
    (140) compound_op -> . MINUS_EQ
    (141) compound_op -> . MUL_EQ
    (142) compound_op -> . DIV_EQ
    (143) compound_op -> . MOD_EQ

    DOT             shift and go to state 236
    EQ              shift and go to state 239
    PLUS_EQ         shift and go to state 240
    MINUS_EQ        shift and go to state 241
    MUL_EQ          shift and go to state 242
    DIV_EQ          shift and go to state 243
    MOD_EQ          shift and go to state 244

    assign_tail                    shift and go to state 235
    assign_op                      shift and go to state 237
    compound_op                    shift and go to state 238

state 205

    (108) loop_statement -> for_loop .

    NEWLINE         reduce using rule 108 (loop_statement -> for_loop .)


state 206

    (109) loop_statement -> until_loop .

    NEWLINE         reduce using rule 109 (loop_statement -> until_loop .)


state 207

    (110) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 110 (loop_statement -> repeat_until .)


state 208

    (130) output_statement -> DISPLAY . value next_val
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 188
    CONVERT_TO_FLT  shift and go to state 189
    CONVERT_TO_BLN  shift and go to state 190
    CONVERT_TO_STR  shift and go to state 191
    FUNCTION_NAME   shift and go to state 192
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 194
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    value                          shift and go to state 245
    type_cast                      shift and go to state 185
    expression                     shift and go to state 186
    function_call                  shift and go to state 187
    factor                         shift and go to state 46
    input_statement                shift and go to state 193
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 209

    (101) conditional_statement -> CHECK . LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 246


state 210

    (111) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 247


state 211

    (112) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 248


state 212

    (113) repeat_until -> REPEAT . LBRACE statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 249


state 213

    (95) local_dec_tail -> COMMA IDENT . local_dec_tail
    (94) local_dec_tail -> . empty
    (95) local_dec_tail -> . COMMA IDENT local_dec_tail
    (96) local_dec_tail -> . EQ local_value local_dec_tail2
    (169) empty -> .

    COMMA           shift and go to state 179
    EQ              shift and go to state 180
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    local_dec_tail                 shift and go to state 250
    empty                          shift and go to state 178

state 214

    (96) local_dec_tail -> EQ local_value . local_dec_tail2
    (97) local_dec_tail2 -> . COMMA IDENT local_dec_tail
    (98) local_dec_tail2 -> . empty
    (169) empty -> .

    COMMA           shift and go to state 252
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    local_dec_tail2                shift and go to state 251
    empty                          shift and go to state 253

state 215

    (99) local_value -> value .

    COMMA           reduce using rule 99 (local_value -> value .)
    NEWLINE         reduce using rule 99 (local_value -> value .)
    SWAP            reduce using rule 99 (local_value -> value .)
    FUNCTION_NAME   reduce using rule 99 (local_value -> value .)
    IDENT           reduce using rule 99 (local_value -> value .)
    DISPLAY         reduce using rule 99 (local_value -> value .)
    CHECK           reduce using rule 99 (local_value -> value .)
    FOR             reduce using rule 99 (local_value -> value .)
    UNTIL           reduce using rule 99 (local_value -> value .)
    REPEAT          reduce using rule 99 (local_value -> value .)
    INPUT           reduce using rule 99 (local_value -> value .)
    INT             reduce using rule 99 (local_value -> value .)
    FLT             reduce using rule 99 (local_value -> value .)
    BLN             reduce using rule 99 (local_value -> value .)
    CHR             reduce using rule 99 (local_value -> value .)
    STR             reduce using rule 99 (local_value -> value .)
    REVIVE          reduce using rule 99 (local_value -> value .)
    RBRACE          reduce using rule 99 (local_value -> value .)
    SHIFT           reduce using rule 99 (local_value -> value .)
    OTHERWISE       reduce using rule 99 (local_value -> value .)


state 216

    (100) local_value -> list_value .

    COMMA           reduce using rule 100 (local_value -> list_value .)
    NEWLINE         reduce using rule 100 (local_value -> list_value .)
    SWAP            reduce using rule 100 (local_value -> list_value .)
    FUNCTION_NAME   reduce using rule 100 (local_value -> list_value .)
    IDENT           reduce using rule 100 (local_value -> list_value .)
    DISPLAY         reduce using rule 100 (local_value -> list_value .)
    CHECK           reduce using rule 100 (local_value -> list_value .)
    FOR             reduce using rule 100 (local_value -> list_value .)
    UNTIL           reduce using rule 100 (local_value -> list_value .)
    REPEAT          reduce using rule 100 (local_value -> list_value .)
    INPUT           reduce using rule 100 (local_value -> list_value .)
    INT             reduce using rule 100 (local_value -> list_value .)
    FLT             reduce using rule 100 (local_value -> list_value .)
    BLN             reduce using rule 100 (local_value -> list_value .)
    CHR             reduce using rule 100 (local_value -> list_value .)
    STR             reduce using rule 100 (local_value -> list_value .)
    REVIVE          reduce using rule 100 (local_value -> list_value .)
    RBRACE          reduce using rule 100 (local_value -> list_value .)
    SHIFT           reduce using rule 100 (local_value -> list_value .)
    OTHERWISE       reduce using rule 100 (local_value -> list_value .)


state 217

    (79) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 79 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 218

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 254


state 219

    (61) function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail .

    NEWLINE         reduce using rule 61 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail .)
    MAIN_CASPER     reduce using rule 61 (function_statements -> ret_type FUNCTION_NAME LPAREN parameters RPAREN LBRACE statements revive RBRACE function_statements_tail .)


state 220

    (63) function_statements_tail -> function_statements .

    NEWLINE         reduce using rule 63 (function_statements_tail -> function_statements .)
    MAIN_CASPER     reduce using rule 63 (function_statements_tail -> function_statements .)


state 221

    (64) function_statements_tail -> empty .
    (62) function_statements -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 62 (function_statements -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 62 (function_statements -> empty .)
    NEWLINE         reduce using rule 62 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 62 (function_statements -> empty .)

  ! NEWLINE         [ reduce using rule 64 (function_statements_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 64 (function_statements_tail -> empty .) ]


state 222

    (161) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (165) typecast_value -> . expression
    (166) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (167) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (168) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 257
    INPUT           shift and go to state 194
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    typecast_value                 shift and go to state 255
    expression                     shift and go to state 256
    input_statement                shift and go to state 258
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 223

    (162) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (165) typecast_value -> . expression
    (166) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (167) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (168) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 257
    INPUT           shift and go to state 194
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    typecast_value                 shift and go to state 259
    expression                     shift and go to state 256
    input_statement                shift and go to state 258
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 224

    (163) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (165) typecast_value -> . expression
    (166) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (167) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (168) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 257
    INPUT           shift and go to state 194
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    typecast_value                 shift and go to state 260
    expression                     shift and go to state 256
    input_statement                shift and go to state 258
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 225

    (164) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (165) typecast_value -> . expression
    (166) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (167) typecast_value -> . input_statement
    (32) expression -> . factor factor_tail
    (168) input_statement -> . INPUT LPAREN RPAREN
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    FUNCTION_NAME   shift and go to state 257
    INPUT           shift and go to state 194
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    typecast_value                 shift and go to state 261
    expression                     shift and go to state 256
    input_statement                shift and go to state 258
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 226

    (122) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (124) arguments -> . empty
    (125) arguments -> . arg_value arg_tail
    (169) empty -> .
    (128) arg_value -> . literal
    (129) arg_value -> . var_call
    (53) literal -> . literal1
    (54) literal -> . literal2
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    RPAREN          reduce using rule 169 (empty -> .)
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57
    CHR_LIT         shift and go to state 87

    arguments                      shift and go to state 262
    empty                          shift and go to state 263
    arg_value                      shift and go to state 264
    literal                        shift and go to state 265
    var_call                       shift and go to state 266
    literal1                       shift and go to state 85
    literal2                       shift and go to state 86

state 227

    (168) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 267


state 228

    (85) statements_tail -> switch_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 268
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 229

    (86) statements_tail -> loop_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 269
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 230

    (87) statements_tail -> function_call unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 270
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 231

    (88) statements_tail -> assignment_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 271
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 232

    (89) statements_tail -> output_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 272
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 233

    (90) statements_tail -> conditional_statement unli_newline . statements
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 273
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 234

    (104) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    IDENT           shift and go to state 274


state 235

    (133) assignment_statement -> IDENT assign_tail .

    NEWLINE         reduce using rule 133 (assignment_statement -> IDENT assign_tail .)


state 236

    (134) assign_tail -> DOT . SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN
    (135) assign_tail -> DOT . PUSH LPAREN list_element RPAREN

    SPLICE          shift and go to state 275
    PUSH            shift and go to state 276


state 237

    (136) assign_tail -> assign_op . value
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 188
    CONVERT_TO_FLT  shift and go to state 189
    CONVERT_TO_BLN  shift and go to state 190
    CONVERT_TO_STR  shift and go to state 191
    FUNCTION_NAME   shift and go to state 192
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 194
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    value                          shift and go to state 277
    type_cast                      shift and go to state 185
    expression                     shift and go to state 186
    function_call                  shift and go to state 187
    factor                         shift and go to state 46
    input_statement                shift and go to state 193
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 238

    (137) assign_op -> compound_op .

    CONVERT_TO_INT  reduce using rule 137 (assign_op -> compound_op .)
    CONVERT_TO_FLT  reduce using rule 137 (assign_op -> compound_op .)
    CONVERT_TO_BLN  reduce using rule 137 (assign_op -> compound_op .)
    CONVERT_TO_STR  reduce using rule 137 (assign_op -> compound_op .)
    FUNCTION_NAME   reduce using rule 137 (assign_op -> compound_op .)
    TILDE           reduce using rule 137 (assign_op -> compound_op .)
    LPAREN          reduce using rule 137 (assign_op -> compound_op .)
    INPUT           reduce using rule 137 (assign_op -> compound_op .)
    IDENT           reduce using rule 137 (assign_op -> compound_op .)
    INT_LIT         reduce using rule 137 (assign_op -> compound_op .)
    FLT_LIT         reduce using rule 137 (assign_op -> compound_op .)
    DAY             reduce using rule 137 (assign_op -> compound_op .)
    NIGHT           reduce using rule 137 (assign_op -> compound_op .)
    STR_LIT         reduce using rule 137 (assign_op -> compound_op .)


state 239

    (138) assign_op -> EQ .

    CONVERT_TO_INT  reduce using rule 138 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 138 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 138 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 138 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 138 (assign_op -> EQ .)
    TILDE           reduce using rule 138 (assign_op -> EQ .)
    LPAREN          reduce using rule 138 (assign_op -> EQ .)
    INPUT           reduce using rule 138 (assign_op -> EQ .)
    IDENT           reduce using rule 138 (assign_op -> EQ .)
    INT_LIT         reduce using rule 138 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 138 (assign_op -> EQ .)
    DAY             reduce using rule 138 (assign_op -> EQ .)
    NIGHT           reduce using rule 138 (assign_op -> EQ .)
    STR_LIT         reduce using rule 138 (assign_op -> EQ .)


state 240

    (139) compound_op -> PLUS_EQ .

    CONVERT_TO_INT  reduce using rule 139 (compound_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 139 (compound_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 139 (compound_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 139 (compound_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 139 (compound_op -> PLUS_EQ .)
    TILDE           reduce using rule 139 (compound_op -> PLUS_EQ .)
    LPAREN          reduce using rule 139 (compound_op -> PLUS_EQ .)
    INPUT           reduce using rule 139 (compound_op -> PLUS_EQ .)
    IDENT           reduce using rule 139 (compound_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 139 (compound_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 139 (compound_op -> PLUS_EQ .)
    DAY             reduce using rule 139 (compound_op -> PLUS_EQ .)
    NIGHT           reduce using rule 139 (compound_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 139 (compound_op -> PLUS_EQ .)


state 241

    (140) compound_op -> MINUS_EQ .

    CONVERT_TO_INT  reduce using rule 140 (compound_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 140 (compound_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 140 (compound_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 140 (compound_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 140 (compound_op -> MINUS_EQ .)
    TILDE           reduce using rule 140 (compound_op -> MINUS_EQ .)
    LPAREN          reduce using rule 140 (compound_op -> MINUS_EQ .)
    INPUT           reduce using rule 140 (compound_op -> MINUS_EQ .)
    IDENT           reduce using rule 140 (compound_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 140 (compound_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 140 (compound_op -> MINUS_EQ .)
    DAY             reduce using rule 140 (compound_op -> MINUS_EQ .)
    NIGHT           reduce using rule 140 (compound_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 140 (compound_op -> MINUS_EQ .)


state 242

    (141) compound_op -> MUL_EQ .

    CONVERT_TO_INT  reduce using rule 141 (compound_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 141 (compound_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 141 (compound_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 141 (compound_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 141 (compound_op -> MUL_EQ .)
    TILDE           reduce using rule 141 (compound_op -> MUL_EQ .)
    LPAREN          reduce using rule 141 (compound_op -> MUL_EQ .)
    INPUT           reduce using rule 141 (compound_op -> MUL_EQ .)
    IDENT           reduce using rule 141 (compound_op -> MUL_EQ .)
    INT_LIT         reduce using rule 141 (compound_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 141 (compound_op -> MUL_EQ .)
    DAY             reduce using rule 141 (compound_op -> MUL_EQ .)
    NIGHT           reduce using rule 141 (compound_op -> MUL_EQ .)
    STR_LIT         reduce using rule 141 (compound_op -> MUL_EQ .)


state 243

    (142) compound_op -> DIV_EQ .

    CONVERT_TO_INT  reduce using rule 142 (compound_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 142 (compound_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 142 (compound_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 142 (compound_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 142 (compound_op -> DIV_EQ .)
    TILDE           reduce using rule 142 (compound_op -> DIV_EQ .)
    LPAREN          reduce using rule 142 (compound_op -> DIV_EQ .)
    INPUT           reduce using rule 142 (compound_op -> DIV_EQ .)
    IDENT           reduce using rule 142 (compound_op -> DIV_EQ .)
    INT_LIT         reduce using rule 142 (compound_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 142 (compound_op -> DIV_EQ .)
    DAY             reduce using rule 142 (compound_op -> DIV_EQ .)
    NIGHT           reduce using rule 142 (compound_op -> DIV_EQ .)
    STR_LIT         reduce using rule 142 (compound_op -> DIV_EQ .)


state 244

    (143) compound_op -> MOD_EQ .

    CONVERT_TO_INT  reduce using rule 143 (compound_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 143 (compound_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 143 (compound_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 143 (compound_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 143 (compound_op -> MOD_EQ .)
    TILDE           reduce using rule 143 (compound_op -> MOD_EQ .)
    LPAREN          reduce using rule 143 (compound_op -> MOD_EQ .)
    INPUT           reduce using rule 143 (compound_op -> MOD_EQ .)
    IDENT           reduce using rule 143 (compound_op -> MOD_EQ .)
    INT_LIT         reduce using rule 143 (compound_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 143 (compound_op -> MOD_EQ .)
    DAY             reduce using rule 143 (compound_op -> MOD_EQ .)
    NIGHT           reduce using rule 143 (compound_op -> MOD_EQ .)
    STR_LIT         reduce using rule 143 (compound_op -> MOD_EQ .)


state 245

    (130) output_statement -> DISPLAY value . next_val
    (131) next_val -> . COMMA value next_val
    (132) next_val -> . empty
    (169) empty -> .

    COMMA           shift and go to state 279
    NEWLINE         reduce using rule 169 (empty -> .)

    next_val                       shift and go to state 278
    empty                          shift and go to state 280

state 246

    (101) conditional_statement -> CHECK LPAREN . expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    expression                     shift and go to state 281
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 247

    (111) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (114) control_variable -> . INT IDENT EQ control_var_tail

    INT             shift and go to state 283

    control_variable               shift and go to state 282

state 248

    (112) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE statements RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    expression                     shift and go to state 284
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 249

    (113) repeat_until -> REPEAT LBRACE . statements RBRACE UNTIL LPAREN expression RPAREN
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 285
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 250

    (95) local_dec_tail -> COMMA IDENT local_dec_tail .

    NEWLINE         reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    SWAP            reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FUNCTION_NAME   reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    IDENT           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    DISPLAY         reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    CHECK           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FOR             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    UNTIL           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    REPEAT          reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    INPUT           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    INT             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    FLT             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    BLN             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    CHR             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    STR             reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    REVIVE          reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    RBRACE          reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    SHIFT           reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)
    OTHERWISE       reduce using rule 95 (local_dec_tail -> COMMA IDENT local_dec_tail .)


state 251

    (96) local_dec_tail -> EQ local_value local_dec_tail2 .

    NEWLINE         reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    SWAP            reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FUNCTION_NAME   reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    IDENT           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    DISPLAY         reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    CHECK           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FOR             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    UNTIL           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    REPEAT          reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    INPUT           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    INT             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    FLT             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    BLN             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    CHR             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    STR             reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    REVIVE          reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    RBRACE          reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    SHIFT           reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)
    OTHERWISE       reduce using rule 96 (local_dec_tail -> EQ local_value local_dec_tail2 .)


state 252

    (97) local_dec_tail2 -> COMMA . IDENT local_dec_tail

    IDENT           shift and go to state 286


state 253

    (98) local_dec_tail2 -> empty .

    NEWLINE         reduce using rule 98 (local_dec_tail2 -> empty .)
    SWAP            reduce using rule 98 (local_dec_tail2 -> empty .)
    FUNCTION_NAME   reduce using rule 98 (local_dec_tail2 -> empty .)
    IDENT           reduce using rule 98 (local_dec_tail2 -> empty .)
    DISPLAY         reduce using rule 98 (local_dec_tail2 -> empty .)
    CHECK           reduce using rule 98 (local_dec_tail2 -> empty .)
    FOR             reduce using rule 98 (local_dec_tail2 -> empty .)
    UNTIL           reduce using rule 98 (local_dec_tail2 -> empty .)
    REPEAT          reduce using rule 98 (local_dec_tail2 -> empty .)
    INPUT           reduce using rule 98 (local_dec_tail2 -> empty .)
    INT             reduce using rule 98 (local_dec_tail2 -> empty .)
    FLT             reduce using rule 98 (local_dec_tail2 -> empty .)
    BLN             reduce using rule 98 (local_dec_tail2 -> empty .)
    CHR             reduce using rule 98 (local_dec_tail2 -> empty .)
    STR             reduce using rule 98 (local_dec_tail2 -> empty .)
    REVIVE          reduce using rule 98 (local_dec_tail2 -> empty .)
    RBRACE          reduce using rule 98 (local_dec_tail2 -> empty .)
    SHIFT           reduce using rule 98 (local_dec_tail2 -> empty .)
    OTHERWISE       reduce using rule 98 (local_dec_tail2 -> empty .)


state 254

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)


state 255

    (161) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 287


state 256

    (165) typecast_value -> expression .

    RPAREN          reduce using rule 165 (typecast_value -> expression .)


state 257

    (166) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 288


state 258

    (167) typecast_value -> input_statement .

    RPAREN          reduce using rule 167 (typecast_value -> input_statement .)


state 259

    (162) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 289


state 260

    (163) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 290


state 261

    (164) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 291


state 262

    (122) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 292


state 263

    (124) arguments -> empty .

    RPAREN          reduce using rule 124 (arguments -> empty .)


state 264

    (125) arguments -> arg_value . arg_tail
    (126) arg_tail -> . COMMA arg_value arg_tail
    (127) arg_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 294
    RPAREN          reduce using rule 169 (empty -> .)

    arg_tail                       shift and go to state 293
    empty                          shift and go to state 295

state 265

    (128) arg_value -> literal .

    COMMA           reduce using rule 128 (arg_value -> literal .)
    RPAREN          reduce using rule 128 (arg_value -> literal .)


state 266

    (129) arg_value -> var_call .

    COMMA           reduce using rule 129 (arg_value -> var_call .)
    RPAREN          reduce using rule 129 (arg_value -> var_call .)


state 267

    (168) input_statement -> INPUT LPAREN RPAREN .

    RBRACE          reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    NEWLINE         reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    SWAP            reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION_NAME   reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    IDENT           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    DISPLAY         reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    CHECK           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    UNTIL           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    REPEAT          reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    FLT             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    BLN             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    CHR             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    STR             reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    REVIVE          reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    SHIFT           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    OTHERWISE       reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 168 (input_statement -> INPUT LPAREN RPAREN .)


state 268

    (85) statements_tail -> switch_statement unli_newline statements .

    REVIVE          reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)
    RBRACE          reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)
    NEWLINE         reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)
    SHIFT           reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)
    OTHERWISE       reduce using rule 85 (statements_tail -> switch_statement unli_newline statements .)


state 269

    (86) statements_tail -> loop_statement unli_newline statements .

    REVIVE          reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)
    RBRACE          reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)
    NEWLINE         reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)
    SHIFT           reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)
    OTHERWISE       reduce using rule 86 (statements_tail -> loop_statement unli_newline statements .)


state 270

    (87) statements_tail -> function_call unli_newline statements .

    REVIVE          reduce using rule 87 (statements_tail -> function_call unli_newline statements .)
    RBRACE          reduce using rule 87 (statements_tail -> function_call unli_newline statements .)
    NEWLINE         reduce using rule 87 (statements_tail -> function_call unli_newline statements .)
    SHIFT           reduce using rule 87 (statements_tail -> function_call unli_newline statements .)
    OTHERWISE       reduce using rule 87 (statements_tail -> function_call unli_newline statements .)


state 271

    (88) statements_tail -> assignment_statement unli_newline statements .

    REVIVE          reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)
    RBRACE          reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)
    NEWLINE         reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)
    SHIFT           reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)
    OTHERWISE       reduce using rule 88 (statements_tail -> assignment_statement unli_newline statements .)


state 272

    (89) statements_tail -> output_statement unli_newline statements .

    REVIVE          reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)
    RBRACE          reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)
    NEWLINE         reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)
    SHIFT           reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)
    OTHERWISE       reduce using rule 89 (statements_tail -> output_statement unli_newline statements .)


state 273

    (90) statements_tail -> conditional_statement unli_newline statements .

    REVIVE          reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)
    RBRACE          reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)
    NEWLINE         reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)
    SHIFT           reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)
    OTHERWISE       reduce using rule 90 (statements_tail -> conditional_statement unli_newline statements .)


state 274

    (104) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    RPAREN          shift and go to state 296


state 275

    (134) assign_tail -> DOT SPLICE . LPAREN start COMMA deleteCount COMMA splice_items RPAREN

    LPAREN          shift and go to state 297


state 276

    (135) assign_tail -> DOT PUSH . LPAREN list_element RPAREN

    LPAREN          shift and go to state 298


state 277

    (136) assign_tail -> assign_op value .

    NEWLINE         reduce using rule 136 (assign_tail -> assign_op value .)


state 278

    (130) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 130 (output_statement -> DISPLAY value next_val .)


state 279

    (131) next_val -> COMMA . value next_val
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 188
    CONVERT_TO_FLT  shift and go to state 189
    CONVERT_TO_BLN  shift and go to state 190
    CONVERT_TO_STR  shift and go to state 191
    FUNCTION_NAME   shift and go to state 192
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 194
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    value                          shift and go to state 299
    type_cast                      shift and go to state 185
    expression                     shift and go to state 186
    function_call                  shift and go to state 187
    factor                         shift and go to state 46
    input_statement                shift and go to state 193
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 280

    (132) next_val -> empty .

    NEWLINE         reduce using rule 132 (next_val -> empty .)


state 281

    (101) conditional_statement -> CHECK LPAREN expression . RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 300


state 282

    (111) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 301


state 283

    (114) control_variable -> INT . IDENT EQ control_var_tail

    IDENT           shift and go to state 302


state 284

    (112) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 303


state 285

    (113) repeat_until -> REPEAT LBRACE statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 304


state 286

    (97) local_dec_tail2 -> COMMA IDENT . local_dec_tail
    (94) local_dec_tail -> . empty
    (95) local_dec_tail -> . COMMA IDENT local_dec_tail
    (96) local_dec_tail -> . EQ local_value local_dec_tail2
    (169) empty -> .

    COMMA           shift and go to state 179
    EQ              shift and go to state 180
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    REVIVE          reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    local_dec_tail                 shift and go to state 305
    empty                          shift and go to state 178

state 287

    (161) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    RBRACE          reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 161 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 288

    (166) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 306


state 289

    (162) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    RBRACE          reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 162 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 290

    (163) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    RBRACE          reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INT             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    STR             reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 163 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 291

    (164) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    RBRACE          reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    NEWLINE         reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INT             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    STR             reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 164 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 292

    (122) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    RBRACE          reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    NEWLINE         reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SWAP            reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FUNCTION_NAME   reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    IDENT           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    DISPLAY         reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHECK           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FOR             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    UNTIL           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REPEAT          reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INPUT           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INT             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FLT             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    BLN             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHR             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    STR             reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REVIVE          reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SHIFT           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    OTHERWISE       reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 122 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 293

    (125) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 125 (arguments -> arg_value arg_tail .)


state 294

    (126) arg_tail -> COMMA . arg_value arg_tail
    (128) arg_value -> . literal
    (129) arg_value -> . var_call
    (53) literal -> . literal1
    (54) literal -> . literal2
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57
    CHR_LIT         shift and go to state 87

    arg_value                      shift and go to state 307
    literal                        shift and go to state 265
    var_call                       shift and go to state 266
    literal1                       shift and go to state 85
    literal2                       shift and go to state 86

state 295

    (127) arg_tail -> empty .

    RPAREN          reduce using rule 127 (arg_tail -> empty .)


state 296

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE

    LBRACE          shift and go to state 308


state 297

    (134) assign_tail -> DOT SPLICE LPAREN . start COMMA deleteCount COMMA splice_items RPAREN
    (144) start -> . INT_LIT

    INT_LIT         shift and go to state 310

    start                          shift and go to state 309

state 298

    (135) assign_tail -> DOT PUSH LPAREN . list_element RPAREN
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57
    CHR_LIT         shift and go to state 87

    list_element                   shift and go to state 311
    literal                        shift and go to state 84
    literal1                       shift and go to state 85
    literal2                       shift and go to state 86

state 299

    (131) next_val -> COMMA value . next_val
    (131) next_val -> . COMMA value next_val
    (132) next_val -> . empty
    (169) empty -> .

    COMMA           shift and go to state 279
    NEWLINE         reduce using rule 169 (empty -> .)

    next_val                       shift and go to state 312
    empty                          shift and go to state 280

state 300

    (101) conditional_statement -> CHECK LPAREN expression RPAREN . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 313


state 301

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN LBRACE statements RBRACE
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    expression                     shift and go to state 314
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 302

    (114) control_variable -> INT IDENT . EQ control_var_tail

    EQ              shift and go to state 315


state 303

    (112) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 316


state 304

    (113) repeat_until -> REPEAT LBRACE statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 317


state 305

    (97) local_dec_tail2 -> COMMA IDENT local_dec_tail .

    NEWLINE         reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    SWAP            reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FUNCTION_NAME   reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    IDENT           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    DISPLAY         reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    CHECK           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FOR             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    UNTIL           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    REPEAT          reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    INPUT           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    INT             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    FLT             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    BLN             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    CHR             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    STR             reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    REVIVE          reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    RBRACE          reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    SHIFT           reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)
    OTHERWISE       reduce using rule 97 (local_dec_tail2 -> COMMA IDENT local_dec_tail .)


state 306

    (166) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 166 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 307

    (126) arg_tail -> COMMA arg_value . arg_tail
    (126) arg_tail -> . COMMA arg_value arg_tail
    (127) arg_tail -> . empty
    (169) empty -> .

    COMMA           shift and go to state 294
    RPAREN          reduce using rule 169 (empty -> .)

    arg_tail                       shift and go to state 318
    empty                          shift and go to state 295

state 308

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . switch_condition OTHERWISE LBRACE statements RBRACE RBRACE
    (105) switch_condition -> . SHIFT value COLON statements switchcond_tail

    SHIFT           shift and go to state 320

    switch_condition               shift and go to state 319

state 309

    (134) assign_tail -> DOT SPLICE LPAREN start . COMMA deleteCount COMMA splice_items RPAREN

    COMMA           shift and go to state 321


state 310

    (144) start -> INT_LIT .

    COMMA           reduce using rule 144 (start -> INT_LIT .)


state 311

    (135) assign_tail -> DOT PUSH LPAREN list_element . RPAREN

    RPAREN          shift and go to state 322


state 312

    (131) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 131 (next_val -> COMMA value next_val .)


state 313

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 323
    empty                          shift and go to state 17

state 314

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN LBRACE statements RBRACE

    SEMICOLON       shift and go to state 324


state 315

    (114) control_variable -> INT IDENT EQ . control_var_tail
    (115) control_var_tail -> . INT_LIT
    (116) control_var_tail -> . var_call
    (149) var_call -> . IDENT list_index

    INT_LIT         shift and go to state 326
    IDENT           shift and go to state 54

    control_var_tail               shift and go to state 325
    var_call                       shift and go to state 327

state 316

    (112) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . statements RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 328
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 317

    (113) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 329


state 318

    (126) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 126 (arg_tail -> COMMA arg_value arg_tail .)


state 319

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition . OTHERWISE LBRACE statements RBRACE RBRACE

    OTHERWISE       shift and go to state 330


state 320

    (105) switch_condition -> SHIFT . value COLON statements switchcond_tail
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 188
    CONVERT_TO_FLT  shift and go to state 189
    CONVERT_TO_BLN  shift and go to state 190
    CONVERT_TO_STR  shift and go to state 191
    FUNCTION_NAME   shift and go to state 192
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 194
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    value                          shift and go to state 331
    type_cast                      shift and go to state 185
    expression                     shift and go to state 186
    function_call                  shift and go to state 187
    factor                         shift and go to state 46
    input_statement                shift and go to state 193
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 321

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA . deleteCount COMMA splice_items RPAREN
    (145) deleteCount -> . empty
    (146) deleteCount -> . INT_LIT
    (169) empty -> .

    INT_LIT         shift and go to state 334
    COMMA           reduce using rule 169 (empty -> .)

    deleteCount                    shift and go to state 332
    empty                          shift and go to state 333

state 322

    (135) assign_tail -> DOT PUSH LPAREN list_element RPAREN .

    NEWLINE         reduce using rule 135 (assign_tail -> DOT PUSH LPAREN list_element RPAREN .)


state 323

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 335
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 324

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN LBRACE statements RBRACE
    (117) update -> . var_call update_tail
    (149) var_call -> . IDENT list_index

    IDENT           shift and go to state 54

    update                         shift and go to state 336
    var_call                       shift and go to state 337

state 325

    (114) control_variable -> INT IDENT EQ control_var_tail .

    SEMICOLON       reduce using rule 114 (control_variable -> INT IDENT EQ control_var_tail .)


state 326

    (115) control_var_tail -> INT_LIT .

    SEMICOLON       reduce using rule 115 (control_var_tail -> INT_LIT .)


state 327

    (116) control_var_tail -> var_call .

    SEMICOLON       reduce using rule 116 (control_var_tail -> var_call .)


state 328

    (112) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 338


state 329

    (113) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN . expression RPAREN
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    expression                     shift and go to state 339
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 330

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE . LBRACE statements RBRACE RBRACE

    LBRACE          shift and go to state 340


state 331

    (105) switch_condition -> SHIFT value . COLON statements switchcond_tail

    COLON           shift and go to state 341


state 332

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount . COMMA splice_items RPAREN

    COMMA           shift and go to state 342


state 333

    (145) deleteCount -> empty .

    COMMA           reduce using rule 145 (deleteCount -> empty .)


state 334

    (146) deleteCount -> INT_LIT .

    COMMA           reduce using rule 146 (deleteCount -> INT_LIT .)


state 335

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 343
    empty                          shift and go to state 17

state 336

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 344


state 337

    (117) update -> var_call . update_tail
    (118) update_tail -> . postfix_op
    (119) update_tail -> . compound_op value
    (120) postfix_op -> . PLUS_PLUS
    (121) postfix_op -> . MINUS_MINUS
    (139) compound_op -> . PLUS_EQ
    (140) compound_op -> . MINUS_EQ
    (141) compound_op -> . MUL_EQ
    (142) compound_op -> . DIV_EQ
    (143) compound_op -> . MOD_EQ

    PLUS_PLUS       shift and go to state 91
    MINUS_MINUS     shift and go to state 92
    PLUS_EQ         shift and go to state 240
    MINUS_EQ        shift and go to state 241
    MUL_EQ          shift and go to state 242
    DIV_EQ          shift and go to state 243
    MOD_EQ          shift and go to state 244

    update_tail                    shift and go to state 345
    postfix_op                     shift and go to state 346
    compound_op                    shift and go to state 347

state 338

    (112) until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 112 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE statements RBRACE .)


state 339

    (113) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 348


state 340

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE . statements RBRACE RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 349
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 341

    (105) switch_condition -> SHIFT value COLON . statements switchcond_tail
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SHIFT           reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 350
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 342

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA . splice_items RPAREN
    (147) splice_items -> . empty
    (148) splice_items -> . list_element
    (169) empty -> .
    (24) list_element -> . literal element_tail
    (53) literal -> . literal1
    (54) literal -> . literal2
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT
    (60) literal2 -> . CHR_LIT

    RPAREN          reduce using rule 169 (empty -> .)
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57
    CHR_LIT         shift and go to state 87

    splice_items                   shift and go to state 351
    empty                          shift and go to state 352
    list_element                   shift and go to state 353
    literal                        shift and go to state 84
    literal1                       shift and go to state 85
    literal2                       shift and go to state 86

state 343

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RBRACE          shift and go to state 354


state 344

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 355


state 345

    (117) update -> var_call update_tail .

    RPAREN          reduce using rule 117 (update -> var_call update_tail .)


state 346

    (118) update_tail -> postfix_op .

    RPAREN          reduce using rule 118 (update_tail -> postfix_op .)


state 347

    (119) update_tail -> compound_op . value
    (158) value -> . type_cast
    (159) value -> . expression
    (160) value -> . function_call
    (161) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (162) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (163) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (164) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (32) expression -> . factor factor_tail
    (122) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (123) function_call -> . input_statement
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (168) input_statement -> . INPUT LPAREN RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 188
    CONVERT_TO_FLT  shift and go to state 189
    CONVERT_TO_BLN  shift and go to state 190
    CONVERT_TO_STR  shift and go to state 191
    FUNCTION_NAME   shift and go to state 192
    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    INPUT           shift and go to state 194
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    value                          shift and go to state 356
    type_cast                      shift and go to state 185
    expression                     shift and go to state 186
    function_call                  shift and go to state 187
    factor                         shift and go to state 46
    input_statement                shift and go to state 193
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 348

    (113) repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 113 (repeat_until -> REPEAT LBRACE statements RBRACE UNTIL LPAREN expression RPAREN .)


state 349

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements . RBRACE RBRACE

    RBRACE          shift and go to state 357


state 350

    (105) switch_condition -> SHIFT value COLON statements . switchcond_tail
    (106) switchcond_tail -> . switch_condition
    (107) switchcond_tail -> . empty
    (105) switch_condition -> . SHIFT value COLON statements switchcond_tail
    (169) empty -> .

    SHIFT           shift and go to state 320
    OTHERWISE       reduce using rule 169 (empty -> .)

    switchcond_tail                shift and go to state 358
    switch_condition               shift and go to state 359
    empty                          shift and go to state 360

state 351

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items . RPAREN

    RPAREN          shift and go to state 361


state 352

    (147) splice_items -> empty .

    RPAREN          reduce using rule 147 (splice_items -> empty .)


state 353

    (148) splice_items -> list_element .

    RPAREN          reduce using rule 148 (splice_items -> list_element .)


state 354

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    OTHERWISE_CHECK reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 362
    empty                          shift and go to state 17

state 355

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE . statements RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 363
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 356

    (119) update_tail -> compound_op value .

    RPAREN          reduce using rule 119 (update_tail -> compound_op value .)


state 357

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE . RBRACE

    RBRACE          shift and go to state 364


state 358

    (105) switch_condition -> SHIFT value COLON statements switchcond_tail .

    OTHERWISE       reduce using rule 105 (switch_condition -> SHIFT value COLON statements switchcond_tail .)


state 359

    (106) switchcond_tail -> switch_condition .

    OTHERWISE       reduce using rule 106 (switchcond_tail -> switch_condition .)


state 360

    (107) switchcond_tail -> empty .

    OTHERWISE       reduce using rule 107 (switchcond_tail -> empty .)


state 361

    (134) assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN .

    NEWLINE         reduce using rule 134 (assign_tail -> DOT SPLICE LPAREN start COMMA deleteCount COMMA splice_items RPAREN .)


state 362

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (102) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (103) conditional_tail -> . empty
    (169) empty -> .

    OTHERWISE_CHECK shift and go to state 366
    NEWLINE         reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    conditional_tail               shift and go to state 365
    empty                          shift and go to state 367

state 363

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 368


state 364

    (104) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE .

    NEWLINE         reduce using rule 104 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE switch_condition OTHERWISE LBRACE statements RBRACE RBRACE .)


state 365

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    OTHERWISE       reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 369
    empty                          shift and go to state 17

state 366

    (102) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail

    LPAREN          shift and go to state 370


state 367

    (103) conditional_tail -> empty .

    NEWLINE         reduce using rule 103 (conditional_tail -> empty .)
    OTHERWISE       reduce using rule 103 (conditional_tail -> empty .)


state 368

    (111) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE .

    NEWLINE         reduce using rule 111 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN LBRACE statements RBRACE .)


state 369

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    OTHERWISE       shift and go to state 371


state 370

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN LBRACE statements RBRACE conditional_tail
    (32) expression -> . factor factor_tail
    (33) factor -> . var_call postfix
    (34) factor -> . literal1
    (35) factor -> . TILDE INT_LIT
    (36) factor -> . TILDE FLT_LIT
    (37) factor -> . LPAREN expression RPAREN
    (149) var_call -> . IDENT list_index
    (55) literal1 -> . INT_LIT
    (56) literal1 -> . FLT_LIT
    (57) literal1 -> . DAY
    (58) literal1 -> . NIGHT
    (59) literal1 -> . STR_LIT

    TILDE           shift and go to state 50
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 51
    FLT_LIT         shift and go to state 52
    DAY             shift and go to state 55
    NIGHT           shift and go to state 56
    STR_LIT         shift and go to state 57

    expression                     shift and go to state 372
    factor                         shift and go to state 46
    var_call                       shift and go to state 48
    literal1                       shift and go to state 49

state 371

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    LBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 373
    empty                          shift and go to state 17

state 372

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN LBRACE statements RBRACE conditional_tail

    RPAREN          shift and go to state 374


state 373

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 375


state 374

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . LBRACE statements RBRACE conditional_tail

    LBRACE          shift and go to state 376


state 375

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 18
    INT             reduce using rule 169 (empty -> .)
    FLT             reduce using rule 169 (empty -> .)
    BLN             reduce using rule 169 (empty -> .)
    CHR             reduce using rule 169 (empty -> .)
    STR             reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)

  ! NEWLINE         [ reduce using rule 169 (empty -> .) ]

    maybe_newline                  shift and go to state 377
    empty                          shift and go to state 17

state 376

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE . statements RBRACE conditional_tail
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 169 (empty -> .)
    NEWLINE         reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 378
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 377

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (83) statements -> . empty
    (84) statements -> . local_dec maybe_newline statements_tail
    (169) empty -> .
    (92) local_dec -> . var_statement local_dec_tail
    (93) local_dec -> . empty
    (11) var_statement -> . data_type IDENT list_dec
    (27) data_type -> . INT
    (28) data_type -> . FLT
    (29) data_type -> . BLN
    (30) data_type -> . CHR
    (31) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 169 (empty -> .)
    RBRACE          reduce using rule 169 (empty -> .)
    SWAP            reduce using rule 169 (empty -> .)
    FUNCTION_NAME   reduce using rule 169 (empty -> .)
    IDENT           reduce using rule 169 (empty -> .)
    DISPLAY         reduce using rule 169 (empty -> .)
    CHECK           reduce using rule 169 (empty -> .)
    FOR             reduce using rule 169 (empty -> .)
    UNTIL           reduce using rule 169 (empty -> .)
    REPEAT          reduce using rule 169 (empty -> .)
    INPUT           reduce using rule 169 (empty -> .)
    INT             shift and go to state 10
    FLT             shift and go to state 11
    BLN             shift and go to state 12
    CHR             shift and go to state 13
    STR             shift and go to state 14

  ! INT             [ reduce using rule 169 (empty -> .) ]
  ! FLT             [ reduce using rule 169 (empty -> .) ]
  ! BLN             [ reduce using rule 169 (empty -> .) ]
  ! CHR             [ reduce using rule 169 (empty -> .) ]
  ! STR             [ reduce using rule 169 (empty -> .) ]

    statements                     shift and go to state 379
    empty                          shift and go to state 167
    local_dec                      shift and go to state 168
    var_statement                  shift and go to state 169
    data_type                      shift and go to state 9

state 378

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements . RBRACE conditional_tail

    RBRACE          shift and go to state 380


state 379

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (169) empty -> .

    NEWLINE         shift and go to state 18
    RBRACE          reduce using rule 169 (empty -> .)

    maybe_newline                  shift and go to state 381
    empty                          shift and go to state 17

state 380

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE . conditional_tail
    (102) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail
    (103) conditional_tail -> . empty
    (169) empty -> .

    OTHERWISE_CHECK shift and go to state 366
    NEWLINE         reduce using rule 169 (empty -> .)
    OTHERWISE       reduce using rule 169 (empty -> .)

    conditional_tail               shift and go to state 382
    empty                          shift and go to state 367

state 381

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 383


state 382

    (102) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .

    NEWLINE         reduce using rule 102 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .)
    OTHERWISE       reduce using rule 102 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN LBRACE statements RBRACE conditional_tail .)


state 383

    (101) conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 101 (conditional_statement -> CHECK LPAREN expression RPAREN LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 18 resolved as shift
WARNING: shift/reduce conflict for INT in state 160 resolved as shift
WARNING: shift/reduce conflict for FLT in state 160 resolved as shift
WARNING: shift/reduce conflict for BLN in state 160 resolved as shift
WARNING: shift/reduce conflict for CHR in state 160 resolved as shift
WARNING: shift/reduce conflict for STR in state 160 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 165 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 168 resolved as shift
WARNING: shift/reduce conflict for INT in state 172 resolved as shift
WARNING: shift/reduce conflict for FLT in state 172 resolved as shift
WARNING: shift/reduce conflict for BLN in state 172 resolved as shift
WARNING: shift/reduce conflict for CHR in state 172 resolved as shift
WARNING: shift/reduce conflict for STR in state 172 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 176 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 176 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 176 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 176 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 176 resolved as shift
WARNING: shift/reduce conflict for FOR in state 176 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 176 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 176 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 176 resolved as shift
WARNING: shift/reduce conflict for INT in state 176 resolved as shift
WARNING: shift/reduce conflict for FLT in state 176 resolved as shift
WARNING: shift/reduce conflict for BLN in state 176 resolved as shift
WARNING: shift/reduce conflict for CHR in state 176 resolved as shift
WARNING: shift/reduce conflict for STR in state 176 resolved as shift
WARNING: shift/reduce conflict for INT in state 228 resolved as shift
WARNING: shift/reduce conflict for FLT in state 228 resolved as shift
WARNING: shift/reduce conflict for BLN in state 228 resolved as shift
WARNING: shift/reduce conflict for CHR in state 228 resolved as shift
WARNING: shift/reduce conflict for STR in state 228 resolved as shift
WARNING: shift/reduce conflict for INT in state 229 resolved as shift
WARNING: shift/reduce conflict for FLT in state 229 resolved as shift
WARNING: shift/reduce conflict for BLN in state 229 resolved as shift
WARNING: shift/reduce conflict for CHR in state 229 resolved as shift
WARNING: shift/reduce conflict for STR in state 229 resolved as shift
WARNING: shift/reduce conflict for INT in state 230 resolved as shift
WARNING: shift/reduce conflict for FLT in state 230 resolved as shift
WARNING: shift/reduce conflict for BLN in state 230 resolved as shift
WARNING: shift/reduce conflict for CHR in state 230 resolved as shift
WARNING: shift/reduce conflict for STR in state 230 resolved as shift
WARNING: shift/reduce conflict for INT in state 231 resolved as shift
WARNING: shift/reduce conflict for FLT in state 231 resolved as shift
WARNING: shift/reduce conflict for BLN in state 231 resolved as shift
WARNING: shift/reduce conflict for CHR in state 231 resolved as shift
WARNING: shift/reduce conflict for STR in state 231 resolved as shift
WARNING: shift/reduce conflict for INT in state 232 resolved as shift
WARNING: shift/reduce conflict for FLT in state 232 resolved as shift
WARNING: shift/reduce conflict for BLN in state 232 resolved as shift
WARNING: shift/reduce conflict for CHR in state 232 resolved as shift
WARNING: shift/reduce conflict for STR in state 232 resolved as shift
WARNING: shift/reduce conflict for INT in state 233 resolved as shift
WARNING: shift/reduce conflict for FLT in state 233 resolved as shift
WARNING: shift/reduce conflict for BLN in state 233 resolved as shift
WARNING: shift/reduce conflict for CHR in state 233 resolved as shift
WARNING: shift/reduce conflict for STR in state 233 resolved as shift
WARNING: shift/reduce conflict for INT in state 249 resolved as shift
WARNING: shift/reduce conflict for FLT in state 249 resolved as shift
WARNING: shift/reduce conflict for BLN in state 249 resolved as shift
WARNING: shift/reduce conflict for CHR in state 249 resolved as shift
WARNING: shift/reduce conflict for STR in state 249 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 313 resolved as shift
WARNING: shift/reduce conflict for INT in state 316 resolved as shift
WARNING: shift/reduce conflict for FLT in state 316 resolved as shift
WARNING: shift/reduce conflict for BLN in state 316 resolved as shift
WARNING: shift/reduce conflict for CHR in state 316 resolved as shift
WARNING: shift/reduce conflict for STR in state 316 resolved as shift
WARNING: shift/reduce conflict for INT in state 323 resolved as shift
WARNING: shift/reduce conflict for FLT in state 323 resolved as shift
WARNING: shift/reduce conflict for BLN in state 323 resolved as shift
WARNING: shift/reduce conflict for CHR in state 323 resolved as shift
WARNING: shift/reduce conflict for STR in state 323 resolved as shift
WARNING: shift/reduce conflict for INT in state 340 resolved as shift
WARNING: shift/reduce conflict for FLT in state 340 resolved as shift
WARNING: shift/reduce conflict for BLN in state 340 resolved as shift
WARNING: shift/reduce conflict for CHR in state 340 resolved as shift
WARNING: shift/reduce conflict for STR in state 340 resolved as shift
WARNING: shift/reduce conflict for INT in state 341 resolved as shift
WARNING: shift/reduce conflict for FLT in state 341 resolved as shift
WARNING: shift/reduce conflict for BLN in state 341 resolved as shift
WARNING: shift/reduce conflict for CHR in state 341 resolved as shift
WARNING: shift/reduce conflict for STR in state 341 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 354 resolved as shift
WARNING: shift/reduce conflict for INT in state 355 resolved as shift
WARNING: shift/reduce conflict for FLT in state 355 resolved as shift
WARNING: shift/reduce conflict for BLN in state 355 resolved as shift
WARNING: shift/reduce conflict for CHR in state 355 resolved as shift
WARNING: shift/reduce conflict for STR in state 355 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 375 resolved as shift
WARNING: shift/reduce conflict for INT in state 376 resolved as shift
WARNING: shift/reduce conflict for FLT in state 376 resolved as shift
WARNING: shift/reduce conflict for BLN in state 376 resolved as shift
WARNING: shift/reduce conflict for CHR in state 376 resolved as shift
WARNING: shift/reduce conflict for STR in state 376 resolved as shift
WARNING: shift/reduce conflict for INT in state 377 resolved as shift
WARNING: shift/reduce conflict for FLT in state 377 resolved as shift
WARNING: shift/reduce conflict for BLN in state 377 resolved as shift
WARNING: shift/reduce conflict for CHR in state 377 resolved as shift
WARNING: shift/reduce conflict for STR in state 377 resolved as shift
WARNING: reduce/reduce conflict in state 167 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 167
WARNING: reduce/reduce conflict in state 221 resolved using rule (function_statements -> empty)
WARNING: rejected rule (function_statements_tail -> empty) in state 221
WARNING: Rule (function_statements_tail -> empty) is never reduced
