Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_statement -> data_type IDENT global_statement_tail
Rule 11    global_statement_tail -> empty
Rule 12    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 13    global_statement_tail -> EQ global_dec_value global_tail2
Rule 14    global_tail2 -> empty
Rule 15    global_tail2 -> COMMA IDENT global_statement_tail
Rule 16    global_dec_value -> global_value
Rule 17    global_dec_value -> LBRACKET list_element RBRACKET
Rule 18    global_value -> expression
Rule 19    var_statement -> data_type IDENT var_tail unli_newline
Rule 20    var_tail -> empty
Rule 21    var_tail -> EQ tail_value var_tail2
Rule 22    var_tail -> COMMA IDENT var_tail
Rule 23    var_tail2 -> empty
Rule 24    var_tail2 -> COMMA IDENT var_tail
Rule 25    tail_value -> value
Rule 26    tail_value -> LBRACKET list_element RBRACKET
Rule 27    list_element -> literal element_tail
Rule 28    element_tail -> empty
Rule 29    element_tail -> COMMA list_element
Rule 30    index -> INT_LIT
Rule 31    index -> IDENT
Rule 32    data_type -> INT
Rule 33    data_type -> FLT
Rule 34    data_type -> BLN
Rule 35    data_type -> CHR
Rule 36    data_type -> STR
Rule 37    value -> type_cast
Rule 38    value -> expression
Rule 39    value -> function_call
Rule 40    type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 41    type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 42    type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 43    type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 44    typecast_value -> expression
Rule 45    typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 46    typecast_value -> input_statement
Rule 47    literal -> INT_LIT
Rule 48    literal -> FLT_LIT
Rule 49    literal -> DAY
Rule 50    literal -> NIGHT
Rule 51    literal -> CHR_LIT
Rule 52    literal -> STR_LIT
Rule 53    expression -> factor factor_tail
Rule 54    factor -> var_call
Rule 55    factor -> literal
Rule 56    factor -> TILDE literal
Rule 57    factor -> LPAREN expression RPAREN
Rule 58    factor_tail -> empty
Rule 59    factor_tail -> PLUS expression
Rule 60    factor_tail -> MINUS expression
Rule 61    factor_tail -> MULTIPLY expression
Rule 62    factor_tail -> DIVISION expression
Rule 63    factor_tail -> MODULO expression
Rule 64    factor_tail -> EXPONENT expression
Rule 65    factor_tail -> GT expression
Rule 66    factor_tail -> LT expression
Rule 67    factor_tail -> EQ_EQ expression
Rule 68    factor_tail -> GT_EQ expression
Rule 69    factor_tail -> LT_EQ expression
Rule 70    factor_tail -> NOT_EQ expression
Rule 71    factor_tail -> AND expression
Rule 72    factor_tail -> OR expression
Rule 73    var_call -> IDENT var_call_tail
Rule 74    var_call_tail -> empty
Rule 75    var_call_tail -> LBRACKET index RBRACKET
Rule 76    function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
Rule 77    function_statements -> empty
Rule 78    function_statements_tail -> function_statements
Rule 79    ret_type -> FUNCTION
Rule 80    ret_type -> function_dtype
Rule 81    function_dtype -> FUNCTION_INT
Rule 82    function_dtype -> FUNCTION_FLT
Rule 83    function_dtype -> FUNCTION_CHR
Rule 84    function_dtype -> FUNCTION_BLN
Rule 85    function_dtype -> FUNCTION_STR
Rule 86    function_dtype -> FUNCTION_LIST_INT
Rule 87    function_dtype -> FUNCTION_LIST_FLT
Rule 88    function_dtype -> FUNCTION_LIST_CHR
Rule 89    function_dtype -> FUNCTION_LIST_STR
Rule 90    function_dtype -> FUNCTION_LIST_BLN
Rule 91    parameters -> data_type IDENT parameters_tail
Rule 92    parameters -> empty
Rule 93    parameters_tail -> empty
Rule 94    parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 95    revive -> REVIVE value
Rule 96    revive -> empty
Rule 97    statements -> empty
Rule 98    statements -> local_dec maybe_newline statements_tail
Rule 99    statements_tail -> string_operation_statement unli_newline statements
Rule 100   statements_tail -> conditional_statement unli_newline statements
Rule 101   statements_tail -> switch_statement unli_newline statements
Rule 102   statements_tail -> loop_statement unli_newline statements
Rule 103   statements_tail -> function_call unli_newline statements
Rule 104   statements_tail -> output_statement unli_newline statements
Rule 105   statements_tail -> statements
Rule 106   local_dec -> empty
Rule 107   local_dec -> var_statement
Rule 108   conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
Rule 109   conditional_tail -> empty
Rule 110   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
Rule 111   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
Rule 112   switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail
Rule 113   switchcond_tail -> empty
Rule 114   switchcond_tail -> switch_condition
Rule 115   loop_statement -> for_loop
Rule 116   loop_statement -> until_loop
Rule 117   loop_statement -> repeat_until
Rule 118   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
Rule 119   until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
Rule 120   repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
Rule 121   control_variable -> INT IDENT EQ INT_LIT
Rule 122   update -> var_call update_tail
Rule 123   update_tail -> postfix
Rule 124   update_tail -> assign_op value
Rule 125   postfix -> PLUS_PLUS
Rule 126   postfix -> MINUS_MINUS
Rule 127   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 128   function_call -> output_statement
Rule 129   arguments -> empty
Rule 130   arguments -> arg_value arg_tail
Rule 131   arg_tail -> empty
Rule 132   arg_tail -> COMMA arg_value arg_tail
Rule 133   arg_value -> literal
Rule 134   arg_value -> var_call
Rule 135   output_statement -> DISPLAY value next_val
Rule 136   output_statement -> DISPLAY LPAREN value next_val RPAREN
Rule 137   next_val -> empty
Rule 138   next_val -> COMMA value next_val
Rule 139   input_statement -> INPUT LPAREN RPAREN
Rule 140   string_operation_statement -> var_call string_operation_tail
Rule 141   string_operation_tail -> PLUS string_val stringcon_tail
Rule 142   string_operation_tail -> update_tail
Rule 143   assign_op -> PLUS_EQ
Rule 144   assign_op -> MINUS_EQ
Rule 145   assign_op -> MUL_EQ
Rule 146   assign_op -> DIV_EQ
Rule 147   assign_op -> MOD_EQ
Rule 148   assign_op -> EQ
Rule 149   stringcon_tail -> empty
Rule 150   stringcon_tail -> PLUS string_val stringcon_tail
Rule 151   string_val -> var_call
Rule 152   string_val -> STR_LIT
Rule 153   empty -> <empty>

Terminals, with rules where they appear

AND                  : 71
BIRTH                : 1
BLN                  : 34
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 108
CHR                  : 35
CHR_LIT              : 51
COLON                : 112
COMMA                : 12 15 22 24 29 94 132 138
COMMENT              : 
CONVERT_TO_BLN       : 42
CONVERT_TO_FLT       : 41
CONVERT_TO_INT       : 40
CONVERT_TO_STR       : 43
DAY                  : 49
DISPLAY              : 135 136
DIVISION             : 62
DIV_EQ               : 146
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 13 21 121 148
EQ_EQ                : 67
EXPONENT             : 64
FLT                  : 33
FLT_LIT              : 48
FOR                  : 118
FUNCTION             : 79
FUNCTION_BLN         : 84
FUNCTION_CHR         : 83
FUNCTION_FLT         : 82
FUNCTION_INT         : 81
FUNCTION_LIST_BLN    : 90
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 88
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 87
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 86
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 89
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 45 76 127
FUNCTION_STR         : 85
GHOST                : 1
GT                   : 65
GT_EQ                : 68
IDENT                : 10 12 15 19 22 24 31 73 91 94 111 121
ILLEGAL              : 
IN                   : 
INPUT                : 139
INT                  : 32 121
INT_LIT              : 30 47 121
LBRACE               : 6 76 108 108 110 111 111 118 119 120
LBRACKET             : 17 26 75
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 40 41 42 43 45 57 76 108 110 111 118 119 120 127 136 139
LT                   : 66
LT_EQ                : 69
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 60
MINUS_EQ             : 144
MINUS_MINUS          : 126
MODULO               : 63
MOD_EQ               : 147
MULTIPLY             : 61
MUL_EQ               : 145
NEWLINE              : 3 4 5
NIGHT                : 50
NOT                  : 
NOT_EQ               : 70
OR                   : 72
OTHERWISE            : 108 111
OTHERWISE_CHECK      : 110
PLUS                 : 59 141 150
PLUS_EQ              : 143
PLUS_PLUS            : 125
POW                  : 
RBRACE               : 6 76 108 108 110 111 111 118 119 120
RBRACKET             : 17 26 75
REPEAT               : 120
REVIVE               : 95
RPAREN               : 6 40 41 42 43 45 57 76 108 110 111 118 119 120 127 136 139
SEMICOLON            : 118 118
SHIFT                : 112
SKIP                 : 
STOP                 : 
STR                  : 36
STR_LIT              : 52 152
SWAP                 : 111
TILDE                : 56
TYPE                 : 
UNTIL                : 119 120
error                : 

Nonterminals, with rules where they appear

arg_tail             : 130 132
arg_value            : 130 132
arguments            : 127
assign_op            : 124
conditional_statement : 100
conditional_tail     : 108 110
control_variable     : 118
data_type            : 10 19 91 94
element_tail         : 27
empty                : 2 8 11 14 20 23 28 58 74 77 92 93 96 97 106 109 113 129 131 137 149
expression           : 18 38 44 57 59 60 61 62 63 64 65 66 67 68 69 70 71 72 108 110 118 119 120
factor               : 53
factor_tail          : 53
for_loop             : 115
function_call        : 39 103
function_dtype       : 80
function_statements  : 1 78
function_statements_tail : 76
global_dec           : 1 9
global_dec_value     : 13
global_statement     : 7
global_statement_tail : 10 12 15
global_tail          : 7
global_tail2         : 13
global_value         : 16
index                : 75
input_statement      : 46
list_element         : 17 26 29
literal              : 27 55 56 133
local_dec            : 98
loop_statement       : 102
main_function        : 1
maybe_newline        : 1 1 3 6 6 6 76 76 76 98 108 108 108 108 108 108 110 110 110 111 111 111 111 111 111 112 118 118 119 120
next_val             : 135 136 138
output_statement     : 104 128
parameters           : 76
parameters_tail      : 91 94
postfix              : 123
program              : 0
repeat_until         : 117
ret_type             : 76
revive               : 76
statements           : 6 76 99 100 101 102 103 104 105 108 108 110 111 112 118 119 120
statements_tail      : 98
string_operation_statement : 99
string_operation_tail : 140
string_val           : 141 150
stringcon_tail       : 141 150
switch_condition     : 111 114
switch_statement     : 101
switchcond_tail      : 112
tail_value           : 21
type_cast            : 37
typecast_value       : 40 41 42 43
unli_newline         : 1 1 5 7 19 76 76 99 100 101 102 103 104
until_loop           : 116
update               : 118
update_tail          : 122 142
value                : 25 95 112 124 135 136 138
var_call             : 54 122 134 140 151
var_call_tail        : 73
var_statement        : 107
var_tail             : 19 22 24
var_tail2            : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . data_type IDENT global_statement_tail
    (153) empty -> .
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 153 (empty -> .)
    MAIN_CASPER     reduce using rule 153 (empty -> .)
    FUNCTION        reduce using rule 153 (empty -> .)
    FUNCTION_INT    reduce using rule 153 (empty -> .)
    FUNCTION_FLT    reduce using rule 153 (empty -> .)
    FUNCTION_CHR    reduce using rule 153 (empty -> .)
    FUNCTION_BLN    reduce using rule 153 (empty -> .)
    FUNCTION_STR    reduce using rule 153 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 14

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 153 (empty -> .)
    FUNCTION        reduce using rule 153 (empty -> .)
    FUNCTION_INT    reduce using rule 153 (empty -> .)
    FUNCTION_FLT    reduce using rule 153 (empty -> .)
    FUNCTION_CHR    reduce using rule 153 (empty -> .)
    FUNCTION_BLN    reduce using rule 153 (empty -> .)
    FUNCTION_STR    reduce using rule 153 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 15
    empty                          shift and go to state 16

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 18

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)


state 8

    (10) global_statement -> data_type . IDENT global_statement_tail

    IDENT           shift and go to state 19


state 9

    (32) data_type -> INT .

    IDENT           reduce using rule 32 (data_type -> INT .)


state 10

    (33) data_type -> FLT .

    IDENT           reduce using rule 33 (data_type -> FLT .)


state 11

    (34) data_type -> BLN .

    IDENT           reduce using rule 34 (data_type -> BLN .)


state 12

    (35) data_type -> CHR .

    IDENT           reduce using rule 35 (data_type -> CHR .)


state 13

    (36) data_type -> STR .

    IDENT           reduce using rule 36 (data_type -> STR .)


state 14

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 15

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (76) function_statements -> . maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (77) function_statements -> . empty
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 153 (empty -> .)
    FUNCTION        reduce using rule 153 (empty -> .)
    FUNCTION_INT    reduce using rule 153 (empty -> .)
    FUNCTION_FLT    reduce using rule 153 (empty -> .)
    FUNCTION_CHR    reduce using rule 153 (empty -> .)
    FUNCTION_BLN    reduce using rule 153 (empty -> .)
    FUNCTION_STR    reduce using rule 153 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 20
    function_statements            shift and go to state 21
    empty                          shift and go to state 22

state 16

    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE_CHECK reduce using rule 2 (maybe_newline -> empty .)


state 17

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 153 (empty -> .)
    FUNCTION        reduce using rule 153 (empty -> .)
    FUNCTION_INT    reduce using rule 153 (empty -> .)
    FUNCTION_FLT    reduce using rule 153 (empty -> .)
    FUNCTION_CHR    reduce using rule 153 (empty -> .)
    FUNCTION_BLN    reduce using rule 153 (empty -> .)
    FUNCTION_STR    reduce using rule 153 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 153 (empty -> .)
    LBRACE          reduce using rule 153 (empty -> .)
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    OTHERWISE_CHECK reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 23
    empty                          shift and go to state 16

state 18

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (10) global_statement -> . data_type IDENT global_statement_tail
    (153) empty -> .
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    NEWLINE         reduce using rule 153 (empty -> .)
    MAIN_CASPER     reduce using rule 153 (empty -> .)
    FUNCTION        reduce using rule 153 (empty -> .)
    FUNCTION_INT    reduce using rule 153 (empty -> .)
    FUNCTION_FLT    reduce using rule 153 (empty -> .)
    FUNCTION_CHR    reduce using rule 153 (empty -> .)
    FUNCTION_BLN    reduce using rule 153 (empty -> .)
    FUNCTION_STR    reduce using rule 153 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 24
    global_dec                     shift and go to state 25
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 19

    (10) global_statement -> data_type IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (153) empty -> .

    COMMA           shift and go to state 28
    EQ              shift and go to state 29
    NEWLINE         reduce using rule 153 (empty -> .)

    global_statement_tail          shift and go to state 26
    empty                          shift and go to state 27

state 20

    (76) function_statements -> maybe_newline . ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (79) ret_type -> . FUNCTION
    (80) ret_type -> . function_dtype
    (81) function_dtype -> . FUNCTION_INT
    (82) function_dtype -> . FUNCTION_FLT
    (83) function_dtype -> . FUNCTION_CHR
    (84) function_dtype -> . FUNCTION_BLN
    (85) function_dtype -> . FUNCTION_STR
    (86) function_dtype -> . FUNCTION_LIST_INT
    (87) function_dtype -> . FUNCTION_LIST_FLT
    (88) function_dtype -> . FUNCTION_LIST_CHR
    (89) function_dtype -> . FUNCTION_LIST_STR
    (90) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 31
    FUNCTION_INT    shift and go to state 33
    FUNCTION_FLT    shift and go to state 34
    FUNCTION_CHR    shift and go to state 35
    FUNCTION_BLN    shift and go to state 36
    FUNCTION_STR    shift and go to state 37
    FUNCTION_LIST_INT shift and go to state 38
    FUNCTION_LIST_FLT shift and go to state 39
    FUNCTION_LIST_CHR shift and go to state 40
    FUNCTION_LIST_STR shift and go to state 41
    FUNCTION_LIST_BLN shift and go to state 42

    ret_type                       shift and go to state 30
    function_dtype                 shift and go to state 32

state 21

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 43
    empty                          shift and go to state 16

state 22

    (77) function_statements -> empty .
    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 77 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 77 (function_statements -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)


state 23

    (3) maybe_newline -> NEWLINE maybe_newline .

    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE_CHECK reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 24

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 25

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)


state 26

    (10) global_statement -> data_type IDENT global_statement_tail .

    NEWLINE         reduce using rule 10 (global_statement -> data_type IDENT global_statement_tail .)


state 27

    (11) global_statement_tail -> empty .

    NEWLINE         reduce using rule 11 (global_statement_tail -> empty .)


state 28

    (12) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 44


state 29

    (13) global_statement_tail -> EQ . global_dec_value global_tail2
    (16) global_dec_value -> . global_value
    (17) global_dec_value -> . LBRACKET list_element RBRACKET
    (18) global_value -> . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LBRACKET        shift and go to state 47
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    global_dec_value               shift and go to state 45
    global_value                   shift and go to state 46
    expression                     shift and go to state 48
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 30

    (76) function_statements -> maybe_newline ret_type . FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail

    FUNCTION_NAME   shift and go to state 61


state 31

    (79) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 79 (ret_type -> FUNCTION .)


state 32

    (80) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 80 (ret_type -> function_dtype .)


state 33

    (81) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 81 (function_dtype -> FUNCTION_INT .)


state 34

    (82) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 82 (function_dtype -> FUNCTION_FLT .)


state 35

    (83) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 83 (function_dtype -> FUNCTION_CHR .)


state 36

    (84) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 84 (function_dtype -> FUNCTION_BLN .)


state 37

    (85) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 85 (function_dtype -> FUNCTION_STR .)


state 38

    (86) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 86 (function_dtype -> FUNCTION_LIST_INT .)


state 39

    (87) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 87 (function_dtype -> FUNCTION_LIST_FLT .)


state 40

    (88) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 88 (function_dtype -> FUNCTION_LIST_CHR .)


state 41

    (89) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 89 (function_dtype -> FUNCTION_LIST_STR .)


state 42

    (90) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 90 (function_dtype -> FUNCTION_LIST_BLN .)


state 43

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 63

    main_function                  shift and go to state 62

state 44

    (12) global_statement_tail -> COMMA IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (153) empty -> .

    COMMA           shift and go to state 28
    EQ              shift and go to state 29
    NEWLINE         reduce using rule 153 (empty -> .)

    global_statement_tail          shift and go to state 64
    empty                          shift and go to state 27

state 45

    (13) global_statement_tail -> EQ global_dec_value . global_tail2
    (14) global_tail2 -> . empty
    (15) global_tail2 -> . COMMA IDENT global_statement_tail
    (153) empty -> .

    COMMA           shift and go to state 67
    NEWLINE         reduce using rule 153 (empty -> .)

    global_tail2                   shift and go to state 65
    empty                          shift and go to state 66

state 46

    (16) global_dec_value -> global_value .

    COMMA           reduce using rule 16 (global_dec_value -> global_value .)
    NEWLINE         reduce using rule 16 (global_dec_value -> global_value .)


state 47

    (17) global_dec_value -> LBRACKET . list_element RBRACKET
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    list_element                   shift and go to state 68
    literal                        shift and go to state 69

state 48

    (18) global_value -> expression .

    COMMA           reduce using rule 18 (global_value -> expression .)
    NEWLINE         reduce using rule 18 (global_value -> expression .)


state 49

    (53) expression -> factor . factor_tail
    (58) factor_tail -> . empty
    (59) factor_tail -> . PLUS expression
    (60) factor_tail -> . MINUS expression
    (61) factor_tail -> . MULTIPLY expression
    (62) factor_tail -> . DIVISION expression
    (63) factor_tail -> . MODULO expression
    (64) factor_tail -> . EXPONENT expression
    (65) factor_tail -> . GT expression
    (66) factor_tail -> . LT expression
    (67) factor_tail -> . EQ_EQ expression
    (68) factor_tail -> . GT_EQ expression
    (69) factor_tail -> . LT_EQ expression
    (70) factor_tail -> . NOT_EQ expression
    (71) factor_tail -> . AND expression
    (72) factor_tail -> . OR expression
    (153) empty -> .

    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    MULTIPLY        shift and go to state 74
    DIVISION        shift and go to state 75
    MODULO          shift and go to state 76
    EXPONENT        shift and go to state 77
    GT              shift and go to state 78
    LT              shift and go to state 79
    EQ_EQ           shift and go to state 80
    GT_EQ           shift and go to state 81
    LT_EQ           shift and go to state 82
    NOT_EQ          shift and go to state 83
    AND             shift and go to state 84
    OR              shift and go to state 85
    COMMA           reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    RPAREN          reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    COLON           reduce using rule 153 (empty -> .)
    SEMICOLON       reduce using rule 153 (empty -> .)

    factor_tail                    shift and go to state 70
    empty                          shift and go to state 71

state 50

    (54) factor -> var_call .

    PLUS            reduce using rule 54 (factor -> var_call .)
    MINUS           reduce using rule 54 (factor -> var_call .)
    MULTIPLY        reduce using rule 54 (factor -> var_call .)
    DIVISION        reduce using rule 54 (factor -> var_call .)
    MODULO          reduce using rule 54 (factor -> var_call .)
    EXPONENT        reduce using rule 54 (factor -> var_call .)
    GT              reduce using rule 54 (factor -> var_call .)
    LT              reduce using rule 54 (factor -> var_call .)
    EQ_EQ           reduce using rule 54 (factor -> var_call .)
    GT_EQ           reduce using rule 54 (factor -> var_call .)
    LT_EQ           reduce using rule 54 (factor -> var_call .)
    NOT_EQ          reduce using rule 54 (factor -> var_call .)
    AND             reduce using rule 54 (factor -> var_call .)
    OR              reduce using rule 54 (factor -> var_call .)
    COMMA           reduce using rule 54 (factor -> var_call .)
    NEWLINE         reduce using rule 54 (factor -> var_call .)
    RPAREN          reduce using rule 54 (factor -> var_call .)
    RBRACE          reduce using rule 54 (factor -> var_call .)
    COLON           reduce using rule 54 (factor -> var_call .)
    SEMICOLON       reduce using rule 54 (factor -> var_call .)


state 51

    (55) factor -> literal .

    PLUS            reduce using rule 55 (factor -> literal .)
    MINUS           reduce using rule 55 (factor -> literal .)
    MULTIPLY        reduce using rule 55 (factor -> literal .)
    DIVISION        reduce using rule 55 (factor -> literal .)
    MODULO          reduce using rule 55 (factor -> literal .)
    EXPONENT        reduce using rule 55 (factor -> literal .)
    GT              reduce using rule 55 (factor -> literal .)
    LT              reduce using rule 55 (factor -> literal .)
    EQ_EQ           reduce using rule 55 (factor -> literal .)
    GT_EQ           reduce using rule 55 (factor -> literal .)
    LT_EQ           reduce using rule 55 (factor -> literal .)
    NOT_EQ          reduce using rule 55 (factor -> literal .)
    AND             reduce using rule 55 (factor -> literal .)
    OR              reduce using rule 55 (factor -> literal .)
    COMMA           reduce using rule 55 (factor -> literal .)
    NEWLINE         reduce using rule 55 (factor -> literal .)
    RPAREN          reduce using rule 55 (factor -> literal .)
    RBRACE          reduce using rule 55 (factor -> literal .)
    COLON           reduce using rule 55 (factor -> literal .)
    SEMICOLON       reduce using rule 55 (factor -> literal .)


state 52

    (56) factor -> TILDE . literal
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    literal                        shift and go to state 86

state 53

    (57) factor -> LPAREN . expression RPAREN
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 87
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 54

    (73) var_call -> IDENT . var_call_tail
    (74) var_call_tail -> . empty
    (75) var_call_tail -> . LBRACKET index RBRACKET
    (153) empty -> .

    LBRACKET        shift and go to state 90
    PLUS            reduce using rule 153 (empty -> .)
    MINUS           reduce using rule 153 (empty -> .)
    MULTIPLY        reduce using rule 153 (empty -> .)
    DIVISION        reduce using rule 153 (empty -> .)
    MODULO          reduce using rule 153 (empty -> .)
    EXPONENT        reduce using rule 153 (empty -> .)
    GT              reduce using rule 153 (empty -> .)
    LT              reduce using rule 153 (empty -> .)
    EQ_EQ           reduce using rule 153 (empty -> .)
    GT_EQ           reduce using rule 153 (empty -> .)
    LT_EQ           reduce using rule 153 (empty -> .)
    NOT_EQ          reduce using rule 153 (empty -> .)
    AND             reduce using rule 153 (empty -> .)
    OR              reduce using rule 153 (empty -> .)
    COMMA           reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    RPAREN          reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    COLON           reduce using rule 153 (empty -> .)
    SEMICOLON       reduce using rule 153 (empty -> .)
    PLUS_PLUS       reduce using rule 153 (empty -> .)
    MINUS_MINUS     reduce using rule 153 (empty -> .)
    PLUS_EQ         reduce using rule 153 (empty -> .)
    MINUS_EQ        reduce using rule 153 (empty -> .)
    MUL_EQ          reduce using rule 153 (empty -> .)
    DIV_EQ          reduce using rule 153 (empty -> .)
    MOD_EQ          reduce using rule 153 (empty -> .)
    EQ              reduce using rule 153 (empty -> .)

    var_call_tail                  shift and go to state 88
    empty                          shift and go to state 89

state 55

    (47) literal -> INT_LIT .

    PLUS            reduce using rule 47 (literal -> INT_LIT .)
    MINUS           reduce using rule 47 (literal -> INT_LIT .)
    MULTIPLY        reduce using rule 47 (literal -> INT_LIT .)
    DIVISION        reduce using rule 47 (literal -> INT_LIT .)
    MODULO          reduce using rule 47 (literal -> INT_LIT .)
    EXPONENT        reduce using rule 47 (literal -> INT_LIT .)
    GT              reduce using rule 47 (literal -> INT_LIT .)
    LT              reduce using rule 47 (literal -> INT_LIT .)
    EQ_EQ           reduce using rule 47 (literal -> INT_LIT .)
    GT_EQ           reduce using rule 47 (literal -> INT_LIT .)
    LT_EQ           reduce using rule 47 (literal -> INT_LIT .)
    NOT_EQ          reduce using rule 47 (literal -> INT_LIT .)
    AND             reduce using rule 47 (literal -> INT_LIT .)
    OR              reduce using rule 47 (literal -> INT_LIT .)
    COMMA           reduce using rule 47 (literal -> INT_LIT .)
    NEWLINE         reduce using rule 47 (literal -> INT_LIT .)
    RBRACKET        reduce using rule 47 (literal -> INT_LIT .)
    RPAREN          reduce using rule 47 (literal -> INT_LIT .)
    RBRACE          reduce using rule 47 (literal -> INT_LIT .)
    COLON           reduce using rule 47 (literal -> INT_LIT .)
    SEMICOLON       reduce using rule 47 (literal -> INT_LIT .)


state 56

    (48) literal -> FLT_LIT .

    PLUS            reduce using rule 48 (literal -> FLT_LIT .)
    MINUS           reduce using rule 48 (literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 48 (literal -> FLT_LIT .)
    DIVISION        reduce using rule 48 (literal -> FLT_LIT .)
    MODULO          reduce using rule 48 (literal -> FLT_LIT .)
    EXPONENT        reduce using rule 48 (literal -> FLT_LIT .)
    GT              reduce using rule 48 (literal -> FLT_LIT .)
    LT              reduce using rule 48 (literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    GT_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    LT_EQ           reduce using rule 48 (literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 48 (literal -> FLT_LIT .)
    AND             reduce using rule 48 (literal -> FLT_LIT .)
    OR              reduce using rule 48 (literal -> FLT_LIT .)
    COMMA           reduce using rule 48 (literal -> FLT_LIT .)
    NEWLINE         reduce using rule 48 (literal -> FLT_LIT .)
    RBRACKET        reduce using rule 48 (literal -> FLT_LIT .)
    RPAREN          reduce using rule 48 (literal -> FLT_LIT .)
    RBRACE          reduce using rule 48 (literal -> FLT_LIT .)
    COLON           reduce using rule 48 (literal -> FLT_LIT .)
    SEMICOLON       reduce using rule 48 (literal -> FLT_LIT .)


state 57

    (49) literal -> DAY .

    PLUS            reduce using rule 49 (literal -> DAY .)
    MINUS           reduce using rule 49 (literal -> DAY .)
    MULTIPLY        reduce using rule 49 (literal -> DAY .)
    DIVISION        reduce using rule 49 (literal -> DAY .)
    MODULO          reduce using rule 49 (literal -> DAY .)
    EXPONENT        reduce using rule 49 (literal -> DAY .)
    GT              reduce using rule 49 (literal -> DAY .)
    LT              reduce using rule 49 (literal -> DAY .)
    EQ_EQ           reduce using rule 49 (literal -> DAY .)
    GT_EQ           reduce using rule 49 (literal -> DAY .)
    LT_EQ           reduce using rule 49 (literal -> DAY .)
    NOT_EQ          reduce using rule 49 (literal -> DAY .)
    AND             reduce using rule 49 (literal -> DAY .)
    OR              reduce using rule 49 (literal -> DAY .)
    COMMA           reduce using rule 49 (literal -> DAY .)
    NEWLINE         reduce using rule 49 (literal -> DAY .)
    RBRACKET        reduce using rule 49 (literal -> DAY .)
    RPAREN          reduce using rule 49 (literal -> DAY .)
    RBRACE          reduce using rule 49 (literal -> DAY .)
    COLON           reduce using rule 49 (literal -> DAY .)
    SEMICOLON       reduce using rule 49 (literal -> DAY .)


state 58

    (50) literal -> NIGHT .

    PLUS            reduce using rule 50 (literal -> NIGHT .)
    MINUS           reduce using rule 50 (literal -> NIGHT .)
    MULTIPLY        reduce using rule 50 (literal -> NIGHT .)
    DIVISION        reduce using rule 50 (literal -> NIGHT .)
    MODULO          reduce using rule 50 (literal -> NIGHT .)
    EXPONENT        reduce using rule 50 (literal -> NIGHT .)
    GT              reduce using rule 50 (literal -> NIGHT .)
    LT              reduce using rule 50 (literal -> NIGHT .)
    EQ_EQ           reduce using rule 50 (literal -> NIGHT .)
    GT_EQ           reduce using rule 50 (literal -> NIGHT .)
    LT_EQ           reduce using rule 50 (literal -> NIGHT .)
    NOT_EQ          reduce using rule 50 (literal -> NIGHT .)
    AND             reduce using rule 50 (literal -> NIGHT .)
    OR              reduce using rule 50 (literal -> NIGHT .)
    COMMA           reduce using rule 50 (literal -> NIGHT .)
    NEWLINE         reduce using rule 50 (literal -> NIGHT .)
    RBRACKET        reduce using rule 50 (literal -> NIGHT .)
    RPAREN          reduce using rule 50 (literal -> NIGHT .)
    RBRACE          reduce using rule 50 (literal -> NIGHT .)
    COLON           reduce using rule 50 (literal -> NIGHT .)
    SEMICOLON       reduce using rule 50 (literal -> NIGHT .)


state 59

    (51) literal -> CHR_LIT .

    PLUS            reduce using rule 51 (literal -> CHR_LIT .)
    MINUS           reduce using rule 51 (literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 51 (literal -> CHR_LIT .)
    DIVISION        reduce using rule 51 (literal -> CHR_LIT .)
    MODULO          reduce using rule 51 (literal -> CHR_LIT .)
    EXPONENT        reduce using rule 51 (literal -> CHR_LIT .)
    GT              reduce using rule 51 (literal -> CHR_LIT .)
    LT              reduce using rule 51 (literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    GT_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    LT_EQ           reduce using rule 51 (literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 51 (literal -> CHR_LIT .)
    AND             reduce using rule 51 (literal -> CHR_LIT .)
    OR              reduce using rule 51 (literal -> CHR_LIT .)
    COMMA           reduce using rule 51 (literal -> CHR_LIT .)
    NEWLINE         reduce using rule 51 (literal -> CHR_LIT .)
    RBRACKET        reduce using rule 51 (literal -> CHR_LIT .)
    RPAREN          reduce using rule 51 (literal -> CHR_LIT .)
    RBRACE          reduce using rule 51 (literal -> CHR_LIT .)
    COLON           reduce using rule 51 (literal -> CHR_LIT .)
    SEMICOLON       reduce using rule 51 (literal -> CHR_LIT .)


state 60

    (52) literal -> STR_LIT .

    PLUS            reduce using rule 52 (literal -> STR_LIT .)
    MINUS           reduce using rule 52 (literal -> STR_LIT .)
    MULTIPLY        reduce using rule 52 (literal -> STR_LIT .)
    DIVISION        reduce using rule 52 (literal -> STR_LIT .)
    MODULO          reduce using rule 52 (literal -> STR_LIT .)
    EXPONENT        reduce using rule 52 (literal -> STR_LIT .)
    GT              reduce using rule 52 (literal -> STR_LIT .)
    LT              reduce using rule 52 (literal -> STR_LIT .)
    EQ_EQ           reduce using rule 52 (literal -> STR_LIT .)
    GT_EQ           reduce using rule 52 (literal -> STR_LIT .)
    LT_EQ           reduce using rule 52 (literal -> STR_LIT .)
    NOT_EQ          reduce using rule 52 (literal -> STR_LIT .)
    AND             reduce using rule 52 (literal -> STR_LIT .)
    OR              reduce using rule 52 (literal -> STR_LIT .)
    COMMA           reduce using rule 52 (literal -> STR_LIT .)
    NEWLINE         reduce using rule 52 (literal -> STR_LIT .)
    RBRACKET        reduce using rule 52 (literal -> STR_LIT .)
    RPAREN          reduce using rule 52 (literal -> STR_LIT .)
    RBRACE          reduce using rule 52 (literal -> STR_LIT .)
    COLON           reduce using rule 52 (literal -> STR_LIT .)
    SEMICOLON       reduce using rule 52 (literal -> STR_LIT .)


state 61

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME . LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail

    LPAREN          shift and go to state 91


state 62

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 92

state 63

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 93


state 64

    (12) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 12 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 65

    (13) global_statement_tail -> EQ global_dec_value global_tail2 .

    NEWLINE         reduce using rule 13 (global_statement_tail -> EQ global_dec_value global_tail2 .)


state 66

    (14) global_tail2 -> empty .

    NEWLINE         reduce using rule 14 (global_tail2 -> empty .)


state 67

    (15) global_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 94


state 68

    (17) global_dec_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 95


state 69

    (27) list_element -> literal . element_tail
    (28) element_tail -> . empty
    (29) element_tail -> . COMMA list_element
    (153) empty -> .

    COMMA           shift and go to state 98
    RBRACKET        reduce using rule 153 (empty -> .)

    element_tail                   shift and go to state 96
    empty                          shift and go to state 97

state 70

    (53) expression -> factor factor_tail .

    COMMA           reduce using rule 53 (expression -> factor factor_tail .)
    NEWLINE         reduce using rule 53 (expression -> factor factor_tail .)
    RPAREN          reduce using rule 53 (expression -> factor factor_tail .)
    RBRACE          reduce using rule 53 (expression -> factor factor_tail .)
    COLON           reduce using rule 53 (expression -> factor factor_tail .)
    SEMICOLON       reduce using rule 53 (expression -> factor factor_tail .)


state 71

    (58) factor_tail -> empty .

    COMMA           reduce using rule 58 (factor_tail -> empty .)
    NEWLINE         reduce using rule 58 (factor_tail -> empty .)
    RPAREN          reduce using rule 58 (factor_tail -> empty .)
    RBRACE          reduce using rule 58 (factor_tail -> empty .)
    COLON           reduce using rule 58 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 58 (factor_tail -> empty .)


state 72

    (59) factor_tail -> PLUS . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 99
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 73

    (60) factor_tail -> MINUS . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 100
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 74

    (61) factor_tail -> MULTIPLY . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 101
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 75

    (62) factor_tail -> DIVISION . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 102
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 76

    (63) factor_tail -> MODULO . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 103
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 77

    (64) factor_tail -> EXPONENT . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 104
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 78

    (65) factor_tail -> GT . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 105
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 79

    (66) factor_tail -> LT . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 106
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 80

    (67) factor_tail -> EQ_EQ . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 107
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 81

    (68) factor_tail -> GT_EQ . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 108
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 82

    (69) factor_tail -> LT_EQ . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 109
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 83

    (70) factor_tail -> NOT_EQ . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 110
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 84

    (71) factor_tail -> AND . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 111
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 85

    (72) factor_tail -> OR . expression
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 112
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 86

    (56) factor -> TILDE literal .

    PLUS            reduce using rule 56 (factor -> TILDE literal .)
    MINUS           reduce using rule 56 (factor -> TILDE literal .)
    MULTIPLY        reduce using rule 56 (factor -> TILDE literal .)
    DIVISION        reduce using rule 56 (factor -> TILDE literal .)
    MODULO          reduce using rule 56 (factor -> TILDE literal .)
    EXPONENT        reduce using rule 56 (factor -> TILDE literal .)
    GT              reduce using rule 56 (factor -> TILDE literal .)
    LT              reduce using rule 56 (factor -> TILDE literal .)
    EQ_EQ           reduce using rule 56 (factor -> TILDE literal .)
    GT_EQ           reduce using rule 56 (factor -> TILDE literal .)
    LT_EQ           reduce using rule 56 (factor -> TILDE literal .)
    NOT_EQ          reduce using rule 56 (factor -> TILDE literal .)
    AND             reduce using rule 56 (factor -> TILDE literal .)
    OR              reduce using rule 56 (factor -> TILDE literal .)
    COMMA           reduce using rule 56 (factor -> TILDE literal .)
    NEWLINE         reduce using rule 56 (factor -> TILDE literal .)
    RPAREN          reduce using rule 56 (factor -> TILDE literal .)
    RBRACE          reduce using rule 56 (factor -> TILDE literal .)
    COLON           reduce using rule 56 (factor -> TILDE literal .)
    SEMICOLON       reduce using rule 56 (factor -> TILDE literal .)


state 87

    (57) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 113


state 88

    (73) var_call -> IDENT var_call_tail .

    PLUS            reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MINUS           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MULTIPLY        reduce using rule 73 (var_call -> IDENT var_call_tail .)
    DIVISION        reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MODULO          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    EXPONENT        reduce using rule 73 (var_call -> IDENT var_call_tail .)
    GT              reduce using rule 73 (var_call -> IDENT var_call_tail .)
    LT              reduce using rule 73 (var_call -> IDENT var_call_tail .)
    EQ_EQ           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    GT_EQ           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    LT_EQ           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    NOT_EQ          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    AND             reduce using rule 73 (var_call -> IDENT var_call_tail .)
    OR              reduce using rule 73 (var_call -> IDENT var_call_tail .)
    COMMA           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    NEWLINE         reduce using rule 73 (var_call -> IDENT var_call_tail .)
    RPAREN          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    RBRACE          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    COLON           reduce using rule 73 (var_call -> IDENT var_call_tail .)
    SEMICOLON       reduce using rule 73 (var_call -> IDENT var_call_tail .)
    PLUS_PLUS       reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MINUS_MINUS     reduce using rule 73 (var_call -> IDENT var_call_tail .)
    PLUS_EQ         reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MINUS_EQ        reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MUL_EQ          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    DIV_EQ          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    MOD_EQ          reduce using rule 73 (var_call -> IDENT var_call_tail .)
    EQ              reduce using rule 73 (var_call -> IDENT var_call_tail .)


state 89

    (74) var_call_tail -> empty .

    PLUS            reduce using rule 74 (var_call_tail -> empty .)
    MINUS           reduce using rule 74 (var_call_tail -> empty .)
    MULTIPLY        reduce using rule 74 (var_call_tail -> empty .)
    DIVISION        reduce using rule 74 (var_call_tail -> empty .)
    MODULO          reduce using rule 74 (var_call_tail -> empty .)
    EXPONENT        reduce using rule 74 (var_call_tail -> empty .)
    GT              reduce using rule 74 (var_call_tail -> empty .)
    LT              reduce using rule 74 (var_call_tail -> empty .)
    EQ_EQ           reduce using rule 74 (var_call_tail -> empty .)
    GT_EQ           reduce using rule 74 (var_call_tail -> empty .)
    LT_EQ           reduce using rule 74 (var_call_tail -> empty .)
    NOT_EQ          reduce using rule 74 (var_call_tail -> empty .)
    AND             reduce using rule 74 (var_call_tail -> empty .)
    OR              reduce using rule 74 (var_call_tail -> empty .)
    COMMA           reduce using rule 74 (var_call_tail -> empty .)
    NEWLINE         reduce using rule 74 (var_call_tail -> empty .)
    RPAREN          reduce using rule 74 (var_call_tail -> empty .)
    RBRACE          reduce using rule 74 (var_call_tail -> empty .)
    COLON           reduce using rule 74 (var_call_tail -> empty .)
    SEMICOLON       reduce using rule 74 (var_call_tail -> empty .)
    PLUS_PLUS       reduce using rule 74 (var_call_tail -> empty .)
    MINUS_MINUS     reduce using rule 74 (var_call_tail -> empty .)
    PLUS_EQ         reduce using rule 74 (var_call_tail -> empty .)
    MINUS_EQ        reduce using rule 74 (var_call_tail -> empty .)
    MUL_EQ          reduce using rule 74 (var_call_tail -> empty .)
    DIV_EQ          reduce using rule 74 (var_call_tail -> empty .)
    MOD_EQ          reduce using rule 74 (var_call_tail -> empty .)
    EQ              reduce using rule 74 (var_call_tail -> empty .)


state 90

    (75) var_call_tail -> LBRACKET . index RBRACKET
    (30) index -> . INT_LIT
    (31) index -> . IDENT

    INT_LIT         shift and go to state 115
    IDENT           shift and go to state 116

    index                          shift and go to state 114

state 91

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN . parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (91) parameters -> . data_type IDENT parameters_tail
    (92) parameters -> . empty
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR
    (153) empty -> .

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13
    RPAREN          reduce using rule 153 (empty -> .)

    parameters                     shift and go to state 117
    data_type                      shift and go to state 118
    empty                          shift and go to state 119

state 92

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 120


state 93

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 121


state 94

    (15) global_tail2 -> COMMA IDENT . global_statement_tail
    (11) global_statement_tail -> . empty
    (12) global_statement_tail -> . COMMA IDENT global_statement_tail
    (13) global_statement_tail -> . EQ global_dec_value global_tail2
    (153) empty -> .

    COMMA           shift and go to state 28
    EQ              shift and go to state 29
    NEWLINE         reduce using rule 153 (empty -> .)

    global_statement_tail          shift and go to state 122
    empty                          shift and go to state 27

state 95

    (17) global_dec_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 17 (global_dec_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 17 (global_dec_value -> LBRACKET list_element RBRACKET .)


state 96

    (27) list_element -> literal element_tail .

    RBRACKET        reduce using rule 27 (list_element -> literal element_tail .)


state 97

    (28) element_tail -> empty .

    RBRACKET        reduce using rule 28 (element_tail -> empty .)


state 98

    (29) element_tail -> COMMA . list_element
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    list_element                   shift and go to state 123
    literal                        shift and go to state 69

state 99

    (59) factor_tail -> PLUS expression .

    COMMA           reduce using rule 59 (factor_tail -> PLUS expression .)
    NEWLINE         reduce using rule 59 (factor_tail -> PLUS expression .)
    RPAREN          reduce using rule 59 (factor_tail -> PLUS expression .)
    RBRACE          reduce using rule 59 (factor_tail -> PLUS expression .)
    COLON           reduce using rule 59 (factor_tail -> PLUS expression .)
    SEMICOLON       reduce using rule 59 (factor_tail -> PLUS expression .)


state 100

    (60) factor_tail -> MINUS expression .

    COMMA           reduce using rule 60 (factor_tail -> MINUS expression .)
    NEWLINE         reduce using rule 60 (factor_tail -> MINUS expression .)
    RPAREN          reduce using rule 60 (factor_tail -> MINUS expression .)
    RBRACE          reduce using rule 60 (factor_tail -> MINUS expression .)
    COLON           reduce using rule 60 (factor_tail -> MINUS expression .)
    SEMICOLON       reduce using rule 60 (factor_tail -> MINUS expression .)


state 101

    (61) factor_tail -> MULTIPLY expression .

    COMMA           reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    NEWLINE         reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    RPAREN          reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    RBRACE          reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    COLON           reduce using rule 61 (factor_tail -> MULTIPLY expression .)
    SEMICOLON       reduce using rule 61 (factor_tail -> MULTIPLY expression .)


state 102

    (62) factor_tail -> DIVISION expression .

    COMMA           reduce using rule 62 (factor_tail -> DIVISION expression .)
    NEWLINE         reduce using rule 62 (factor_tail -> DIVISION expression .)
    RPAREN          reduce using rule 62 (factor_tail -> DIVISION expression .)
    RBRACE          reduce using rule 62 (factor_tail -> DIVISION expression .)
    COLON           reduce using rule 62 (factor_tail -> DIVISION expression .)
    SEMICOLON       reduce using rule 62 (factor_tail -> DIVISION expression .)


state 103

    (63) factor_tail -> MODULO expression .

    COMMA           reduce using rule 63 (factor_tail -> MODULO expression .)
    NEWLINE         reduce using rule 63 (factor_tail -> MODULO expression .)
    RPAREN          reduce using rule 63 (factor_tail -> MODULO expression .)
    RBRACE          reduce using rule 63 (factor_tail -> MODULO expression .)
    COLON           reduce using rule 63 (factor_tail -> MODULO expression .)
    SEMICOLON       reduce using rule 63 (factor_tail -> MODULO expression .)


state 104

    (64) factor_tail -> EXPONENT expression .

    COMMA           reduce using rule 64 (factor_tail -> EXPONENT expression .)
    NEWLINE         reduce using rule 64 (factor_tail -> EXPONENT expression .)
    RPAREN          reduce using rule 64 (factor_tail -> EXPONENT expression .)
    RBRACE          reduce using rule 64 (factor_tail -> EXPONENT expression .)
    COLON           reduce using rule 64 (factor_tail -> EXPONENT expression .)
    SEMICOLON       reduce using rule 64 (factor_tail -> EXPONENT expression .)


state 105

    (65) factor_tail -> GT expression .

    COMMA           reduce using rule 65 (factor_tail -> GT expression .)
    NEWLINE         reduce using rule 65 (factor_tail -> GT expression .)
    RPAREN          reduce using rule 65 (factor_tail -> GT expression .)
    RBRACE          reduce using rule 65 (factor_tail -> GT expression .)
    COLON           reduce using rule 65 (factor_tail -> GT expression .)
    SEMICOLON       reduce using rule 65 (factor_tail -> GT expression .)


state 106

    (66) factor_tail -> LT expression .

    COMMA           reduce using rule 66 (factor_tail -> LT expression .)
    NEWLINE         reduce using rule 66 (factor_tail -> LT expression .)
    RPAREN          reduce using rule 66 (factor_tail -> LT expression .)
    RBRACE          reduce using rule 66 (factor_tail -> LT expression .)
    COLON           reduce using rule 66 (factor_tail -> LT expression .)
    SEMICOLON       reduce using rule 66 (factor_tail -> LT expression .)


state 107

    (67) factor_tail -> EQ_EQ expression .

    COMMA           reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    NEWLINE         reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    RPAREN          reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    RBRACE          reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    COLON           reduce using rule 67 (factor_tail -> EQ_EQ expression .)
    SEMICOLON       reduce using rule 67 (factor_tail -> EQ_EQ expression .)


state 108

    (68) factor_tail -> GT_EQ expression .

    COMMA           reduce using rule 68 (factor_tail -> GT_EQ expression .)
    NEWLINE         reduce using rule 68 (factor_tail -> GT_EQ expression .)
    RPAREN          reduce using rule 68 (factor_tail -> GT_EQ expression .)
    RBRACE          reduce using rule 68 (factor_tail -> GT_EQ expression .)
    COLON           reduce using rule 68 (factor_tail -> GT_EQ expression .)
    SEMICOLON       reduce using rule 68 (factor_tail -> GT_EQ expression .)


state 109

    (69) factor_tail -> LT_EQ expression .

    COMMA           reduce using rule 69 (factor_tail -> LT_EQ expression .)
    NEWLINE         reduce using rule 69 (factor_tail -> LT_EQ expression .)
    RPAREN          reduce using rule 69 (factor_tail -> LT_EQ expression .)
    RBRACE          reduce using rule 69 (factor_tail -> LT_EQ expression .)
    COLON           reduce using rule 69 (factor_tail -> LT_EQ expression .)
    SEMICOLON       reduce using rule 69 (factor_tail -> LT_EQ expression .)


state 110

    (70) factor_tail -> NOT_EQ expression .

    COMMA           reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    NEWLINE         reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    RPAREN          reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    RBRACE          reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    COLON           reduce using rule 70 (factor_tail -> NOT_EQ expression .)
    SEMICOLON       reduce using rule 70 (factor_tail -> NOT_EQ expression .)


state 111

    (71) factor_tail -> AND expression .

    COMMA           reduce using rule 71 (factor_tail -> AND expression .)
    NEWLINE         reduce using rule 71 (factor_tail -> AND expression .)
    RPAREN          reduce using rule 71 (factor_tail -> AND expression .)
    RBRACE          reduce using rule 71 (factor_tail -> AND expression .)
    COLON           reduce using rule 71 (factor_tail -> AND expression .)
    SEMICOLON       reduce using rule 71 (factor_tail -> AND expression .)


state 112

    (72) factor_tail -> OR expression .

    COMMA           reduce using rule 72 (factor_tail -> OR expression .)
    NEWLINE         reduce using rule 72 (factor_tail -> OR expression .)
    RPAREN          reduce using rule 72 (factor_tail -> OR expression .)
    RBRACE          reduce using rule 72 (factor_tail -> OR expression .)
    COLON           reduce using rule 72 (factor_tail -> OR expression .)
    SEMICOLON       reduce using rule 72 (factor_tail -> OR expression .)


state 113

    (57) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 57 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 57 (factor -> LPAREN expression RPAREN .)


state 114

    (75) var_call_tail -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 124


state 115

    (30) index -> INT_LIT .

    RBRACKET        reduce using rule 30 (index -> INT_LIT .)


state 116

    (31) index -> IDENT .

    RBRACKET        reduce using rule 31 (index -> IDENT .)


state 117

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters . RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail

    RPAREN          shift and go to state 125


state 118

    (91) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 126


state 119

    (92) parameters -> empty .

    RPAREN          reduce using rule 92 (parameters -> empty .)


state 120

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 121

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 127
    empty                          shift and go to state 16

state 122

    (15) global_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 15 (global_tail2 -> COMMA IDENT global_statement_tail .)


state 123

    (29) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 29 (element_tail -> COMMA list_element .)


state 124

    (75) var_call_tail -> LBRACKET index RBRACKET .

    PLUS            reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    GT              reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    LT              reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    AND             reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    OR              reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_PLUS       reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ              reduce using rule 75 (var_call_tail -> LBRACKET index RBRACKET .)


state 125

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN . maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 128
    empty                          shift and go to state 16

state 126

    (91) parameters -> data_type IDENT . parameters_tail
    (93) parameters_tail -> . empty
    (94) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (153) empty -> .

    COMMA           shift and go to state 131
    RPAREN          reduce using rule 153 (empty -> .)

    parameters_tail                shift and go to state 129
    empty                          shift and go to state 130

state 127

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 132


state 128

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline . LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail

    LBRACE          shift and go to state 133


state 129

    (91) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 91 (parameters -> data_type IDENT parameters_tail .)


state 130

    (93) parameters_tail -> empty .

    RPAREN          reduce using rule 93 (parameters_tail -> empty .)


state 131

    (94) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    data_type                      shift and go to state 134

state 132

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 135
    empty                          shift and go to state 16

state 133

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE . unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 136

state 134

    (94) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 137


state 135

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 138
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 136

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline . statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 143
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 137

    (94) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (93) parameters_tail -> . empty
    (94) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (153) empty -> .

    COMMA           shift and go to state 131
    RPAREN          reduce using rule 153 (empty -> .)

    parameters_tail                shift and go to state 144
    empty                          shift and go to state 130

state 138

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 145
    empty                          shift and go to state 16

state 139

    (97) statements -> empty .
    (106) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 97 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 97 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 97 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 97 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 97 (statements -> empty .)
    NEWLINE         reduce using rule 97 (statements -> empty .)
    RBRACE          reduce using rule 97 (statements -> empty .)
    REVIVE          reduce using rule 97 (statements -> empty .)
    SHIFT           reduce using rule 97 (statements -> empty .)
    OTHERWISE       reduce using rule 97 (statements -> empty .)
    CHECK           reduce using rule 106 (local_dec -> empty .)
    SWAP            reduce using rule 106 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 106 (local_dec -> empty .)
    DISPLAY         reduce using rule 106 (local_dec -> empty .)
    IDENT           reduce using rule 106 (local_dec -> empty .)
    FOR             reduce using rule 106 (local_dec -> empty .)
    UNTIL           reduce using rule 106 (local_dec -> empty .)
    REPEAT          reduce using rule 106 (local_dec -> empty .)
    INT             reduce using rule 106 (local_dec -> empty .)
    FLT             reduce using rule 106 (local_dec -> empty .)
    BLN             reduce using rule 106 (local_dec -> empty .)
    CHR             reduce using rule 106 (local_dec -> empty .)
    STR             reduce using rule 106 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 106 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 106 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 106 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 106 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 106 (local_dec -> empty .) ]


state 140

    (98) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 146
    empty                          shift and go to state 16

state 141

    (107) local_dec -> var_statement .

    NEWLINE         reduce using rule 107 (local_dec -> var_statement .)
    CHECK           reduce using rule 107 (local_dec -> var_statement .)
    SWAP            reduce using rule 107 (local_dec -> var_statement .)
    FUNCTION_NAME   reduce using rule 107 (local_dec -> var_statement .)
    DISPLAY         reduce using rule 107 (local_dec -> var_statement .)
    IDENT           reduce using rule 107 (local_dec -> var_statement .)
    FOR             reduce using rule 107 (local_dec -> var_statement .)
    UNTIL           reduce using rule 107 (local_dec -> var_statement .)
    REPEAT          reduce using rule 107 (local_dec -> var_statement .)
    INT             reduce using rule 107 (local_dec -> var_statement .)
    FLT             reduce using rule 107 (local_dec -> var_statement .)
    BLN             reduce using rule 107 (local_dec -> var_statement .)
    CHR             reduce using rule 107 (local_dec -> var_statement .)
    STR             reduce using rule 107 (local_dec -> var_statement .)
    RBRACE          reduce using rule 107 (local_dec -> var_statement .)
    REVIVE          reduce using rule 107 (local_dec -> var_statement .)
    SHIFT           reduce using rule 107 (local_dec -> var_statement .)
    OTHERWISE       reduce using rule 107 (local_dec -> var_statement .)


state 142

    (19) var_statement -> data_type . IDENT var_tail unli_newline

    IDENT           shift and go to state 147


state 143

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements . revive maybe_newline RBRACE unli_newline function_statements_tail
    (95) revive -> . REVIVE value
    (96) revive -> . empty
    (153) empty -> .

    REVIVE          shift and go to state 149
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)

    revive                         shift and go to state 148
    empty                          shift and go to state 150

state 144

    (94) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 94 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 145

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 151


state 146

    (98) statements -> local_dec maybe_newline . statements_tail
    (99) statements_tail -> . string_operation_statement unli_newline statements
    (100) statements_tail -> . conditional_statement unli_newline statements
    (101) statements_tail -> . switch_statement unli_newline statements
    (102) statements_tail -> . loop_statement unli_newline statements
    (103) statements_tail -> . function_call unli_newline statements
    (104) statements_tail -> . output_statement unli_newline statements
    (105) statements_tail -> . statements
    (140) string_operation_statement -> . var_call string_operation_tail
    (108) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (111) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (115) loop_statement -> . for_loop
    (116) loop_statement -> . until_loop
    (117) loop_statement -> . repeat_until
    (127) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (128) function_call -> . output_statement
    (135) output_statement -> . DISPLAY value next_val
    (136) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (73) var_call -> . IDENT var_call_tail
    (118) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (119) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (120) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    CHECK           shift and go to state 161
    SWAP            shift and go to state 162
    FUNCTION_NAME   shift and go to state 166
    DISPLAY         shift and go to state 167
    IDENT           shift and go to state 54
    FOR             shift and go to state 168
    UNTIL           shift and go to state 169
    REPEAT          shift and go to state 170
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 153 (empty -> .) ]
  ! SWAP            [ reduce using rule 153 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 153 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 153 (empty -> .) ]
  ! IDENT           [ reduce using rule 153 (empty -> .) ]
  ! FOR             [ reduce using rule 153 (empty -> .) ]
  ! UNTIL           [ reduce using rule 153 (empty -> .) ]
  ! REPEAT          [ reduce using rule 153 (empty -> .) ]
  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    local_dec                      shift and go to state 140
    statements_tail                shift and go to state 152
    string_operation_statement     shift and go to state 153
    statements                     shift and go to state 154
    conditional_statement          shift and go to state 155
    switch_statement               shift and go to state 156
    loop_statement                 shift and go to state 157
    function_call                  shift and go to state 158
    output_statement               shift and go to state 159
    var_call                       shift and go to state 160
    for_loop                       shift and go to state 163
    until_loop                     shift and go to state 164
    repeat_until                   shift and go to state 165
    empty                          shift and go to state 139
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 147

    (19) var_statement -> data_type IDENT . var_tail unli_newline
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (153) empty -> .

    EQ              shift and go to state 173
    COMMA           shift and go to state 174
    NEWLINE         reduce using rule 153 (empty -> .)

    var_tail                       shift and go to state 171
    empty                          shift and go to state 172

state 148

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive . maybe_newline RBRACE unli_newline function_statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 175
    empty                          shift and go to state 16

state 149

    (95) revive -> REVIVE . value
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (127) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (128) function_call -> . output_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (135) output_statement -> . DISPLAY value next_val
    (136) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 180
    CONVERT_TO_FLT  shift and go to state 181
    CONVERT_TO_BLN  shift and go to state 182
    CONVERT_TO_STR  shift and go to state 183
    FUNCTION_NAME   shift and go to state 166
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    DISPLAY         shift and go to state 167
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 176
    type_cast                      shift and go to state 177
    expression                     shift and go to state 178
    function_call                  shift and go to state 179
    factor                         shift and go to state 49
    output_statement               shift and go to state 184
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 150

    (96) revive -> empty .

    NEWLINE         reduce using rule 96 (revive -> empty .)
    RBRACE          reduce using rule 96 (revive -> empty .)


state 151

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)


state 152

    (98) statements -> local_dec maybe_newline statements_tail .

    NEWLINE         reduce using rule 98 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 98 (statements -> local_dec maybe_newline statements_tail .)
    REVIVE          reduce using rule 98 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 98 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 98 (statements -> local_dec maybe_newline statements_tail .)


state 153

    (99) statements_tail -> string_operation_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 185

state 154

    (105) statements_tail -> statements .

    NEWLINE         reduce using rule 105 (statements_tail -> statements .)
    RBRACE          reduce using rule 105 (statements_tail -> statements .)
    REVIVE          reduce using rule 105 (statements_tail -> statements .)
    SHIFT           reduce using rule 105 (statements_tail -> statements .)
    OTHERWISE       reduce using rule 105 (statements_tail -> statements .)


state 155

    (100) statements_tail -> conditional_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 186

state 156

    (101) statements_tail -> switch_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 187

state 157

    (102) statements_tail -> loop_statement . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 188

state 158

    (103) statements_tail -> function_call . unli_newline statements
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 189

state 159

    (104) statements_tail -> output_statement . unli_newline statements
    (128) function_call -> output_statement .
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 128 (function_call -> output_statement .) ]

    unli_newline                   shift and go to state 190

state 160

    (140) string_operation_statement -> var_call . string_operation_tail
    (141) string_operation_tail -> . PLUS string_val stringcon_tail
    (142) string_operation_tail -> . update_tail
    (123) update_tail -> . postfix
    (124) update_tail -> . assign_op value
    (125) postfix -> . PLUS_PLUS
    (126) postfix -> . MINUS_MINUS
    (143) assign_op -> . PLUS_EQ
    (144) assign_op -> . MINUS_EQ
    (145) assign_op -> . MUL_EQ
    (146) assign_op -> . DIV_EQ
    (147) assign_op -> . MOD_EQ
    (148) assign_op -> . EQ

    PLUS            shift and go to state 192
    PLUS_PLUS       shift and go to state 196
    MINUS_MINUS     shift and go to state 197
    PLUS_EQ         shift and go to state 198
    MINUS_EQ        shift and go to state 199
    MUL_EQ          shift and go to state 200
    DIV_EQ          shift and go to state 201
    MOD_EQ          shift and go to state 202
    EQ              shift and go to state 203

    string_operation_tail          shift and go to state 191
    update_tail                    shift and go to state 193
    postfix                        shift and go to state 194
    assign_op                      shift and go to state 195

state 161

    (108) conditional_statement -> CHECK . LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 204


state 162

    (111) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LPAREN          shift and go to state 205


state 163

    (115) loop_statement -> for_loop .

    NEWLINE         reduce using rule 115 (loop_statement -> for_loop .)


state 164

    (116) loop_statement -> until_loop .

    NEWLINE         reduce using rule 116 (loop_statement -> until_loop .)


state 165

    (117) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 117 (loop_statement -> repeat_until .)


state 166

    (127) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 206


state 167

    (135) output_statement -> DISPLAY . value next_val
    (136) output_statement -> DISPLAY . LPAREN value next_val RPAREN
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (127) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (128) function_call -> . output_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (135) output_statement -> . DISPLAY value next_val
    (136) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LPAREN          shift and go to state 208
    CONVERT_TO_INT  shift and go to state 180
    CONVERT_TO_FLT  shift and go to state 181
    CONVERT_TO_BLN  shift and go to state 182
    CONVERT_TO_STR  shift and go to state 183
    FUNCTION_NAME   shift and go to state 166
    TILDE           shift and go to state 52
    DISPLAY         shift and go to state 167
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 207
    type_cast                      shift and go to state 177
    expression                     shift and go to state 178
    function_call                  shift and go to state 179
    factor                         shift and go to state 49
    output_statement               shift and go to state 184
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 168

    (118) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 209


state 169

    (119) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 210


state 170

    (120) repeat_until -> REPEAT . LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 211


state 171

    (19) var_statement -> data_type IDENT var_tail . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 212

state 172

    (20) var_tail -> empty .

    NEWLINE         reduce using rule 20 (var_tail -> empty .)


state 173

    (21) var_tail -> EQ . tail_value var_tail2
    (25) tail_value -> . value
    (26) tail_value -> . LBRACKET list_element RBRACKET
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (127) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (128) function_call -> . output_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (135) output_statement -> . DISPLAY value next_val
    (136) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    LBRACKET        shift and go to state 215
    CONVERT_TO_INT  shift and go to state 180
    CONVERT_TO_FLT  shift and go to state 181
    CONVERT_TO_BLN  shift and go to state 182
    CONVERT_TO_STR  shift and go to state 183
    FUNCTION_NAME   shift and go to state 166
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    DISPLAY         shift and go to state 167
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    tail_value                     shift and go to state 213
    value                          shift and go to state 214
    type_cast                      shift and go to state 177
    expression                     shift and go to state 178
    function_call                  shift and go to state 179
    factor                         shift and go to state 49
    output_statement               shift and go to state 184
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 174

    (22) var_tail -> COMMA . IDENT var_tail

    IDENT           shift and go to state 216


state 175

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline . RBRACE unli_newline function_statements_tail

    RBRACE          shift and go to state 217


state 176

    (95) revive -> REVIVE value .

    NEWLINE         reduce using rule 95 (revive -> REVIVE value .)
    RBRACE          reduce using rule 95 (revive -> REVIVE value .)


state 177

    (37) value -> type_cast .

    NEWLINE         reduce using rule 37 (value -> type_cast .)
    RBRACE          reduce using rule 37 (value -> type_cast .)
    COMMA           reduce using rule 37 (value -> type_cast .)
    RPAREN          reduce using rule 37 (value -> type_cast .)
    COLON           reduce using rule 37 (value -> type_cast .)


state 178

    (38) value -> expression .

    NEWLINE         reduce using rule 38 (value -> expression .)
    RBRACE          reduce using rule 38 (value -> expression .)
    COMMA           reduce using rule 38 (value -> expression .)
    RPAREN          reduce using rule 38 (value -> expression .)
    COLON           reduce using rule 38 (value -> expression .)


state 179

    (39) value -> function_call .

    NEWLINE         reduce using rule 39 (value -> function_call .)
    RBRACE          reduce using rule 39 (value -> function_call .)
    COMMA           reduce using rule 39 (value -> function_call .)
    RPAREN          reduce using rule 39 (value -> function_call .)
    COLON           reduce using rule 39 (value -> function_call .)


state 180

    (40) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 218


state 181

    (41) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 219


state 182

    (42) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 220


state 183

    (43) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 221


state 184

    (128) function_call -> output_statement .

    NEWLINE         reduce using rule 128 (function_call -> output_statement .)
    RBRACE          reduce using rule 128 (function_call -> output_statement .)
    COMMA           reduce using rule 128 (function_call -> output_statement .)
    RPAREN          reduce using rule 128 (function_call -> output_statement .)
    COLON           reduce using rule 128 (function_call -> output_statement .)


state 185

    (99) statements_tail -> string_operation_statement unli_newline . statements
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 222
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 186

    (100) statements_tail -> conditional_statement unli_newline . statements
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 223
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 187

    (101) statements_tail -> switch_statement unli_newline . statements
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 224
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 188

    (102) statements_tail -> loop_statement unli_newline . statements
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 225
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 189

    (103) statements_tail -> function_call unli_newline . statements
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 226
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 190

    (104) statements_tail -> output_statement unli_newline . statements
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    REVIVE          reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 227
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 191

    (140) string_operation_statement -> var_call string_operation_tail .

    NEWLINE         reduce using rule 140 (string_operation_statement -> var_call string_operation_tail .)


state 192

    (141) string_operation_tail -> PLUS . string_val stringcon_tail
    (151) string_val -> . var_call
    (152) string_val -> . STR_LIT
    (73) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 230
    IDENT           shift and go to state 54

    string_val                     shift and go to state 228
    var_call                       shift and go to state 229

state 193

    (142) string_operation_tail -> update_tail .

    NEWLINE         reduce using rule 142 (string_operation_tail -> update_tail .)


state 194

    (123) update_tail -> postfix .

    NEWLINE         reduce using rule 123 (update_tail -> postfix .)
    RPAREN          reduce using rule 123 (update_tail -> postfix .)


state 195

    (124) update_tail -> assign_op . value
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (127) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (128) function_call -> . output_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (135) output_statement -> . DISPLAY value next_val
    (136) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 180
    CONVERT_TO_FLT  shift and go to state 181
    CONVERT_TO_BLN  shift and go to state 182
    CONVERT_TO_STR  shift and go to state 183
    FUNCTION_NAME   shift and go to state 166
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    DISPLAY         shift and go to state 167
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 231
    type_cast                      shift and go to state 177
    expression                     shift and go to state 178
    function_call                  shift and go to state 179
    factor                         shift and go to state 49
    output_statement               shift and go to state 184
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 196

    (125) postfix -> PLUS_PLUS .

    NEWLINE         reduce using rule 125 (postfix -> PLUS_PLUS .)
    RPAREN          reduce using rule 125 (postfix -> PLUS_PLUS .)


state 197

    (126) postfix -> MINUS_MINUS .

    NEWLINE         reduce using rule 126 (postfix -> MINUS_MINUS .)
    RPAREN          reduce using rule 126 (postfix -> MINUS_MINUS .)


state 198

    (143) assign_op -> PLUS_EQ .

    CONVERT_TO_INT  reduce using rule 143 (assign_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 143 (assign_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 143 (assign_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 143 (assign_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 143 (assign_op -> PLUS_EQ .)
    TILDE           reduce using rule 143 (assign_op -> PLUS_EQ .)
    LPAREN          reduce using rule 143 (assign_op -> PLUS_EQ .)
    DISPLAY         reduce using rule 143 (assign_op -> PLUS_EQ .)
    IDENT           reduce using rule 143 (assign_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 143 (assign_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 143 (assign_op -> PLUS_EQ .)
    DAY             reduce using rule 143 (assign_op -> PLUS_EQ .)
    NIGHT           reduce using rule 143 (assign_op -> PLUS_EQ .)
    CHR_LIT         reduce using rule 143 (assign_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 143 (assign_op -> PLUS_EQ .)


state 199

    (144) assign_op -> MINUS_EQ .

    CONVERT_TO_INT  reduce using rule 144 (assign_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 144 (assign_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 144 (assign_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 144 (assign_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 144 (assign_op -> MINUS_EQ .)
    TILDE           reduce using rule 144 (assign_op -> MINUS_EQ .)
    LPAREN          reduce using rule 144 (assign_op -> MINUS_EQ .)
    DISPLAY         reduce using rule 144 (assign_op -> MINUS_EQ .)
    IDENT           reduce using rule 144 (assign_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 144 (assign_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 144 (assign_op -> MINUS_EQ .)
    DAY             reduce using rule 144 (assign_op -> MINUS_EQ .)
    NIGHT           reduce using rule 144 (assign_op -> MINUS_EQ .)
    CHR_LIT         reduce using rule 144 (assign_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 144 (assign_op -> MINUS_EQ .)


state 200

    (145) assign_op -> MUL_EQ .

    CONVERT_TO_INT  reduce using rule 145 (assign_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 145 (assign_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 145 (assign_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 145 (assign_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 145 (assign_op -> MUL_EQ .)
    TILDE           reduce using rule 145 (assign_op -> MUL_EQ .)
    LPAREN          reduce using rule 145 (assign_op -> MUL_EQ .)
    DISPLAY         reduce using rule 145 (assign_op -> MUL_EQ .)
    IDENT           reduce using rule 145 (assign_op -> MUL_EQ .)
    INT_LIT         reduce using rule 145 (assign_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 145 (assign_op -> MUL_EQ .)
    DAY             reduce using rule 145 (assign_op -> MUL_EQ .)
    NIGHT           reduce using rule 145 (assign_op -> MUL_EQ .)
    CHR_LIT         reduce using rule 145 (assign_op -> MUL_EQ .)
    STR_LIT         reduce using rule 145 (assign_op -> MUL_EQ .)


state 201

    (146) assign_op -> DIV_EQ .

    CONVERT_TO_INT  reduce using rule 146 (assign_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 146 (assign_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 146 (assign_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 146 (assign_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 146 (assign_op -> DIV_EQ .)
    TILDE           reduce using rule 146 (assign_op -> DIV_EQ .)
    LPAREN          reduce using rule 146 (assign_op -> DIV_EQ .)
    DISPLAY         reduce using rule 146 (assign_op -> DIV_EQ .)
    IDENT           reduce using rule 146 (assign_op -> DIV_EQ .)
    INT_LIT         reduce using rule 146 (assign_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 146 (assign_op -> DIV_EQ .)
    DAY             reduce using rule 146 (assign_op -> DIV_EQ .)
    NIGHT           reduce using rule 146 (assign_op -> DIV_EQ .)
    CHR_LIT         reduce using rule 146 (assign_op -> DIV_EQ .)
    STR_LIT         reduce using rule 146 (assign_op -> DIV_EQ .)


state 202

    (147) assign_op -> MOD_EQ .

    CONVERT_TO_INT  reduce using rule 147 (assign_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 147 (assign_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 147 (assign_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 147 (assign_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 147 (assign_op -> MOD_EQ .)
    TILDE           reduce using rule 147 (assign_op -> MOD_EQ .)
    LPAREN          reduce using rule 147 (assign_op -> MOD_EQ .)
    DISPLAY         reduce using rule 147 (assign_op -> MOD_EQ .)
    IDENT           reduce using rule 147 (assign_op -> MOD_EQ .)
    INT_LIT         reduce using rule 147 (assign_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 147 (assign_op -> MOD_EQ .)
    DAY             reduce using rule 147 (assign_op -> MOD_EQ .)
    NIGHT           reduce using rule 147 (assign_op -> MOD_EQ .)
    CHR_LIT         reduce using rule 147 (assign_op -> MOD_EQ .)
    STR_LIT         reduce using rule 147 (assign_op -> MOD_EQ .)


state 203

    (148) assign_op -> EQ .

    CONVERT_TO_INT  reduce using rule 148 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 148 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 148 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 148 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 148 (assign_op -> EQ .)
    TILDE           reduce using rule 148 (assign_op -> EQ .)
    LPAREN          reduce using rule 148 (assign_op -> EQ .)
    DISPLAY         reduce using rule 148 (assign_op -> EQ .)
    IDENT           reduce using rule 148 (assign_op -> EQ .)
    INT_LIT         reduce using rule 148 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 148 (assign_op -> EQ .)
    DAY             reduce using rule 148 (assign_op -> EQ .)
    NIGHT           reduce using rule 148 (assign_op -> EQ .)
    CHR_LIT         reduce using rule 148 (assign_op -> EQ .)
    STR_LIT         reduce using rule 148 (assign_op -> EQ .)


state 204

    (108) conditional_statement -> CHECK LPAREN . expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 232
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 205

    (111) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    IDENT           shift and go to state 233


state 206

    (127) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (129) arguments -> . empty
    (130) arguments -> . arg_value arg_tail
    (153) empty -> .
    (133) arg_value -> . literal
    (134) arg_value -> . var_call
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT
    (73) var_call -> . IDENT var_call_tail

    RPAREN          reduce using rule 153 (empty -> .)
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60
    IDENT           shift and go to state 54

    arguments                      shift and go to state 234
    empty                          shift and go to state 235
    arg_value                      shift and go to state 236
    literal                        shift and go to state 237
    var_call                       shift and go to state 238

state 207

    (135) output_statement -> DISPLAY value . next_val
    (137) next_val -> . empty
    (138) next_val -> . COMMA value next_val
    (153) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 241
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    RPAREN          reduce using rule 153 (empty -> .)
    COLON           reduce using rule 153 (empty -> .)

  ! COMMA           [ reduce using rule 153 (empty -> .) ]

    next_val                       shift and go to state 239
    empty                          shift and go to state 240

state 208

    (136) output_statement -> DISPLAY LPAREN . value next_val RPAREN
    (57) factor -> LPAREN . expression RPAREN
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (53) expression -> . factor factor_tail
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (127) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (128) function_call -> . output_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (135) output_statement -> . DISPLAY value next_val
    (136) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 180
    CONVERT_TO_FLT  shift and go to state 181
    CONVERT_TO_BLN  shift and go to state 182
    CONVERT_TO_STR  shift and go to state 183
    FUNCTION_NAME   shift and go to state 166
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    DISPLAY         shift and go to state 167
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 242
    expression                     shift and go to state 243
    type_cast                      shift and go to state 177
    function_call                  shift and go to state 179
    factor                         shift and go to state 49
    output_statement               shift and go to state 184
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 209

    (118) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (121) control_variable -> . INT IDENT EQ INT_LIT

    INT             shift and go to state 245

    control_variable               shift and go to state 244

state 210

    (119) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE maybe_newline statements RBRACE
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 246
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 211

    (120) repeat_until -> REPEAT LBRACE . maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 247
    empty                          shift and go to state 16

state 212

    (19) var_statement -> data_type IDENT var_tail unli_newline .

    NEWLINE         reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    CHECK           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    SWAP            reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    FUNCTION_NAME   reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    DISPLAY         reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    IDENT           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    FOR             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    UNTIL           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    REPEAT          reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    INT             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    FLT             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    BLN             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    CHR             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    STR             reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    RBRACE          reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    REVIVE          reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    SHIFT           reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)
    OTHERWISE       reduce using rule 19 (var_statement -> data_type IDENT var_tail unli_newline .)


state 213

    (21) var_tail -> EQ tail_value . var_tail2
    (23) var_tail2 -> . empty
    (24) var_tail2 -> . COMMA IDENT var_tail
    (153) empty -> .

    COMMA           shift and go to state 250
    NEWLINE         reduce using rule 153 (empty -> .)

    var_tail2                      shift and go to state 248
    empty                          shift and go to state 249

state 214

    (25) tail_value -> value .

    COMMA           reduce using rule 25 (tail_value -> value .)
    NEWLINE         reduce using rule 25 (tail_value -> value .)


state 215

    (26) tail_value -> LBRACKET . list_element RBRACKET
    (27) list_element -> . literal element_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    list_element                   shift and go to state 251
    literal                        shift and go to state 69

state 216

    (22) var_tail -> COMMA IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (153) empty -> .

    EQ              shift and go to state 173
    COMMA           shift and go to state 174
    NEWLINE         reduce using rule 153 (empty -> .)

    var_tail                       shift and go to state 252
    empty                          shift and go to state 172

state 217

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE . unli_newline function_statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 253

state 218

    (40) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (139) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 256
    INPUT           shift and go to state 258
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 254
    expression                     shift and go to state 255
    input_statement                shift and go to state 257
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 219

    (41) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (139) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 256
    INPUT           shift and go to state 258
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 259
    expression                     shift and go to state 255
    input_statement                shift and go to state 257
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 220

    (42) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (139) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 256
    INPUT           shift and go to state 258
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 260
    expression                     shift and go to state 255
    input_statement                shift and go to state 257
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 221

    (43) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (44) typecast_value -> . expression
    (45) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (46) typecast_value -> . input_statement
    (53) expression -> . factor factor_tail
    (139) input_statement -> . INPUT LPAREN RPAREN
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    FUNCTION_NAME   shift and go to state 256
    INPUT           shift and go to state 258
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    typecast_value                 shift and go to state 261
    expression                     shift and go to state 255
    input_statement                shift and go to state 257
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 222

    (99) statements_tail -> string_operation_statement unli_newline statements .

    NEWLINE         reduce using rule 99 (statements_tail -> string_operation_statement unli_newline statements .)
    RBRACE          reduce using rule 99 (statements_tail -> string_operation_statement unli_newline statements .)
    REVIVE          reduce using rule 99 (statements_tail -> string_operation_statement unli_newline statements .)
    SHIFT           reduce using rule 99 (statements_tail -> string_operation_statement unli_newline statements .)
    OTHERWISE       reduce using rule 99 (statements_tail -> string_operation_statement unli_newline statements .)


state 223

    (100) statements_tail -> conditional_statement unli_newline statements .

    NEWLINE         reduce using rule 100 (statements_tail -> conditional_statement unli_newline statements .)
    RBRACE          reduce using rule 100 (statements_tail -> conditional_statement unli_newline statements .)
    REVIVE          reduce using rule 100 (statements_tail -> conditional_statement unli_newline statements .)
    SHIFT           reduce using rule 100 (statements_tail -> conditional_statement unli_newline statements .)
    OTHERWISE       reduce using rule 100 (statements_tail -> conditional_statement unli_newline statements .)


state 224

    (101) statements_tail -> switch_statement unli_newline statements .

    NEWLINE         reduce using rule 101 (statements_tail -> switch_statement unli_newline statements .)
    RBRACE          reduce using rule 101 (statements_tail -> switch_statement unli_newline statements .)
    REVIVE          reduce using rule 101 (statements_tail -> switch_statement unli_newline statements .)
    SHIFT           reduce using rule 101 (statements_tail -> switch_statement unli_newline statements .)
    OTHERWISE       reduce using rule 101 (statements_tail -> switch_statement unli_newline statements .)


state 225

    (102) statements_tail -> loop_statement unli_newline statements .

    NEWLINE         reduce using rule 102 (statements_tail -> loop_statement unli_newline statements .)
    RBRACE          reduce using rule 102 (statements_tail -> loop_statement unli_newline statements .)
    REVIVE          reduce using rule 102 (statements_tail -> loop_statement unli_newline statements .)
    SHIFT           reduce using rule 102 (statements_tail -> loop_statement unli_newline statements .)
    OTHERWISE       reduce using rule 102 (statements_tail -> loop_statement unli_newline statements .)


state 226

    (103) statements_tail -> function_call unli_newline statements .

    NEWLINE         reduce using rule 103 (statements_tail -> function_call unli_newline statements .)
    RBRACE          reduce using rule 103 (statements_tail -> function_call unli_newline statements .)
    REVIVE          reduce using rule 103 (statements_tail -> function_call unli_newline statements .)
    SHIFT           reduce using rule 103 (statements_tail -> function_call unli_newline statements .)
    OTHERWISE       reduce using rule 103 (statements_tail -> function_call unli_newline statements .)


state 227

    (104) statements_tail -> output_statement unli_newline statements .

    NEWLINE         reduce using rule 104 (statements_tail -> output_statement unli_newline statements .)
    RBRACE          reduce using rule 104 (statements_tail -> output_statement unli_newline statements .)
    REVIVE          reduce using rule 104 (statements_tail -> output_statement unli_newline statements .)
    SHIFT           reduce using rule 104 (statements_tail -> output_statement unli_newline statements .)
    OTHERWISE       reduce using rule 104 (statements_tail -> output_statement unli_newline statements .)


state 228

    (141) string_operation_tail -> PLUS string_val . stringcon_tail
    (149) stringcon_tail -> . empty
    (150) stringcon_tail -> . PLUS string_val stringcon_tail
    (153) empty -> .

    PLUS            shift and go to state 262
    NEWLINE         reduce using rule 153 (empty -> .)

    stringcon_tail                 shift and go to state 263
    empty                          shift and go to state 264

state 229

    (151) string_val -> var_call .

    PLUS            reduce using rule 151 (string_val -> var_call .)
    NEWLINE         reduce using rule 151 (string_val -> var_call .)


state 230

    (152) string_val -> STR_LIT .

    PLUS            reduce using rule 152 (string_val -> STR_LIT .)
    NEWLINE         reduce using rule 152 (string_val -> STR_LIT .)


state 231

    (124) update_tail -> assign_op value .

    NEWLINE         reduce using rule 124 (update_tail -> assign_op value .)
    RPAREN          reduce using rule 124 (update_tail -> assign_op value .)


state 232

    (108) conditional_statement -> CHECK LPAREN expression . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 265


state 233

    (111) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    RPAREN          shift and go to state 266


state 234

    (127) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 267


state 235

    (129) arguments -> empty .

    RPAREN          reduce using rule 129 (arguments -> empty .)


state 236

    (130) arguments -> arg_value . arg_tail
    (131) arg_tail -> . empty
    (132) arg_tail -> . COMMA arg_value arg_tail
    (153) empty -> .

    COMMA           shift and go to state 270
    RPAREN          reduce using rule 153 (empty -> .)

    arg_tail                       shift and go to state 268
    empty                          shift and go to state 269

state 237

    (133) arg_value -> literal .

    COMMA           reduce using rule 133 (arg_value -> literal .)
    RPAREN          reduce using rule 133 (arg_value -> literal .)


state 238

    (134) arg_value -> var_call .

    COMMA           reduce using rule 134 (arg_value -> var_call .)
    RPAREN          reduce using rule 134 (arg_value -> var_call .)


state 239

    (135) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 135 (output_statement -> DISPLAY value next_val .)
    RBRACE          reduce using rule 135 (output_statement -> DISPLAY value next_val .)
    COMMA           reduce using rule 135 (output_statement -> DISPLAY value next_val .)
    RPAREN          reduce using rule 135 (output_statement -> DISPLAY value next_val .)
    COLON           reduce using rule 135 (output_statement -> DISPLAY value next_val .)


state 240

    (137) next_val -> empty .

    COMMA           reduce using rule 137 (next_val -> empty .)
    NEWLINE         reduce using rule 137 (next_val -> empty .)
    RBRACE          reduce using rule 137 (next_val -> empty .)
    RPAREN          reduce using rule 137 (next_val -> empty .)
    COLON           reduce using rule 137 (next_val -> empty .)


state 241

    (138) next_val -> COMMA . value next_val
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (127) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (128) function_call -> . output_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (135) output_statement -> . DISPLAY value next_val
    (136) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 180
    CONVERT_TO_FLT  shift and go to state 181
    CONVERT_TO_BLN  shift and go to state 182
    CONVERT_TO_STR  shift and go to state 183
    FUNCTION_NAME   shift and go to state 166
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    DISPLAY         shift and go to state 167
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 271
    type_cast                      shift and go to state 177
    expression                     shift and go to state 178
    function_call                  shift and go to state 179
    factor                         shift and go to state 49
    output_statement               shift and go to state 184
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 242

    (136) output_statement -> DISPLAY LPAREN value . next_val RPAREN
    (137) next_val -> . empty
    (138) next_val -> . COMMA value next_val
    (153) empty -> .

    COMMA           shift and go to state 241
    RPAREN          reduce using rule 153 (empty -> .)

    next_val                       shift and go to state 272
    empty                          shift and go to state 240

state 243

    (57) factor -> LPAREN expression . RPAREN
    (38) value -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 113
    COMMA           reduce using rule 38 (value -> expression .)

  ! RPAREN          [ reduce using rule 38 (value -> expression .) ]


state 244

    (118) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 273


state 245

    (121) control_variable -> INT . IDENT EQ INT_LIT

    IDENT           shift and go to state 274


state 246

    (119) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 275


state 247

    (120) repeat_until -> REPEAT LBRACE maybe_newline . statements RBRACE UNTIL LPAREN expression RPAREN
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 276
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 248

    (21) var_tail -> EQ tail_value var_tail2 .

    NEWLINE         reduce using rule 21 (var_tail -> EQ tail_value var_tail2 .)


state 249

    (23) var_tail2 -> empty .

    NEWLINE         reduce using rule 23 (var_tail2 -> empty .)


state 250

    (24) var_tail2 -> COMMA . IDENT var_tail

    IDENT           shift and go to state 277


state 251

    (26) tail_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 278


state 252

    (22) var_tail -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 22 (var_tail -> COMMA IDENT var_tail .)


state 253

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline . function_statements_tail
    (78) function_statements_tail -> . function_statements
    (76) function_statements -> . maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail
    (77) function_statements -> . empty
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 153 (empty -> .)
    FUNCTION        reduce using rule 153 (empty -> .)
    FUNCTION_INT    reduce using rule 153 (empty -> .)
    FUNCTION_FLT    reduce using rule 153 (empty -> .)
    FUNCTION_CHR    reduce using rule 153 (empty -> .)
    FUNCTION_BLN    reduce using rule 153 (empty -> .)
    FUNCTION_STR    reduce using rule 153 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 153 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 153 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 20
    function_statements_tail       shift and go to state 279
    function_statements            shift and go to state 280
    empty                          shift and go to state 22

state 254

    (40) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 281


state 255

    (44) typecast_value -> expression .

    RPAREN          reduce using rule 44 (typecast_value -> expression .)


state 256

    (45) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 282


state 257

    (46) typecast_value -> input_statement .

    RPAREN          reduce using rule 46 (typecast_value -> input_statement .)


state 258

    (139) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 283


state 259

    (41) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 284


state 260

    (42) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 285


state 261

    (43) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 286


state 262

    (150) stringcon_tail -> PLUS . string_val stringcon_tail
    (151) string_val -> . var_call
    (152) string_val -> . STR_LIT
    (73) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 230
    IDENT           shift and go to state 54

    string_val                     shift and go to state 287
    var_call                       shift and go to state 229

state 263

    (141) string_operation_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 141 (string_operation_tail -> PLUS string_val stringcon_tail .)


state 264

    (149) stringcon_tail -> empty .

    NEWLINE         reduce using rule 149 (stringcon_tail -> empty .)


state 265

    (108) conditional_statement -> CHECK LPAREN expression RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 288
    empty                          shift and go to state 16

state 266

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 289


state 267

    (127) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 127 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 127 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 127 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 127 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 127 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 268

    (130) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 130 (arguments -> arg_value arg_tail .)


state 269

    (131) arg_tail -> empty .

    RPAREN          reduce using rule 131 (arg_tail -> empty .)


state 270

    (132) arg_tail -> COMMA . arg_value arg_tail
    (133) arg_value -> . literal
    (134) arg_value -> . var_call
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT
    (73) var_call -> . IDENT var_call_tail

    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60
    IDENT           shift and go to state 54

    arg_value                      shift and go to state 290
    literal                        shift and go to state 237
    var_call                       shift and go to state 238

state 271

    (138) next_val -> COMMA value . next_val
    (137) next_val -> . empty
    (138) next_val -> . COMMA value next_val
    (153) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 241
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    RPAREN          reduce using rule 153 (empty -> .)
    COLON           reduce using rule 153 (empty -> .)

  ! COMMA           [ reduce using rule 153 (empty -> .) ]

    next_val                       shift and go to state 291
    empty                          shift and go to state 240

state 272

    (136) output_statement -> DISPLAY LPAREN value next_val . RPAREN

    RPAREN          shift and go to state 292


state 273

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 293
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 274

    (121) control_variable -> INT IDENT . EQ INT_LIT

    EQ              shift and go to state 294


state 275

    (119) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 295


state 276

    (120) repeat_until -> REPEAT LBRACE maybe_newline statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 296


state 277

    (24) var_tail2 -> COMMA IDENT . var_tail
    (20) var_tail -> . empty
    (21) var_tail -> . EQ tail_value var_tail2
    (22) var_tail -> . COMMA IDENT var_tail
    (153) empty -> .

    EQ              shift and go to state 173
    COMMA           shift and go to state 174
    NEWLINE         reduce using rule 153 (empty -> .)

    var_tail                       shift and go to state 297
    empty                          shift and go to state 172

state 278

    (26) tail_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 26 (tail_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 26 (tail_value -> LBRACKET list_element RBRACKET .)


state 279

    (76) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail .

    NEWLINE         reduce using rule 76 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail .)
    MAIN_CASPER     reduce using rule 76 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE unli_newline function_statements_tail .)


state 280

    (78) function_statements_tail -> function_statements .

    NEWLINE         reduce using rule 78 (function_statements_tail -> function_statements .)
    MAIN_CASPER     reduce using rule 78 (function_statements_tail -> function_statements .)


state 281

    (40) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 40 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 282

    (45) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 298


state 283

    (139) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 299


state 284

    (41) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 41 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 285

    (42) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 42 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 286

    (43) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 43 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 287

    (150) stringcon_tail -> PLUS string_val . stringcon_tail
    (149) stringcon_tail -> . empty
    (150) stringcon_tail -> . PLUS string_val stringcon_tail
    (153) empty -> .

    PLUS            shift and go to state 262
    NEWLINE         reduce using rule 153 (empty -> .)

    stringcon_tail                 shift and go to state 300
    empty                          shift and go to state 264

state 288

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 301


state 289

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    SHIFT           reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 302
    empty                          shift and go to state 16

state 290

    (132) arg_tail -> COMMA arg_value . arg_tail
    (131) arg_tail -> . empty
    (132) arg_tail -> . COMMA arg_value arg_tail
    (153) empty -> .

    COMMA           shift and go to state 270
    RPAREN          reduce using rule 153 (empty -> .)

    arg_tail                       shift and go to state 303
    empty                          shift and go to state 269

state 291

    (138) next_val -> COMMA value next_val .

    COMMA           reduce using rule 138 (next_val -> COMMA value next_val .)
    NEWLINE         reduce using rule 138 (next_val -> COMMA value next_val .)
    RBRACE          reduce using rule 138 (next_val -> COMMA value next_val .)
    RPAREN          reduce using rule 138 (next_val -> COMMA value next_val .)
    COLON           reduce using rule 138 (next_val -> COMMA value next_val .)


state 292

    (136) output_statement -> DISPLAY LPAREN value next_val RPAREN .

    NEWLINE         reduce using rule 136 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)
    RBRACE          reduce using rule 136 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)
    COMMA           reduce using rule 136 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)
    RPAREN          reduce using rule 136 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)
    COLON           reduce using rule 136 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)


state 293

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 304


state 294

    (121) control_variable -> INT IDENT EQ . INT_LIT

    INT_LIT         shift and go to state 305


state 295

    (119) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 306
    empty                          shift and go to state 16

state 296

    (120) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 307


state 297

    (24) var_tail2 -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 24 (var_tail2 -> COMMA IDENT var_tail .)


state 298

    (45) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 45 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 299

    (139) input_statement -> INPUT LPAREN RPAREN .

    RPAREN          reduce using rule 139 (input_statement -> INPUT LPAREN RPAREN .)


state 300

    (150) stringcon_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 150 (stringcon_tail -> PLUS string_val stringcon_tail .)


state 301

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 308
    empty                          shift and go to state 16

state 302

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline . switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (112) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    SHIFT           shift and go to state 310

    switch_condition               shift and go to state 309

state 303

    (132) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 132 (arg_tail -> COMMA arg_value arg_tail .)


state 304

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (122) update -> . var_call update_tail
    (73) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 54

    update                         shift and go to state 311
    var_call                       shift and go to state 312

state 305

    (121) control_variable -> INT IDENT EQ INT_LIT .

    SEMICOLON       reduce using rule 121 (control_variable -> INT IDENT EQ INT_LIT .)


state 306

    (119) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline . statements RBRACE
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 313
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 307

    (120) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 314


state 308

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 315
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 309

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE       reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 316
    empty                          shift and go to state 16

state 310

    (112) switch_condition -> SHIFT . value COLON maybe_newline statements switchcond_tail
    (37) value -> . type_cast
    (38) value -> . expression
    (39) value -> . function_call
    (40) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (41) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (42) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (43) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (53) expression -> . factor factor_tail
    (127) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (128) function_call -> . output_statement
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (135) output_statement -> . DISPLAY value next_val
    (136) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    CONVERT_TO_INT  shift and go to state 180
    CONVERT_TO_FLT  shift and go to state 181
    CONVERT_TO_BLN  shift and go to state 182
    CONVERT_TO_STR  shift and go to state 183
    FUNCTION_NAME   shift and go to state 166
    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    DISPLAY         shift and go to state 167
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    value                          shift and go to state 317
    type_cast                      shift and go to state 177
    expression                     shift and go to state 178
    function_call                  shift and go to state 179
    factor                         shift and go to state 49
    output_statement               shift and go to state 184
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 311

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 318


state 312

    (122) update -> var_call . update_tail
    (123) update_tail -> . postfix
    (124) update_tail -> . assign_op value
    (125) postfix -> . PLUS_PLUS
    (126) postfix -> . MINUS_MINUS
    (143) assign_op -> . PLUS_EQ
    (144) assign_op -> . MINUS_EQ
    (145) assign_op -> . MUL_EQ
    (146) assign_op -> . DIV_EQ
    (147) assign_op -> . MOD_EQ
    (148) assign_op -> . EQ

    PLUS_PLUS       shift and go to state 196
    MINUS_MINUS     shift and go to state 197
    PLUS_EQ         shift and go to state 198
    MINUS_EQ        shift and go to state 199
    MUL_EQ          shift and go to state 200
    DIV_EQ          shift and go to state 201
    MOD_EQ          shift and go to state 202
    EQ              shift and go to state 203

    update_tail                    shift and go to state 319
    postfix                        shift and go to state 194
    assign_op                      shift and go to state 195

state 313

    (119) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 320


state 314

    (120) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN . expression RPAREN
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 321
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 315

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    RBRACE          shift and go to state 322


state 316

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    OTHERWISE       shift and go to state 323


state 317

    (112) switch_condition -> SHIFT value . COLON maybe_newline statements switchcond_tail

    COLON           shift and go to state 324


state 318

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 325
    empty                          shift and go to state 16

state 319

    (122) update -> var_call update_tail .

    RPAREN          reduce using rule 122 (update -> var_call update_tail .)


state 320

    (119) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 119 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .)


state 321

    (120) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 326


state 322

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 327
    empty                          shift and go to state 16

state 323

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 328
    empty                          shift and go to state 16

state 324

    (112) switch_condition -> SHIFT value COLON . maybe_newline statements switchcond_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    SHIFT           reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 329
    empty                          shift and go to state 16

state 325

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 330


state 326

    (120) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 120 (repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN .)


state 327

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (109) conditional_tail -> . empty
    (110) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (153) empty -> .

    OTHERWISE_CHECK shift and go to state 333
    NEWLINE         reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)

    conditional_tail               shift and go to state 331
    empty                          shift and go to state 332

state 328

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 334


state 329

    (112) switch_condition -> SHIFT value COLON maybe_newline . statements switchcond_tail
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SHIFT           reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 335
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 330

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 336
    empty                          shift and go to state 16

state 331

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE       reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 337
    empty                          shift and go to state 16

state 332

    (109) conditional_tail -> empty .

    NEWLINE         reduce using rule 109 (conditional_tail -> empty .)
    OTHERWISE       reduce using rule 109 (conditional_tail -> empty .)


state 333

    (110) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    LPAREN          shift and go to state 338


state 334

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 339
    empty                          shift and go to state 16

state 335

    (112) switch_condition -> SHIFT value COLON maybe_newline statements . switchcond_tail
    (113) switchcond_tail -> . empty
    (114) switchcond_tail -> . switch_condition
    (153) empty -> .
    (112) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    NEWLINE         reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)
    SHIFT           shift and go to state 310

    switchcond_tail                shift and go to state 340
    empty                          shift and go to state 341
    switch_condition               shift and go to state 342

state 336

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 343
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 337

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    OTHERWISE       shift and go to state 344


state 338

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (53) expression -> . factor factor_tail
    (54) factor -> . var_call
    (55) factor -> . literal
    (56) factor -> . TILDE literal
    (57) factor -> . LPAREN expression RPAREN
    (73) var_call -> . IDENT var_call_tail
    (47) literal -> . INT_LIT
    (48) literal -> . FLT_LIT
    (49) literal -> . DAY
    (50) literal -> . NIGHT
    (51) literal -> . CHR_LIT
    (52) literal -> . STR_LIT

    TILDE           shift and go to state 52
    LPAREN          shift and go to state 53
    IDENT           shift and go to state 54
    INT_LIT         shift and go to state 55
    FLT_LIT         shift and go to state 56
    DAY             shift and go to state 57
    NIGHT           shift and go to state 58
    CHR_LIT         shift and go to state 59
    STR_LIT         shift and go to state 60

    expression                     shift and go to state 345
    factor                         shift and go to state 49
    var_call                       shift and go to state 50
    literal                        shift and go to state 51

state 339

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline RBRACE
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 346
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 340

    (112) switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .

    NEWLINE         reduce using rule 112 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)
    OTHERWISE       reduce using rule 112 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)


state 341

    (113) switchcond_tail -> empty .

    NEWLINE         reduce using rule 113 (switchcond_tail -> empty .)
    OTHERWISE       reduce using rule 113 (switchcond_tail -> empty .)


state 342

    (114) switchcond_tail -> switch_condition .

    NEWLINE         reduce using rule 114 (switchcond_tail -> switch_condition .)
    OTHERWISE       reduce using rule 114 (switchcond_tail -> switch_condition .)


state 343

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 347


state 344

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 348
    empty                          shift and go to state 16

state 345

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    RPAREN          shift and go to state 349


state 346

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 350
    empty                          shift and go to state 16

state 347

    (118) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 118 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .)


state 348

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 351


state 349

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 352
    empty                          shift and go to state 16

state 350

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline RBRACE

    RBRACE          shift and go to state 353


state 351

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 354
    empty                          shift and go to state 16

state 352

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    LBRACE          shift and go to state 355


state 353

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 153 (empty -> .)

    maybe_newline                  shift and go to state 356
    empty                          shift and go to state 16

state 354

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements RBRACE
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 357
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 355

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 153 (empty -> .)
    FLT             reduce using rule 153 (empty -> .)
    BLN             reduce using rule 153 (empty -> .)
    CHR             reduce using rule 153 (empty -> .)
    STR             reduce using rule 153 (empty -> .)
    RBRACE          reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 358
    empty                          shift and go to state 16

state 356

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . RBRACE

    RBRACE          shift and go to state 359


state 357

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 360


state 358

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail
    (97) statements -> . empty
    (98) statements -> . local_dec maybe_newline statements_tail
    (153) empty -> .
    (106) local_dec -> . empty
    (107) local_dec -> . var_statement
    (19) var_statement -> . data_type IDENT var_tail unli_newline
    (32) data_type -> . INT
    (33) data_type -> . FLT
    (34) data_type -> . BLN
    (35) data_type -> . CHR
    (36) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 153 (empty -> .)
    NEWLINE         reduce using rule 153 (empty -> .)
    CHECK           reduce using rule 153 (empty -> .)
    SWAP            reduce using rule 153 (empty -> .)
    FUNCTION_NAME   reduce using rule 153 (empty -> .)
    DISPLAY         reduce using rule 153 (empty -> .)
    IDENT           reduce using rule 153 (empty -> .)
    FOR             reduce using rule 153 (empty -> .)
    UNTIL           reduce using rule 153 (empty -> .)
    REPEAT          reduce using rule 153 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 153 (empty -> .) ]
  ! FLT             [ reduce using rule 153 (empty -> .) ]
  ! BLN             [ reduce using rule 153 (empty -> .) ]
  ! CHR             [ reduce using rule 153 (empty -> .) ]
  ! STR             [ reduce using rule 153 (empty -> .) ]

    statements                     shift and go to state 361
    empty                          shift and go to state 139
    local_dec                      shift and go to state 140
    var_statement                  shift and go to state 141
    data_type                      shift and go to state 142

state 359

    (111) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .

    NEWLINE         reduce using rule 111 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .)


state 360

    (108) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 108 (conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .)


state 361

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail

    RBRACE          shift and go to state 362


state 362

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (153) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)

  ! NEWLINE         [ reduce using rule 153 (empty -> .) ]

    maybe_newline                  shift and go to state 363
    empty                          shift and go to state 16

state 363

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail
    (109) conditional_tail -> . empty
    (110) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (153) empty -> .

    OTHERWISE_CHECK shift and go to state 333
    NEWLINE         reduce using rule 153 (empty -> .)
    OTHERWISE       reduce using rule 153 (empty -> .)

    conditional_tail               shift and go to state 364
    empty                          shift and go to state 332

state 364

    (110) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .

    NEWLINE         reduce using rule 110 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .)
    OTHERWISE       reduce using rule 110 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 15 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 17 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 132 resolved as shift
WARNING: shift/reduce conflict for INT in state 135 resolved as shift
WARNING: shift/reduce conflict for FLT in state 135 resolved as shift
WARNING: shift/reduce conflict for BLN in state 135 resolved as shift
WARNING: shift/reduce conflict for CHR in state 135 resolved as shift
WARNING: shift/reduce conflict for STR in state 135 resolved as shift
WARNING: shift/reduce conflict for INT in state 136 resolved as shift
WARNING: shift/reduce conflict for FLT in state 136 resolved as shift
WARNING: shift/reduce conflict for BLN in state 136 resolved as shift
WARNING: shift/reduce conflict for CHR in state 136 resolved as shift
WARNING: shift/reduce conflict for STR in state 136 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 140 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 146 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 146 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 146 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 146 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 146 resolved as shift
WARNING: shift/reduce conflict for FOR in state 146 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 146 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 146 resolved as shift
WARNING: shift/reduce conflict for INT in state 146 resolved as shift
WARNING: shift/reduce conflict for FLT in state 146 resolved as shift
WARNING: shift/reduce conflict for BLN in state 146 resolved as shift
WARNING: shift/reduce conflict for CHR in state 146 resolved as shift
WARNING: shift/reduce conflict for STR in state 146 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 159 resolved as shift
WARNING: shift/reduce conflict for INT in state 185 resolved as shift
WARNING: shift/reduce conflict for FLT in state 185 resolved as shift
WARNING: shift/reduce conflict for BLN in state 185 resolved as shift
WARNING: shift/reduce conflict for CHR in state 185 resolved as shift
WARNING: shift/reduce conflict for STR in state 185 resolved as shift
WARNING: shift/reduce conflict for INT in state 186 resolved as shift
WARNING: shift/reduce conflict for FLT in state 186 resolved as shift
WARNING: shift/reduce conflict for BLN in state 186 resolved as shift
WARNING: shift/reduce conflict for CHR in state 186 resolved as shift
WARNING: shift/reduce conflict for STR in state 186 resolved as shift
WARNING: shift/reduce conflict for INT in state 187 resolved as shift
WARNING: shift/reduce conflict for FLT in state 187 resolved as shift
WARNING: shift/reduce conflict for BLN in state 187 resolved as shift
WARNING: shift/reduce conflict for CHR in state 187 resolved as shift
WARNING: shift/reduce conflict for STR in state 187 resolved as shift
WARNING: shift/reduce conflict for INT in state 188 resolved as shift
WARNING: shift/reduce conflict for FLT in state 188 resolved as shift
WARNING: shift/reduce conflict for BLN in state 188 resolved as shift
WARNING: shift/reduce conflict for CHR in state 188 resolved as shift
WARNING: shift/reduce conflict for STR in state 188 resolved as shift
WARNING: shift/reduce conflict for INT in state 189 resolved as shift
WARNING: shift/reduce conflict for FLT in state 189 resolved as shift
WARNING: shift/reduce conflict for BLN in state 189 resolved as shift
WARNING: shift/reduce conflict for CHR in state 189 resolved as shift
WARNING: shift/reduce conflict for STR in state 189 resolved as shift
WARNING: shift/reduce conflict for INT in state 190 resolved as shift
WARNING: shift/reduce conflict for FLT in state 190 resolved as shift
WARNING: shift/reduce conflict for BLN in state 190 resolved as shift
WARNING: shift/reduce conflict for CHR in state 190 resolved as shift
WARNING: shift/reduce conflict for STR in state 190 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 207 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 211 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 243 resolved as shift
WARNING: shift/reduce conflict for INT in state 247 resolved as shift
WARNING: shift/reduce conflict for FLT in state 247 resolved as shift
WARNING: shift/reduce conflict for BLN in state 247 resolved as shift
WARNING: shift/reduce conflict for CHR in state 247 resolved as shift
WARNING: shift/reduce conflict for STR in state 247 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 253 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 271 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 295 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 301 resolved as shift
WARNING: shift/reduce conflict for INT in state 306 resolved as shift
WARNING: shift/reduce conflict for FLT in state 306 resolved as shift
WARNING: shift/reduce conflict for BLN in state 306 resolved as shift
WARNING: shift/reduce conflict for CHR in state 306 resolved as shift
WARNING: shift/reduce conflict for STR in state 306 resolved as shift
WARNING: shift/reduce conflict for INT in state 308 resolved as shift
WARNING: shift/reduce conflict for FLT in state 308 resolved as shift
WARNING: shift/reduce conflict for BLN in state 308 resolved as shift
WARNING: shift/reduce conflict for CHR in state 308 resolved as shift
WARNING: shift/reduce conflict for STR in state 308 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 322 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 324 resolved as shift
WARNING: shift/reduce conflict for INT in state 329 resolved as shift
WARNING: shift/reduce conflict for FLT in state 329 resolved as shift
WARNING: shift/reduce conflict for BLN in state 329 resolved as shift
WARNING: shift/reduce conflict for CHR in state 329 resolved as shift
WARNING: shift/reduce conflict for STR in state 329 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 330 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 334 resolved as shift
WARNING: shift/reduce conflict for INT in state 336 resolved as shift
WARNING: shift/reduce conflict for FLT in state 336 resolved as shift
WARNING: shift/reduce conflict for BLN in state 336 resolved as shift
WARNING: shift/reduce conflict for CHR in state 336 resolved as shift
WARNING: shift/reduce conflict for STR in state 336 resolved as shift
WARNING: shift/reduce conflict for INT in state 339 resolved as shift
WARNING: shift/reduce conflict for FLT in state 339 resolved as shift
WARNING: shift/reduce conflict for BLN in state 339 resolved as shift
WARNING: shift/reduce conflict for CHR in state 339 resolved as shift
WARNING: shift/reduce conflict for STR in state 339 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 351 resolved as shift
WARNING: shift/reduce conflict for INT in state 354 resolved as shift
WARNING: shift/reduce conflict for FLT in state 354 resolved as shift
WARNING: shift/reduce conflict for BLN in state 354 resolved as shift
WARNING: shift/reduce conflict for CHR in state 354 resolved as shift
WARNING: shift/reduce conflict for STR in state 354 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 355 resolved as shift
WARNING: shift/reduce conflict for INT in state 358 resolved as shift
WARNING: shift/reduce conflict for FLT in state 358 resolved as shift
WARNING: shift/reduce conflict for BLN in state 358 resolved as shift
WARNING: shift/reduce conflict for CHR in state 358 resolved as shift
WARNING: shift/reduce conflict for STR in state 358 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 362 resolved as shift
WARNING: reduce/reduce conflict in state 139 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 139
