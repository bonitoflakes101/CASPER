Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BLN_LIT
    CARRIAGE_RETURN
    COMMENT
    DOUBLE_LT
    DOUBLE_SLASH
    EOF
    FUNCTION_LIST_BLN2D
    FUNCTION_LIST_CHR2D
    FUNCTION_LIST_FLT2D
    FUNCTION_LIST_INT2D
    FUNCTION_LIST_STR2D
    ILLEGAL
    IN
    LIST_BLN
    LIST_BLN2D
    LIST_CHR
    LIST_CHR2D
    LIST_FLT
    LIST_FLT2D
    LIST_INT
    LIST_INT2D
    LIST_STR
    LIST_STR2D
    MEASURE
    NOT
    POW
    SKIP
    STOP
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
Rule 2     maybe_newline -> empty
Rule 3     maybe_newline -> NEWLINE maybe_newline
Rule 4     unli_newline -> NEWLINE
Rule 5     unli_newline -> NEWLINE unli_newline
Rule 6     main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
Rule 7     global_dec -> global_statement unli_newline global_tail
Rule 8     global_dec -> empty
Rule 9     global_tail -> global_dec
Rule 10    global_tail -> empty
Rule 11    global_statement -> data_type IDENT global_statement_tail
Rule 12    global_statement_tail -> empty
Rule 13    global_statement_tail -> COMMA IDENT global_statement_tail
Rule 14    global_statement_tail -> EQ global_dec_value global_tail2
Rule 15    global_tail2 -> empty
Rule 16    global_tail2 -> COMMA IDENT global_statement_tail
Rule 17    global_dec_value -> global_value
Rule 18    global_dec_value -> LBRACKET list_element RBRACKET
Rule 19    global_value -> factor
Rule 20    global_value -> expression
Rule 21    var_statement -> data_type IDENT var_tail
Rule 22    var_tail -> empty
Rule 23    var_tail -> EQ tail_value var_tail2
Rule 24    var_tail -> COMMA IDENT var_tail
Rule 25    var_tail2 -> empty
Rule 26    var_tail2 -> COMMA IDENT var_tail
Rule 27    tail_value -> value
Rule 28    tail_value -> LBRACKET list_element RBRACKET
Rule 29    list_element -> literal element_tail
Rule 30    element_tail -> empty
Rule 31    element_tail -> COMMA list_element
Rule 32    index -> INT_LIT
Rule 33    index -> IDENT
Rule 34    data_type -> INT
Rule 35    data_type -> FLT
Rule 36    data_type -> BLN
Rule 37    data_type -> CHR
Rule 38    data_type -> STR
Rule 39    value -> factor
Rule 40    value -> type_cast
Rule 41    value -> expression
Rule 42    value -> function_call
Rule 43    type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN
Rule 44    type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN
Rule 45    type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN
Rule 46    type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN
Rule 47    typecast_value -> IDENT
Rule 48    typecast_value -> literal
Rule 49    typecast_value -> expression
Rule 50    typecast_value -> FUNCTION_NAME LPAREN RPAREN
Rule 51    typecast_value -> input_statement
Rule 52    literal -> INT_LIT
Rule 53    literal -> FLT_LIT
Rule 54    literal -> DAY
Rule 55    literal -> NIGHT
Rule 56    literal -> CHR_LIT
Rule 57    literal -> STR_LIT
Rule 58    expression -> expr_head expr_tail
Rule 59    expr_head -> term term_tail
Rule 60    term -> factor factor_tail
Rule 61    factor -> var_call
Rule 62    factor -> literal
Rule 63    factor -> TILDE literal
Rule 64    factor -> LPAREN expression RPAREN
Rule 65    factor_tail -> empty
Rule 66    factor_tail -> PLUS expression
Rule 67    factor_tail -> MINUS expression
Rule 68    factor_tail -> MULTIPLY expression
Rule 69    factor_tail -> DIVISION expression
Rule 70    factor_tail -> MODULO expression
Rule 71    factor_tail -> EXPONENT expression
Rule 72    term_tail -> empty
Rule 73    term_tail -> GT expression
Rule 74    term_tail -> LT expression
Rule 75    term_tail -> EQ_EQ expression
Rule 76    term_tail -> GT_EQ expression
Rule 77    term_tail -> LT_EQ expression
Rule 78    term_tail -> NOT_EQ expression
Rule 79    expr_tail -> empty
Rule 80    expr_tail -> AND expression
Rule 81    expr_tail -> OR expression
Rule 82    var_call -> IDENT var_call_tail
Rule 83    var_call_tail -> empty
Rule 84    var_call_tail -> LBRACKET index RBRACKET
Rule 85    function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
Rule 86    function_statements -> empty
Rule 87    ret_type -> FUNCTION
Rule 88    ret_type -> function_dtype
Rule 89    function_dtype -> FUNCTION_INT
Rule 90    function_dtype -> FUNCTION_FLT
Rule 91    function_dtype -> FUNCTION_CHR
Rule 92    function_dtype -> FUNCTION_BLN
Rule 93    function_dtype -> FUNCTION_STR
Rule 94    function_dtype -> FUNCTION_LIST_INT
Rule 95    function_dtype -> FUNCTION_LIST_FLT
Rule 96    function_dtype -> FUNCTION_LIST_CHR
Rule 97    function_dtype -> FUNCTION_LIST_STR
Rule 98    function_dtype -> FUNCTION_LIST_BLN
Rule 99    parameters -> data_type IDENT parameters_tail
Rule 100   parameters -> empty
Rule 101   parameters_tail -> empty
Rule 102   parameters_tail -> COMMA data_type IDENT parameters_tail
Rule 103   revive -> REVIVE value
Rule 104   revive -> empty
Rule 105   statements -> empty
Rule 106   statements -> local_dec maybe_newline statements_tail
Rule 107   statements_tail -> empty
Rule 108   statements_tail -> local_dec maybe_newline statements_tail
Rule 109   statements_tail -> string_operation_statement unli_newline statements_tail
Rule 110   statements_tail -> conditional_statement unli_newline statements_tail
Rule 111   statements_tail -> switch_statement unli_newline statements_tail
Rule 112   statements_tail -> loop_statement unli_newline statements_tail
Rule 113   statements_tail -> function_call unli_newline statements_tail
Rule 114   statements_tail -> output_statement unli_newline statements_tail
Rule 115   local_dec -> empty
Rule 116   local_dec -> var_statement
Rule 117   conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
Rule 118   conditional_tail -> empty
Rule 119   conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
Rule 120   conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
Rule 121   conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
Rule 122   conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
Rule 123   switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
Rule 124   switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail
Rule 125   switchcond_tail -> empty
Rule 126   switchcond_tail -> switch_condition
Rule 127   loop_statement -> for_loop
Rule 128   loop_statement -> until_loop
Rule 129   loop_statement -> repeat_until
Rule 130   for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
Rule 131   until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
Rule 132   repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
Rule 133   control_variable -> INT IDENT EQ INT_LIT
Rule 134   update -> var_call update_tail
Rule 135   update_tail -> postfix
Rule 136   update_tail -> assign_op value
Rule 137   postfix -> PLUS_PLUS
Rule 138   postfix -> MINUS_MINUS
Rule 139   function_call -> FUNCTION_NAME LPAREN arguments RPAREN
Rule 140   function_call -> input_statement
Rule 141   arguments -> empty
Rule 142   arguments -> arg_value arg_tail
Rule 143   arg_tail -> empty
Rule 144   arg_tail -> COMMA arg_value arg_tail
Rule 145   arg_value -> literal
Rule 146   arg_value -> var_call
Rule 147   output_statement -> DISPLAY value next_val
Rule 148   output_statement -> DISPLAY LPAREN value next_val RPAREN
Rule 149   next_val -> empty
Rule 150   next_val -> COMMA value next_val
Rule 151   input_statement -> INPUT LPAREN RPAREN
Rule 152   string_operation_statement -> var_call string_operation_tail
Rule 153   string_operation_tail -> PLUS string_val stringcon_tail
Rule 154   string_operation_tail -> update_tail
Rule 155   assign_op -> PLUS_EQ
Rule 156   assign_op -> MINUS_EQ
Rule 157   assign_op -> MUL_EQ
Rule 158   assign_op -> DIV_EQ
Rule 159   assign_op -> MOD_EQ
Rule 160   assign_op -> EQ
Rule 161   stringcon_tail -> empty
Rule 162   stringcon_tail -> PLUS string_val stringcon_tail
Rule 163   string_val -> var_call
Rule 164   string_val -> STR_LIT
Rule 165   empty -> <empty>

Terminals, with rules where they appear

AND                  : 80
BIRTH                : 1
BLN                  : 36
BLN_LIT              : 
CARRIAGE_RETURN      : 
CHECK                : 117
CHR                  : 37
CHR_LIT              : 56
COLON                : 124
COMMA                : 13 16 24 26 31 102 144 150
COMMENT              : 
CONVERT_TO_BLN       : 45
CONVERT_TO_FLT       : 44
CONVERT_TO_INT       : 43
CONVERT_TO_STR       : 46
DAY                  : 54
DISPLAY              : 147 148
DIVISION             : 69
DIV_EQ               : 158
DOUBLE_LT            : 
DOUBLE_SLASH         : 
EOF                  : 
EQ                   : 14 23 133 160
EQ_EQ                : 75
EXPONENT             : 71
FLT                  : 35
FLT_LIT              : 53
FOR                  : 130
FUNCTION             : 87
FUNCTION_BLN         : 92
FUNCTION_CHR         : 91
FUNCTION_FLT         : 90
FUNCTION_INT         : 89
FUNCTION_LIST_BLN    : 98
FUNCTION_LIST_BLN2D  : 
FUNCTION_LIST_CHR    : 96
FUNCTION_LIST_CHR2D  : 
FUNCTION_LIST_FLT    : 95
FUNCTION_LIST_FLT2D  : 
FUNCTION_LIST_INT    : 94
FUNCTION_LIST_INT2D  : 
FUNCTION_LIST_STR    : 97
FUNCTION_LIST_STR2D  : 
FUNCTION_NAME        : 50 85 139
FUNCTION_STR         : 93
GHOST                : 1
GT                   : 73
GT_EQ                : 76
IDENT                : 11 13 16 21 24 26 33 47 82 99 102 123 133
ILLEGAL              : 
IN                   : 
INPUT                : 151
INT                  : 34 133
INT_LIT              : 32 52 133
LBRACE               : 6 85 117 119 120 121 122 123 123 130 131 132
LBRACKET             : 18 28 84
LIST_BLN             : 
LIST_BLN2D           : 
LIST_CHR             : 
LIST_CHR2D           : 
LIST_FLT             : 
LIST_FLT2D           : 
LIST_INT             : 
LIST_INT2D           : 
LIST_STR             : 
LIST_STR2D           : 
LPAREN               : 6 43 44 45 46 50 64 85 117 119 121 123 130 131 132 139 148 151
LT                   : 74
LT_EQ                : 77
MAIN_CASPER          : 6
MEASURE              : 
MINUS                : 67
MINUS_EQ             : 156
MINUS_MINUS          : 138
MODULO               : 70
MOD_EQ               : 159
MULTIPLY             : 68
MUL_EQ               : 157
NEWLINE              : 3 4 5
NIGHT                : 55
NOT                  : 
NOT_EQ               : 78
OR                   : 81
OTHERWISE            : 120 122 123
OTHERWISE_CHECK      : 119 121
PLUS                 : 66 153 162
PLUS_EQ              : 155
PLUS_PLUS            : 137
POW                  : 
RBRACE               : 6 85 117 119 120 121 122 123 123 130 131 132
RBRACKET             : 18 28 84
REPEAT               : 132
REVIVE               : 103
RPAREN               : 6 43 44 45 46 50 64 85 117 119 121 123 130 131 132 139 148 151
SEMICOLON            : 130 130
SHIFT                : 124
SKIP                 : 
STOP                 : 
STR                  : 38
STR_LIT              : 57 164
SWAP                 : 123
TILDE                : 63
TYPE                 : 
UNTIL                : 131 132
error                : 

Nonterminals, with rules where they appear

arg_tail             : 142 144
arg_value            : 142 144
arguments            : 139
assign_op            : 136
conditional_statement : 110
conditional_tail     : 117
conditional_tail2    : 119 121
control_variable     : 130
data_type            : 11 21 99 102
element_tail         : 29
empty                : 2 8 10 12 15 22 25 30 65 72 79 83 86 100 101 104 105 107 115 118 125 141 143 149 161
expr_head            : 58
expr_tail            : 58
expression           : 20 41 49 64 66 67 68 69 70 71 73 74 75 76 77 78 80 81 117 119 121 130 131 132
factor               : 19 39 60
factor_tail          : 60
for_loop             : 127
function_call        : 42 113
function_dtype       : 88
function_statements  : 1
global_dec           : 1 9
global_dec_value     : 14
global_statement     : 7
global_statement_tail : 11 13 16
global_tail          : 7
global_tail2         : 14
global_value         : 17
index                : 84
input_statement      : 51 140
list_element         : 18 28 31
literal              : 29 48 62 63 145
local_dec            : 106 108
loop_statement       : 112
main_function        : 1
maybe_newline        : 1 1 3 6 6 6 85 85 85 106 108 117 117 117 119 119 119 120 120 121 121 121 122 122 123 123 123 123 123 123 124 130 130 131 132
next_val             : 147 148 150
output_statement     : 114
parameters           : 85
parameters_tail      : 99 102
postfix              : 135
program              : 0
repeat_until         : 129
ret_type             : 85
revive               : 85
statements           : 6 85 117 119 120 121 122 123 124 130 131 132
statements_tail      : 106 108 109 110 111 112 113 114
string_operation_statement : 109
string_operation_tail : 152
string_val           : 153 162
stringcon_tail       : 153 162
switch_condition     : 123 126
switch_statement     : 111
switchcond_tail      : 124
tail_value           : 23
term                 : 59
term_tail            : 59
type_cast            : 40
typecast_value       : 43 44 45 46
unli_newline         : 1 1 5 7 85 109 110 111 112 113 114
until_loop           : 128
update               : 130
update_tail          : 134 154
value                : 27 103 124 136 147 148 150
var_call             : 61 134 146 152 163
var_call_tail        : 82
var_statement        : 116
var_tail             : 21 24 26
var_tail2            : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST

    BIRTH           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> BIRTH . unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 3

state 3

    (1) program -> BIRTH unli_newline . global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (11) global_statement -> . data_type IDENT global_statement_tail
    (165) empty -> .
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 165 (empty -> .)
    MAIN_CASPER     reduce using rule 165 (empty -> .)
    FUNCTION        reduce using rule 165 (empty -> .)
    FUNCTION_INT    reduce using rule 165 (empty -> .)
    FUNCTION_FLT    reduce using rule 165 (empty -> .)
    FUNCTION_CHR    reduce using rule 165 (empty -> .)
    FUNCTION_BLN    reduce using rule 165 (empty -> .)
    FUNCTION_STR    reduce using rule 165 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_dec                     shift and go to state 5
    global_statement               shift and go to state 6
    empty                          shift and go to state 7
    data_type                      shift and go to state 8

state 4

    (4) unli_newline -> NEWLINE .
    (5) unli_newline -> NEWLINE . unli_newline
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

  ! shift/reduce conflict for NEWLINE resolved as shift
    INT             reduce using rule 4 (unli_newline -> NEWLINE .)
    FLT             reduce using rule 4 (unli_newline -> NEWLINE .)
    BLN             reduce using rule 4 (unli_newline -> NEWLINE .)
    CHR             reduce using rule 4 (unli_newline -> NEWLINE .)
    STR             reduce using rule 4 (unli_newline -> NEWLINE .)
    MAIN_CASPER     reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION        reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_INT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_FLT    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_CHR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_BLN    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_STR    reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_INT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_FLT reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_CHR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_STR reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_LIST_BLN reduce using rule 4 (unli_newline -> NEWLINE .)
    GHOST           reduce using rule 4 (unli_newline -> NEWLINE .)
    REVIVE          reduce using rule 4 (unli_newline -> NEWLINE .)
    RBRACE          reduce using rule 4 (unli_newline -> NEWLINE .)
    CHECK           reduce using rule 4 (unli_newline -> NEWLINE .)
    SWAP            reduce using rule 4 (unli_newline -> NEWLINE .)
    FUNCTION_NAME   reduce using rule 4 (unli_newline -> NEWLINE .)
    DISPLAY         reduce using rule 4 (unli_newline -> NEWLINE .)
    IDENT           reduce using rule 4 (unli_newline -> NEWLINE .)
    FOR             reduce using rule 4 (unli_newline -> NEWLINE .)
    UNTIL           reduce using rule 4 (unli_newline -> NEWLINE .)
    REPEAT          reduce using rule 4 (unli_newline -> NEWLINE .)
    INPUT           reduce using rule 4 (unli_newline -> NEWLINE .)
    SHIFT           reduce using rule 4 (unli_newline -> NEWLINE .)
    OTHERWISE       reduce using rule 4 (unli_newline -> NEWLINE .)
    NEWLINE         shift and go to state 4

  ! NEWLINE         [ reduce using rule 4 (unli_newline -> NEWLINE .) ]

    unli_newline                   shift and go to state 14

state 5

    (1) program -> BIRTH unli_newline global_dec . maybe_newline function_statements maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 165 (empty -> .)
    FUNCTION        reduce using rule 165 (empty -> .)
    FUNCTION_INT    reduce using rule 165 (empty -> .)
    FUNCTION_FLT    reduce using rule 165 (empty -> .)
    FUNCTION_CHR    reduce using rule 165 (empty -> .)
    FUNCTION_BLN    reduce using rule 165 (empty -> .)
    FUNCTION_STR    reduce using rule 165 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 15
    empty                          shift and go to state 16

state 6

    (7) global_dec -> global_statement . unli_newline global_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 18

state 7

    (8) global_dec -> empty .

    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)


state 8

    (11) global_statement -> data_type . IDENT global_statement_tail

    IDENT           shift and go to state 19


state 9

    (34) data_type -> INT .

    IDENT           reduce using rule 34 (data_type -> INT .)


state 10

    (35) data_type -> FLT .

    IDENT           reduce using rule 35 (data_type -> FLT .)


state 11

    (36) data_type -> BLN .

    IDENT           reduce using rule 36 (data_type -> BLN .)


state 12

    (37) data_type -> CHR .

    IDENT           reduce using rule 37 (data_type -> CHR .)


state 13

    (38) data_type -> STR .

    IDENT           reduce using rule 38 (data_type -> STR .)


state 14

    (5) unli_newline -> NEWLINE unli_newline .

    INT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FLT             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    BLN             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    STR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    NEWLINE         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    MAIN_CASPER     reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION        reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_INT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_FLT    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_CHR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_BLN    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_STR    reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_INT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_FLT reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_CHR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_STR reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_LIST_BLN reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    GHOST           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REVIVE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    RBRACE          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    CHECK           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SWAP            reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FUNCTION_NAME   reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    DISPLAY         reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    IDENT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    FOR             reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    UNTIL           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    REPEAT          reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    INPUT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    SHIFT           reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)
    OTHERWISE       reduce using rule 5 (unli_newline -> NEWLINE unli_newline .)


state 15

    (1) program -> BIRTH unli_newline global_dec maybe_newline . function_statements maybe_newline main_function unli_newline GHOST
    (85) function_statements -> . maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (86) function_statements -> . empty
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 165 (empty -> .)
    FUNCTION        reduce using rule 165 (empty -> .)
    FUNCTION_INT    reduce using rule 165 (empty -> .)
    FUNCTION_FLT    reduce using rule 165 (empty -> .)
    FUNCTION_CHR    reduce using rule 165 (empty -> .)
    FUNCTION_BLN    reduce using rule 165 (empty -> .)
    FUNCTION_STR    reduce using rule 165 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 20
    function_statements            shift and go to state 21
    empty                          shift and go to state 22

state 16

    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 2 (maybe_newline -> empty .)
    MAIN_CASPER     reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)
    LBRACE          reduce using rule 2 (maybe_newline -> empty .)
    INT             reduce using rule 2 (maybe_newline -> empty .)
    FLT             reduce using rule 2 (maybe_newline -> empty .)
    BLN             reduce using rule 2 (maybe_newline -> empty .)
    CHR             reduce using rule 2 (maybe_newline -> empty .)
    STR             reduce using rule 2 (maybe_newline -> empty .)
    RBRACE          reduce using rule 2 (maybe_newline -> empty .)
    CHECK           reduce using rule 2 (maybe_newline -> empty .)
    SWAP            reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_NAME   reduce using rule 2 (maybe_newline -> empty .)
    DISPLAY         reduce using rule 2 (maybe_newline -> empty .)
    IDENT           reduce using rule 2 (maybe_newline -> empty .)
    FOR             reduce using rule 2 (maybe_newline -> empty .)
    UNTIL           reduce using rule 2 (maybe_newline -> empty .)
    REPEAT          reduce using rule 2 (maybe_newline -> empty .)
    INPUT           reduce using rule 2 (maybe_newline -> empty .)
    REVIVE          reduce using rule 2 (maybe_newline -> empty .)
    SHIFT           reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE       reduce using rule 2 (maybe_newline -> empty .)
    OTHERWISE_CHECK reduce using rule 2 (maybe_newline -> empty .)


state 17

    (3) maybe_newline -> NEWLINE . maybe_newline
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 165 (empty -> .)
    FUNCTION        reduce using rule 165 (empty -> .)
    FUNCTION_INT    reduce using rule 165 (empty -> .)
    FUNCTION_FLT    reduce using rule 165 (empty -> .)
    FUNCTION_CHR    reduce using rule 165 (empty -> .)
    FUNCTION_BLN    reduce using rule 165 (empty -> .)
    FUNCTION_STR    reduce using rule 165 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 165 (empty -> .)
    LBRACE          reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    OTHERWISE_CHECK reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 23
    empty                          shift and go to state 16

state 18

    (7) global_dec -> global_statement unli_newline . global_tail
    (9) global_tail -> . global_dec
    (10) global_tail -> . empty
    (7) global_dec -> . global_statement unli_newline global_tail
    (8) global_dec -> . empty
    (165) empty -> .
    (11) global_statement -> . data_type IDENT global_statement_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    NEWLINE         reduce using rule 165 (empty -> .)
    MAIN_CASPER     reduce using rule 165 (empty -> .)
    FUNCTION        reduce using rule 165 (empty -> .)
    FUNCTION_INT    reduce using rule 165 (empty -> .)
    FUNCTION_FLT    reduce using rule 165 (empty -> .)
    FUNCTION_CHR    reduce using rule 165 (empty -> .)
    FUNCTION_BLN    reduce using rule 165 (empty -> .)
    FUNCTION_STR    reduce using rule 165 (empty -> .)
    FUNCTION_LIST_INT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_FLT reduce using rule 165 (empty -> .)
    FUNCTION_LIST_CHR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_STR reduce using rule 165 (empty -> .)
    FUNCTION_LIST_BLN reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    global_statement               shift and go to state 6
    global_tail                    shift and go to state 24
    global_dec                     shift and go to state 25
    empty                          shift and go to state 26
    data_type                      shift and go to state 8

state 19

    (11) global_statement -> data_type IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (165) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 165 (empty -> .)

    global_statement_tail          shift and go to state 27
    empty                          shift and go to state 28

state 20

    (85) function_statements -> maybe_newline . ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (87) ret_type -> . FUNCTION
    (88) ret_type -> . function_dtype
    (89) function_dtype -> . FUNCTION_INT
    (90) function_dtype -> . FUNCTION_FLT
    (91) function_dtype -> . FUNCTION_CHR
    (92) function_dtype -> . FUNCTION_BLN
    (93) function_dtype -> . FUNCTION_STR
    (94) function_dtype -> . FUNCTION_LIST_INT
    (95) function_dtype -> . FUNCTION_LIST_FLT
    (96) function_dtype -> . FUNCTION_LIST_CHR
    (97) function_dtype -> . FUNCTION_LIST_STR
    (98) function_dtype -> . FUNCTION_LIST_BLN

    FUNCTION        shift and go to state 32
    FUNCTION_INT    shift and go to state 34
    FUNCTION_FLT    shift and go to state 35
    FUNCTION_CHR    shift and go to state 36
    FUNCTION_BLN    shift and go to state 37
    FUNCTION_STR    shift and go to state 38
    FUNCTION_LIST_INT shift and go to state 39
    FUNCTION_LIST_FLT shift and go to state 40
    FUNCTION_LIST_CHR shift and go to state 41
    FUNCTION_LIST_STR shift and go to state 42
    FUNCTION_LIST_BLN shift and go to state 43

    ret_type                       shift and go to state 31
    function_dtype                 shift and go to state 33

state 21

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements . maybe_newline main_function unli_newline GHOST
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    MAIN_CASPER     reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 44
    empty                          shift and go to state 16

state 22

    (86) function_statements -> empty .
    (2) maybe_newline -> empty .

    NEWLINE         reduce using rule 86 (function_statements -> empty .)
    MAIN_CASPER     reduce using rule 86 (function_statements -> empty .)
    FUNCTION        reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_INT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_FLT    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_CHR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_BLN    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_STR    reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_INT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_FLT reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_CHR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_STR reduce using rule 2 (maybe_newline -> empty .)
    FUNCTION_LIST_BLN reduce using rule 2 (maybe_newline -> empty .)


state 23

    (3) maybe_newline -> NEWLINE maybe_newline .

    NEWLINE         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    MAIN_CASPER     reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION        reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_INT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_FLT    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_CHR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_BLN    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_STR    reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_INT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_FLT reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_CHR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_STR reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_LIST_BLN reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    LBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FLT             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    BLN             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    STR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    RBRACE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    CHECK           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SWAP            reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FUNCTION_NAME   reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    DISPLAY         reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    IDENT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    FOR             reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    UNTIL           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REPEAT          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    INPUT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    REVIVE          reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    SHIFT           reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE       reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)
    OTHERWISE_CHECK reduce using rule 3 (maybe_newline -> NEWLINE maybe_newline .)


state 24

    (7) global_dec -> global_statement unli_newline global_tail .

    NEWLINE         reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    MAIN_CASPER     reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION        reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_INT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_FLT    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_CHR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_BLN    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_STR    reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_INT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_FLT reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_CHR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_STR reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)
    FUNCTION_LIST_BLN reduce using rule 7 (global_dec -> global_statement unli_newline global_tail .)


state 25

    (9) global_tail -> global_dec .

    NEWLINE         reduce using rule 9 (global_tail -> global_dec .)
    MAIN_CASPER     reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION        reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_INT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_FLT    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_CHR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_BLN    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_STR    reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_INT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_FLT reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_CHR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_STR reduce using rule 9 (global_tail -> global_dec .)
    FUNCTION_LIST_BLN reduce using rule 9 (global_tail -> global_dec .)


state 26

    (10) global_tail -> empty .
    (8) global_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for MAIN_CASPER resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_INT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_FLT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_CHR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_BLN resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_STR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_INT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_FLT resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_CHR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_STR resolved using rule 8 (global_dec -> empty .)
  ! reduce/reduce conflict for FUNCTION_LIST_BLN resolved using rule 8 (global_dec -> empty .)
    NEWLINE         reduce using rule 8 (global_dec -> empty .)
    MAIN_CASPER     reduce using rule 8 (global_dec -> empty .)
    FUNCTION        reduce using rule 8 (global_dec -> empty .)
    FUNCTION_INT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_FLT    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_CHR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_BLN    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_STR    reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_INT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_FLT reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_CHR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_STR reduce using rule 8 (global_dec -> empty .)
    FUNCTION_LIST_BLN reduce using rule 8 (global_dec -> empty .)

  ! NEWLINE         [ reduce using rule 10 (global_tail -> empty .) ]
  ! MAIN_CASPER     [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION        [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_INT    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_FLT    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_CHR    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_BLN    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_STR    [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_INT [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_FLT [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_CHR [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_STR [ reduce using rule 10 (global_tail -> empty .) ]
  ! FUNCTION_LIST_BLN [ reduce using rule 10 (global_tail -> empty .) ]


state 27

    (11) global_statement -> data_type IDENT global_statement_tail .

    NEWLINE         reduce using rule 11 (global_statement -> data_type IDENT global_statement_tail .)


state 28

    (12) global_statement_tail -> empty .

    NEWLINE         reduce using rule 12 (global_statement_tail -> empty .)


state 29

    (13) global_statement_tail -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 45


state 30

    (14) global_statement_tail -> EQ . global_dec_value global_tail2
    (17) global_dec_value -> . global_value
    (18) global_dec_value -> . LBRACKET list_element RBRACKET
    (19) global_value -> . factor
    (20) global_value -> . expression
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (58) expression -> . expr_head expr_tail
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail

    LBRACKET        shift and go to state 48
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    global_dec_value               shift and go to state 46
    global_value                   shift and go to state 47
    factor                         shift and go to state 49
    expression                     shift and go to state 50
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    term                           shift and go to state 63

state 31

    (85) function_statements -> maybe_newline ret_type . FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    FUNCTION_NAME   shift and go to state 64


state 32

    (87) ret_type -> FUNCTION .

    FUNCTION_NAME   reduce using rule 87 (ret_type -> FUNCTION .)


state 33

    (88) ret_type -> function_dtype .

    FUNCTION_NAME   reduce using rule 88 (ret_type -> function_dtype .)


state 34

    (89) function_dtype -> FUNCTION_INT .

    FUNCTION_NAME   reduce using rule 89 (function_dtype -> FUNCTION_INT .)


state 35

    (90) function_dtype -> FUNCTION_FLT .

    FUNCTION_NAME   reduce using rule 90 (function_dtype -> FUNCTION_FLT .)


state 36

    (91) function_dtype -> FUNCTION_CHR .

    FUNCTION_NAME   reduce using rule 91 (function_dtype -> FUNCTION_CHR .)


state 37

    (92) function_dtype -> FUNCTION_BLN .

    FUNCTION_NAME   reduce using rule 92 (function_dtype -> FUNCTION_BLN .)


state 38

    (93) function_dtype -> FUNCTION_STR .

    FUNCTION_NAME   reduce using rule 93 (function_dtype -> FUNCTION_STR .)


state 39

    (94) function_dtype -> FUNCTION_LIST_INT .

    FUNCTION_NAME   reduce using rule 94 (function_dtype -> FUNCTION_LIST_INT .)


state 40

    (95) function_dtype -> FUNCTION_LIST_FLT .

    FUNCTION_NAME   reduce using rule 95 (function_dtype -> FUNCTION_LIST_FLT .)


state 41

    (96) function_dtype -> FUNCTION_LIST_CHR .

    FUNCTION_NAME   reduce using rule 96 (function_dtype -> FUNCTION_LIST_CHR .)


state 42

    (97) function_dtype -> FUNCTION_LIST_STR .

    FUNCTION_NAME   reduce using rule 97 (function_dtype -> FUNCTION_LIST_STR .)


state 43

    (98) function_dtype -> FUNCTION_LIST_BLN .

    FUNCTION_NAME   reduce using rule 98 (function_dtype -> FUNCTION_LIST_BLN .)


state 44

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline . main_function unli_newline GHOST
    (6) main_function -> . MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    MAIN_CASPER     shift and go to state 66

    main_function                  shift and go to state 65

state 45

    (13) global_statement_tail -> COMMA IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (165) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 165 (empty -> .)

    global_statement_tail          shift and go to state 67
    empty                          shift and go to state 28

state 46

    (14) global_statement_tail -> EQ global_dec_value . global_tail2
    (15) global_tail2 -> . empty
    (16) global_tail2 -> . COMMA IDENT global_statement_tail
    (165) empty -> .

    COMMA           shift and go to state 70
    NEWLINE         reduce using rule 165 (empty -> .)

    global_tail2                   shift and go to state 68
    empty                          shift and go to state 69

state 47

    (17) global_dec_value -> global_value .

    COMMA           reduce using rule 17 (global_dec_value -> global_value .)
    NEWLINE         reduce using rule 17 (global_dec_value -> global_value .)


state 48

    (18) global_dec_value -> LBRACKET . list_element RBRACKET
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 71
    literal                        shift and go to state 72

state 49

    (19) global_value -> factor .
    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (165) empty -> .

  ! reduce/reduce conflict for COMMA resolved using rule 19 (global_value -> factor .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 19 (global_value -> factor .)
    COMMA           reduce using rule 19 (global_value -> factor .)
    NEWLINE         reduce using rule 19 (global_value -> factor .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 165 (empty -> .)
    LT              reduce using rule 165 (empty -> .)
    EQ_EQ           reduce using rule 165 (empty -> .)
    GT_EQ           reduce using rule 165 (empty -> .)
    LT_EQ           reduce using rule 165 (empty -> .)
    NOT_EQ          reduce using rule 165 (empty -> .)
    AND             reduce using rule 165 (empty -> .)
    OR              reduce using rule 165 (empty -> .)

  ! COMMA           [ reduce using rule 165 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 50

    (20) global_value -> expression .

    COMMA           reduce using rule 20 (global_value -> expression .)
    NEWLINE         reduce using rule 20 (global_value -> expression .)


state 51

    (61) factor -> var_call .

    PLUS            reduce using rule 61 (factor -> var_call .)
    MINUS           reduce using rule 61 (factor -> var_call .)
    MULTIPLY        reduce using rule 61 (factor -> var_call .)
    DIVISION        reduce using rule 61 (factor -> var_call .)
    MODULO          reduce using rule 61 (factor -> var_call .)
    EXPONENT        reduce using rule 61 (factor -> var_call .)
    COMMA           reduce using rule 61 (factor -> var_call .)
    NEWLINE         reduce using rule 61 (factor -> var_call .)
    GT              reduce using rule 61 (factor -> var_call .)
    LT              reduce using rule 61 (factor -> var_call .)
    EQ_EQ           reduce using rule 61 (factor -> var_call .)
    GT_EQ           reduce using rule 61 (factor -> var_call .)
    LT_EQ           reduce using rule 61 (factor -> var_call .)
    NOT_EQ          reduce using rule 61 (factor -> var_call .)
    AND             reduce using rule 61 (factor -> var_call .)
    OR              reduce using rule 61 (factor -> var_call .)
    RPAREN          reduce using rule 61 (factor -> var_call .)
    RBRACE          reduce using rule 61 (factor -> var_call .)
    CHECK           reduce using rule 61 (factor -> var_call .)
    SWAP            reduce using rule 61 (factor -> var_call .)
    FUNCTION_NAME   reduce using rule 61 (factor -> var_call .)
    DISPLAY         reduce using rule 61 (factor -> var_call .)
    IDENT           reduce using rule 61 (factor -> var_call .)
    FOR             reduce using rule 61 (factor -> var_call .)
    UNTIL           reduce using rule 61 (factor -> var_call .)
    REPEAT          reduce using rule 61 (factor -> var_call .)
    INPUT           reduce using rule 61 (factor -> var_call .)
    INT             reduce using rule 61 (factor -> var_call .)
    FLT             reduce using rule 61 (factor -> var_call .)
    BLN             reduce using rule 61 (factor -> var_call .)
    CHR             reduce using rule 61 (factor -> var_call .)
    STR             reduce using rule 61 (factor -> var_call .)
    REVIVE          reduce using rule 61 (factor -> var_call .)
    SHIFT           reduce using rule 61 (factor -> var_call .)
    OTHERWISE       reduce using rule 61 (factor -> var_call .)
    COLON           reduce using rule 61 (factor -> var_call .)
    SEMICOLON       reduce using rule 61 (factor -> var_call .)


state 52

    (62) factor -> literal .

    PLUS            reduce using rule 62 (factor -> literal .)
    MINUS           reduce using rule 62 (factor -> literal .)
    MULTIPLY        reduce using rule 62 (factor -> literal .)
    DIVISION        reduce using rule 62 (factor -> literal .)
    MODULO          reduce using rule 62 (factor -> literal .)
    EXPONENT        reduce using rule 62 (factor -> literal .)
    COMMA           reduce using rule 62 (factor -> literal .)
    NEWLINE         reduce using rule 62 (factor -> literal .)
    GT              reduce using rule 62 (factor -> literal .)
    LT              reduce using rule 62 (factor -> literal .)
    EQ_EQ           reduce using rule 62 (factor -> literal .)
    GT_EQ           reduce using rule 62 (factor -> literal .)
    LT_EQ           reduce using rule 62 (factor -> literal .)
    NOT_EQ          reduce using rule 62 (factor -> literal .)
    AND             reduce using rule 62 (factor -> literal .)
    OR              reduce using rule 62 (factor -> literal .)
    RPAREN          reduce using rule 62 (factor -> literal .)
    RBRACE          reduce using rule 62 (factor -> literal .)
    CHECK           reduce using rule 62 (factor -> literal .)
    SWAP            reduce using rule 62 (factor -> literal .)
    FUNCTION_NAME   reduce using rule 62 (factor -> literal .)
    DISPLAY         reduce using rule 62 (factor -> literal .)
    IDENT           reduce using rule 62 (factor -> literal .)
    FOR             reduce using rule 62 (factor -> literal .)
    UNTIL           reduce using rule 62 (factor -> literal .)
    REPEAT          reduce using rule 62 (factor -> literal .)
    INPUT           reduce using rule 62 (factor -> literal .)
    INT             reduce using rule 62 (factor -> literal .)
    FLT             reduce using rule 62 (factor -> literal .)
    BLN             reduce using rule 62 (factor -> literal .)
    CHR             reduce using rule 62 (factor -> literal .)
    STR             reduce using rule 62 (factor -> literal .)
    REVIVE          reduce using rule 62 (factor -> literal .)
    SHIFT           reduce using rule 62 (factor -> literal .)
    OTHERWISE       reduce using rule 62 (factor -> literal .)
    COLON           reduce using rule 62 (factor -> literal .)
    SEMICOLON       reduce using rule 62 (factor -> literal .)


state 53

    (63) factor -> TILDE . literal
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    literal                        shift and go to state 81

state 54

    (64) factor -> LPAREN . expression RPAREN
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 82
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 55

    (58) expression -> expr_head . expr_tail
    (79) expr_tail -> . empty
    (80) expr_tail -> . AND expression
    (81) expr_tail -> . OR expression
    (165) empty -> .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    AND             shift and go to state 86
    OR              shift and go to state 87
    GT              reduce using rule 165 (empty -> .)
    LT              reduce using rule 165 (empty -> .)
    EQ_EQ           reduce using rule 165 (empty -> .)
    GT_EQ           reduce using rule 165 (empty -> .)
    LT_EQ           reduce using rule 165 (empty -> .)
    NOT_EQ          reduce using rule 165 (empty -> .)
    COMMA           reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    RPAREN          reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    COLON           reduce using rule 165 (empty -> .)
    SEMICOLON       reduce using rule 165 (empty -> .)

  ! AND             [ reduce using rule 165 (empty -> .) ]
  ! OR              [ reduce using rule 165 (empty -> .) ]

    expr_tail                      shift and go to state 84
    empty                          shift and go to state 85

state 56

    (82) var_call -> IDENT . var_call_tail
    (83) var_call_tail -> . empty
    (84) var_call_tail -> . LBRACKET index RBRACKET
    (165) empty -> .

    LBRACKET        shift and go to state 90
    PLUS            reduce using rule 165 (empty -> .)
    MINUS           reduce using rule 165 (empty -> .)
    MULTIPLY        reduce using rule 165 (empty -> .)
    DIVISION        reduce using rule 165 (empty -> .)
    MODULO          reduce using rule 165 (empty -> .)
    EXPONENT        reduce using rule 165 (empty -> .)
    COMMA           reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    GT              reduce using rule 165 (empty -> .)
    LT              reduce using rule 165 (empty -> .)
    EQ_EQ           reduce using rule 165 (empty -> .)
    GT_EQ           reduce using rule 165 (empty -> .)
    LT_EQ           reduce using rule 165 (empty -> .)
    NOT_EQ          reduce using rule 165 (empty -> .)
    AND             reduce using rule 165 (empty -> .)
    OR              reduce using rule 165 (empty -> .)
    RPAREN          reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    COLON           reduce using rule 165 (empty -> .)
    SEMICOLON       reduce using rule 165 (empty -> .)
    PLUS_PLUS       reduce using rule 165 (empty -> .)
    MINUS_MINUS     reduce using rule 165 (empty -> .)
    PLUS_EQ         reduce using rule 165 (empty -> .)
    MINUS_EQ        reduce using rule 165 (empty -> .)
    MUL_EQ          reduce using rule 165 (empty -> .)
    DIV_EQ          reduce using rule 165 (empty -> .)
    MOD_EQ          reduce using rule 165 (empty -> .)
    EQ              reduce using rule 165 (empty -> .)

    var_call_tail                  shift and go to state 88
    empty                          shift and go to state 89

state 57

    (52) literal -> INT_LIT .

    PLUS            reduce using rule 52 (literal -> INT_LIT .)
    MINUS           reduce using rule 52 (literal -> INT_LIT .)
    MULTIPLY        reduce using rule 52 (literal -> INT_LIT .)
    DIVISION        reduce using rule 52 (literal -> INT_LIT .)
    MODULO          reduce using rule 52 (literal -> INT_LIT .)
    EXPONENT        reduce using rule 52 (literal -> INT_LIT .)
    COMMA           reduce using rule 52 (literal -> INT_LIT .)
    NEWLINE         reduce using rule 52 (literal -> INT_LIT .)
    GT              reduce using rule 52 (literal -> INT_LIT .)
    LT              reduce using rule 52 (literal -> INT_LIT .)
    EQ_EQ           reduce using rule 52 (literal -> INT_LIT .)
    GT_EQ           reduce using rule 52 (literal -> INT_LIT .)
    LT_EQ           reduce using rule 52 (literal -> INT_LIT .)
    NOT_EQ          reduce using rule 52 (literal -> INT_LIT .)
    AND             reduce using rule 52 (literal -> INT_LIT .)
    OR              reduce using rule 52 (literal -> INT_LIT .)
    RBRACKET        reduce using rule 52 (literal -> INT_LIT .)
    RPAREN          reduce using rule 52 (literal -> INT_LIT .)
    RBRACE          reduce using rule 52 (literal -> INT_LIT .)
    CHECK           reduce using rule 52 (literal -> INT_LIT .)
    SWAP            reduce using rule 52 (literal -> INT_LIT .)
    FUNCTION_NAME   reduce using rule 52 (literal -> INT_LIT .)
    DISPLAY         reduce using rule 52 (literal -> INT_LIT .)
    IDENT           reduce using rule 52 (literal -> INT_LIT .)
    FOR             reduce using rule 52 (literal -> INT_LIT .)
    UNTIL           reduce using rule 52 (literal -> INT_LIT .)
    REPEAT          reduce using rule 52 (literal -> INT_LIT .)
    INPUT           reduce using rule 52 (literal -> INT_LIT .)
    INT             reduce using rule 52 (literal -> INT_LIT .)
    FLT             reduce using rule 52 (literal -> INT_LIT .)
    BLN             reduce using rule 52 (literal -> INT_LIT .)
    CHR             reduce using rule 52 (literal -> INT_LIT .)
    STR             reduce using rule 52 (literal -> INT_LIT .)
    REVIVE          reduce using rule 52 (literal -> INT_LIT .)
    SHIFT           reduce using rule 52 (literal -> INT_LIT .)
    OTHERWISE       reduce using rule 52 (literal -> INT_LIT .)
    COLON           reduce using rule 52 (literal -> INT_LIT .)
    SEMICOLON       reduce using rule 52 (literal -> INT_LIT .)


state 58

    (53) literal -> FLT_LIT .

    PLUS            reduce using rule 53 (literal -> FLT_LIT .)
    MINUS           reduce using rule 53 (literal -> FLT_LIT .)
    MULTIPLY        reduce using rule 53 (literal -> FLT_LIT .)
    DIVISION        reduce using rule 53 (literal -> FLT_LIT .)
    MODULO          reduce using rule 53 (literal -> FLT_LIT .)
    EXPONENT        reduce using rule 53 (literal -> FLT_LIT .)
    COMMA           reduce using rule 53 (literal -> FLT_LIT .)
    NEWLINE         reduce using rule 53 (literal -> FLT_LIT .)
    GT              reduce using rule 53 (literal -> FLT_LIT .)
    LT              reduce using rule 53 (literal -> FLT_LIT .)
    EQ_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    GT_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    LT_EQ           reduce using rule 53 (literal -> FLT_LIT .)
    NOT_EQ          reduce using rule 53 (literal -> FLT_LIT .)
    AND             reduce using rule 53 (literal -> FLT_LIT .)
    OR              reduce using rule 53 (literal -> FLT_LIT .)
    RBRACKET        reduce using rule 53 (literal -> FLT_LIT .)
    RPAREN          reduce using rule 53 (literal -> FLT_LIT .)
    RBRACE          reduce using rule 53 (literal -> FLT_LIT .)
    CHECK           reduce using rule 53 (literal -> FLT_LIT .)
    SWAP            reduce using rule 53 (literal -> FLT_LIT .)
    FUNCTION_NAME   reduce using rule 53 (literal -> FLT_LIT .)
    DISPLAY         reduce using rule 53 (literal -> FLT_LIT .)
    IDENT           reduce using rule 53 (literal -> FLT_LIT .)
    FOR             reduce using rule 53 (literal -> FLT_LIT .)
    UNTIL           reduce using rule 53 (literal -> FLT_LIT .)
    REPEAT          reduce using rule 53 (literal -> FLT_LIT .)
    INPUT           reduce using rule 53 (literal -> FLT_LIT .)
    INT             reduce using rule 53 (literal -> FLT_LIT .)
    FLT             reduce using rule 53 (literal -> FLT_LIT .)
    BLN             reduce using rule 53 (literal -> FLT_LIT .)
    CHR             reduce using rule 53 (literal -> FLT_LIT .)
    STR             reduce using rule 53 (literal -> FLT_LIT .)
    REVIVE          reduce using rule 53 (literal -> FLT_LIT .)
    SHIFT           reduce using rule 53 (literal -> FLT_LIT .)
    OTHERWISE       reduce using rule 53 (literal -> FLT_LIT .)
    COLON           reduce using rule 53 (literal -> FLT_LIT .)
    SEMICOLON       reduce using rule 53 (literal -> FLT_LIT .)


state 59

    (54) literal -> DAY .

    PLUS            reduce using rule 54 (literal -> DAY .)
    MINUS           reduce using rule 54 (literal -> DAY .)
    MULTIPLY        reduce using rule 54 (literal -> DAY .)
    DIVISION        reduce using rule 54 (literal -> DAY .)
    MODULO          reduce using rule 54 (literal -> DAY .)
    EXPONENT        reduce using rule 54 (literal -> DAY .)
    COMMA           reduce using rule 54 (literal -> DAY .)
    NEWLINE         reduce using rule 54 (literal -> DAY .)
    GT              reduce using rule 54 (literal -> DAY .)
    LT              reduce using rule 54 (literal -> DAY .)
    EQ_EQ           reduce using rule 54 (literal -> DAY .)
    GT_EQ           reduce using rule 54 (literal -> DAY .)
    LT_EQ           reduce using rule 54 (literal -> DAY .)
    NOT_EQ          reduce using rule 54 (literal -> DAY .)
    AND             reduce using rule 54 (literal -> DAY .)
    OR              reduce using rule 54 (literal -> DAY .)
    RBRACKET        reduce using rule 54 (literal -> DAY .)
    RPAREN          reduce using rule 54 (literal -> DAY .)
    RBRACE          reduce using rule 54 (literal -> DAY .)
    CHECK           reduce using rule 54 (literal -> DAY .)
    SWAP            reduce using rule 54 (literal -> DAY .)
    FUNCTION_NAME   reduce using rule 54 (literal -> DAY .)
    DISPLAY         reduce using rule 54 (literal -> DAY .)
    IDENT           reduce using rule 54 (literal -> DAY .)
    FOR             reduce using rule 54 (literal -> DAY .)
    UNTIL           reduce using rule 54 (literal -> DAY .)
    REPEAT          reduce using rule 54 (literal -> DAY .)
    INPUT           reduce using rule 54 (literal -> DAY .)
    INT             reduce using rule 54 (literal -> DAY .)
    FLT             reduce using rule 54 (literal -> DAY .)
    BLN             reduce using rule 54 (literal -> DAY .)
    CHR             reduce using rule 54 (literal -> DAY .)
    STR             reduce using rule 54 (literal -> DAY .)
    REVIVE          reduce using rule 54 (literal -> DAY .)
    SHIFT           reduce using rule 54 (literal -> DAY .)
    OTHERWISE       reduce using rule 54 (literal -> DAY .)
    COLON           reduce using rule 54 (literal -> DAY .)
    SEMICOLON       reduce using rule 54 (literal -> DAY .)


state 60

    (55) literal -> NIGHT .

    PLUS            reduce using rule 55 (literal -> NIGHT .)
    MINUS           reduce using rule 55 (literal -> NIGHT .)
    MULTIPLY        reduce using rule 55 (literal -> NIGHT .)
    DIVISION        reduce using rule 55 (literal -> NIGHT .)
    MODULO          reduce using rule 55 (literal -> NIGHT .)
    EXPONENT        reduce using rule 55 (literal -> NIGHT .)
    COMMA           reduce using rule 55 (literal -> NIGHT .)
    NEWLINE         reduce using rule 55 (literal -> NIGHT .)
    GT              reduce using rule 55 (literal -> NIGHT .)
    LT              reduce using rule 55 (literal -> NIGHT .)
    EQ_EQ           reduce using rule 55 (literal -> NIGHT .)
    GT_EQ           reduce using rule 55 (literal -> NIGHT .)
    LT_EQ           reduce using rule 55 (literal -> NIGHT .)
    NOT_EQ          reduce using rule 55 (literal -> NIGHT .)
    AND             reduce using rule 55 (literal -> NIGHT .)
    OR              reduce using rule 55 (literal -> NIGHT .)
    RBRACKET        reduce using rule 55 (literal -> NIGHT .)
    RPAREN          reduce using rule 55 (literal -> NIGHT .)
    RBRACE          reduce using rule 55 (literal -> NIGHT .)
    CHECK           reduce using rule 55 (literal -> NIGHT .)
    SWAP            reduce using rule 55 (literal -> NIGHT .)
    FUNCTION_NAME   reduce using rule 55 (literal -> NIGHT .)
    DISPLAY         reduce using rule 55 (literal -> NIGHT .)
    IDENT           reduce using rule 55 (literal -> NIGHT .)
    FOR             reduce using rule 55 (literal -> NIGHT .)
    UNTIL           reduce using rule 55 (literal -> NIGHT .)
    REPEAT          reduce using rule 55 (literal -> NIGHT .)
    INPUT           reduce using rule 55 (literal -> NIGHT .)
    INT             reduce using rule 55 (literal -> NIGHT .)
    FLT             reduce using rule 55 (literal -> NIGHT .)
    BLN             reduce using rule 55 (literal -> NIGHT .)
    CHR             reduce using rule 55 (literal -> NIGHT .)
    STR             reduce using rule 55 (literal -> NIGHT .)
    REVIVE          reduce using rule 55 (literal -> NIGHT .)
    SHIFT           reduce using rule 55 (literal -> NIGHT .)
    OTHERWISE       reduce using rule 55 (literal -> NIGHT .)
    COLON           reduce using rule 55 (literal -> NIGHT .)
    SEMICOLON       reduce using rule 55 (literal -> NIGHT .)


state 61

    (56) literal -> CHR_LIT .

    PLUS            reduce using rule 56 (literal -> CHR_LIT .)
    MINUS           reduce using rule 56 (literal -> CHR_LIT .)
    MULTIPLY        reduce using rule 56 (literal -> CHR_LIT .)
    DIVISION        reduce using rule 56 (literal -> CHR_LIT .)
    MODULO          reduce using rule 56 (literal -> CHR_LIT .)
    EXPONENT        reduce using rule 56 (literal -> CHR_LIT .)
    COMMA           reduce using rule 56 (literal -> CHR_LIT .)
    NEWLINE         reduce using rule 56 (literal -> CHR_LIT .)
    GT              reduce using rule 56 (literal -> CHR_LIT .)
    LT              reduce using rule 56 (literal -> CHR_LIT .)
    EQ_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    GT_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    LT_EQ           reduce using rule 56 (literal -> CHR_LIT .)
    NOT_EQ          reduce using rule 56 (literal -> CHR_LIT .)
    AND             reduce using rule 56 (literal -> CHR_LIT .)
    OR              reduce using rule 56 (literal -> CHR_LIT .)
    RBRACKET        reduce using rule 56 (literal -> CHR_LIT .)
    RPAREN          reduce using rule 56 (literal -> CHR_LIT .)
    RBRACE          reduce using rule 56 (literal -> CHR_LIT .)
    CHECK           reduce using rule 56 (literal -> CHR_LIT .)
    SWAP            reduce using rule 56 (literal -> CHR_LIT .)
    FUNCTION_NAME   reduce using rule 56 (literal -> CHR_LIT .)
    DISPLAY         reduce using rule 56 (literal -> CHR_LIT .)
    IDENT           reduce using rule 56 (literal -> CHR_LIT .)
    FOR             reduce using rule 56 (literal -> CHR_LIT .)
    UNTIL           reduce using rule 56 (literal -> CHR_LIT .)
    REPEAT          reduce using rule 56 (literal -> CHR_LIT .)
    INPUT           reduce using rule 56 (literal -> CHR_LIT .)
    INT             reduce using rule 56 (literal -> CHR_LIT .)
    FLT             reduce using rule 56 (literal -> CHR_LIT .)
    BLN             reduce using rule 56 (literal -> CHR_LIT .)
    CHR             reduce using rule 56 (literal -> CHR_LIT .)
    STR             reduce using rule 56 (literal -> CHR_LIT .)
    REVIVE          reduce using rule 56 (literal -> CHR_LIT .)
    SHIFT           reduce using rule 56 (literal -> CHR_LIT .)
    OTHERWISE       reduce using rule 56 (literal -> CHR_LIT .)
    COLON           reduce using rule 56 (literal -> CHR_LIT .)
    SEMICOLON       reduce using rule 56 (literal -> CHR_LIT .)


state 62

    (57) literal -> STR_LIT .

    PLUS            reduce using rule 57 (literal -> STR_LIT .)
    MINUS           reduce using rule 57 (literal -> STR_LIT .)
    MULTIPLY        reduce using rule 57 (literal -> STR_LIT .)
    DIVISION        reduce using rule 57 (literal -> STR_LIT .)
    MODULO          reduce using rule 57 (literal -> STR_LIT .)
    EXPONENT        reduce using rule 57 (literal -> STR_LIT .)
    COMMA           reduce using rule 57 (literal -> STR_LIT .)
    NEWLINE         reduce using rule 57 (literal -> STR_LIT .)
    GT              reduce using rule 57 (literal -> STR_LIT .)
    LT              reduce using rule 57 (literal -> STR_LIT .)
    EQ_EQ           reduce using rule 57 (literal -> STR_LIT .)
    GT_EQ           reduce using rule 57 (literal -> STR_LIT .)
    LT_EQ           reduce using rule 57 (literal -> STR_LIT .)
    NOT_EQ          reduce using rule 57 (literal -> STR_LIT .)
    AND             reduce using rule 57 (literal -> STR_LIT .)
    OR              reduce using rule 57 (literal -> STR_LIT .)
    RBRACKET        reduce using rule 57 (literal -> STR_LIT .)
    RPAREN          reduce using rule 57 (literal -> STR_LIT .)
    RBRACE          reduce using rule 57 (literal -> STR_LIT .)
    CHECK           reduce using rule 57 (literal -> STR_LIT .)
    SWAP            reduce using rule 57 (literal -> STR_LIT .)
    FUNCTION_NAME   reduce using rule 57 (literal -> STR_LIT .)
    DISPLAY         reduce using rule 57 (literal -> STR_LIT .)
    IDENT           reduce using rule 57 (literal -> STR_LIT .)
    FOR             reduce using rule 57 (literal -> STR_LIT .)
    UNTIL           reduce using rule 57 (literal -> STR_LIT .)
    REPEAT          reduce using rule 57 (literal -> STR_LIT .)
    INPUT           reduce using rule 57 (literal -> STR_LIT .)
    INT             reduce using rule 57 (literal -> STR_LIT .)
    FLT             reduce using rule 57 (literal -> STR_LIT .)
    BLN             reduce using rule 57 (literal -> STR_LIT .)
    CHR             reduce using rule 57 (literal -> STR_LIT .)
    STR             reduce using rule 57 (literal -> STR_LIT .)
    REVIVE          reduce using rule 57 (literal -> STR_LIT .)
    SHIFT           reduce using rule 57 (literal -> STR_LIT .)
    OTHERWISE       reduce using rule 57 (literal -> STR_LIT .)
    COLON           reduce using rule 57 (literal -> STR_LIT .)
    SEMICOLON       reduce using rule 57 (literal -> STR_LIT .)


state 63

    (59) expr_head -> term . term_tail
    (72) term_tail -> . empty
    (73) term_tail -> . GT expression
    (74) term_tail -> . LT expression
    (75) term_tail -> . EQ_EQ expression
    (76) term_tail -> . GT_EQ expression
    (77) term_tail -> . LT_EQ expression
    (78) term_tail -> . NOT_EQ expression
    (165) empty -> .

  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ_EQ resolved as shift
  ! shift/reduce conflict for GT_EQ resolved as shift
  ! shift/reduce conflict for LT_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
    GT              shift and go to state 93
    LT              shift and go to state 94
    EQ_EQ           shift and go to state 95
    GT_EQ           shift and go to state 96
    LT_EQ           shift and go to state 97
    NOT_EQ          shift and go to state 98
    AND             reduce using rule 165 (empty -> .)
    OR              reduce using rule 165 (empty -> .)
    COMMA           reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    RPAREN          reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    COLON           reduce using rule 165 (empty -> .)
    SEMICOLON       reduce using rule 165 (empty -> .)

  ! GT              [ reduce using rule 165 (empty -> .) ]
  ! LT              [ reduce using rule 165 (empty -> .) ]
  ! EQ_EQ           [ reduce using rule 165 (empty -> .) ]
  ! GT_EQ           [ reduce using rule 165 (empty -> .) ]
  ! LT_EQ           [ reduce using rule 165 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 165 (empty -> .) ]

    term_tail                      shift and go to state 91
    empty                          shift and go to state 92

state 64

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME . LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    LPAREN          shift and go to state 99


state 65

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function . unli_newline GHOST
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 100

state 66

    (6) main_function -> MAIN_CASPER . LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    LPAREN          shift and go to state 101


state 67

    (13) global_statement_tail -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 13 (global_statement_tail -> COMMA IDENT global_statement_tail .)


state 68

    (14) global_statement_tail -> EQ global_dec_value global_tail2 .

    NEWLINE         reduce using rule 14 (global_statement_tail -> EQ global_dec_value global_tail2 .)


state 69

    (15) global_tail2 -> empty .

    NEWLINE         reduce using rule 15 (global_tail2 -> empty .)


state 70

    (16) global_tail2 -> COMMA . IDENT global_statement_tail

    IDENT           shift and go to state 102


state 71

    (18) global_dec_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 103


state 72

    (29) list_element -> literal . element_tail
    (30) element_tail -> . empty
    (31) element_tail -> . COMMA list_element
    (165) empty -> .

    COMMA           shift and go to state 106
    RBRACKET        reduce using rule 165 (empty -> .)

    element_tail                   shift and go to state 104
    empty                          shift and go to state 105

state 73

    (60) term -> factor factor_tail .

    GT              reduce using rule 60 (term -> factor factor_tail .)
    LT              reduce using rule 60 (term -> factor factor_tail .)
    EQ_EQ           reduce using rule 60 (term -> factor factor_tail .)
    GT_EQ           reduce using rule 60 (term -> factor factor_tail .)
    LT_EQ           reduce using rule 60 (term -> factor factor_tail .)
    NOT_EQ          reduce using rule 60 (term -> factor factor_tail .)
    AND             reduce using rule 60 (term -> factor factor_tail .)
    OR              reduce using rule 60 (term -> factor factor_tail .)
    COMMA           reduce using rule 60 (term -> factor factor_tail .)
    NEWLINE         reduce using rule 60 (term -> factor factor_tail .)
    RPAREN          reduce using rule 60 (term -> factor factor_tail .)
    RBRACE          reduce using rule 60 (term -> factor factor_tail .)
    CHECK           reduce using rule 60 (term -> factor factor_tail .)
    SWAP            reduce using rule 60 (term -> factor factor_tail .)
    FUNCTION_NAME   reduce using rule 60 (term -> factor factor_tail .)
    DISPLAY         reduce using rule 60 (term -> factor factor_tail .)
    IDENT           reduce using rule 60 (term -> factor factor_tail .)
    FOR             reduce using rule 60 (term -> factor factor_tail .)
    UNTIL           reduce using rule 60 (term -> factor factor_tail .)
    REPEAT          reduce using rule 60 (term -> factor factor_tail .)
    INPUT           reduce using rule 60 (term -> factor factor_tail .)
    INT             reduce using rule 60 (term -> factor factor_tail .)
    FLT             reduce using rule 60 (term -> factor factor_tail .)
    BLN             reduce using rule 60 (term -> factor factor_tail .)
    CHR             reduce using rule 60 (term -> factor factor_tail .)
    STR             reduce using rule 60 (term -> factor factor_tail .)
    REVIVE          reduce using rule 60 (term -> factor factor_tail .)
    SHIFT           reduce using rule 60 (term -> factor factor_tail .)
    OTHERWISE       reduce using rule 60 (term -> factor factor_tail .)
    COLON           reduce using rule 60 (term -> factor factor_tail .)
    SEMICOLON       reduce using rule 60 (term -> factor factor_tail .)


state 74

    (65) factor_tail -> empty .

    GT              reduce using rule 65 (factor_tail -> empty .)
    LT              reduce using rule 65 (factor_tail -> empty .)
    EQ_EQ           reduce using rule 65 (factor_tail -> empty .)
    GT_EQ           reduce using rule 65 (factor_tail -> empty .)
    LT_EQ           reduce using rule 65 (factor_tail -> empty .)
    NOT_EQ          reduce using rule 65 (factor_tail -> empty .)
    AND             reduce using rule 65 (factor_tail -> empty .)
    OR              reduce using rule 65 (factor_tail -> empty .)
    COMMA           reduce using rule 65 (factor_tail -> empty .)
    NEWLINE         reduce using rule 65 (factor_tail -> empty .)
    RPAREN          reduce using rule 65 (factor_tail -> empty .)
    RBRACE          reduce using rule 65 (factor_tail -> empty .)
    CHECK           reduce using rule 65 (factor_tail -> empty .)
    SWAP            reduce using rule 65 (factor_tail -> empty .)
    FUNCTION_NAME   reduce using rule 65 (factor_tail -> empty .)
    DISPLAY         reduce using rule 65 (factor_tail -> empty .)
    IDENT           reduce using rule 65 (factor_tail -> empty .)
    FOR             reduce using rule 65 (factor_tail -> empty .)
    UNTIL           reduce using rule 65 (factor_tail -> empty .)
    REPEAT          reduce using rule 65 (factor_tail -> empty .)
    INPUT           reduce using rule 65 (factor_tail -> empty .)
    INT             reduce using rule 65 (factor_tail -> empty .)
    FLT             reduce using rule 65 (factor_tail -> empty .)
    BLN             reduce using rule 65 (factor_tail -> empty .)
    CHR             reduce using rule 65 (factor_tail -> empty .)
    STR             reduce using rule 65 (factor_tail -> empty .)
    REVIVE          reduce using rule 65 (factor_tail -> empty .)
    SHIFT           reduce using rule 65 (factor_tail -> empty .)
    OTHERWISE       reduce using rule 65 (factor_tail -> empty .)
    COLON           reduce using rule 65 (factor_tail -> empty .)
    SEMICOLON       reduce using rule 65 (factor_tail -> empty .)


state 75

    (66) factor_tail -> PLUS . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 107
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 76

    (67) factor_tail -> MINUS . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 108
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 77

    (68) factor_tail -> MULTIPLY . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 109
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 78

    (69) factor_tail -> DIVISION . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 110
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 79

    (70) factor_tail -> MODULO . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 111
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 80

    (71) factor_tail -> EXPONENT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 112
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 81

    (63) factor -> TILDE literal .

    PLUS            reduce using rule 63 (factor -> TILDE literal .)
    MINUS           reduce using rule 63 (factor -> TILDE literal .)
    MULTIPLY        reduce using rule 63 (factor -> TILDE literal .)
    DIVISION        reduce using rule 63 (factor -> TILDE literal .)
    MODULO          reduce using rule 63 (factor -> TILDE literal .)
    EXPONENT        reduce using rule 63 (factor -> TILDE literal .)
    COMMA           reduce using rule 63 (factor -> TILDE literal .)
    NEWLINE         reduce using rule 63 (factor -> TILDE literal .)
    GT              reduce using rule 63 (factor -> TILDE literal .)
    LT              reduce using rule 63 (factor -> TILDE literal .)
    EQ_EQ           reduce using rule 63 (factor -> TILDE literal .)
    GT_EQ           reduce using rule 63 (factor -> TILDE literal .)
    LT_EQ           reduce using rule 63 (factor -> TILDE literal .)
    NOT_EQ          reduce using rule 63 (factor -> TILDE literal .)
    AND             reduce using rule 63 (factor -> TILDE literal .)
    OR              reduce using rule 63 (factor -> TILDE literal .)
    RPAREN          reduce using rule 63 (factor -> TILDE literal .)
    RBRACE          reduce using rule 63 (factor -> TILDE literal .)
    CHECK           reduce using rule 63 (factor -> TILDE literal .)
    SWAP            reduce using rule 63 (factor -> TILDE literal .)
    FUNCTION_NAME   reduce using rule 63 (factor -> TILDE literal .)
    DISPLAY         reduce using rule 63 (factor -> TILDE literal .)
    IDENT           reduce using rule 63 (factor -> TILDE literal .)
    FOR             reduce using rule 63 (factor -> TILDE literal .)
    UNTIL           reduce using rule 63 (factor -> TILDE literal .)
    REPEAT          reduce using rule 63 (factor -> TILDE literal .)
    INPUT           reduce using rule 63 (factor -> TILDE literal .)
    INT             reduce using rule 63 (factor -> TILDE literal .)
    FLT             reduce using rule 63 (factor -> TILDE literal .)
    BLN             reduce using rule 63 (factor -> TILDE literal .)
    CHR             reduce using rule 63 (factor -> TILDE literal .)
    STR             reduce using rule 63 (factor -> TILDE literal .)
    REVIVE          reduce using rule 63 (factor -> TILDE literal .)
    SHIFT           reduce using rule 63 (factor -> TILDE literal .)
    OTHERWISE       reduce using rule 63 (factor -> TILDE literal .)
    COLON           reduce using rule 63 (factor -> TILDE literal .)
    SEMICOLON       reduce using rule 63 (factor -> TILDE literal .)


state 82

    (64) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 113


state 83

    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (165) empty -> .

    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 165 (empty -> .)
    LT              reduce using rule 165 (empty -> .)
    EQ_EQ           reduce using rule 165 (empty -> .)
    GT_EQ           reduce using rule 165 (empty -> .)
    LT_EQ           reduce using rule 165 (empty -> .)
    NOT_EQ          reduce using rule 165 (empty -> .)
    AND             reduce using rule 165 (empty -> .)
    OR              reduce using rule 165 (empty -> .)
    COMMA           reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    RPAREN          reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    COLON           reduce using rule 165 (empty -> .)
    SEMICOLON       reduce using rule 165 (empty -> .)

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 84

    (58) expression -> expr_head expr_tail .

    COMMA           reduce using rule 58 (expression -> expr_head expr_tail .)
    NEWLINE         reduce using rule 58 (expression -> expr_head expr_tail .)
    RPAREN          reduce using rule 58 (expression -> expr_head expr_tail .)
    GT              reduce using rule 58 (expression -> expr_head expr_tail .)
    LT              reduce using rule 58 (expression -> expr_head expr_tail .)
    EQ_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    GT_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    LT_EQ           reduce using rule 58 (expression -> expr_head expr_tail .)
    NOT_EQ          reduce using rule 58 (expression -> expr_head expr_tail .)
    AND             reduce using rule 58 (expression -> expr_head expr_tail .)
    OR              reduce using rule 58 (expression -> expr_head expr_tail .)
    RBRACE          reduce using rule 58 (expression -> expr_head expr_tail .)
    CHECK           reduce using rule 58 (expression -> expr_head expr_tail .)
    SWAP            reduce using rule 58 (expression -> expr_head expr_tail .)
    FUNCTION_NAME   reduce using rule 58 (expression -> expr_head expr_tail .)
    DISPLAY         reduce using rule 58 (expression -> expr_head expr_tail .)
    IDENT           reduce using rule 58 (expression -> expr_head expr_tail .)
    FOR             reduce using rule 58 (expression -> expr_head expr_tail .)
    UNTIL           reduce using rule 58 (expression -> expr_head expr_tail .)
    REPEAT          reduce using rule 58 (expression -> expr_head expr_tail .)
    INPUT           reduce using rule 58 (expression -> expr_head expr_tail .)
    INT             reduce using rule 58 (expression -> expr_head expr_tail .)
    FLT             reduce using rule 58 (expression -> expr_head expr_tail .)
    BLN             reduce using rule 58 (expression -> expr_head expr_tail .)
    CHR             reduce using rule 58 (expression -> expr_head expr_tail .)
    STR             reduce using rule 58 (expression -> expr_head expr_tail .)
    REVIVE          reduce using rule 58 (expression -> expr_head expr_tail .)
    SHIFT           reduce using rule 58 (expression -> expr_head expr_tail .)
    OTHERWISE       reduce using rule 58 (expression -> expr_head expr_tail .)
    COLON           reduce using rule 58 (expression -> expr_head expr_tail .)
    SEMICOLON       reduce using rule 58 (expression -> expr_head expr_tail .)


state 85

    (79) expr_tail -> empty .

    GT              reduce using rule 79 (expr_tail -> empty .)
    LT              reduce using rule 79 (expr_tail -> empty .)
    EQ_EQ           reduce using rule 79 (expr_tail -> empty .)
    GT_EQ           reduce using rule 79 (expr_tail -> empty .)
    LT_EQ           reduce using rule 79 (expr_tail -> empty .)
    NOT_EQ          reduce using rule 79 (expr_tail -> empty .)
    AND             reduce using rule 79 (expr_tail -> empty .)
    OR              reduce using rule 79 (expr_tail -> empty .)
    COMMA           reduce using rule 79 (expr_tail -> empty .)
    NEWLINE         reduce using rule 79 (expr_tail -> empty .)
    RPAREN          reduce using rule 79 (expr_tail -> empty .)
    RBRACE          reduce using rule 79 (expr_tail -> empty .)
    CHECK           reduce using rule 79 (expr_tail -> empty .)
    SWAP            reduce using rule 79 (expr_tail -> empty .)
    FUNCTION_NAME   reduce using rule 79 (expr_tail -> empty .)
    DISPLAY         reduce using rule 79 (expr_tail -> empty .)
    IDENT           reduce using rule 79 (expr_tail -> empty .)
    FOR             reduce using rule 79 (expr_tail -> empty .)
    UNTIL           reduce using rule 79 (expr_tail -> empty .)
    REPEAT          reduce using rule 79 (expr_tail -> empty .)
    INPUT           reduce using rule 79 (expr_tail -> empty .)
    INT             reduce using rule 79 (expr_tail -> empty .)
    FLT             reduce using rule 79 (expr_tail -> empty .)
    BLN             reduce using rule 79 (expr_tail -> empty .)
    CHR             reduce using rule 79 (expr_tail -> empty .)
    STR             reduce using rule 79 (expr_tail -> empty .)
    REVIVE          reduce using rule 79 (expr_tail -> empty .)
    SHIFT           reduce using rule 79 (expr_tail -> empty .)
    OTHERWISE       reduce using rule 79 (expr_tail -> empty .)
    COLON           reduce using rule 79 (expr_tail -> empty .)
    SEMICOLON       reduce using rule 79 (expr_tail -> empty .)


state 86

    (80) expr_tail -> AND . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 114
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 87

    (81) expr_tail -> OR . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 115
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 88

    (82) var_call -> IDENT var_call_tail .

    PLUS            reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MULTIPLY        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    DIVISION        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MODULO          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EXPONENT        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    COMMA           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    NEWLINE         reduce using rule 82 (var_call -> IDENT var_call_tail .)
    GT              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    LT              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EQ_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    GT_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    LT_EQ           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    NOT_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    AND             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    OR              reduce using rule 82 (var_call -> IDENT var_call_tail .)
    RPAREN          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    RBRACE          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    CHECK           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    SWAP            reduce using rule 82 (var_call -> IDENT var_call_tail .)
    FUNCTION_NAME   reduce using rule 82 (var_call -> IDENT var_call_tail .)
    DISPLAY         reduce using rule 82 (var_call -> IDENT var_call_tail .)
    IDENT           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    FOR             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    UNTIL           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    REPEAT          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    INPUT           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    INT             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    FLT             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    BLN             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    CHR             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    STR             reduce using rule 82 (var_call -> IDENT var_call_tail .)
    REVIVE          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    SHIFT           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    OTHERWISE       reduce using rule 82 (var_call -> IDENT var_call_tail .)
    COLON           reduce using rule 82 (var_call -> IDENT var_call_tail .)
    SEMICOLON       reduce using rule 82 (var_call -> IDENT var_call_tail .)
    PLUS_PLUS       reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS_MINUS     reduce using rule 82 (var_call -> IDENT var_call_tail .)
    PLUS_EQ         reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MINUS_EQ        reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MUL_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    DIV_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    MOD_EQ          reduce using rule 82 (var_call -> IDENT var_call_tail .)
    EQ              reduce using rule 82 (var_call -> IDENT var_call_tail .)


state 89

    (83) var_call_tail -> empty .

    PLUS            reduce using rule 83 (var_call_tail -> empty .)
    MINUS           reduce using rule 83 (var_call_tail -> empty .)
    MULTIPLY        reduce using rule 83 (var_call_tail -> empty .)
    DIVISION        reduce using rule 83 (var_call_tail -> empty .)
    MODULO          reduce using rule 83 (var_call_tail -> empty .)
    EXPONENT        reduce using rule 83 (var_call_tail -> empty .)
    COMMA           reduce using rule 83 (var_call_tail -> empty .)
    NEWLINE         reduce using rule 83 (var_call_tail -> empty .)
    GT              reduce using rule 83 (var_call_tail -> empty .)
    LT              reduce using rule 83 (var_call_tail -> empty .)
    EQ_EQ           reduce using rule 83 (var_call_tail -> empty .)
    GT_EQ           reduce using rule 83 (var_call_tail -> empty .)
    LT_EQ           reduce using rule 83 (var_call_tail -> empty .)
    NOT_EQ          reduce using rule 83 (var_call_tail -> empty .)
    AND             reduce using rule 83 (var_call_tail -> empty .)
    OR              reduce using rule 83 (var_call_tail -> empty .)
    RPAREN          reduce using rule 83 (var_call_tail -> empty .)
    RBRACE          reduce using rule 83 (var_call_tail -> empty .)
    CHECK           reduce using rule 83 (var_call_tail -> empty .)
    SWAP            reduce using rule 83 (var_call_tail -> empty .)
    FUNCTION_NAME   reduce using rule 83 (var_call_tail -> empty .)
    DISPLAY         reduce using rule 83 (var_call_tail -> empty .)
    IDENT           reduce using rule 83 (var_call_tail -> empty .)
    FOR             reduce using rule 83 (var_call_tail -> empty .)
    UNTIL           reduce using rule 83 (var_call_tail -> empty .)
    REPEAT          reduce using rule 83 (var_call_tail -> empty .)
    INPUT           reduce using rule 83 (var_call_tail -> empty .)
    INT             reduce using rule 83 (var_call_tail -> empty .)
    FLT             reduce using rule 83 (var_call_tail -> empty .)
    BLN             reduce using rule 83 (var_call_tail -> empty .)
    CHR             reduce using rule 83 (var_call_tail -> empty .)
    STR             reduce using rule 83 (var_call_tail -> empty .)
    REVIVE          reduce using rule 83 (var_call_tail -> empty .)
    SHIFT           reduce using rule 83 (var_call_tail -> empty .)
    OTHERWISE       reduce using rule 83 (var_call_tail -> empty .)
    COLON           reduce using rule 83 (var_call_tail -> empty .)
    SEMICOLON       reduce using rule 83 (var_call_tail -> empty .)
    PLUS_PLUS       reduce using rule 83 (var_call_tail -> empty .)
    MINUS_MINUS     reduce using rule 83 (var_call_tail -> empty .)
    PLUS_EQ         reduce using rule 83 (var_call_tail -> empty .)
    MINUS_EQ        reduce using rule 83 (var_call_tail -> empty .)
    MUL_EQ          reduce using rule 83 (var_call_tail -> empty .)
    DIV_EQ          reduce using rule 83 (var_call_tail -> empty .)
    MOD_EQ          reduce using rule 83 (var_call_tail -> empty .)
    EQ              reduce using rule 83 (var_call_tail -> empty .)


state 90

    (84) var_call_tail -> LBRACKET . index RBRACKET
    (32) index -> . INT_LIT
    (33) index -> . IDENT

    INT_LIT         shift and go to state 117
    IDENT           shift and go to state 118

    index                          shift and go to state 116

state 91

    (59) expr_head -> term term_tail .

    AND             reduce using rule 59 (expr_head -> term term_tail .)
    OR              reduce using rule 59 (expr_head -> term term_tail .)
    COMMA           reduce using rule 59 (expr_head -> term term_tail .)
    NEWLINE         reduce using rule 59 (expr_head -> term term_tail .)
    RPAREN          reduce using rule 59 (expr_head -> term term_tail .)
    GT              reduce using rule 59 (expr_head -> term term_tail .)
    LT              reduce using rule 59 (expr_head -> term term_tail .)
    EQ_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    GT_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    LT_EQ           reduce using rule 59 (expr_head -> term term_tail .)
    NOT_EQ          reduce using rule 59 (expr_head -> term term_tail .)
    RBRACE          reduce using rule 59 (expr_head -> term term_tail .)
    CHECK           reduce using rule 59 (expr_head -> term term_tail .)
    SWAP            reduce using rule 59 (expr_head -> term term_tail .)
    FUNCTION_NAME   reduce using rule 59 (expr_head -> term term_tail .)
    DISPLAY         reduce using rule 59 (expr_head -> term term_tail .)
    IDENT           reduce using rule 59 (expr_head -> term term_tail .)
    FOR             reduce using rule 59 (expr_head -> term term_tail .)
    UNTIL           reduce using rule 59 (expr_head -> term term_tail .)
    REPEAT          reduce using rule 59 (expr_head -> term term_tail .)
    INPUT           reduce using rule 59 (expr_head -> term term_tail .)
    INT             reduce using rule 59 (expr_head -> term term_tail .)
    FLT             reduce using rule 59 (expr_head -> term term_tail .)
    BLN             reduce using rule 59 (expr_head -> term term_tail .)
    CHR             reduce using rule 59 (expr_head -> term term_tail .)
    STR             reduce using rule 59 (expr_head -> term term_tail .)
    REVIVE          reduce using rule 59 (expr_head -> term term_tail .)
    SHIFT           reduce using rule 59 (expr_head -> term term_tail .)
    OTHERWISE       reduce using rule 59 (expr_head -> term term_tail .)
    COLON           reduce using rule 59 (expr_head -> term term_tail .)
    SEMICOLON       reduce using rule 59 (expr_head -> term term_tail .)


state 92

    (72) term_tail -> empty .

    GT              reduce using rule 72 (term_tail -> empty .)
    LT              reduce using rule 72 (term_tail -> empty .)
    EQ_EQ           reduce using rule 72 (term_tail -> empty .)
    GT_EQ           reduce using rule 72 (term_tail -> empty .)
    LT_EQ           reduce using rule 72 (term_tail -> empty .)
    NOT_EQ          reduce using rule 72 (term_tail -> empty .)
    AND             reduce using rule 72 (term_tail -> empty .)
    OR              reduce using rule 72 (term_tail -> empty .)
    COMMA           reduce using rule 72 (term_tail -> empty .)
    NEWLINE         reduce using rule 72 (term_tail -> empty .)
    RPAREN          reduce using rule 72 (term_tail -> empty .)
    RBRACE          reduce using rule 72 (term_tail -> empty .)
    CHECK           reduce using rule 72 (term_tail -> empty .)
    SWAP            reduce using rule 72 (term_tail -> empty .)
    FUNCTION_NAME   reduce using rule 72 (term_tail -> empty .)
    DISPLAY         reduce using rule 72 (term_tail -> empty .)
    IDENT           reduce using rule 72 (term_tail -> empty .)
    FOR             reduce using rule 72 (term_tail -> empty .)
    UNTIL           reduce using rule 72 (term_tail -> empty .)
    REPEAT          reduce using rule 72 (term_tail -> empty .)
    INPUT           reduce using rule 72 (term_tail -> empty .)
    INT             reduce using rule 72 (term_tail -> empty .)
    FLT             reduce using rule 72 (term_tail -> empty .)
    BLN             reduce using rule 72 (term_tail -> empty .)
    CHR             reduce using rule 72 (term_tail -> empty .)
    STR             reduce using rule 72 (term_tail -> empty .)
    REVIVE          reduce using rule 72 (term_tail -> empty .)
    SHIFT           reduce using rule 72 (term_tail -> empty .)
    OTHERWISE       reduce using rule 72 (term_tail -> empty .)
    COLON           reduce using rule 72 (term_tail -> empty .)
    SEMICOLON       reduce using rule 72 (term_tail -> empty .)


state 93

    (73) term_tail -> GT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 119
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 94

    (74) term_tail -> LT . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 120
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 95

    (75) term_tail -> EQ_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 121
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 96

    (76) term_tail -> GT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 122
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 97

    (77) term_tail -> LT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 123
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 98

    (78) term_tail -> NOT_EQ . expression
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 124
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 99

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN . parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (99) parameters -> . data_type IDENT parameters_tail
    (100) parameters -> . empty
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR
    (165) empty -> .

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13
    RPAREN          reduce using rule 165 (empty -> .)

    parameters                     shift and go to state 125
    data_type                      shift and go to state 126
    empty                          shift and go to state 127

state 100

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline . GHOST

    GHOST           shift and go to state 128


state 101

    (6) main_function -> MAIN_CASPER LPAREN . RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE

    RPAREN          shift and go to state 129


state 102

    (16) global_tail2 -> COMMA IDENT . global_statement_tail
    (12) global_statement_tail -> . empty
    (13) global_statement_tail -> . COMMA IDENT global_statement_tail
    (14) global_statement_tail -> . EQ global_dec_value global_tail2
    (165) empty -> .

    COMMA           shift and go to state 29
    EQ              shift and go to state 30
    NEWLINE         reduce using rule 165 (empty -> .)

    global_statement_tail          shift and go to state 130
    empty                          shift and go to state 28

state 103

    (18) global_dec_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 18 (global_dec_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 18 (global_dec_value -> LBRACKET list_element RBRACKET .)


state 104

    (29) list_element -> literal element_tail .

    RBRACKET        reduce using rule 29 (list_element -> literal element_tail .)


state 105

    (30) element_tail -> empty .

    RBRACKET        reduce using rule 30 (element_tail -> empty .)


state 106

    (31) element_tail -> COMMA . list_element
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 131
    literal                        shift and go to state 72

state 107

    (66) factor_tail -> PLUS expression .

    GT              reduce using rule 66 (factor_tail -> PLUS expression .)
    LT              reduce using rule 66 (factor_tail -> PLUS expression .)
    EQ_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    GT_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    LT_EQ           reduce using rule 66 (factor_tail -> PLUS expression .)
    NOT_EQ          reduce using rule 66 (factor_tail -> PLUS expression .)
    AND             reduce using rule 66 (factor_tail -> PLUS expression .)
    OR              reduce using rule 66 (factor_tail -> PLUS expression .)
    COMMA           reduce using rule 66 (factor_tail -> PLUS expression .)
    NEWLINE         reduce using rule 66 (factor_tail -> PLUS expression .)
    RPAREN          reduce using rule 66 (factor_tail -> PLUS expression .)
    RBRACE          reduce using rule 66 (factor_tail -> PLUS expression .)
    CHECK           reduce using rule 66 (factor_tail -> PLUS expression .)
    SWAP            reduce using rule 66 (factor_tail -> PLUS expression .)
    FUNCTION_NAME   reduce using rule 66 (factor_tail -> PLUS expression .)
    DISPLAY         reduce using rule 66 (factor_tail -> PLUS expression .)
    IDENT           reduce using rule 66 (factor_tail -> PLUS expression .)
    FOR             reduce using rule 66 (factor_tail -> PLUS expression .)
    UNTIL           reduce using rule 66 (factor_tail -> PLUS expression .)
    REPEAT          reduce using rule 66 (factor_tail -> PLUS expression .)
    INPUT           reduce using rule 66 (factor_tail -> PLUS expression .)
    INT             reduce using rule 66 (factor_tail -> PLUS expression .)
    FLT             reduce using rule 66 (factor_tail -> PLUS expression .)
    BLN             reduce using rule 66 (factor_tail -> PLUS expression .)
    CHR             reduce using rule 66 (factor_tail -> PLUS expression .)
    STR             reduce using rule 66 (factor_tail -> PLUS expression .)
    REVIVE          reduce using rule 66 (factor_tail -> PLUS expression .)
    SHIFT           reduce using rule 66 (factor_tail -> PLUS expression .)
    OTHERWISE       reduce using rule 66 (factor_tail -> PLUS expression .)
    COLON           reduce using rule 66 (factor_tail -> PLUS expression .)
    SEMICOLON       reduce using rule 66 (factor_tail -> PLUS expression .)


state 108

    (67) factor_tail -> MINUS expression .

    GT              reduce using rule 67 (factor_tail -> MINUS expression .)
    LT              reduce using rule 67 (factor_tail -> MINUS expression .)
    EQ_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    GT_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    LT_EQ           reduce using rule 67 (factor_tail -> MINUS expression .)
    NOT_EQ          reduce using rule 67 (factor_tail -> MINUS expression .)
    AND             reduce using rule 67 (factor_tail -> MINUS expression .)
    OR              reduce using rule 67 (factor_tail -> MINUS expression .)
    COMMA           reduce using rule 67 (factor_tail -> MINUS expression .)
    NEWLINE         reduce using rule 67 (factor_tail -> MINUS expression .)
    RPAREN          reduce using rule 67 (factor_tail -> MINUS expression .)
    RBRACE          reduce using rule 67 (factor_tail -> MINUS expression .)
    CHECK           reduce using rule 67 (factor_tail -> MINUS expression .)
    SWAP            reduce using rule 67 (factor_tail -> MINUS expression .)
    FUNCTION_NAME   reduce using rule 67 (factor_tail -> MINUS expression .)
    DISPLAY         reduce using rule 67 (factor_tail -> MINUS expression .)
    IDENT           reduce using rule 67 (factor_tail -> MINUS expression .)
    FOR             reduce using rule 67 (factor_tail -> MINUS expression .)
    UNTIL           reduce using rule 67 (factor_tail -> MINUS expression .)
    REPEAT          reduce using rule 67 (factor_tail -> MINUS expression .)
    INPUT           reduce using rule 67 (factor_tail -> MINUS expression .)
    INT             reduce using rule 67 (factor_tail -> MINUS expression .)
    FLT             reduce using rule 67 (factor_tail -> MINUS expression .)
    BLN             reduce using rule 67 (factor_tail -> MINUS expression .)
    CHR             reduce using rule 67 (factor_tail -> MINUS expression .)
    STR             reduce using rule 67 (factor_tail -> MINUS expression .)
    REVIVE          reduce using rule 67 (factor_tail -> MINUS expression .)
    SHIFT           reduce using rule 67 (factor_tail -> MINUS expression .)
    OTHERWISE       reduce using rule 67 (factor_tail -> MINUS expression .)
    COLON           reduce using rule 67 (factor_tail -> MINUS expression .)
    SEMICOLON       reduce using rule 67 (factor_tail -> MINUS expression .)


state 109

    (68) factor_tail -> MULTIPLY expression .

    GT              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    LT              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    EQ_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    GT_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    LT_EQ           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    NOT_EQ          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    AND             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    OR              reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    COMMA           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    NEWLINE         reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    RPAREN          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    RBRACE          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    CHECK           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    SWAP            reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    FUNCTION_NAME   reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    DISPLAY         reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    IDENT           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    FOR             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    UNTIL           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    REPEAT          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    INPUT           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    INT             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    FLT             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    BLN             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    CHR             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    STR             reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    REVIVE          reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    SHIFT           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    OTHERWISE       reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    COLON           reduce using rule 68 (factor_tail -> MULTIPLY expression .)
    SEMICOLON       reduce using rule 68 (factor_tail -> MULTIPLY expression .)


state 110

    (69) factor_tail -> DIVISION expression .

    GT              reduce using rule 69 (factor_tail -> DIVISION expression .)
    LT              reduce using rule 69 (factor_tail -> DIVISION expression .)
    EQ_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    GT_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    LT_EQ           reduce using rule 69 (factor_tail -> DIVISION expression .)
    NOT_EQ          reduce using rule 69 (factor_tail -> DIVISION expression .)
    AND             reduce using rule 69 (factor_tail -> DIVISION expression .)
    OR              reduce using rule 69 (factor_tail -> DIVISION expression .)
    COMMA           reduce using rule 69 (factor_tail -> DIVISION expression .)
    NEWLINE         reduce using rule 69 (factor_tail -> DIVISION expression .)
    RPAREN          reduce using rule 69 (factor_tail -> DIVISION expression .)
    RBRACE          reduce using rule 69 (factor_tail -> DIVISION expression .)
    CHECK           reduce using rule 69 (factor_tail -> DIVISION expression .)
    SWAP            reduce using rule 69 (factor_tail -> DIVISION expression .)
    FUNCTION_NAME   reduce using rule 69 (factor_tail -> DIVISION expression .)
    DISPLAY         reduce using rule 69 (factor_tail -> DIVISION expression .)
    IDENT           reduce using rule 69 (factor_tail -> DIVISION expression .)
    FOR             reduce using rule 69 (factor_tail -> DIVISION expression .)
    UNTIL           reduce using rule 69 (factor_tail -> DIVISION expression .)
    REPEAT          reduce using rule 69 (factor_tail -> DIVISION expression .)
    INPUT           reduce using rule 69 (factor_tail -> DIVISION expression .)
    INT             reduce using rule 69 (factor_tail -> DIVISION expression .)
    FLT             reduce using rule 69 (factor_tail -> DIVISION expression .)
    BLN             reduce using rule 69 (factor_tail -> DIVISION expression .)
    CHR             reduce using rule 69 (factor_tail -> DIVISION expression .)
    STR             reduce using rule 69 (factor_tail -> DIVISION expression .)
    REVIVE          reduce using rule 69 (factor_tail -> DIVISION expression .)
    SHIFT           reduce using rule 69 (factor_tail -> DIVISION expression .)
    OTHERWISE       reduce using rule 69 (factor_tail -> DIVISION expression .)
    COLON           reduce using rule 69 (factor_tail -> DIVISION expression .)
    SEMICOLON       reduce using rule 69 (factor_tail -> DIVISION expression .)


state 111

    (70) factor_tail -> MODULO expression .

    GT              reduce using rule 70 (factor_tail -> MODULO expression .)
    LT              reduce using rule 70 (factor_tail -> MODULO expression .)
    EQ_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    GT_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    LT_EQ           reduce using rule 70 (factor_tail -> MODULO expression .)
    NOT_EQ          reduce using rule 70 (factor_tail -> MODULO expression .)
    AND             reduce using rule 70 (factor_tail -> MODULO expression .)
    OR              reduce using rule 70 (factor_tail -> MODULO expression .)
    COMMA           reduce using rule 70 (factor_tail -> MODULO expression .)
    NEWLINE         reduce using rule 70 (factor_tail -> MODULO expression .)
    RPAREN          reduce using rule 70 (factor_tail -> MODULO expression .)
    RBRACE          reduce using rule 70 (factor_tail -> MODULO expression .)
    CHECK           reduce using rule 70 (factor_tail -> MODULO expression .)
    SWAP            reduce using rule 70 (factor_tail -> MODULO expression .)
    FUNCTION_NAME   reduce using rule 70 (factor_tail -> MODULO expression .)
    DISPLAY         reduce using rule 70 (factor_tail -> MODULO expression .)
    IDENT           reduce using rule 70 (factor_tail -> MODULO expression .)
    FOR             reduce using rule 70 (factor_tail -> MODULO expression .)
    UNTIL           reduce using rule 70 (factor_tail -> MODULO expression .)
    REPEAT          reduce using rule 70 (factor_tail -> MODULO expression .)
    INPUT           reduce using rule 70 (factor_tail -> MODULO expression .)
    INT             reduce using rule 70 (factor_tail -> MODULO expression .)
    FLT             reduce using rule 70 (factor_tail -> MODULO expression .)
    BLN             reduce using rule 70 (factor_tail -> MODULO expression .)
    CHR             reduce using rule 70 (factor_tail -> MODULO expression .)
    STR             reduce using rule 70 (factor_tail -> MODULO expression .)
    REVIVE          reduce using rule 70 (factor_tail -> MODULO expression .)
    SHIFT           reduce using rule 70 (factor_tail -> MODULO expression .)
    OTHERWISE       reduce using rule 70 (factor_tail -> MODULO expression .)
    COLON           reduce using rule 70 (factor_tail -> MODULO expression .)
    SEMICOLON       reduce using rule 70 (factor_tail -> MODULO expression .)


state 112

    (71) factor_tail -> EXPONENT expression .

    GT              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    LT              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    EQ_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    GT_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    LT_EQ           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    NOT_EQ          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    AND             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    OR              reduce using rule 71 (factor_tail -> EXPONENT expression .)
    COMMA           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    NEWLINE         reduce using rule 71 (factor_tail -> EXPONENT expression .)
    RPAREN          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    RBRACE          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    CHECK           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    SWAP            reduce using rule 71 (factor_tail -> EXPONENT expression .)
    FUNCTION_NAME   reduce using rule 71 (factor_tail -> EXPONENT expression .)
    DISPLAY         reduce using rule 71 (factor_tail -> EXPONENT expression .)
    IDENT           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    FOR             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    UNTIL           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    REPEAT          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    INPUT           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    INT             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    FLT             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    BLN             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    CHR             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    STR             reduce using rule 71 (factor_tail -> EXPONENT expression .)
    REVIVE          reduce using rule 71 (factor_tail -> EXPONENT expression .)
    SHIFT           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    OTHERWISE       reduce using rule 71 (factor_tail -> EXPONENT expression .)
    COLON           reduce using rule 71 (factor_tail -> EXPONENT expression .)
    SEMICOLON       reduce using rule 71 (factor_tail -> EXPONENT expression .)


state 113

    (64) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    DIVISION        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    EXPONENT        reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    EQ_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    GT_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    LT_EQ           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    NOT_EQ          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    CHECK           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    SWAP            reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    FUNCTION_NAME   reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    DISPLAY         reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    IDENT           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    REPEAT          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    INPUT           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    INT             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    FLT             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    BLN             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    CHR             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    STR             reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    REVIVE          reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    SHIFT           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    OTHERWISE       reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 64 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 64 (factor -> LPAREN expression RPAREN .)


state 114

    (80) expr_tail -> AND expression .

    GT              reduce using rule 80 (expr_tail -> AND expression .)
    LT              reduce using rule 80 (expr_tail -> AND expression .)
    EQ_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    GT_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    LT_EQ           reduce using rule 80 (expr_tail -> AND expression .)
    NOT_EQ          reduce using rule 80 (expr_tail -> AND expression .)
    AND             reduce using rule 80 (expr_tail -> AND expression .)
    OR              reduce using rule 80 (expr_tail -> AND expression .)
    COMMA           reduce using rule 80 (expr_tail -> AND expression .)
    NEWLINE         reduce using rule 80 (expr_tail -> AND expression .)
    RPAREN          reduce using rule 80 (expr_tail -> AND expression .)
    RBRACE          reduce using rule 80 (expr_tail -> AND expression .)
    CHECK           reduce using rule 80 (expr_tail -> AND expression .)
    SWAP            reduce using rule 80 (expr_tail -> AND expression .)
    FUNCTION_NAME   reduce using rule 80 (expr_tail -> AND expression .)
    DISPLAY         reduce using rule 80 (expr_tail -> AND expression .)
    IDENT           reduce using rule 80 (expr_tail -> AND expression .)
    FOR             reduce using rule 80 (expr_tail -> AND expression .)
    UNTIL           reduce using rule 80 (expr_tail -> AND expression .)
    REPEAT          reduce using rule 80 (expr_tail -> AND expression .)
    INPUT           reduce using rule 80 (expr_tail -> AND expression .)
    INT             reduce using rule 80 (expr_tail -> AND expression .)
    FLT             reduce using rule 80 (expr_tail -> AND expression .)
    BLN             reduce using rule 80 (expr_tail -> AND expression .)
    CHR             reduce using rule 80 (expr_tail -> AND expression .)
    STR             reduce using rule 80 (expr_tail -> AND expression .)
    REVIVE          reduce using rule 80 (expr_tail -> AND expression .)
    SHIFT           reduce using rule 80 (expr_tail -> AND expression .)
    OTHERWISE       reduce using rule 80 (expr_tail -> AND expression .)
    COLON           reduce using rule 80 (expr_tail -> AND expression .)
    SEMICOLON       reduce using rule 80 (expr_tail -> AND expression .)


state 115

    (81) expr_tail -> OR expression .

    GT              reduce using rule 81 (expr_tail -> OR expression .)
    LT              reduce using rule 81 (expr_tail -> OR expression .)
    EQ_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    GT_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    LT_EQ           reduce using rule 81 (expr_tail -> OR expression .)
    NOT_EQ          reduce using rule 81 (expr_tail -> OR expression .)
    AND             reduce using rule 81 (expr_tail -> OR expression .)
    OR              reduce using rule 81 (expr_tail -> OR expression .)
    COMMA           reduce using rule 81 (expr_tail -> OR expression .)
    NEWLINE         reduce using rule 81 (expr_tail -> OR expression .)
    RPAREN          reduce using rule 81 (expr_tail -> OR expression .)
    RBRACE          reduce using rule 81 (expr_tail -> OR expression .)
    CHECK           reduce using rule 81 (expr_tail -> OR expression .)
    SWAP            reduce using rule 81 (expr_tail -> OR expression .)
    FUNCTION_NAME   reduce using rule 81 (expr_tail -> OR expression .)
    DISPLAY         reduce using rule 81 (expr_tail -> OR expression .)
    IDENT           reduce using rule 81 (expr_tail -> OR expression .)
    FOR             reduce using rule 81 (expr_tail -> OR expression .)
    UNTIL           reduce using rule 81 (expr_tail -> OR expression .)
    REPEAT          reduce using rule 81 (expr_tail -> OR expression .)
    INPUT           reduce using rule 81 (expr_tail -> OR expression .)
    INT             reduce using rule 81 (expr_tail -> OR expression .)
    FLT             reduce using rule 81 (expr_tail -> OR expression .)
    BLN             reduce using rule 81 (expr_tail -> OR expression .)
    CHR             reduce using rule 81 (expr_tail -> OR expression .)
    STR             reduce using rule 81 (expr_tail -> OR expression .)
    REVIVE          reduce using rule 81 (expr_tail -> OR expression .)
    SHIFT           reduce using rule 81 (expr_tail -> OR expression .)
    OTHERWISE       reduce using rule 81 (expr_tail -> OR expression .)
    COLON           reduce using rule 81 (expr_tail -> OR expression .)
    SEMICOLON       reduce using rule 81 (expr_tail -> OR expression .)


state 116

    (84) var_call_tail -> LBRACKET index . RBRACKET

    RBRACKET        shift and go to state 132


state 117

    (32) index -> INT_LIT .

    RBRACKET        reduce using rule 32 (index -> INT_LIT .)


state 118

    (33) index -> IDENT .

    RBRACKET        reduce using rule 33 (index -> IDENT .)


state 119

    (73) term_tail -> GT expression .

    GT              reduce using rule 73 (term_tail -> GT expression .)
    LT              reduce using rule 73 (term_tail -> GT expression .)
    EQ_EQ           reduce using rule 73 (term_tail -> GT expression .)
    GT_EQ           reduce using rule 73 (term_tail -> GT expression .)
    LT_EQ           reduce using rule 73 (term_tail -> GT expression .)
    NOT_EQ          reduce using rule 73 (term_tail -> GT expression .)
    AND             reduce using rule 73 (term_tail -> GT expression .)
    OR              reduce using rule 73 (term_tail -> GT expression .)
    COMMA           reduce using rule 73 (term_tail -> GT expression .)
    NEWLINE         reduce using rule 73 (term_tail -> GT expression .)
    RPAREN          reduce using rule 73 (term_tail -> GT expression .)
    RBRACE          reduce using rule 73 (term_tail -> GT expression .)
    CHECK           reduce using rule 73 (term_tail -> GT expression .)
    SWAP            reduce using rule 73 (term_tail -> GT expression .)
    FUNCTION_NAME   reduce using rule 73 (term_tail -> GT expression .)
    DISPLAY         reduce using rule 73 (term_tail -> GT expression .)
    IDENT           reduce using rule 73 (term_tail -> GT expression .)
    FOR             reduce using rule 73 (term_tail -> GT expression .)
    UNTIL           reduce using rule 73 (term_tail -> GT expression .)
    REPEAT          reduce using rule 73 (term_tail -> GT expression .)
    INPUT           reduce using rule 73 (term_tail -> GT expression .)
    INT             reduce using rule 73 (term_tail -> GT expression .)
    FLT             reduce using rule 73 (term_tail -> GT expression .)
    BLN             reduce using rule 73 (term_tail -> GT expression .)
    CHR             reduce using rule 73 (term_tail -> GT expression .)
    STR             reduce using rule 73 (term_tail -> GT expression .)
    REVIVE          reduce using rule 73 (term_tail -> GT expression .)
    SHIFT           reduce using rule 73 (term_tail -> GT expression .)
    OTHERWISE       reduce using rule 73 (term_tail -> GT expression .)
    COLON           reduce using rule 73 (term_tail -> GT expression .)
    SEMICOLON       reduce using rule 73 (term_tail -> GT expression .)


state 120

    (74) term_tail -> LT expression .

    GT              reduce using rule 74 (term_tail -> LT expression .)
    LT              reduce using rule 74 (term_tail -> LT expression .)
    EQ_EQ           reduce using rule 74 (term_tail -> LT expression .)
    GT_EQ           reduce using rule 74 (term_tail -> LT expression .)
    LT_EQ           reduce using rule 74 (term_tail -> LT expression .)
    NOT_EQ          reduce using rule 74 (term_tail -> LT expression .)
    AND             reduce using rule 74 (term_tail -> LT expression .)
    OR              reduce using rule 74 (term_tail -> LT expression .)
    COMMA           reduce using rule 74 (term_tail -> LT expression .)
    NEWLINE         reduce using rule 74 (term_tail -> LT expression .)
    RPAREN          reduce using rule 74 (term_tail -> LT expression .)
    RBRACE          reduce using rule 74 (term_tail -> LT expression .)
    CHECK           reduce using rule 74 (term_tail -> LT expression .)
    SWAP            reduce using rule 74 (term_tail -> LT expression .)
    FUNCTION_NAME   reduce using rule 74 (term_tail -> LT expression .)
    DISPLAY         reduce using rule 74 (term_tail -> LT expression .)
    IDENT           reduce using rule 74 (term_tail -> LT expression .)
    FOR             reduce using rule 74 (term_tail -> LT expression .)
    UNTIL           reduce using rule 74 (term_tail -> LT expression .)
    REPEAT          reduce using rule 74 (term_tail -> LT expression .)
    INPUT           reduce using rule 74 (term_tail -> LT expression .)
    INT             reduce using rule 74 (term_tail -> LT expression .)
    FLT             reduce using rule 74 (term_tail -> LT expression .)
    BLN             reduce using rule 74 (term_tail -> LT expression .)
    CHR             reduce using rule 74 (term_tail -> LT expression .)
    STR             reduce using rule 74 (term_tail -> LT expression .)
    REVIVE          reduce using rule 74 (term_tail -> LT expression .)
    SHIFT           reduce using rule 74 (term_tail -> LT expression .)
    OTHERWISE       reduce using rule 74 (term_tail -> LT expression .)
    COLON           reduce using rule 74 (term_tail -> LT expression .)
    SEMICOLON       reduce using rule 74 (term_tail -> LT expression .)


state 121

    (75) term_tail -> EQ_EQ expression .

    GT              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    LT              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    EQ_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    GT_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    LT_EQ           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    NOT_EQ          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    AND             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    OR              reduce using rule 75 (term_tail -> EQ_EQ expression .)
    COMMA           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    NEWLINE         reduce using rule 75 (term_tail -> EQ_EQ expression .)
    RPAREN          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    RBRACE          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    CHECK           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    SWAP            reduce using rule 75 (term_tail -> EQ_EQ expression .)
    FUNCTION_NAME   reduce using rule 75 (term_tail -> EQ_EQ expression .)
    DISPLAY         reduce using rule 75 (term_tail -> EQ_EQ expression .)
    IDENT           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    FOR             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    UNTIL           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    REPEAT          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    INPUT           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    INT             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    FLT             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    BLN             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    CHR             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    STR             reduce using rule 75 (term_tail -> EQ_EQ expression .)
    REVIVE          reduce using rule 75 (term_tail -> EQ_EQ expression .)
    SHIFT           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    OTHERWISE       reduce using rule 75 (term_tail -> EQ_EQ expression .)
    COLON           reduce using rule 75 (term_tail -> EQ_EQ expression .)
    SEMICOLON       reduce using rule 75 (term_tail -> EQ_EQ expression .)


state 122

    (76) term_tail -> GT_EQ expression .

    GT              reduce using rule 76 (term_tail -> GT_EQ expression .)
    LT              reduce using rule 76 (term_tail -> GT_EQ expression .)
    EQ_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    GT_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    LT_EQ           reduce using rule 76 (term_tail -> GT_EQ expression .)
    NOT_EQ          reduce using rule 76 (term_tail -> GT_EQ expression .)
    AND             reduce using rule 76 (term_tail -> GT_EQ expression .)
    OR              reduce using rule 76 (term_tail -> GT_EQ expression .)
    COMMA           reduce using rule 76 (term_tail -> GT_EQ expression .)
    NEWLINE         reduce using rule 76 (term_tail -> GT_EQ expression .)
    RPAREN          reduce using rule 76 (term_tail -> GT_EQ expression .)
    RBRACE          reduce using rule 76 (term_tail -> GT_EQ expression .)
    CHECK           reduce using rule 76 (term_tail -> GT_EQ expression .)
    SWAP            reduce using rule 76 (term_tail -> GT_EQ expression .)
    FUNCTION_NAME   reduce using rule 76 (term_tail -> GT_EQ expression .)
    DISPLAY         reduce using rule 76 (term_tail -> GT_EQ expression .)
    IDENT           reduce using rule 76 (term_tail -> GT_EQ expression .)
    FOR             reduce using rule 76 (term_tail -> GT_EQ expression .)
    UNTIL           reduce using rule 76 (term_tail -> GT_EQ expression .)
    REPEAT          reduce using rule 76 (term_tail -> GT_EQ expression .)
    INPUT           reduce using rule 76 (term_tail -> GT_EQ expression .)
    INT             reduce using rule 76 (term_tail -> GT_EQ expression .)
    FLT             reduce using rule 76 (term_tail -> GT_EQ expression .)
    BLN             reduce using rule 76 (term_tail -> GT_EQ expression .)
    CHR             reduce using rule 76 (term_tail -> GT_EQ expression .)
    STR             reduce using rule 76 (term_tail -> GT_EQ expression .)
    REVIVE          reduce using rule 76 (term_tail -> GT_EQ expression .)
    SHIFT           reduce using rule 76 (term_tail -> GT_EQ expression .)
    OTHERWISE       reduce using rule 76 (term_tail -> GT_EQ expression .)
    COLON           reduce using rule 76 (term_tail -> GT_EQ expression .)
    SEMICOLON       reduce using rule 76 (term_tail -> GT_EQ expression .)


state 123

    (77) term_tail -> LT_EQ expression .

    GT              reduce using rule 77 (term_tail -> LT_EQ expression .)
    LT              reduce using rule 77 (term_tail -> LT_EQ expression .)
    EQ_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    GT_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    LT_EQ           reduce using rule 77 (term_tail -> LT_EQ expression .)
    NOT_EQ          reduce using rule 77 (term_tail -> LT_EQ expression .)
    AND             reduce using rule 77 (term_tail -> LT_EQ expression .)
    OR              reduce using rule 77 (term_tail -> LT_EQ expression .)
    COMMA           reduce using rule 77 (term_tail -> LT_EQ expression .)
    NEWLINE         reduce using rule 77 (term_tail -> LT_EQ expression .)
    RPAREN          reduce using rule 77 (term_tail -> LT_EQ expression .)
    RBRACE          reduce using rule 77 (term_tail -> LT_EQ expression .)
    CHECK           reduce using rule 77 (term_tail -> LT_EQ expression .)
    SWAP            reduce using rule 77 (term_tail -> LT_EQ expression .)
    FUNCTION_NAME   reduce using rule 77 (term_tail -> LT_EQ expression .)
    DISPLAY         reduce using rule 77 (term_tail -> LT_EQ expression .)
    IDENT           reduce using rule 77 (term_tail -> LT_EQ expression .)
    FOR             reduce using rule 77 (term_tail -> LT_EQ expression .)
    UNTIL           reduce using rule 77 (term_tail -> LT_EQ expression .)
    REPEAT          reduce using rule 77 (term_tail -> LT_EQ expression .)
    INPUT           reduce using rule 77 (term_tail -> LT_EQ expression .)
    INT             reduce using rule 77 (term_tail -> LT_EQ expression .)
    FLT             reduce using rule 77 (term_tail -> LT_EQ expression .)
    BLN             reduce using rule 77 (term_tail -> LT_EQ expression .)
    CHR             reduce using rule 77 (term_tail -> LT_EQ expression .)
    STR             reduce using rule 77 (term_tail -> LT_EQ expression .)
    REVIVE          reduce using rule 77 (term_tail -> LT_EQ expression .)
    SHIFT           reduce using rule 77 (term_tail -> LT_EQ expression .)
    OTHERWISE       reduce using rule 77 (term_tail -> LT_EQ expression .)
    COLON           reduce using rule 77 (term_tail -> LT_EQ expression .)
    SEMICOLON       reduce using rule 77 (term_tail -> LT_EQ expression .)


state 124

    (78) term_tail -> NOT_EQ expression .

    GT              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    LT              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    EQ_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    GT_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    LT_EQ           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    NOT_EQ          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    AND             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    OR              reduce using rule 78 (term_tail -> NOT_EQ expression .)
    COMMA           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    NEWLINE         reduce using rule 78 (term_tail -> NOT_EQ expression .)
    RPAREN          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    RBRACE          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    CHECK           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    SWAP            reduce using rule 78 (term_tail -> NOT_EQ expression .)
    FUNCTION_NAME   reduce using rule 78 (term_tail -> NOT_EQ expression .)
    DISPLAY         reduce using rule 78 (term_tail -> NOT_EQ expression .)
    IDENT           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    FOR             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    UNTIL           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    REPEAT          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    INPUT           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    INT             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    FLT             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    BLN             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    CHR             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    STR             reduce using rule 78 (term_tail -> NOT_EQ expression .)
    REVIVE          reduce using rule 78 (term_tail -> NOT_EQ expression .)
    SHIFT           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    OTHERWISE       reduce using rule 78 (term_tail -> NOT_EQ expression .)
    COLON           reduce using rule 78 (term_tail -> NOT_EQ expression .)
    SEMICOLON       reduce using rule 78 (term_tail -> NOT_EQ expression .)


state 125

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters . RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE

    RPAREN          shift and go to state 133


state 126

    (99) parameters -> data_type . IDENT parameters_tail

    IDENT           shift and go to state 134


state 127

    (100) parameters -> empty .

    RPAREN          reduce using rule 100 (parameters -> empty .)


state 128

    (1) program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .

    $end            reduce using rule 1 (program -> BIRTH unli_newline global_dec maybe_newline function_statements maybe_newline main_function unli_newline GHOST .)


state 129

    (6) main_function -> MAIN_CASPER LPAREN RPAREN . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 135
    empty                          shift and go to state 16

state 130

    (16) global_tail2 -> COMMA IDENT global_statement_tail .

    NEWLINE         reduce using rule 16 (global_tail2 -> COMMA IDENT global_statement_tail .)


state 131

    (31) element_tail -> COMMA list_element .

    RBRACKET        reduce using rule 31 (element_tail -> COMMA list_element .)


state 132

    (84) var_call_tail -> LBRACKET index RBRACKET .

    PLUS            reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MULTIPLY        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    DIVISION        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MODULO          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EXPONENT        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    COMMA           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    NEWLINE         reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    GT              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    LT              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    GT_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    LT_EQ           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    NOT_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    AND             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    OR              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    RPAREN          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    RBRACE          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    CHECK           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    SWAP            reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    FUNCTION_NAME   reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    DISPLAY         reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    IDENT           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    FOR             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    UNTIL           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    REPEAT          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    INPUT           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    INT             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    FLT             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    BLN             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    CHR             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    STR             reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    REVIVE          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    SHIFT           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    OTHERWISE       reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    COLON           reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    SEMICOLON       reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_PLUS       reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_MINUS     reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    PLUS_EQ         reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MINUS_EQ        reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MUL_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    DIV_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    MOD_EQ          reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)
    EQ              reduce using rule 84 (var_call_tail -> LBRACKET index RBRACKET .)


state 133

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN . maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 136
    empty                          shift and go to state 16

state 134

    (99) parameters -> data_type IDENT . parameters_tail
    (101) parameters_tail -> . empty
    (102) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (165) empty -> .

    COMMA           shift and go to state 139
    RPAREN          reduce using rule 165 (empty -> .)

    parameters_tail                shift and go to state 137
    empty                          shift and go to state 138

state 135

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE

    LBRACE          shift and go to state 140


state 136

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline . LBRACE unli_newline statements revive maybe_newline RBRACE

    LBRACE          shift and go to state 141


state 137

    (99) parameters -> data_type IDENT parameters_tail .

    RPAREN          reduce using rule 99 (parameters -> data_type IDENT parameters_tail .)


state 138

    (101) parameters_tail -> empty .

    RPAREN          reduce using rule 101 (parameters_tail -> empty .)


state 139

    (102) parameters_tail -> COMMA . data_type IDENT parameters_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

    data_type                      shift and go to state 142

state 140

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 143
    empty                          shift and go to state 16

state 141

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE . unli_newline statements revive maybe_newline RBRACE
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 144

state 142

    (102) parameters_tail -> COMMA data_type . IDENT parameters_tail

    IDENT           shift and go to state 145


state 143

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 146
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 144

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline . statements revive maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    REVIVE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 151
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 145

    (102) parameters_tail -> COMMA data_type IDENT . parameters_tail
    (101) parameters_tail -> . empty
    (102) parameters_tail -> . COMMA data_type IDENT parameters_tail
    (165) empty -> .

    COMMA           shift and go to state 139
    RPAREN          reduce using rule 165 (empty -> .)

    parameters_tail                shift and go to state 152
    empty                          shift and go to state 138

state 146

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 153
    empty                          shift and go to state 16

state 147

    (105) statements -> empty .
    (115) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 105 (statements -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 105 (statements -> empty .)
    NEWLINE         reduce using rule 105 (statements -> empty .)
    RBRACE          reduce using rule 105 (statements -> empty .)
    REVIVE          reduce using rule 105 (statements -> empty .)
    SHIFT           reduce using rule 105 (statements -> empty .)
    OTHERWISE       reduce using rule 105 (statements -> empty .)
    CHECK           reduce using rule 115 (local_dec -> empty .)
    SWAP            reduce using rule 115 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 115 (local_dec -> empty .)
    DISPLAY         reduce using rule 115 (local_dec -> empty .)
    IDENT           reduce using rule 115 (local_dec -> empty .)
    FOR             reduce using rule 115 (local_dec -> empty .)
    UNTIL           reduce using rule 115 (local_dec -> empty .)
    REPEAT          reduce using rule 115 (local_dec -> empty .)
    INPUT           reduce using rule 115 (local_dec -> empty .)
    INT             reduce using rule 115 (local_dec -> empty .)
    FLT             reduce using rule 115 (local_dec -> empty .)
    BLN             reduce using rule 115 (local_dec -> empty .)
    CHR             reduce using rule 115 (local_dec -> empty .)
    STR             reduce using rule 115 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 115 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 115 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 115 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 115 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 115 (local_dec -> empty .) ]


state 148

    (106) statements -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 154
    empty                          shift and go to state 16

state 149

    (116) local_dec -> var_statement .

    NEWLINE         reduce using rule 116 (local_dec -> var_statement .)
    CHECK           reduce using rule 116 (local_dec -> var_statement .)
    SWAP            reduce using rule 116 (local_dec -> var_statement .)
    FUNCTION_NAME   reduce using rule 116 (local_dec -> var_statement .)
    DISPLAY         reduce using rule 116 (local_dec -> var_statement .)
    IDENT           reduce using rule 116 (local_dec -> var_statement .)
    FOR             reduce using rule 116 (local_dec -> var_statement .)
    UNTIL           reduce using rule 116 (local_dec -> var_statement .)
    REPEAT          reduce using rule 116 (local_dec -> var_statement .)
    INPUT           reduce using rule 116 (local_dec -> var_statement .)
    INT             reduce using rule 116 (local_dec -> var_statement .)
    FLT             reduce using rule 116 (local_dec -> var_statement .)
    BLN             reduce using rule 116 (local_dec -> var_statement .)
    CHR             reduce using rule 116 (local_dec -> var_statement .)
    STR             reduce using rule 116 (local_dec -> var_statement .)
    RBRACE          reduce using rule 116 (local_dec -> var_statement .)
    REVIVE          reduce using rule 116 (local_dec -> var_statement .)
    SHIFT           reduce using rule 116 (local_dec -> var_statement .)
    OTHERWISE       reduce using rule 116 (local_dec -> var_statement .)


state 150

    (21) var_statement -> data_type . IDENT var_tail

    IDENT           shift and go to state 155


state 151

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements . revive maybe_newline RBRACE
    (103) revive -> . REVIVE value
    (104) revive -> . empty
    (165) empty -> .

    REVIVE          shift and go to state 157
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)

    revive                         shift and go to state 156
    empty                          shift and go to state 158

state 152

    (102) parameters_tail -> COMMA data_type IDENT parameters_tail .

    RPAREN          reduce using rule 102 (parameters_tail -> COMMA data_type IDENT parameters_tail .)


state 153

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE

    RBRACE          shift and go to state 159


state 154

    (106) statements -> local_dec maybe_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (152) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (123) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (127) loop_statement -> . for_loop
    (128) loop_statement -> . until_loop
    (129) loop_statement -> . repeat_until
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (147) output_statement -> . DISPLAY value next_val
    (148) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (130) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (132) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (151) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 175
    DISPLAY         shift and go to state 177
    IDENT           shift and go to state 56
    FOR             shift and go to state 178
    UNTIL           shift and go to state 179
    REPEAT          shift and go to state 180
    INPUT           shift and go to state 181
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    local_dec                      shift and go to state 160
    statements_tail                shift and go to state 161
    empty                          shift and go to state 162
    string_operation_statement     shift and go to state 163
    conditional_statement          shift and go to state 164
    switch_statement               shift and go to state 165
    loop_statement                 shift and go to state 166
    function_call                  shift and go to state 167
    output_statement               shift and go to state 168
    var_statement                  shift and go to state 149
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 176
    data_type                      shift and go to state 150

state 155

    (21) var_statement -> data_type IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (165) empty -> .

    EQ              shift and go to state 184
    COMMA           shift and go to state 185
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

    var_tail                       shift and go to state 182
    empty                          shift and go to state 183

state 156

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 186
    empty                          shift and go to state 16

state 157

    (103) revive -> REVIVE . value
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 192
    CONVERT_TO_FLT  shift and go to state 193
    CONVERT_TO_BLN  shift and go to state 194
    CONVERT_TO_STR  shift and go to state 195
    FUNCTION_NAME   shift and go to state 175
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181

    value                          shift and go to state 187
    factor                         shift and go to state 188
    type_cast                      shift and go to state 189
    expression                     shift and go to state 190
    function_call                  shift and go to state 191
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 176
    term                           shift and go to state 63

state 158

    (104) revive -> empty .

    NEWLINE         reduce using rule 104 (revive -> empty .)
    RBRACE          reduce using rule 104 (revive -> empty .)


state 159

    (6) main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .

    NEWLINE         reduce using rule 6 (main_function -> MAIN_CASPER LPAREN RPAREN maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE .)


state 160

    (108) statements_tail -> local_dec . maybe_newline statements_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 196
    empty                          shift and go to state 16

state 161

    (106) statements -> local_dec maybe_newline statements_tail .

    NEWLINE         reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    REVIVE          reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 106 (statements -> local_dec maybe_newline statements_tail .)


state 162

    (107) statements_tail -> empty .
    (115) local_dec -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 107 (statements_tail -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 107 (statements_tail -> empty .)
  ! reduce/reduce conflict for REVIVE resolved using rule 107 (statements_tail -> empty .)
  ! reduce/reduce conflict for SHIFT resolved using rule 107 (statements_tail -> empty .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 107 (statements_tail -> empty .)
    NEWLINE         reduce using rule 107 (statements_tail -> empty .)
    RBRACE          reduce using rule 107 (statements_tail -> empty .)
    REVIVE          reduce using rule 107 (statements_tail -> empty .)
    SHIFT           reduce using rule 107 (statements_tail -> empty .)
    OTHERWISE       reduce using rule 107 (statements_tail -> empty .)
    CHECK           reduce using rule 115 (local_dec -> empty .)
    SWAP            reduce using rule 115 (local_dec -> empty .)
    FUNCTION_NAME   reduce using rule 115 (local_dec -> empty .)
    DISPLAY         reduce using rule 115 (local_dec -> empty .)
    IDENT           reduce using rule 115 (local_dec -> empty .)
    FOR             reduce using rule 115 (local_dec -> empty .)
    UNTIL           reduce using rule 115 (local_dec -> empty .)
    REPEAT          reduce using rule 115 (local_dec -> empty .)
    INPUT           reduce using rule 115 (local_dec -> empty .)
    INT             reduce using rule 115 (local_dec -> empty .)
    FLT             reduce using rule 115 (local_dec -> empty .)
    BLN             reduce using rule 115 (local_dec -> empty .)
    CHR             reduce using rule 115 (local_dec -> empty .)
    STR             reduce using rule 115 (local_dec -> empty .)

  ! NEWLINE         [ reduce using rule 115 (local_dec -> empty .) ]
  ! RBRACE          [ reduce using rule 115 (local_dec -> empty .) ]
  ! REVIVE          [ reduce using rule 115 (local_dec -> empty .) ]
  ! SHIFT           [ reduce using rule 115 (local_dec -> empty .) ]
  ! OTHERWISE       [ reduce using rule 115 (local_dec -> empty .) ]


state 163

    (109) statements_tail -> string_operation_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 197

state 164

    (110) statements_tail -> conditional_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 198

state 165

    (111) statements_tail -> switch_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 199

state 166

    (112) statements_tail -> loop_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 200

state 167

    (113) statements_tail -> function_call . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 201

state 168

    (114) statements_tail -> output_statement . unli_newline statements_tail
    (4) unli_newline -> . NEWLINE
    (5) unli_newline -> . NEWLINE unli_newline

    NEWLINE         shift and go to state 4

    unli_newline                   shift and go to state 202

state 169

    (152) string_operation_statement -> var_call . string_operation_tail
    (153) string_operation_tail -> . PLUS string_val stringcon_tail
    (154) string_operation_tail -> . update_tail
    (135) update_tail -> . postfix
    (136) update_tail -> . assign_op value
    (137) postfix -> . PLUS_PLUS
    (138) postfix -> . MINUS_MINUS
    (155) assign_op -> . PLUS_EQ
    (156) assign_op -> . MINUS_EQ
    (157) assign_op -> . MUL_EQ
    (158) assign_op -> . DIV_EQ
    (159) assign_op -> . MOD_EQ
    (160) assign_op -> . EQ

    PLUS            shift and go to state 204
    PLUS_PLUS       shift and go to state 208
    MINUS_MINUS     shift and go to state 209
    PLUS_EQ         shift and go to state 210
    MINUS_EQ        shift and go to state 211
    MUL_EQ          shift and go to state 212
    DIV_EQ          shift and go to state 213
    MOD_EQ          shift and go to state 214
    EQ              shift and go to state 215

    string_operation_tail          shift and go to state 203
    update_tail                    shift and go to state 205
    postfix                        shift and go to state 206
    assign_op                      shift and go to state 207

state 170

    (117) conditional_statement -> CHECK . LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    LPAREN          shift and go to state 216


state 171

    (123) switch_statement -> SWAP . LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LPAREN          shift and go to state 217


state 172

    (127) loop_statement -> for_loop .

    NEWLINE         reduce using rule 127 (loop_statement -> for_loop .)


state 173

    (128) loop_statement -> until_loop .

    NEWLINE         reduce using rule 128 (loop_statement -> until_loop .)


state 174

    (129) loop_statement -> repeat_until .

    NEWLINE         reduce using rule 129 (loop_statement -> repeat_until .)


state 175

    (139) function_call -> FUNCTION_NAME . LPAREN arguments RPAREN

    LPAREN          shift and go to state 218


state 176

    (140) function_call -> input_statement .

    NEWLINE         reduce using rule 140 (function_call -> input_statement .)
    RBRACE          reduce using rule 140 (function_call -> input_statement .)
    COMMA           reduce using rule 140 (function_call -> input_statement .)
    CHECK           reduce using rule 140 (function_call -> input_statement .)
    SWAP            reduce using rule 140 (function_call -> input_statement .)
    FUNCTION_NAME   reduce using rule 140 (function_call -> input_statement .)
    DISPLAY         reduce using rule 140 (function_call -> input_statement .)
    IDENT           reduce using rule 140 (function_call -> input_statement .)
    FOR             reduce using rule 140 (function_call -> input_statement .)
    UNTIL           reduce using rule 140 (function_call -> input_statement .)
    REPEAT          reduce using rule 140 (function_call -> input_statement .)
    INPUT           reduce using rule 140 (function_call -> input_statement .)
    INT             reduce using rule 140 (function_call -> input_statement .)
    FLT             reduce using rule 140 (function_call -> input_statement .)
    BLN             reduce using rule 140 (function_call -> input_statement .)
    CHR             reduce using rule 140 (function_call -> input_statement .)
    STR             reduce using rule 140 (function_call -> input_statement .)
    REVIVE          reduce using rule 140 (function_call -> input_statement .)
    SHIFT           reduce using rule 140 (function_call -> input_statement .)
    OTHERWISE       reduce using rule 140 (function_call -> input_statement .)
    RPAREN          reduce using rule 140 (function_call -> input_statement .)
    COLON           reduce using rule 140 (function_call -> input_statement .)


state 177

    (147) output_statement -> DISPLAY . value next_val
    (148) output_statement -> DISPLAY . LPAREN value next_val RPAREN
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    LPAREN          shift and go to state 220
    TILDE           shift and go to state 53
    CONVERT_TO_INT  shift and go to state 192
    CONVERT_TO_FLT  shift and go to state 193
    CONVERT_TO_BLN  shift and go to state 194
    CONVERT_TO_STR  shift and go to state 195
    FUNCTION_NAME   shift and go to state 175
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181

    value                          shift and go to state 219
    factor                         shift and go to state 188
    type_cast                      shift and go to state 189
    expression                     shift and go to state 190
    function_call                  shift and go to state 191
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 176
    term                           shift and go to state 63

state 178

    (130) for_loop -> FOR . LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 221


state 179

    (131) until_loop -> UNTIL . LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE

    LPAREN          shift and go to state 222


state 180

    (132) repeat_until -> REPEAT . LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN

    LBRACE          shift and go to state 223


state 181

    (151) input_statement -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 224


state 182

    (21) var_statement -> data_type IDENT var_tail .

    NEWLINE         reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    CHECK           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    SWAP            reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    FUNCTION_NAME   reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    DISPLAY         reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    IDENT           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    FOR             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    UNTIL           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    REPEAT          reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    INPUT           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    INT             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    FLT             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    BLN             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    CHR             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    STR             reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    RBRACE          reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    REVIVE          reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    SHIFT           reduce using rule 21 (var_statement -> data_type IDENT var_tail .)
    OTHERWISE       reduce using rule 21 (var_statement -> data_type IDENT var_tail .)


state 183

    (22) var_tail -> empty .

    NEWLINE         reduce using rule 22 (var_tail -> empty .)
    CHECK           reduce using rule 22 (var_tail -> empty .)
    SWAP            reduce using rule 22 (var_tail -> empty .)
    FUNCTION_NAME   reduce using rule 22 (var_tail -> empty .)
    DISPLAY         reduce using rule 22 (var_tail -> empty .)
    IDENT           reduce using rule 22 (var_tail -> empty .)
    FOR             reduce using rule 22 (var_tail -> empty .)
    UNTIL           reduce using rule 22 (var_tail -> empty .)
    REPEAT          reduce using rule 22 (var_tail -> empty .)
    INPUT           reduce using rule 22 (var_tail -> empty .)
    INT             reduce using rule 22 (var_tail -> empty .)
    FLT             reduce using rule 22 (var_tail -> empty .)
    BLN             reduce using rule 22 (var_tail -> empty .)
    CHR             reduce using rule 22 (var_tail -> empty .)
    STR             reduce using rule 22 (var_tail -> empty .)
    RBRACE          reduce using rule 22 (var_tail -> empty .)
    REVIVE          reduce using rule 22 (var_tail -> empty .)
    SHIFT           reduce using rule 22 (var_tail -> empty .)
    OTHERWISE       reduce using rule 22 (var_tail -> empty .)


state 184

    (23) var_tail -> EQ . tail_value var_tail2
    (27) tail_value -> . value
    (28) tail_value -> . LBRACKET list_element RBRACKET
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    LBRACKET        shift and go to state 227
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 192
    CONVERT_TO_FLT  shift and go to state 193
    CONVERT_TO_BLN  shift and go to state 194
    CONVERT_TO_STR  shift and go to state 195
    FUNCTION_NAME   shift and go to state 175
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181

    tail_value                     shift and go to state 225
    value                          shift and go to state 226
    factor                         shift and go to state 188
    type_cast                      shift and go to state 189
    expression                     shift and go to state 190
    function_call                  shift and go to state 191
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 176
    term                           shift and go to state 63

state 185

    (24) var_tail -> COMMA . IDENT var_tail

    IDENT           shift and go to state 228


state 186

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline . RBRACE

    RBRACE          shift and go to state 229


state 187

    (103) revive -> REVIVE value .

    NEWLINE         reduce using rule 103 (revive -> REVIVE value .)
    RBRACE          reduce using rule 103 (revive -> REVIVE value .)


state 188

    (39) value -> factor .
    (60) term -> factor . factor_tail
    (65) factor_tail -> . empty
    (66) factor_tail -> . PLUS expression
    (67) factor_tail -> . MINUS expression
    (68) factor_tail -> . MULTIPLY expression
    (69) factor_tail -> . DIVISION expression
    (70) factor_tail -> . MODULO expression
    (71) factor_tail -> . EXPONENT expression
    (165) empty -> .

  ! reduce/reduce conflict for NEWLINE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for RBRACE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for COMMA resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for CHECK resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for SWAP resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for FUNCTION_NAME resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for DISPLAY resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for IDENT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for FOR resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for UNTIL resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for REPEAT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for INPUT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for INT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for FLT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for BLN resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for CHR resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for STR resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for REVIVE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for SHIFT resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for OTHERWISE resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for RPAREN resolved using rule 39 (value -> factor .)
  ! reduce/reduce conflict for COLON resolved using rule 39 (value -> factor .)
    NEWLINE         reduce using rule 39 (value -> factor .)
    RBRACE          reduce using rule 39 (value -> factor .)
    COMMA           reduce using rule 39 (value -> factor .)
    CHECK           reduce using rule 39 (value -> factor .)
    SWAP            reduce using rule 39 (value -> factor .)
    FUNCTION_NAME   reduce using rule 39 (value -> factor .)
    DISPLAY         reduce using rule 39 (value -> factor .)
    IDENT           reduce using rule 39 (value -> factor .)
    FOR             reduce using rule 39 (value -> factor .)
    UNTIL           reduce using rule 39 (value -> factor .)
    REPEAT          reduce using rule 39 (value -> factor .)
    INPUT           reduce using rule 39 (value -> factor .)
    INT             reduce using rule 39 (value -> factor .)
    FLT             reduce using rule 39 (value -> factor .)
    BLN             reduce using rule 39 (value -> factor .)
    CHR             reduce using rule 39 (value -> factor .)
    STR             reduce using rule 39 (value -> factor .)
    REVIVE          reduce using rule 39 (value -> factor .)
    SHIFT           reduce using rule 39 (value -> factor .)
    OTHERWISE       reduce using rule 39 (value -> factor .)
    RPAREN          reduce using rule 39 (value -> factor .)
    COLON           reduce using rule 39 (value -> factor .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76
    MULTIPLY        shift and go to state 77
    DIVISION        shift and go to state 78
    MODULO          shift and go to state 79
    EXPONENT        shift and go to state 80
    GT              reduce using rule 165 (empty -> .)
    LT              reduce using rule 165 (empty -> .)
    EQ_EQ           reduce using rule 165 (empty -> .)
    GT_EQ           reduce using rule 165 (empty -> .)
    LT_EQ           reduce using rule 165 (empty -> .)
    NOT_EQ          reduce using rule 165 (empty -> .)
    AND             reduce using rule 165 (empty -> .)
    OR              reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]
  ! RBRACE          [ reduce using rule 165 (empty -> .) ]
  ! COMMA           [ reduce using rule 165 (empty -> .) ]
  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]
  ! REVIVE          [ reduce using rule 165 (empty -> .) ]
  ! SHIFT           [ reduce using rule 165 (empty -> .) ]
  ! OTHERWISE       [ reduce using rule 165 (empty -> .) ]
  ! RPAREN          [ reduce using rule 165 (empty -> .) ]
  ! COLON           [ reduce using rule 165 (empty -> .) ]

    factor_tail                    shift and go to state 73
    empty                          shift and go to state 74

state 189

    (40) value -> type_cast .

    NEWLINE         reduce using rule 40 (value -> type_cast .)
    RBRACE          reduce using rule 40 (value -> type_cast .)
    COMMA           reduce using rule 40 (value -> type_cast .)
    CHECK           reduce using rule 40 (value -> type_cast .)
    SWAP            reduce using rule 40 (value -> type_cast .)
    FUNCTION_NAME   reduce using rule 40 (value -> type_cast .)
    DISPLAY         reduce using rule 40 (value -> type_cast .)
    IDENT           reduce using rule 40 (value -> type_cast .)
    FOR             reduce using rule 40 (value -> type_cast .)
    UNTIL           reduce using rule 40 (value -> type_cast .)
    REPEAT          reduce using rule 40 (value -> type_cast .)
    INPUT           reduce using rule 40 (value -> type_cast .)
    INT             reduce using rule 40 (value -> type_cast .)
    FLT             reduce using rule 40 (value -> type_cast .)
    BLN             reduce using rule 40 (value -> type_cast .)
    CHR             reduce using rule 40 (value -> type_cast .)
    STR             reduce using rule 40 (value -> type_cast .)
    REVIVE          reduce using rule 40 (value -> type_cast .)
    SHIFT           reduce using rule 40 (value -> type_cast .)
    OTHERWISE       reduce using rule 40 (value -> type_cast .)
    RPAREN          reduce using rule 40 (value -> type_cast .)
    COLON           reduce using rule 40 (value -> type_cast .)


state 190

    (41) value -> expression .

    NEWLINE         reduce using rule 41 (value -> expression .)
    RBRACE          reduce using rule 41 (value -> expression .)
    COMMA           reduce using rule 41 (value -> expression .)
    CHECK           reduce using rule 41 (value -> expression .)
    SWAP            reduce using rule 41 (value -> expression .)
    FUNCTION_NAME   reduce using rule 41 (value -> expression .)
    DISPLAY         reduce using rule 41 (value -> expression .)
    IDENT           reduce using rule 41 (value -> expression .)
    FOR             reduce using rule 41 (value -> expression .)
    UNTIL           reduce using rule 41 (value -> expression .)
    REPEAT          reduce using rule 41 (value -> expression .)
    INPUT           reduce using rule 41 (value -> expression .)
    INT             reduce using rule 41 (value -> expression .)
    FLT             reduce using rule 41 (value -> expression .)
    BLN             reduce using rule 41 (value -> expression .)
    CHR             reduce using rule 41 (value -> expression .)
    STR             reduce using rule 41 (value -> expression .)
    REVIVE          reduce using rule 41 (value -> expression .)
    SHIFT           reduce using rule 41 (value -> expression .)
    OTHERWISE       reduce using rule 41 (value -> expression .)
    RPAREN          reduce using rule 41 (value -> expression .)
    COLON           reduce using rule 41 (value -> expression .)


state 191

    (42) value -> function_call .

    NEWLINE         reduce using rule 42 (value -> function_call .)
    RBRACE          reduce using rule 42 (value -> function_call .)
    COMMA           reduce using rule 42 (value -> function_call .)
    CHECK           reduce using rule 42 (value -> function_call .)
    SWAP            reduce using rule 42 (value -> function_call .)
    FUNCTION_NAME   reduce using rule 42 (value -> function_call .)
    DISPLAY         reduce using rule 42 (value -> function_call .)
    IDENT           reduce using rule 42 (value -> function_call .)
    FOR             reduce using rule 42 (value -> function_call .)
    UNTIL           reduce using rule 42 (value -> function_call .)
    REPEAT          reduce using rule 42 (value -> function_call .)
    INPUT           reduce using rule 42 (value -> function_call .)
    INT             reduce using rule 42 (value -> function_call .)
    FLT             reduce using rule 42 (value -> function_call .)
    BLN             reduce using rule 42 (value -> function_call .)
    CHR             reduce using rule 42 (value -> function_call .)
    STR             reduce using rule 42 (value -> function_call .)
    REVIVE          reduce using rule 42 (value -> function_call .)
    SHIFT           reduce using rule 42 (value -> function_call .)
    OTHERWISE       reduce using rule 42 (value -> function_call .)
    RPAREN          reduce using rule 42 (value -> function_call .)
    COLON           reduce using rule 42 (value -> function_call .)


state 192

    (43) type_cast -> CONVERT_TO_INT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 230


state 193

    (44) type_cast -> CONVERT_TO_FLT . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 231


state 194

    (45) type_cast -> CONVERT_TO_BLN . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 232


state 195

    (46) type_cast -> CONVERT_TO_STR . LPAREN typecast_value RPAREN

    LPAREN          shift and go to state 233


state 196

    (108) statements_tail -> local_dec maybe_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (152) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (123) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (127) loop_statement -> . for_loop
    (128) loop_statement -> . until_loop
    (129) loop_statement -> . repeat_until
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (147) output_statement -> . DISPLAY value next_val
    (148) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (130) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (132) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (151) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 175
    DISPLAY         shift and go to state 177
    IDENT           shift and go to state 56
    FOR             shift and go to state 178
    UNTIL           shift and go to state 179
    REPEAT          shift and go to state 180
    INPUT           shift and go to state 181
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    local_dec                      shift and go to state 160
    statements_tail                shift and go to state 234
    empty                          shift and go to state 162
    string_operation_statement     shift and go to state 163
    conditional_statement          shift and go to state 164
    switch_statement               shift and go to state 165
    loop_statement                 shift and go to state 166
    function_call                  shift and go to state 167
    output_statement               shift and go to state 168
    var_statement                  shift and go to state 149
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 176
    data_type                      shift and go to state 150

state 197

    (109) statements_tail -> string_operation_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (152) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (123) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (127) loop_statement -> . for_loop
    (128) loop_statement -> . until_loop
    (129) loop_statement -> . repeat_until
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (147) output_statement -> . DISPLAY value next_val
    (148) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (130) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (132) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (151) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 175
    DISPLAY         shift and go to state 177
    IDENT           shift and go to state 56
    FOR             shift and go to state 178
    UNTIL           shift and go to state 179
    REPEAT          shift and go to state 180
    INPUT           shift and go to state 181
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    string_operation_statement     shift and go to state 163
    statements_tail                shift and go to state 235
    empty                          shift and go to state 162
    local_dec                      shift and go to state 160
    conditional_statement          shift and go to state 164
    switch_statement               shift and go to state 165
    loop_statement                 shift and go to state 166
    function_call                  shift and go to state 167
    output_statement               shift and go to state 168
    var_statement                  shift and go to state 149
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 176
    data_type                      shift and go to state 150

state 198

    (110) statements_tail -> conditional_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (152) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (123) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (127) loop_statement -> . for_loop
    (128) loop_statement -> . until_loop
    (129) loop_statement -> . repeat_until
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (147) output_statement -> . DISPLAY value next_val
    (148) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (130) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (132) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (151) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 175
    DISPLAY         shift and go to state 177
    IDENT           shift and go to state 56
    FOR             shift and go to state 178
    UNTIL           shift and go to state 179
    REPEAT          shift and go to state 180
    INPUT           shift and go to state 181
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    conditional_statement          shift and go to state 164
    statements_tail                shift and go to state 236
    empty                          shift and go to state 162
    local_dec                      shift and go to state 160
    string_operation_statement     shift and go to state 163
    switch_statement               shift and go to state 165
    loop_statement                 shift and go to state 166
    function_call                  shift and go to state 167
    output_statement               shift and go to state 168
    var_statement                  shift and go to state 149
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 176
    data_type                      shift and go to state 150

state 199

    (111) statements_tail -> switch_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (152) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (123) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (127) loop_statement -> . for_loop
    (128) loop_statement -> . until_loop
    (129) loop_statement -> . repeat_until
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (147) output_statement -> . DISPLAY value next_val
    (148) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (130) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (132) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (151) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 175
    DISPLAY         shift and go to state 177
    IDENT           shift and go to state 56
    FOR             shift and go to state 178
    UNTIL           shift and go to state 179
    REPEAT          shift and go to state 180
    INPUT           shift and go to state 181
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    switch_statement               shift and go to state 165
    statements_tail                shift and go to state 237
    empty                          shift and go to state 162
    local_dec                      shift and go to state 160
    string_operation_statement     shift and go to state 163
    conditional_statement          shift and go to state 164
    loop_statement                 shift and go to state 166
    function_call                  shift and go to state 167
    output_statement               shift and go to state 168
    var_statement                  shift and go to state 149
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 176
    data_type                      shift and go to state 150

state 200

    (112) statements_tail -> loop_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (152) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (123) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (127) loop_statement -> . for_loop
    (128) loop_statement -> . until_loop
    (129) loop_statement -> . repeat_until
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (147) output_statement -> . DISPLAY value next_val
    (148) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (130) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (132) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (151) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 175
    DISPLAY         shift and go to state 177
    IDENT           shift and go to state 56
    FOR             shift and go to state 178
    UNTIL           shift and go to state 179
    REPEAT          shift and go to state 180
    INPUT           shift and go to state 181
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    loop_statement                 shift and go to state 166
    statements_tail                shift and go to state 238
    empty                          shift and go to state 162
    local_dec                      shift and go to state 160
    string_operation_statement     shift and go to state 163
    conditional_statement          shift and go to state 164
    switch_statement               shift and go to state 165
    function_call                  shift and go to state 167
    output_statement               shift and go to state 168
    var_statement                  shift and go to state 149
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 176
    data_type                      shift and go to state 150

state 201

    (113) statements_tail -> function_call unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (152) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (123) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (127) loop_statement -> . for_loop
    (128) loop_statement -> . until_loop
    (129) loop_statement -> . repeat_until
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (147) output_statement -> . DISPLAY value next_val
    (148) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (130) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (132) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (151) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 175
    DISPLAY         shift and go to state 177
    IDENT           shift and go to state 56
    FOR             shift and go to state 178
    UNTIL           shift and go to state 179
    REPEAT          shift and go to state 180
    INPUT           shift and go to state 181
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    function_call                  shift and go to state 167
    statements_tail                shift and go to state 239
    empty                          shift and go to state 162
    local_dec                      shift and go to state 160
    string_operation_statement     shift and go to state 163
    conditional_statement          shift and go to state 164
    switch_statement               shift and go to state 165
    loop_statement                 shift and go to state 166
    output_statement               shift and go to state 168
    var_statement                  shift and go to state 149
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 176
    data_type                      shift and go to state 150

state 202

    (114) statements_tail -> output_statement unli_newline . statements_tail
    (107) statements_tail -> . empty
    (108) statements_tail -> . local_dec maybe_newline statements_tail
    (109) statements_tail -> . string_operation_statement unli_newline statements_tail
    (110) statements_tail -> . conditional_statement unli_newline statements_tail
    (111) statements_tail -> . switch_statement unli_newline statements_tail
    (112) statements_tail -> . loop_statement unli_newline statements_tail
    (113) statements_tail -> . function_call unli_newline statements_tail
    (114) statements_tail -> . output_statement unli_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (152) string_operation_statement -> . var_call string_operation_tail
    (117) conditional_statement -> . CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (123) switch_statement -> . SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (127) loop_statement -> . for_loop
    (128) loop_statement -> . until_loop
    (129) loop_statement -> . repeat_until
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (147) output_statement -> . DISPLAY value next_val
    (148) output_statement -> . DISPLAY LPAREN value next_val RPAREN
    (21) var_statement -> . data_type IDENT var_tail
    (82) var_call -> . IDENT var_call_tail
    (130) for_loop -> . FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (131) until_loop -> . UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE
    (132) repeat_until -> . REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (151) input_statement -> . INPUT LPAREN RPAREN
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for CHECK resolved as shift
  ! shift/reduce conflict for SWAP resolved as shift
  ! shift/reduce conflict for FUNCTION_NAME resolved as shift
  ! shift/reduce conflict for DISPLAY resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           shift and go to state 170
    SWAP            shift and go to state 171
    FUNCTION_NAME   shift and go to state 175
    DISPLAY         shift and go to state 177
    IDENT           shift and go to state 56
    FOR             shift and go to state 178
    UNTIL           shift and go to state 179
    REPEAT          shift and go to state 180
    INPUT           shift and go to state 181
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! CHECK           [ reduce using rule 165 (empty -> .) ]
  ! SWAP            [ reduce using rule 165 (empty -> .) ]
  ! FUNCTION_NAME   [ reduce using rule 165 (empty -> .) ]
  ! DISPLAY         [ reduce using rule 165 (empty -> .) ]
  ! IDENT           [ reduce using rule 165 (empty -> .) ]
  ! FOR             [ reduce using rule 165 (empty -> .) ]
  ! UNTIL           [ reduce using rule 165 (empty -> .) ]
  ! REPEAT          [ reduce using rule 165 (empty -> .) ]
  ! INPUT           [ reduce using rule 165 (empty -> .) ]
  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    output_statement               shift and go to state 168
    statements_tail                shift and go to state 240
    empty                          shift and go to state 162
    local_dec                      shift and go to state 160
    string_operation_statement     shift and go to state 163
    conditional_statement          shift and go to state 164
    switch_statement               shift and go to state 165
    loop_statement                 shift and go to state 166
    function_call                  shift and go to state 167
    var_statement                  shift and go to state 149
    var_call                       shift and go to state 169
    for_loop                       shift and go to state 172
    until_loop                     shift and go to state 173
    repeat_until                   shift and go to state 174
    input_statement                shift and go to state 176
    data_type                      shift and go to state 150

state 203

    (152) string_operation_statement -> var_call string_operation_tail .

    NEWLINE         reduce using rule 152 (string_operation_statement -> var_call string_operation_tail .)


state 204

    (153) string_operation_tail -> PLUS . string_val stringcon_tail
    (163) string_val -> . var_call
    (164) string_val -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 243
    IDENT           shift and go to state 56

    string_val                     shift and go to state 241
    var_call                       shift and go to state 242

state 205

    (154) string_operation_tail -> update_tail .

    NEWLINE         reduce using rule 154 (string_operation_tail -> update_tail .)


state 206

    (135) update_tail -> postfix .

    NEWLINE         reduce using rule 135 (update_tail -> postfix .)
    RPAREN          reduce using rule 135 (update_tail -> postfix .)


state 207

    (136) update_tail -> assign_op . value
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 192
    CONVERT_TO_FLT  shift and go to state 193
    CONVERT_TO_BLN  shift and go to state 194
    CONVERT_TO_STR  shift and go to state 195
    FUNCTION_NAME   shift and go to state 175
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181

    value                          shift and go to state 244
    factor                         shift and go to state 188
    type_cast                      shift and go to state 189
    expression                     shift and go to state 190
    function_call                  shift and go to state 191
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 176
    term                           shift and go to state 63

state 208

    (137) postfix -> PLUS_PLUS .

    NEWLINE         reduce using rule 137 (postfix -> PLUS_PLUS .)
    RPAREN          reduce using rule 137 (postfix -> PLUS_PLUS .)


state 209

    (138) postfix -> MINUS_MINUS .

    NEWLINE         reduce using rule 138 (postfix -> MINUS_MINUS .)
    RPAREN          reduce using rule 138 (postfix -> MINUS_MINUS .)


state 210

    (155) assign_op -> PLUS_EQ .

    TILDE           reduce using rule 155 (assign_op -> PLUS_EQ .)
    LPAREN          reduce using rule 155 (assign_op -> PLUS_EQ .)
    CONVERT_TO_INT  reduce using rule 155 (assign_op -> PLUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 155 (assign_op -> PLUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 155 (assign_op -> PLUS_EQ .)
    CONVERT_TO_STR  reduce using rule 155 (assign_op -> PLUS_EQ .)
    FUNCTION_NAME   reduce using rule 155 (assign_op -> PLUS_EQ .)
    IDENT           reduce using rule 155 (assign_op -> PLUS_EQ .)
    INT_LIT         reduce using rule 155 (assign_op -> PLUS_EQ .)
    FLT_LIT         reduce using rule 155 (assign_op -> PLUS_EQ .)
    DAY             reduce using rule 155 (assign_op -> PLUS_EQ .)
    NIGHT           reduce using rule 155 (assign_op -> PLUS_EQ .)
    CHR_LIT         reduce using rule 155 (assign_op -> PLUS_EQ .)
    STR_LIT         reduce using rule 155 (assign_op -> PLUS_EQ .)
    INPUT           reduce using rule 155 (assign_op -> PLUS_EQ .)


state 211

    (156) assign_op -> MINUS_EQ .

    TILDE           reduce using rule 156 (assign_op -> MINUS_EQ .)
    LPAREN          reduce using rule 156 (assign_op -> MINUS_EQ .)
    CONVERT_TO_INT  reduce using rule 156 (assign_op -> MINUS_EQ .)
    CONVERT_TO_FLT  reduce using rule 156 (assign_op -> MINUS_EQ .)
    CONVERT_TO_BLN  reduce using rule 156 (assign_op -> MINUS_EQ .)
    CONVERT_TO_STR  reduce using rule 156 (assign_op -> MINUS_EQ .)
    FUNCTION_NAME   reduce using rule 156 (assign_op -> MINUS_EQ .)
    IDENT           reduce using rule 156 (assign_op -> MINUS_EQ .)
    INT_LIT         reduce using rule 156 (assign_op -> MINUS_EQ .)
    FLT_LIT         reduce using rule 156 (assign_op -> MINUS_EQ .)
    DAY             reduce using rule 156 (assign_op -> MINUS_EQ .)
    NIGHT           reduce using rule 156 (assign_op -> MINUS_EQ .)
    CHR_LIT         reduce using rule 156 (assign_op -> MINUS_EQ .)
    STR_LIT         reduce using rule 156 (assign_op -> MINUS_EQ .)
    INPUT           reduce using rule 156 (assign_op -> MINUS_EQ .)


state 212

    (157) assign_op -> MUL_EQ .

    TILDE           reduce using rule 157 (assign_op -> MUL_EQ .)
    LPAREN          reduce using rule 157 (assign_op -> MUL_EQ .)
    CONVERT_TO_INT  reduce using rule 157 (assign_op -> MUL_EQ .)
    CONVERT_TO_FLT  reduce using rule 157 (assign_op -> MUL_EQ .)
    CONVERT_TO_BLN  reduce using rule 157 (assign_op -> MUL_EQ .)
    CONVERT_TO_STR  reduce using rule 157 (assign_op -> MUL_EQ .)
    FUNCTION_NAME   reduce using rule 157 (assign_op -> MUL_EQ .)
    IDENT           reduce using rule 157 (assign_op -> MUL_EQ .)
    INT_LIT         reduce using rule 157 (assign_op -> MUL_EQ .)
    FLT_LIT         reduce using rule 157 (assign_op -> MUL_EQ .)
    DAY             reduce using rule 157 (assign_op -> MUL_EQ .)
    NIGHT           reduce using rule 157 (assign_op -> MUL_EQ .)
    CHR_LIT         reduce using rule 157 (assign_op -> MUL_EQ .)
    STR_LIT         reduce using rule 157 (assign_op -> MUL_EQ .)
    INPUT           reduce using rule 157 (assign_op -> MUL_EQ .)


state 213

    (158) assign_op -> DIV_EQ .

    TILDE           reduce using rule 158 (assign_op -> DIV_EQ .)
    LPAREN          reduce using rule 158 (assign_op -> DIV_EQ .)
    CONVERT_TO_INT  reduce using rule 158 (assign_op -> DIV_EQ .)
    CONVERT_TO_FLT  reduce using rule 158 (assign_op -> DIV_EQ .)
    CONVERT_TO_BLN  reduce using rule 158 (assign_op -> DIV_EQ .)
    CONVERT_TO_STR  reduce using rule 158 (assign_op -> DIV_EQ .)
    FUNCTION_NAME   reduce using rule 158 (assign_op -> DIV_EQ .)
    IDENT           reduce using rule 158 (assign_op -> DIV_EQ .)
    INT_LIT         reduce using rule 158 (assign_op -> DIV_EQ .)
    FLT_LIT         reduce using rule 158 (assign_op -> DIV_EQ .)
    DAY             reduce using rule 158 (assign_op -> DIV_EQ .)
    NIGHT           reduce using rule 158 (assign_op -> DIV_EQ .)
    CHR_LIT         reduce using rule 158 (assign_op -> DIV_EQ .)
    STR_LIT         reduce using rule 158 (assign_op -> DIV_EQ .)
    INPUT           reduce using rule 158 (assign_op -> DIV_EQ .)


state 214

    (159) assign_op -> MOD_EQ .

    TILDE           reduce using rule 159 (assign_op -> MOD_EQ .)
    LPAREN          reduce using rule 159 (assign_op -> MOD_EQ .)
    CONVERT_TO_INT  reduce using rule 159 (assign_op -> MOD_EQ .)
    CONVERT_TO_FLT  reduce using rule 159 (assign_op -> MOD_EQ .)
    CONVERT_TO_BLN  reduce using rule 159 (assign_op -> MOD_EQ .)
    CONVERT_TO_STR  reduce using rule 159 (assign_op -> MOD_EQ .)
    FUNCTION_NAME   reduce using rule 159 (assign_op -> MOD_EQ .)
    IDENT           reduce using rule 159 (assign_op -> MOD_EQ .)
    INT_LIT         reduce using rule 159 (assign_op -> MOD_EQ .)
    FLT_LIT         reduce using rule 159 (assign_op -> MOD_EQ .)
    DAY             reduce using rule 159 (assign_op -> MOD_EQ .)
    NIGHT           reduce using rule 159 (assign_op -> MOD_EQ .)
    CHR_LIT         reduce using rule 159 (assign_op -> MOD_EQ .)
    STR_LIT         reduce using rule 159 (assign_op -> MOD_EQ .)
    INPUT           reduce using rule 159 (assign_op -> MOD_EQ .)


state 215

    (160) assign_op -> EQ .

    TILDE           reduce using rule 160 (assign_op -> EQ .)
    LPAREN          reduce using rule 160 (assign_op -> EQ .)
    CONVERT_TO_INT  reduce using rule 160 (assign_op -> EQ .)
    CONVERT_TO_FLT  reduce using rule 160 (assign_op -> EQ .)
    CONVERT_TO_BLN  reduce using rule 160 (assign_op -> EQ .)
    CONVERT_TO_STR  reduce using rule 160 (assign_op -> EQ .)
    FUNCTION_NAME   reduce using rule 160 (assign_op -> EQ .)
    IDENT           reduce using rule 160 (assign_op -> EQ .)
    INT_LIT         reduce using rule 160 (assign_op -> EQ .)
    FLT_LIT         reduce using rule 160 (assign_op -> EQ .)
    DAY             reduce using rule 160 (assign_op -> EQ .)
    NIGHT           reduce using rule 160 (assign_op -> EQ .)
    CHR_LIT         reduce using rule 160 (assign_op -> EQ .)
    STR_LIT         reduce using rule 160 (assign_op -> EQ .)
    INPUT           reduce using rule 160 (assign_op -> EQ .)


state 216

    (117) conditional_statement -> CHECK LPAREN . expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 245
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 217

    (123) switch_statement -> SWAP LPAREN . IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    IDENT           shift and go to state 246


state 218

    (139) function_call -> FUNCTION_NAME LPAREN . arguments RPAREN
    (141) arguments -> . empty
    (142) arguments -> . arg_value arg_tail
    (165) empty -> .
    (145) arg_value -> . literal
    (146) arg_value -> . var_call
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    RPAREN          reduce using rule 165 (empty -> .)
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    IDENT           shift and go to state 56

    arguments                      shift and go to state 247
    empty                          shift and go to state 248
    arg_value                      shift and go to state 249
    literal                        shift and go to state 250
    var_call                       shift and go to state 251

state 219

    (147) output_statement -> DISPLAY value . next_val
    (149) next_val -> . empty
    (150) next_val -> . COMMA value next_val
    (165) empty -> .

    COMMA           shift and go to state 254
    NEWLINE         reduce using rule 165 (empty -> .)

    next_val                       shift and go to state 252
    empty                          shift and go to state 253

state 220

    (148) output_statement -> DISPLAY LPAREN . value next_val RPAREN
    (64) factor -> LPAREN . expression RPAREN
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (58) expression -> . expr_head expr_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (59) expr_head -> . term term_tail
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (151) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 192
    CONVERT_TO_FLT  shift and go to state 193
    CONVERT_TO_BLN  shift and go to state 194
    CONVERT_TO_STR  shift and go to state 195
    FUNCTION_NAME   shift and go to state 175
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181

    value                          shift and go to state 255
    expression                     shift and go to state 256
    factor                         shift and go to state 188
    type_cast                      shift and go to state 189
    function_call                  shift and go to state 191
    expr_head                      shift and go to state 55
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    input_statement                shift and go to state 176
    term                           shift and go to state 63

state 221

    (130) for_loop -> FOR LPAREN . control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (133) control_variable -> . INT IDENT EQ INT_LIT

    INT             shift and go to state 258

    control_variable               shift and go to state 257

state 222

    (131) until_loop -> UNTIL LPAREN . expression RPAREN LBRACE maybe_newline statements RBRACE
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 259
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 223

    (132) repeat_until -> REPEAT LBRACE . maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 260
    empty                          shift and go to state 16

state 224

    (151) input_statement -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 261


state 225

    (23) var_tail -> EQ tail_value . var_tail2
    (25) var_tail2 -> . empty
    (26) var_tail2 -> . COMMA IDENT var_tail
    (165) empty -> .

    COMMA           shift and go to state 264
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

    var_tail2                      shift and go to state 262
    empty                          shift and go to state 263

state 226

    (27) tail_value -> value .

    COMMA           reduce using rule 27 (tail_value -> value .)
    NEWLINE         reduce using rule 27 (tail_value -> value .)
    CHECK           reduce using rule 27 (tail_value -> value .)
    SWAP            reduce using rule 27 (tail_value -> value .)
    FUNCTION_NAME   reduce using rule 27 (tail_value -> value .)
    DISPLAY         reduce using rule 27 (tail_value -> value .)
    IDENT           reduce using rule 27 (tail_value -> value .)
    FOR             reduce using rule 27 (tail_value -> value .)
    UNTIL           reduce using rule 27 (tail_value -> value .)
    REPEAT          reduce using rule 27 (tail_value -> value .)
    INPUT           reduce using rule 27 (tail_value -> value .)
    INT             reduce using rule 27 (tail_value -> value .)
    FLT             reduce using rule 27 (tail_value -> value .)
    BLN             reduce using rule 27 (tail_value -> value .)
    CHR             reduce using rule 27 (tail_value -> value .)
    STR             reduce using rule 27 (tail_value -> value .)
    RBRACE          reduce using rule 27 (tail_value -> value .)
    REVIVE          reduce using rule 27 (tail_value -> value .)
    SHIFT           reduce using rule 27 (tail_value -> value .)
    OTHERWISE       reduce using rule 27 (tail_value -> value .)


state 227

    (28) tail_value -> LBRACKET . list_element RBRACKET
    (29) list_element -> . literal element_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    list_element                   shift and go to state 265
    literal                        shift and go to state 72

state 228

    (24) var_tail -> COMMA IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (165) empty -> .

    EQ              shift and go to state 184
    COMMA           shift and go to state 185
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

    var_tail                       shift and go to state 266
    empty                          shift and go to state 183

state 229

    (85) function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .

    NEWLINE         reduce using rule 85 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .)
    MAIN_CASPER     reduce using rule 85 (function_statements -> maybe_newline ret_type FUNCTION_NAME LPAREN parameters RPAREN maybe_newline LBRACE unli_newline statements revive maybe_newline RBRACE .)


state 230

    (43) type_cast -> CONVERT_TO_INT LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 268
    FUNCTION_NAME   shift and go to state 271
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 267
    literal                        shift and go to state 269
    expression                     shift and go to state 270
    input_statement                shift and go to state 272
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 231

    (44) type_cast -> CONVERT_TO_FLT LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 268
    FUNCTION_NAME   shift and go to state 271
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 273
    literal                        shift and go to state 269
    expression                     shift and go to state 270
    input_statement                shift and go to state 272
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 232

    (45) type_cast -> CONVERT_TO_BLN LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 268
    FUNCTION_NAME   shift and go to state 271
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 274
    literal                        shift and go to state 269
    expression                     shift and go to state 270
    input_statement                shift and go to state 272
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 233

    (46) type_cast -> CONVERT_TO_STR LPAREN . typecast_value RPAREN
    (47) typecast_value -> . IDENT
    (48) typecast_value -> . literal
    (49) typecast_value -> . expression
    (50) typecast_value -> . FUNCTION_NAME LPAREN RPAREN
    (51) typecast_value -> . input_statement
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (58) expression -> . expr_head expr_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 268
    FUNCTION_NAME   shift and go to state 271
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181
    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54

    typecast_value                 shift and go to state 275
    literal                        shift and go to state 269
    expression                     shift and go to state 270
    input_statement                shift and go to state 272
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51

state 234

    (108) statements_tail -> local_dec maybe_newline statements_tail .

    NEWLINE         reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)
    RBRACE          reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)
    REVIVE          reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)
    SHIFT           reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)
    OTHERWISE       reduce using rule 108 (statements_tail -> local_dec maybe_newline statements_tail .)


state 235

    (109) statements_tail -> string_operation_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 109 (statements_tail -> string_operation_statement unli_newline statements_tail .)


state 236

    (110) statements_tail -> conditional_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 110 (statements_tail -> conditional_statement unli_newline statements_tail .)


state 237

    (111) statements_tail -> switch_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 111 (statements_tail -> switch_statement unli_newline statements_tail .)


state 238

    (112) statements_tail -> loop_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 112 (statements_tail -> loop_statement unli_newline statements_tail .)


state 239

    (113) statements_tail -> function_call unli_newline statements_tail .

    NEWLINE         reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)
    RBRACE          reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)
    REVIVE          reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)
    SHIFT           reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)
    OTHERWISE       reduce using rule 113 (statements_tail -> function_call unli_newline statements_tail .)


state 240

    (114) statements_tail -> output_statement unli_newline statements_tail .

    NEWLINE         reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)
    RBRACE          reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)
    REVIVE          reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)
    SHIFT           reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)
    OTHERWISE       reduce using rule 114 (statements_tail -> output_statement unli_newline statements_tail .)


state 241

    (153) string_operation_tail -> PLUS string_val . stringcon_tail
    (161) stringcon_tail -> . empty
    (162) stringcon_tail -> . PLUS string_val stringcon_tail
    (165) empty -> .

    PLUS            shift and go to state 276
    NEWLINE         reduce using rule 165 (empty -> .)

    stringcon_tail                 shift and go to state 277
    empty                          shift and go to state 278

state 242

    (163) string_val -> var_call .

    PLUS            reduce using rule 163 (string_val -> var_call .)
    NEWLINE         reduce using rule 163 (string_val -> var_call .)


state 243

    (164) string_val -> STR_LIT .

    PLUS            reduce using rule 164 (string_val -> STR_LIT .)
    NEWLINE         reduce using rule 164 (string_val -> STR_LIT .)


state 244

    (136) update_tail -> assign_op value .

    NEWLINE         reduce using rule 136 (update_tail -> assign_op value .)
    RPAREN          reduce using rule 136 (update_tail -> assign_op value .)


state 245

    (117) conditional_statement -> CHECK LPAREN expression . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    RPAREN          shift and go to state 279


state 246

    (123) switch_statement -> SWAP LPAREN IDENT . RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    RPAREN          shift and go to state 280


state 247

    (139) function_call -> FUNCTION_NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 281


state 248

    (141) arguments -> empty .

    RPAREN          reduce using rule 141 (arguments -> empty .)


state 249

    (142) arguments -> arg_value . arg_tail
    (143) arg_tail -> . empty
    (144) arg_tail -> . COMMA arg_value arg_tail
    (165) empty -> .

    COMMA           shift and go to state 284
    RPAREN          reduce using rule 165 (empty -> .)

    arg_tail                       shift and go to state 282
    empty                          shift and go to state 283

state 250

    (145) arg_value -> literal .

    COMMA           reduce using rule 145 (arg_value -> literal .)
    RPAREN          reduce using rule 145 (arg_value -> literal .)


state 251

    (146) arg_value -> var_call .

    COMMA           reduce using rule 146 (arg_value -> var_call .)
    RPAREN          reduce using rule 146 (arg_value -> var_call .)


state 252

    (147) output_statement -> DISPLAY value next_val .

    NEWLINE         reduce using rule 147 (output_statement -> DISPLAY value next_val .)


state 253

    (149) next_val -> empty .

    NEWLINE         reduce using rule 149 (next_val -> empty .)
    RPAREN          reduce using rule 149 (next_val -> empty .)


state 254

    (150) next_val -> COMMA . value next_val
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 192
    CONVERT_TO_FLT  shift and go to state 193
    CONVERT_TO_BLN  shift and go to state 194
    CONVERT_TO_STR  shift and go to state 195
    FUNCTION_NAME   shift and go to state 175
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181

    value                          shift and go to state 285
    factor                         shift and go to state 188
    type_cast                      shift and go to state 189
    expression                     shift and go to state 190
    function_call                  shift and go to state 191
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 176
    term                           shift and go to state 63

state 255

    (148) output_statement -> DISPLAY LPAREN value . next_val RPAREN
    (149) next_val -> . empty
    (150) next_val -> . COMMA value next_val
    (165) empty -> .

    COMMA           shift and go to state 254
    RPAREN          reduce using rule 165 (empty -> .)

    next_val                       shift and go to state 286
    empty                          shift and go to state 253

state 256

    (64) factor -> LPAREN expression . RPAREN
    (41) value -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 113
    COMMA           reduce using rule 41 (value -> expression .)

  ! RPAREN          [ reduce using rule 41 (value -> expression .) ]


state 257

    (130) for_loop -> FOR LPAREN control_variable . SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 287


state 258

    (133) control_variable -> INT . IDENT EQ INT_LIT

    IDENT           shift and go to state 288


state 259

    (131) until_loop -> UNTIL LPAREN expression . RPAREN LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 289


state 260

    (132) repeat_until -> REPEAT LBRACE maybe_newline . statements RBRACE UNTIL LPAREN expression RPAREN
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 290
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 261

    (151) input_statement -> INPUT LPAREN RPAREN .

    NEWLINE         reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    RBRACE          reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    COMMA           reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    CHECK           reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    SWAP            reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    FUNCTION_NAME   reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    DISPLAY         reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    IDENT           reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    FOR             reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    UNTIL           reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    REPEAT          reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    INPUT           reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    INT             reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    FLT             reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    BLN             reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    CHR             reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    STR             reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    REVIVE          reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    SHIFT           reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    OTHERWISE       reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    RPAREN          reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)
    COLON           reduce using rule 151 (input_statement -> INPUT LPAREN RPAREN .)


state 262

    (23) var_tail -> EQ tail_value var_tail2 .

    NEWLINE         reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    CHECK           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    SWAP            reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    FUNCTION_NAME   reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    DISPLAY         reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    IDENT           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    FOR             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    UNTIL           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    REPEAT          reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    INPUT           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    INT             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    FLT             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    BLN             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    CHR             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    STR             reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    RBRACE          reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    REVIVE          reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    SHIFT           reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)
    OTHERWISE       reduce using rule 23 (var_tail -> EQ tail_value var_tail2 .)


state 263

    (25) var_tail2 -> empty .

    NEWLINE         reduce using rule 25 (var_tail2 -> empty .)
    CHECK           reduce using rule 25 (var_tail2 -> empty .)
    SWAP            reduce using rule 25 (var_tail2 -> empty .)
    FUNCTION_NAME   reduce using rule 25 (var_tail2 -> empty .)
    DISPLAY         reduce using rule 25 (var_tail2 -> empty .)
    IDENT           reduce using rule 25 (var_tail2 -> empty .)
    FOR             reduce using rule 25 (var_tail2 -> empty .)
    UNTIL           reduce using rule 25 (var_tail2 -> empty .)
    REPEAT          reduce using rule 25 (var_tail2 -> empty .)
    INPUT           reduce using rule 25 (var_tail2 -> empty .)
    INT             reduce using rule 25 (var_tail2 -> empty .)
    FLT             reduce using rule 25 (var_tail2 -> empty .)
    BLN             reduce using rule 25 (var_tail2 -> empty .)
    CHR             reduce using rule 25 (var_tail2 -> empty .)
    STR             reduce using rule 25 (var_tail2 -> empty .)
    RBRACE          reduce using rule 25 (var_tail2 -> empty .)
    REVIVE          reduce using rule 25 (var_tail2 -> empty .)
    SHIFT           reduce using rule 25 (var_tail2 -> empty .)
    OTHERWISE       reduce using rule 25 (var_tail2 -> empty .)


state 264

    (26) var_tail2 -> COMMA . IDENT var_tail

    IDENT           shift and go to state 291


state 265

    (28) tail_value -> LBRACKET list_element . RBRACKET

    RBRACKET        shift and go to state 292


state 266

    (24) var_tail -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    CHECK           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    SWAP            reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    FUNCTION_NAME   reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    DISPLAY         reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    IDENT           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    FOR             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    UNTIL           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    REPEAT          reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    INPUT           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    INT             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    FLT             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    BLN             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    CHR             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    STR             reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    RBRACE          reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    REVIVE          reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    SHIFT           reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)
    OTHERWISE       reduce using rule 24 (var_tail -> COMMA IDENT var_tail .)


state 267

    (43) type_cast -> CONVERT_TO_INT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 293


state 268

    (47) typecast_value -> IDENT .
    (82) var_call -> IDENT . var_call_tail
    (83) var_call_tail -> . empty
    (84) var_call_tail -> . LBRACKET index RBRACKET
    (165) empty -> .

  ! reduce/reduce conflict for RPAREN resolved using rule 47 (typecast_value -> IDENT .)
    RPAREN          reduce using rule 47 (typecast_value -> IDENT .)
    LBRACKET        shift and go to state 90
    PLUS            reduce using rule 165 (empty -> .)
    MINUS           reduce using rule 165 (empty -> .)
    MULTIPLY        reduce using rule 165 (empty -> .)
    DIVISION        reduce using rule 165 (empty -> .)
    MODULO          reduce using rule 165 (empty -> .)
    EXPONENT        reduce using rule 165 (empty -> .)
    GT              reduce using rule 165 (empty -> .)
    LT              reduce using rule 165 (empty -> .)
    EQ_EQ           reduce using rule 165 (empty -> .)
    GT_EQ           reduce using rule 165 (empty -> .)
    LT_EQ           reduce using rule 165 (empty -> .)
    NOT_EQ          reduce using rule 165 (empty -> .)
    AND             reduce using rule 165 (empty -> .)
    OR              reduce using rule 165 (empty -> .)

  ! RPAREN          [ reduce using rule 165 (empty -> .) ]

    var_call_tail                  shift and go to state 88
    empty                          shift and go to state 89

state 269

    (48) typecast_value -> literal .
    (62) factor -> literal .

  ! reduce/reduce conflict for RPAREN resolved using rule 48 (typecast_value -> literal .)
    RPAREN          reduce using rule 48 (typecast_value -> literal .)
    PLUS            reduce using rule 62 (factor -> literal .)
    MINUS           reduce using rule 62 (factor -> literal .)
    MULTIPLY        reduce using rule 62 (factor -> literal .)
    DIVISION        reduce using rule 62 (factor -> literal .)
    MODULO          reduce using rule 62 (factor -> literal .)
    EXPONENT        reduce using rule 62 (factor -> literal .)
    GT              reduce using rule 62 (factor -> literal .)
    LT              reduce using rule 62 (factor -> literal .)
    EQ_EQ           reduce using rule 62 (factor -> literal .)
    GT_EQ           reduce using rule 62 (factor -> literal .)
    LT_EQ           reduce using rule 62 (factor -> literal .)
    NOT_EQ          reduce using rule 62 (factor -> literal .)
    AND             reduce using rule 62 (factor -> literal .)
    OR              reduce using rule 62 (factor -> literal .)

  ! RPAREN          [ reduce using rule 62 (factor -> literal .) ]


state 270

    (49) typecast_value -> expression .

    RPAREN          reduce using rule 49 (typecast_value -> expression .)


state 271

    (50) typecast_value -> FUNCTION_NAME . LPAREN RPAREN

    LPAREN          shift and go to state 294


state 272

    (51) typecast_value -> input_statement .

    RPAREN          reduce using rule 51 (typecast_value -> input_statement .)


state 273

    (44) type_cast -> CONVERT_TO_FLT LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 295


state 274

    (45) type_cast -> CONVERT_TO_BLN LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 296


state 275

    (46) type_cast -> CONVERT_TO_STR LPAREN typecast_value . RPAREN

    RPAREN          shift and go to state 297


state 276

    (162) stringcon_tail -> PLUS . string_val stringcon_tail
    (163) string_val -> . var_call
    (164) string_val -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    STR_LIT         shift and go to state 243
    IDENT           shift and go to state 56

    string_val                     shift and go to state 298
    var_call                       shift and go to state 242

state 277

    (153) string_operation_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 153 (string_operation_tail -> PLUS string_val stringcon_tail .)


state 278

    (161) stringcon_tail -> empty .

    NEWLINE         reduce using rule 161 (stringcon_tail -> empty .)


state 279

    (117) conditional_statement -> CHECK LPAREN expression RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 299
    empty                          shift and go to state 16

state 280

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN . LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 300


state 281

    (139) function_call -> FUNCTION_NAME LPAREN arguments RPAREN .

    NEWLINE         reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHECK           reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SWAP            reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FUNCTION_NAME   reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    DISPLAY         reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    IDENT           reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FOR             reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    UNTIL           reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REPEAT          reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INPUT           reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    INT             reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    FLT             reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    BLN             reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    CHR             reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    STR             reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    REVIVE          reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    SHIFT           reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    OTHERWISE       reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)
    COLON           reduce using rule 139 (function_call -> FUNCTION_NAME LPAREN arguments RPAREN .)


state 282

    (142) arguments -> arg_value arg_tail .

    RPAREN          reduce using rule 142 (arguments -> arg_value arg_tail .)


state 283

    (143) arg_tail -> empty .

    RPAREN          reduce using rule 143 (arg_tail -> empty .)


state 284

    (144) arg_tail -> COMMA . arg_value arg_tail
    (145) arg_value -> . literal
    (146) arg_value -> . var_call
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (82) var_call -> . IDENT var_call_tail

    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    IDENT           shift and go to state 56

    arg_value                      shift and go to state 301
    literal                        shift and go to state 250
    var_call                       shift and go to state 251

state 285

    (150) next_val -> COMMA value . next_val
    (149) next_val -> . empty
    (150) next_val -> . COMMA value next_val
    (165) empty -> .

    COMMA           shift and go to state 254
    NEWLINE         reduce using rule 165 (empty -> .)
    RPAREN          reduce using rule 165 (empty -> .)

    next_val                       shift and go to state 302
    empty                          shift and go to state 253

state 286

    (148) output_statement -> DISPLAY LPAREN value next_val . RPAREN

    RPAREN          shift and go to state 303


state 287

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON . expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 304
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 288

    (133) control_variable -> INT IDENT . EQ INT_LIT

    EQ              shift and go to state 305


state 289

    (131) until_loop -> UNTIL LPAREN expression RPAREN . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 306


state 290

    (132) repeat_until -> REPEAT LBRACE maybe_newline statements . RBRACE UNTIL LPAREN expression RPAREN

    RBRACE          shift and go to state 307


state 291

    (26) var_tail2 -> COMMA IDENT . var_tail
    (22) var_tail -> . empty
    (23) var_tail -> . EQ tail_value var_tail2
    (24) var_tail -> . COMMA IDENT var_tail
    (165) empty -> .

    EQ              shift and go to state 184
    COMMA           shift and go to state 185
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    REVIVE          reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

    var_tail                       shift and go to state 308
    empty                          shift and go to state 183

state 292

    (28) tail_value -> LBRACKET list_element RBRACKET .

    COMMA           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    NEWLINE         reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    CHECK           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    SWAP            reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    FUNCTION_NAME   reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    DISPLAY         reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    IDENT           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    FOR             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    UNTIL           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    REPEAT          reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    INPUT           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    INT             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    FLT             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    BLN             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    CHR             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    STR             reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    RBRACE          reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    REVIVE          reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    SHIFT           reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)
    OTHERWISE       reduce using rule 28 (tail_value -> LBRACKET list_element RBRACKET .)


state 293

    (43) type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 43 (type_cast -> CONVERT_TO_INT LPAREN typecast_value RPAREN .)


state 294

    (50) typecast_value -> FUNCTION_NAME LPAREN . RPAREN

    RPAREN          shift and go to state 309


state 295

    (44) type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    INT             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    STR             reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 44 (type_cast -> CONVERT_TO_FLT LPAREN typecast_value RPAREN .)


state 296

    (45) type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    INT             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    STR             reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 45 (type_cast -> CONVERT_TO_BLN LPAREN typecast_value RPAREN .)


state 297

    (46) type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .

    NEWLINE         reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RBRACE          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COMMA           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHECK           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SWAP            reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FUNCTION_NAME   reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    DISPLAY         reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    IDENT           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FOR             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    UNTIL           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REPEAT          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INPUT           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    INT             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    FLT             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    BLN             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    CHR             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    STR             reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    REVIVE          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    SHIFT           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    OTHERWISE       reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    RPAREN          reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)
    COLON           reduce using rule 46 (type_cast -> CONVERT_TO_STR LPAREN typecast_value RPAREN .)


state 298

    (162) stringcon_tail -> PLUS string_val . stringcon_tail
    (161) stringcon_tail -> . empty
    (162) stringcon_tail -> . PLUS string_val stringcon_tail
    (165) empty -> .

    PLUS            shift and go to state 276
    NEWLINE         reduce using rule 165 (empty -> .)

    stringcon_tail                 shift and go to state 310
    empty                          shift and go to state 278

state 299

    (117) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail

    LBRACE          shift and go to state 311


state 300

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE . maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    SHIFT           reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 312
    empty                          shift and go to state 16

state 301

    (144) arg_tail -> COMMA arg_value . arg_tail
    (143) arg_tail -> . empty
    (144) arg_tail -> . COMMA arg_value arg_tail
    (165) empty -> .

    COMMA           shift and go to state 284
    RPAREN          reduce using rule 165 (empty -> .)

    arg_tail                       shift and go to state 313
    empty                          shift and go to state 283

state 302

    (150) next_val -> COMMA value next_val .

    NEWLINE         reduce using rule 150 (next_val -> COMMA value next_val .)
    RPAREN          reduce using rule 150 (next_val -> COMMA value next_val .)


state 303

    (148) output_statement -> DISPLAY LPAREN value next_val RPAREN .

    NEWLINE         reduce using rule 148 (output_statement -> DISPLAY LPAREN value next_val RPAREN .)


state 304

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression . SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    SEMICOLON       shift and go to state 314


state 305

    (133) control_variable -> INT IDENT EQ . INT_LIT

    INT_LIT         shift and go to state 315


state 306

    (131) until_loop -> UNTIL LPAREN expression RPAREN LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 316
    empty                          shift and go to state 16

state 307

    (132) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE . UNTIL LPAREN expression RPAREN

    UNTIL           shift and go to state 317


state 308

    (26) var_tail2 -> COMMA IDENT var_tail .

    NEWLINE         reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    CHECK           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    SWAP            reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    FUNCTION_NAME   reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    DISPLAY         reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    IDENT           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    FOR             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    UNTIL           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    REPEAT          reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    INPUT           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    INT             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    FLT             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    BLN             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    CHR             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    STR             reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    RBRACE          reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    REVIVE          reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    SHIFT           reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)
    OTHERWISE       reduce using rule 26 (var_tail2 -> COMMA IDENT var_tail .)


state 309

    (50) typecast_value -> FUNCTION_NAME LPAREN RPAREN .

    RPAREN          reduce using rule 50 (typecast_value -> FUNCTION_NAME LPAREN RPAREN .)


state 310

    (162) stringcon_tail -> PLUS string_val stringcon_tail .

    NEWLINE         reduce using rule 162 (stringcon_tail -> PLUS string_val stringcon_tail .)


state 311

    (117) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 318
    empty                          shift and go to state 16

state 312

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline . switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (124) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    SHIFT           shift and go to state 320

    switch_condition               shift and go to state 319

state 313

    (144) arg_tail -> COMMA arg_value arg_tail .

    RPAREN          reduce using rule 144 (arg_tail -> COMMA arg_value arg_tail .)


state 314

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON . update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE
    (134) update -> . var_call update_tail
    (82) var_call -> . IDENT var_call_tail

    IDENT           shift and go to state 56

    update                         shift and go to state 321
    var_call                       shift and go to state 322

state 315

    (133) control_variable -> INT IDENT EQ INT_LIT .

    SEMICOLON       reduce using rule 133 (control_variable -> INT IDENT EQ INT_LIT .)


state 316

    (131) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 323
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 317

    (132) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL . LPAREN expression RPAREN

    LPAREN          shift and go to state 324


state 318

    (117) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 325
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 319

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition . maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE       reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 326
    empty                          shift and go to state 16

state 320

    (124) switch_condition -> SHIFT . value COLON maybe_newline statements switchcond_tail
    (39) value -> . factor
    (40) value -> . type_cast
    (41) value -> . expression
    (42) value -> . function_call
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (43) type_cast -> . CONVERT_TO_INT LPAREN typecast_value RPAREN
    (44) type_cast -> . CONVERT_TO_FLT LPAREN typecast_value RPAREN
    (45) type_cast -> . CONVERT_TO_BLN LPAREN typecast_value RPAREN
    (46) type_cast -> . CONVERT_TO_STR LPAREN typecast_value RPAREN
    (58) expression -> . expr_head expr_tail
    (139) function_call -> . FUNCTION_NAME LPAREN arguments RPAREN
    (140) function_call -> . input_statement
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT
    (59) expr_head -> . term term_tail
    (151) input_statement -> . INPUT LPAREN RPAREN
    (60) term -> . factor factor_tail

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    CONVERT_TO_INT  shift and go to state 192
    CONVERT_TO_FLT  shift and go to state 193
    CONVERT_TO_BLN  shift and go to state 194
    CONVERT_TO_STR  shift and go to state 195
    FUNCTION_NAME   shift and go to state 175
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62
    INPUT           shift and go to state 181

    value                          shift and go to state 327
    factor                         shift and go to state 188
    type_cast                      shift and go to state 189
    expression                     shift and go to state 190
    function_call                  shift and go to state 191
    var_call                       shift and go to state 51
    literal                        shift and go to state 52
    expr_head                      shift and go to state 55
    input_statement                shift and go to state 176
    term                           shift and go to state 63

state 321

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE

    RPAREN          shift and go to state 328


state 322

    (134) update -> var_call . update_tail
    (135) update_tail -> . postfix
    (136) update_tail -> . assign_op value
    (137) postfix -> . PLUS_PLUS
    (138) postfix -> . MINUS_MINUS
    (155) assign_op -> . PLUS_EQ
    (156) assign_op -> . MINUS_EQ
    (157) assign_op -> . MUL_EQ
    (158) assign_op -> . DIV_EQ
    (159) assign_op -> . MOD_EQ
    (160) assign_op -> . EQ

    PLUS_PLUS       shift and go to state 208
    MINUS_MINUS     shift and go to state 209
    PLUS_EQ         shift and go to state 210
    MINUS_EQ        shift and go to state 211
    MUL_EQ          shift and go to state 212
    DIV_EQ          shift and go to state 213
    MOD_EQ          shift and go to state 214
    EQ              shift and go to state 215

    update_tail                    shift and go to state 329
    postfix                        shift and go to state 206
    assign_op                      shift and go to state 207

state 323

    (131) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 330


state 324

    (132) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN . expression RPAREN
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 331
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 325

    (117) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail

    RBRACE          shift and go to state 332


state 326

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline . OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    OTHERWISE       shift and go to state 333


state 327

    (124) switch_condition -> SHIFT value . COLON maybe_newline statements switchcond_tail

    COLON           shift and go to state 334


state 328

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 335
    empty                          shift and go to state 16

state 329

    (134) update -> var_call update_tail .

    RPAREN          reduce using rule 134 (update -> var_call update_tail .)


state 330

    (131) until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 131 (until_loop -> UNTIL LPAREN expression RPAREN LBRACE maybe_newline statements RBRACE .)


state 331

    (132) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression . RPAREN

    RPAREN          shift and go to state 336


state 332

    (117) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 337
    empty                          shift and go to state 16

state 333

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE . maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 338
    empty                          shift and go to state 16

state 334

    (124) switch_condition -> SHIFT value COLON . maybe_newline statements switchcond_tail
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    SHIFT           reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 339
    empty                          shift and go to state 16

state 335

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 340


state 336

    (132) repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN .

    NEWLINE         reduce using rule 132 (repeat_until -> REPEAT LBRACE maybe_newline statements RBRACE UNTIL LPAREN expression RPAREN .)


state 337

    (117) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail
    (118) conditional_tail -> . empty
    (119) conditional_tail -> . OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (120) conditional_tail -> . OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE
    (165) empty -> .

    OTHERWISE_CHECK shift and go to state 343
    OTHERWISE       shift and go to state 344
    NEWLINE         reduce using rule 165 (empty -> .)

    conditional_tail               shift and go to state 341
    empty                          shift and go to state 342

state 338

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline . LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE

    LBRACE          shift and go to state 345


state 339

    (124) switch_condition -> SHIFT value COLON maybe_newline . statements switchcond_tail
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    SHIFT           reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 346
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 340

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 347
    empty                          shift and go to state 16

state 341

    (117) conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .

    NEWLINE         reduce using rule 117 (conditional_statement -> CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail .)


state 342

    (118) conditional_tail -> empty .

    NEWLINE         reduce using rule 118 (conditional_tail -> empty .)


state 343

    (119) conditional_tail -> OTHERWISE_CHECK . LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    LPAREN          shift and go to state 348


state 344

    (120) conditional_tail -> OTHERWISE . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 349
    empty                          shift and go to state 16

state 345

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE . maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 350
    empty                          shift and go to state 16

state 346

    (124) switch_condition -> SHIFT value COLON maybe_newline statements . switchcond_tail
    (125) switchcond_tail -> . empty
    (126) switchcond_tail -> . switch_condition
    (165) empty -> .
    (124) switch_condition -> . SHIFT value COLON maybe_newline statements switchcond_tail

    NEWLINE         reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)
    SHIFT           shift and go to state 320

    switchcond_tail                shift and go to state 351
    empty                          shift and go to state 352
    switch_condition               shift and go to state 353

state 347

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 354
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 348

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN . expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 355
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 349

    (120) conditional_tail -> OTHERWISE maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 356


state 350

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline . statements maybe_newline RBRACE maybe_newline RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    NEWLINE         reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 357
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 351

    (124) switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .

    NEWLINE         reduce using rule 124 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)
    OTHERWISE       reduce using rule 124 (switch_condition -> SHIFT value COLON maybe_newline statements switchcond_tail .)


state 352

    (125) switchcond_tail -> empty .

    NEWLINE         reduce using rule 125 (switchcond_tail -> empty .)
    OTHERWISE       reduce using rule 125 (switchcond_tail -> empty .)


state 353

    (126) switchcond_tail -> switch_condition .

    NEWLINE         reduce using rule 126 (switchcond_tail -> switch_condition .)
    OTHERWISE       reduce using rule 126 (switchcond_tail -> switch_condition .)


state 354

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 358


state 355

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    RPAREN          shift and go to state 359


state 356

    (120) conditional_tail -> OTHERWISE maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 360
    empty                          shift and go to state 16

state 357

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements . maybe_newline RBRACE maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 361
    empty                          shift and go to state 16

state 358

    (130) for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 130 (for_loop -> FOR LPAREN control_variable SEMICOLON expression SEMICOLON update RPAREN maybe_newline LBRACE maybe_newline statements RBRACE .)


state 359

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 362
    empty                          shift and go to state 16

state 360

    (120) conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 363
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 361

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline . RBRACE maybe_newline RBRACE

    RBRACE          shift and go to state 364


state 362

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    LBRACE          shift and go to state 365


state 363

    (120) conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 366


state 364

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE . maybe_newline RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    RBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 367
    empty                          shift and go to state 16

state 365

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 368
    empty                          shift and go to state 16

state 366

    (120) conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 120 (conditional_tail -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .)


state 367

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline . RBRACE

    RBRACE          shift and go to state 369


state 368

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail2
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 370
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 369

    (123) switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .

    NEWLINE         reduce using rule 123 (switch_statement -> SWAP LPAREN IDENT RPAREN LBRACE maybe_newline switch_condition maybe_newline OTHERWISE maybe_newline LBRACE maybe_newline statements maybe_newline RBRACE maybe_newline RBRACE .)


state 370

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail2

    RBRACE          shift and go to state 371


state 371

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 372
    empty                          shift and go to state 16

state 372

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail2
    (121) conditional_tail2 -> . OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (122) conditional_tail2 -> . OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    OTHERWISE_CHECK shift and go to state 373
    OTHERWISE       shift and go to state 375

    conditional_tail2              shift and go to state 374

state 373

    (121) conditional_tail2 -> OTHERWISE_CHECK . LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    LPAREN          shift and go to state 376


state 374

    (119) conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2 .

    NEWLINE         reduce using rule 119 (conditional_tail -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2 .)


state 375

    (122) conditional_tail2 -> OTHERWISE . maybe_newline LBRACE maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 377
    empty                          shift and go to state 16

state 376

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN . expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (58) expression -> . expr_head expr_tail
    (59) expr_head -> . term term_tail
    (60) term -> . factor factor_tail
    (61) factor -> . var_call
    (62) factor -> . literal
    (63) factor -> . TILDE literal
    (64) factor -> . LPAREN expression RPAREN
    (82) var_call -> . IDENT var_call_tail
    (52) literal -> . INT_LIT
    (53) literal -> . FLT_LIT
    (54) literal -> . DAY
    (55) literal -> . NIGHT
    (56) literal -> . CHR_LIT
    (57) literal -> . STR_LIT

    TILDE           shift and go to state 53
    LPAREN          shift and go to state 54
    IDENT           shift and go to state 56
    INT_LIT         shift and go to state 57
    FLT_LIT         shift and go to state 58
    DAY             shift and go to state 59
    NIGHT           shift and go to state 60
    CHR_LIT         shift and go to state 61
    STR_LIT         shift and go to state 62

    expression                     shift and go to state 378
    expr_head                      shift and go to state 55
    term                           shift and go to state 63
    factor                         shift and go to state 83
    var_call                       shift and go to state 51
    literal                        shift and go to state 52

state 377

    (122) conditional_tail2 -> OTHERWISE maybe_newline . LBRACE maybe_newline statements RBRACE

    LBRACE          shift and go to state 379


state 378

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression . RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    RPAREN          shift and go to state 380


state 379

    (122) conditional_tail2 -> OTHERWISE maybe_newline LBRACE . maybe_newline statements RBRACE
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 381
    empty                          shift and go to state 16

state 380

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN . maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    LBRACE          reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 382
    empty                          shift and go to state 16

state 381

    (122) conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline . statements RBRACE
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 383
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 382

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline . LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2

    LBRACE          shift and go to state 384


state 383

    (122) conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline statements . RBRACE

    RBRACE          shift and go to state 385


state 384

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE . maybe_newline statements RBRACE maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 17
    INT             reduce using rule 165 (empty -> .)
    FLT             reduce using rule 165 (empty -> .)
    BLN             reduce using rule 165 (empty -> .)
    CHR             reduce using rule 165 (empty -> .)
    STR             reduce using rule 165 (empty -> .)
    RBRACE          reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)

  ! NEWLINE         [ reduce using rule 165 (empty -> .) ]

    maybe_newline                  shift and go to state 386
    empty                          shift and go to state 16

state 385

    (122) conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .

    NEWLINE         reduce using rule 122 (conditional_tail2 -> OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE .)


state 386

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline . statements RBRACE maybe_newline conditional_tail2
    (105) statements -> . empty
    (106) statements -> . local_dec maybe_newline statements_tail
    (165) empty -> .
    (115) local_dec -> . empty
    (116) local_dec -> . var_statement
    (21) var_statement -> . data_type IDENT var_tail
    (34) data_type -> . INT
    (35) data_type -> . FLT
    (36) data_type -> . BLN
    (37) data_type -> . CHR
    (38) data_type -> . STR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLT resolved as shift
  ! shift/reduce conflict for BLN resolved as shift
  ! shift/reduce conflict for CHR resolved as shift
  ! shift/reduce conflict for STR resolved as shift
    RBRACE          reduce using rule 165 (empty -> .)
    NEWLINE         reduce using rule 165 (empty -> .)
    CHECK           reduce using rule 165 (empty -> .)
    SWAP            reduce using rule 165 (empty -> .)
    FUNCTION_NAME   reduce using rule 165 (empty -> .)
    DISPLAY         reduce using rule 165 (empty -> .)
    IDENT           reduce using rule 165 (empty -> .)
    FOR             reduce using rule 165 (empty -> .)
    UNTIL           reduce using rule 165 (empty -> .)
    REPEAT          reduce using rule 165 (empty -> .)
    INPUT           reduce using rule 165 (empty -> .)
    INT             shift and go to state 9
    FLT             shift and go to state 10
    BLN             shift and go to state 11
    CHR             shift and go to state 12
    STR             shift and go to state 13

  ! INT             [ reduce using rule 165 (empty -> .) ]
  ! FLT             [ reduce using rule 165 (empty -> .) ]
  ! BLN             [ reduce using rule 165 (empty -> .) ]
  ! CHR             [ reduce using rule 165 (empty -> .) ]
  ! STR             [ reduce using rule 165 (empty -> .) ]

    statements                     shift and go to state 387
    empty                          shift and go to state 147
    local_dec                      shift and go to state 148
    var_statement                  shift and go to state 149
    data_type                      shift and go to state 150

state 387

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements . RBRACE maybe_newline conditional_tail2

    RBRACE          shift and go to state 388


state 388

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE . maybe_newline conditional_tail2
    (2) maybe_newline -> . empty
    (3) maybe_newline -> . NEWLINE maybe_newline
    (165) empty -> .

    NEWLINE         shift and go to state 17
    OTHERWISE_CHECK reduce using rule 165 (empty -> .)
    OTHERWISE       reduce using rule 165 (empty -> .)

    maybe_newline                  shift and go to state 389
    empty                          shift and go to state 16

state 389

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline . conditional_tail2
    (121) conditional_tail2 -> . OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2
    (122) conditional_tail2 -> . OTHERWISE maybe_newline LBRACE maybe_newline statements RBRACE

    OTHERWISE_CHECK shift and go to state 373
    OTHERWISE       shift and go to state 375

    conditional_tail2              shift and go to state 390

state 390

    (121) conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2 .

    NEWLINE         reduce using rule 121 (conditional_tail2 -> OTHERWISE_CHECK LPAREN expression RPAREN maybe_newline LBRACE maybe_newline statements RBRACE maybe_newline conditional_tail2 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 15 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 17 resolved as shift
WARNING: shift/reduce conflict for AND in state 55 resolved as shift
WARNING: shift/reduce conflict for OR in state 55 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for EQ_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for GT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for LT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 140 resolved as shift
WARNING: shift/reduce conflict for INT in state 143 resolved as shift
WARNING: shift/reduce conflict for FLT in state 143 resolved as shift
WARNING: shift/reduce conflict for BLN in state 143 resolved as shift
WARNING: shift/reduce conflict for CHR in state 143 resolved as shift
WARNING: shift/reduce conflict for STR in state 143 resolved as shift
WARNING: shift/reduce conflict for INT in state 144 resolved as shift
WARNING: shift/reduce conflict for FLT in state 144 resolved as shift
WARNING: shift/reduce conflict for BLN in state 144 resolved as shift
WARNING: shift/reduce conflict for CHR in state 144 resolved as shift
WARNING: shift/reduce conflict for STR in state 144 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 148 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 154 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 154 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 154 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 154 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 154 resolved as shift
WARNING: shift/reduce conflict for FOR in state 154 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 154 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 154 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 154 resolved as shift
WARNING: shift/reduce conflict for INT in state 154 resolved as shift
WARNING: shift/reduce conflict for FLT in state 154 resolved as shift
WARNING: shift/reduce conflict for BLN in state 154 resolved as shift
WARNING: shift/reduce conflict for CHR in state 154 resolved as shift
WARNING: shift/reduce conflict for STR in state 154 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 160 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 196 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 196 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 196 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 196 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 196 resolved as shift
WARNING: shift/reduce conflict for FOR in state 196 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 196 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 196 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 196 resolved as shift
WARNING: shift/reduce conflict for INT in state 196 resolved as shift
WARNING: shift/reduce conflict for FLT in state 196 resolved as shift
WARNING: shift/reduce conflict for BLN in state 196 resolved as shift
WARNING: shift/reduce conflict for CHR in state 196 resolved as shift
WARNING: shift/reduce conflict for STR in state 196 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 197 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 197 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 197 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 197 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 197 resolved as shift
WARNING: shift/reduce conflict for FOR in state 197 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 197 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 197 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 197 resolved as shift
WARNING: shift/reduce conflict for INT in state 197 resolved as shift
WARNING: shift/reduce conflict for FLT in state 197 resolved as shift
WARNING: shift/reduce conflict for BLN in state 197 resolved as shift
WARNING: shift/reduce conflict for CHR in state 197 resolved as shift
WARNING: shift/reduce conflict for STR in state 197 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 198 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 198 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 198 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 198 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 198 resolved as shift
WARNING: shift/reduce conflict for FOR in state 198 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 198 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 198 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 198 resolved as shift
WARNING: shift/reduce conflict for INT in state 198 resolved as shift
WARNING: shift/reduce conflict for FLT in state 198 resolved as shift
WARNING: shift/reduce conflict for BLN in state 198 resolved as shift
WARNING: shift/reduce conflict for CHR in state 198 resolved as shift
WARNING: shift/reduce conflict for STR in state 198 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 199 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 199 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 199 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 199 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 199 resolved as shift
WARNING: shift/reduce conflict for FOR in state 199 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 199 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 199 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 199 resolved as shift
WARNING: shift/reduce conflict for INT in state 199 resolved as shift
WARNING: shift/reduce conflict for FLT in state 199 resolved as shift
WARNING: shift/reduce conflict for BLN in state 199 resolved as shift
WARNING: shift/reduce conflict for CHR in state 199 resolved as shift
WARNING: shift/reduce conflict for STR in state 199 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 200 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 200 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 200 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 200 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 200 resolved as shift
WARNING: shift/reduce conflict for FOR in state 200 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 200 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 200 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 200 resolved as shift
WARNING: shift/reduce conflict for INT in state 200 resolved as shift
WARNING: shift/reduce conflict for FLT in state 200 resolved as shift
WARNING: shift/reduce conflict for BLN in state 200 resolved as shift
WARNING: shift/reduce conflict for CHR in state 200 resolved as shift
WARNING: shift/reduce conflict for STR in state 200 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 201 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 201 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 201 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 201 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 201 resolved as shift
WARNING: shift/reduce conflict for FOR in state 201 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 201 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 201 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 201 resolved as shift
WARNING: shift/reduce conflict for INT in state 201 resolved as shift
WARNING: shift/reduce conflict for FLT in state 201 resolved as shift
WARNING: shift/reduce conflict for BLN in state 201 resolved as shift
WARNING: shift/reduce conflict for CHR in state 201 resolved as shift
WARNING: shift/reduce conflict for STR in state 201 resolved as shift
WARNING: shift/reduce conflict for CHECK in state 202 resolved as shift
WARNING: shift/reduce conflict for SWAP in state 202 resolved as shift
WARNING: shift/reduce conflict for FUNCTION_NAME in state 202 resolved as shift
WARNING: shift/reduce conflict for DISPLAY in state 202 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 202 resolved as shift
WARNING: shift/reduce conflict for FOR in state 202 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 202 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 202 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 202 resolved as shift
WARNING: shift/reduce conflict for INT in state 202 resolved as shift
WARNING: shift/reduce conflict for FLT in state 202 resolved as shift
WARNING: shift/reduce conflict for BLN in state 202 resolved as shift
WARNING: shift/reduce conflict for CHR in state 202 resolved as shift
WARNING: shift/reduce conflict for STR in state 202 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 223 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 256 resolved as shift
WARNING: shift/reduce conflict for INT in state 260 resolved as shift
WARNING: shift/reduce conflict for FLT in state 260 resolved as shift
WARNING: shift/reduce conflict for BLN in state 260 resolved as shift
WARNING: shift/reduce conflict for CHR in state 260 resolved as shift
WARNING: shift/reduce conflict for STR in state 260 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 306 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 311 resolved as shift
WARNING: shift/reduce conflict for INT in state 316 resolved as shift
WARNING: shift/reduce conflict for FLT in state 316 resolved as shift
WARNING: shift/reduce conflict for BLN in state 316 resolved as shift
WARNING: shift/reduce conflict for CHR in state 316 resolved as shift
WARNING: shift/reduce conflict for STR in state 316 resolved as shift
WARNING: shift/reduce conflict for INT in state 318 resolved as shift
WARNING: shift/reduce conflict for FLT in state 318 resolved as shift
WARNING: shift/reduce conflict for BLN in state 318 resolved as shift
WARNING: shift/reduce conflict for CHR in state 318 resolved as shift
WARNING: shift/reduce conflict for STR in state 318 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 332 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 334 resolved as shift
WARNING: shift/reduce conflict for INT in state 339 resolved as shift
WARNING: shift/reduce conflict for FLT in state 339 resolved as shift
WARNING: shift/reduce conflict for BLN in state 339 resolved as shift
WARNING: shift/reduce conflict for CHR in state 339 resolved as shift
WARNING: shift/reduce conflict for STR in state 339 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 340 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 345 resolved as shift
WARNING: shift/reduce conflict for INT in state 347 resolved as shift
WARNING: shift/reduce conflict for FLT in state 347 resolved as shift
WARNING: shift/reduce conflict for BLN in state 347 resolved as shift
WARNING: shift/reduce conflict for CHR in state 347 resolved as shift
WARNING: shift/reduce conflict for STR in state 347 resolved as shift
WARNING: shift/reduce conflict for INT in state 350 resolved as shift
WARNING: shift/reduce conflict for FLT in state 350 resolved as shift
WARNING: shift/reduce conflict for BLN in state 350 resolved as shift
WARNING: shift/reduce conflict for CHR in state 350 resolved as shift
WARNING: shift/reduce conflict for STR in state 350 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 356 resolved as shift
WARNING: shift/reduce conflict for INT in state 360 resolved as shift
WARNING: shift/reduce conflict for FLT in state 360 resolved as shift
WARNING: shift/reduce conflict for BLN in state 360 resolved as shift
WARNING: shift/reduce conflict for CHR in state 360 resolved as shift
WARNING: shift/reduce conflict for STR in state 360 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 365 resolved as shift
WARNING: shift/reduce conflict for INT in state 368 resolved as shift
WARNING: shift/reduce conflict for FLT in state 368 resolved as shift
WARNING: shift/reduce conflict for BLN in state 368 resolved as shift
WARNING: shift/reduce conflict for CHR in state 368 resolved as shift
WARNING: shift/reduce conflict for STR in state 368 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 379 resolved as shift
WARNING: shift/reduce conflict for INT in state 381 resolved as shift
WARNING: shift/reduce conflict for FLT in state 381 resolved as shift
WARNING: shift/reduce conflict for BLN in state 381 resolved as shift
WARNING: shift/reduce conflict for CHR in state 381 resolved as shift
WARNING: shift/reduce conflict for STR in state 381 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 384 resolved as shift
WARNING: shift/reduce conflict for INT in state 386 resolved as shift
WARNING: shift/reduce conflict for FLT in state 386 resolved as shift
WARNING: shift/reduce conflict for BLN in state 386 resolved as shift
WARNING: shift/reduce conflict for CHR in state 386 resolved as shift
WARNING: shift/reduce conflict for STR in state 386 resolved as shift
WARNING: reduce/reduce conflict in state 26 resolved using rule (global_dec -> empty)
WARNING: rejected rule (global_tail -> empty) in state 26
WARNING: reduce/reduce conflict in state 49 resolved using rule (global_value -> factor)
WARNING: rejected rule (empty -> <empty>) in state 49
WARNING: reduce/reduce conflict in state 147 resolved using rule (statements -> empty)
WARNING: rejected rule (local_dec -> empty) in state 147
WARNING: reduce/reduce conflict in state 162 resolved using rule (statements_tail -> empty)
WARNING: rejected rule (local_dec -> empty) in state 162
WARNING: reduce/reduce conflict in state 188 resolved using rule (value -> factor)
WARNING: rejected rule (empty -> <empty>) in state 188
WARNING: reduce/reduce conflict in state 268 resolved using rule (typecast_value -> IDENT)
WARNING: rejected rule (empty -> <empty>) in state 268
WARNING: reduce/reduce conflict in state 269 resolved using rule (typecast_value -> literal)
WARNING: rejected rule (factor -> literal) in state 269
WARNING: Rule (global_tail -> empty) is never reduced
